var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf, __hasOwnProp = Object.prototype.hasOwnProperty;
var __esm = (fn, res) => function() {
  return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
};
var __commonJS = (cb, mod) => function() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: !0 });
}, __copyProps = (to, from2, except, desc) => {
  if (from2 && typeof from2 == "object" || typeof from2 == "function")
    for (let key of __getOwnPropNames(from2))
      !__hasOwnProp.call(to, key) && key !== except && __defProp(to, key, { get: () => from2[key], enumerable: !(desc = __getOwnPropDesc(from2, key)) || desc.enumerable });
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: !0 }) : target,
  mod
)), __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: !0 }), mod);

// node_modules/cookie/index.js
var require_cookie = __commonJS({
  "node_modules/cookie/index.js"(exports) {
    "use strict";
    exports.parse = parse2;
    exports.serialize = serialize2;
    var decode = decodeURIComponent, encode = encodeURIComponent, fieldContentRegExp = /^[\u0009\u0020-\u007e\u0080-\u00ff]+$/;
    function parse2(str, options) {
      if (typeof str != "string")
        throw new TypeError("argument str must be a string");
      for (var obj = {}, opt = options || {}, pairs = str.split(";"), dec = opt.decode || decode, i = 0; i < pairs.length; i++) {
        var pair = pairs[i], index = pair.indexOf("=");
        if (!(index < 0)) {
          var key = pair.substring(0, index).trim();
          if (obj[key] == null) {
            var val = pair.substring(index + 1, pair.length).trim();
            val[0] === '"' && (val = val.slice(1, -1)), obj[key] = tryDecode(val, dec);
          }
        }
      }
      return obj;
    }
    function serialize2(name, val, options) {
      var opt = options || {}, enc = opt.encode || encode;
      if (typeof enc != "function")
        throw new TypeError("option encode is invalid");
      if (!fieldContentRegExp.test(name))
        throw new TypeError("argument name is invalid");
      var value = enc(val);
      if (value && !fieldContentRegExp.test(value))
        throw new TypeError("argument val is invalid");
      var str = name + "=" + value;
      if (opt.maxAge != null) {
        var maxAge = opt.maxAge - 0;
        if (isNaN(maxAge) || !isFinite(maxAge))
          throw new TypeError("option maxAge is invalid");
        str += "; Max-Age=" + Math.floor(maxAge);
      }
      if (opt.domain) {
        if (!fieldContentRegExp.test(opt.domain))
          throw new TypeError("option domain is invalid");
        str += "; Domain=" + opt.domain;
      }
      if (opt.path) {
        if (!fieldContentRegExp.test(opt.path))
          throw new TypeError("option path is invalid");
        str += "; Path=" + opt.path;
      }
      if (opt.expires) {
        if (typeof opt.expires.toUTCString != "function")
          throw new TypeError("option expires is invalid");
        str += "; Expires=" + opt.expires.toUTCString();
      }
      if (opt.httpOnly && (str += "; HttpOnly"), opt.secure && (str += "; Secure"), opt.sameSite) {
        var sameSite = typeof opt.sameSite == "string" ? opt.sameSite.toLowerCase() : opt.sameSite;
        switch (sameSite) {
          case !0:
            str += "; SameSite=Strict";
            break;
          case "lax":
            str += "; SameSite=Lax";
            break;
          case "strict":
            str += "; SameSite=Strict";
            break;
          case "none":
            str += "; SameSite=None";
            break;
          default:
            throw new TypeError("option sameSite is invalid");
        }
      }
      return str;
    }
    function tryDecode(str, decode2) {
      try {
        return decode2(str);
      } catch {
        return str;
      }
    }
  }
});

// node_modules/@remix-run/server-runtime/dist/esm/warnings.js
function warnOnce(condition, message) {
  !condition && !alreadyWarned[message] && (alreadyWarned[message] = !0, console.warn(message));
}
var alreadyWarned, init_warnings = __esm({
  "node_modules/@remix-run/server-runtime/dist/esm/warnings.js"() {
    alreadyWarned = {};
  }
});

// node_modules/@remix-run/server-runtime/dist/esm/cookies.js
async function encodeCookieValue(sign, value, secrets) {
  let encoded = encodeData(value);
  return secrets.length > 0 && (encoded = await sign(encoded, secrets[0])), encoded;
}
async function decodeCookieValue(unsign, value, secrets) {
  if (secrets.length > 0) {
    for (let secret of secrets) {
      let unsignedValue = await unsign(value, secret);
      if (unsignedValue !== !1)
        return decodeData(unsignedValue);
    }
    return null;
  }
  return decodeData(value);
}
function encodeData(value) {
  return btoa(myUnescape(encodeURIComponent(JSON.stringify(value))));
}
function decodeData(value) {
  try {
    return JSON.parse(decodeURIComponent(myEscape(atob(value))));
  } catch {
    return {};
  }
}
function myEscape(value) {
  let str = value.toString(), result = "", index = 0, chr, code;
  for (; index < str.length; )
    chr = str.charAt(index++), /[\w*+\-./@]/.exec(chr) ? result += chr : (code = chr.charCodeAt(0), code < 256 ? result += "%" + hex(code, 2) : result += "%u" + hex(code, 4).toUpperCase());
  return result;
}
function hex(code, length) {
  let result = code.toString(16);
  for (; result.length < length; )
    result = "0" + result;
  return result;
}
function myUnescape(value) {
  let str = value.toString(), result = "", index = 0, chr, part;
  for (; index < str.length; ) {
    if (chr = str.charAt(index++), chr === "%") {
      if (str.charAt(index) === "u") {
        if (part = str.slice(index + 1, index + 5), /^[\da-f]{4}$/i.exec(part)) {
          result += String.fromCharCode(parseInt(part, 16)), index += 5;
          continue;
        }
      } else if (part = str.slice(index, index + 2), /^[\da-f]{2}$/i.exec(part)) {
        result += String.fromCharCode(parseInt(part, 16)), index += 2;
        continue;
      }
    }
    result += chr;
  }
  return result;
}
function warnOnceAboutExpiresCookie(name, expires) {
  warnOnce(!expires, `The "${name}" cookie has an "expires" property set. This will cause the expires value to not be updated when the session is committed. Instead, you should set the expires value when serializing the cookie. You can use \`commitSession(session, { expires })\` if using a session storage object, or \`cookie.serialize("value", { expires })\` if you're using the cookie directly.`);
}
var import_cookie, createCookieFactory, isCookie, init_cookies = __esm({
  "node_modules/@remix-run/server-runtime/dist/esm/cookies.js"() {
    import_cookie = __toESM(require_cookie());
    init_warnings();
    createCookieFactory = ({
      sign,
      unsign
    }) => (name, cookieOptions = {}) => {
      let {
        secrets,
        ...options
      } = {
        secrets: [],
        path: "/",
        sameSite: "lax",
        ...cookieOptions
      };
      return warnOnceAboutExpiresCookie(name, options.expires), {
        get name() {
          return name;
        },
        get isSigned() {
          return secrets.length > 0;
        },
        get expires() {
          return typeof options.maxAge < "u" ? new Date(Date.now() + options.maxAge * 1e3) : options.expires;
        },
        async parse(cookieHeader, parseOptions) {
          if (!cookieHeader)
            return null;
          let cookies = (0, import_cookie.parse)(cookieHeader, {
            ...options,
            ...parseOptions
          });
          return name in cookies ? cookies[name] === "" ? "" : await decodeCookieValue(unsign, cookies[name], secrets) : null;
        },
        async serialize(value, serializeOptions) {
          return (0, import_cookie.serialize)(name, value === "" ? "" : await encodeCookieValue(sign, value, secrets), {
            ...options,
            ...serializeOptions
          });
        }
      };
    }, isCookie = (object) => object != null && typeof object.name == "string" && typeof object.isSigned == "boolean" && typeof object.parse == "function" && typeof object.serialize == "function";
  }
});

// node_modules/@web3-storage/multipart-parser/esm/src/utils.js
function stringToArray(s) {
  let utf8 = unescape(encodeURIComponent(s));
  return Uint8Array.from(utf8, (_2, i) => utf8.charCodeAt(i));
}
function arrayToString(a) {
  let utf8 = String.fromCharCode.apply(null, a);
  return decodeURIComponent(escape(utf8));
}
function mergeArrays(...arrays) {
  let out = new Uint8Array(arrays.reduce((total, arr) => total + arr.length, 0)), offset = 0;
  for (let arr of arrays)
    out.set(arr, offset), offset += arr.length;
  return out;
}
function arraysEqual(a, b) {
  if (a.length !== b.length)
    return !1;
  for (let i = 0; i < a.length; i++)
    if (a[i] !== b[i])
      return !1;
  return !0;
}
var init_utils = __esm({
  "node_modules/@web3-storage/multipart-parser/esm/src/utils.js"() {
  }
});

// node_modules/@web3-storage/multipart-parser/esm/src/search.js
function coerce(a) {
  return a instanceof Uint8Array ? (index) => a[index] : a;
}
function jsmemcmp(buf1, pos1, buf2, pos2, len) {
  let fn1 = coerce(buf1), fn2 = coerce(buf2);
  for (let i = 0; i < len; ++i)
    if (fn1(pos1 + i) !== fn2(pos2 + i))
      return !1;
  return !0;
}
function createOccurenceTable(s) {
  let table = new Array(256).fill(s.length);
  if (s.length > 1)
    for (let i = 0; i < s.length - 1; i++)
      table[s[i]] = s.length - 1 - i;
  return table;
}
var MATCH, StreamSearch, ReadableStreamSearch, EOQ, QueueableStreamSearch, init_search = __esm({
  "node_modules/@web3-storage/multipart-parser/esm/src/search.js"() {
    init_utils();
    MATCH = Symbol("Match"), StreamSearch = class {
      constructor(needle) {
        this._lookbehind = new Uint8Array(), typeof needle == "string" ? this._needle = needle = stringToArray(needle) : this._needle = needle, this._lastChar = needle[needle.length - 1], this._occ = createOccurenceTable(needle);
      }
      feed(chunk) {
        let pos = 0, tokens, allTokens = [];
        for (; pos !== chunk.length; )
          [pos, ...tokens] = this._feed(chunk, pos), allTokens.push(...tokens);
        return allTokens;
      }
      end() {
        let tail = this._lookbehind;
        return this._lookbehind = new Uint8Array(), tail;
      }
      _feed(data, bufPos) {
        let tokens = [], pos = -this._lookbehind.length;
        if (pos < 0) {
          for (; pos < 0 && pos <= data.length - this._needle.length; ) {
            let ch = this._charAt(data, pos + this._needle.length - 1);
            if (ch === this._lastChar && this._memcmp(data, pos, this._needle.length - 1))
              return pos > -this._lookbehind.length && tokens.push(this._lookbehind.slice(0, this._lookbehind.length + pos)), tokens.push(MATCH), this._lookbehind = new Uint8Array(), [
                pos + this._needle.length,
                ...tokens
              ];
            pos += this._occ[ch];
          }
          if (pos < 0)
            for (; pos < 0 && !this._memcmp(data, pos, data.length - pos); )
              pos++;
          if (pos >= 0)
            tokens.push(this._lookbehind), this._lookbehind = new Uint8Array();
          else {
            let bytesToCutOff = this._lookbehind.length + pos;
            return bytesToCutOff > 0 && (tokens.push(this._lookbehind.slice(0, bytesToCutOff)), this._lookbehind = this._lookbehind.slice(bytesToCutOff)), this._lookbehind = Uint8Array.from(new Array(this._lookbehind.length + data.length), (_2, i) => this._charAt(data, i - this._lookbehind.length)), [
              data.length,
              ...tokens
            ];
          }
        }
        for (pos += bufPos; pos <= data.length - this._needle.length; ) {
          let ch = data[pos + this._needle.length - 1];
          if (ch === this._lastChar && data[pos] === this._needle[0] && jsmemcmp(this._needle, 0, data, pos, this._needle.length - 1))
            return pos > bufPos && tokens.push(data.slice(bufPos, pos)), tokens.push(MATCH), [
              pos + this._needle.length,
              ...tokens
            ];
          pos += this._occ[ch];
        }
        if (pos < data.length) {
          for (; pos < data.length && (data[pos] !== this._needle[0] || !jsmemcmp(data, pos, this._needle, 0, data.length - pos)); )
            ++pos;
          pos < data.length && (this._lookbehind = data.slice(pos));
        }
        return pos > 0 && tokens.push(data.slice(bufPos, pos < data.length ? pos : data.length)), [
          data.length,
          ...tokens
        ];
      }
      _charAt(data, pos) {
        return pos < 0 ? this._lookbehind[this._lookbehind.length + pos] : data[pos];
      }
      _memcmp(data, pos, len) {
        return jsmemcmp(this._charAt.bind(this, data), pos, this._needle, 0, len);
      }
    }, ReadableStreamSearch = class {
      constructor(needle, _readableStream) {
        this._readableStream = _readableStream, this._search = new StreamSearch(needle);
      }
      async *[Symbol.asyncIterator]() {
        let reader = this._readableStream.getReader();
        try {
          for (; ; ) {
            let result = await reader.read();
            if (result.done)
              break;
            yield* this._search.feed(result.value);
          }
          let tail = this._search.end();
          tail.length && (yield tail);
        } finally {
          reader.releaseLock();
        }
      }
    }, EOQ = Symbol("End of Queue"), QueueableStreamSearch = class {
      constructor(needle) {
        this._chunksQueue = [], this._closed = !1, this._search = new StreamSearch(needle);
      }
      push(...chunks) {
        if (this._closed)
          throw new Error("cannot call push after close");
        this._chunksQueue.push(...chunks), this._notify && this._notify();
      }
      close() {
        if (this._closed)
          throw new Error("close was already called");
        this._closed = !0, this._chunksQueue.push(EOQ), this._notify && this._notify();
      }
      async *[Symbol.asyncIterator]() {
        for (; ; ) {
          let chunk;
          for (; !(chunk = this._chunksQueue.shift()); )
            await new Promise((resolve) => this._notify = resolve), this._notify = void 0;
          if (chunk === EOQ)
            break;
          yield* this._search.feed(chunk);
        }
        let tail = this._search.end();
        tail.length && (yield tail);
      }
    };
  }
});

// node_modules/@web3-storage/multipart-parser/esm/src/index.js
function parseContentDisposition(header) {
  let parts = header.split(";").map((part) => part.trim());
  if (parts.shift() !== "form-data")
    throw new Error('malformed content-disposition header: missing "form-data" in `' + JSON.stringify(parts) + "`");
  let out = {};
  for (let part of parts) {
    let kv = part.split("=", 2);
    if (kv.length !== 2)
      throw new Error("malformed content-disposition header: key-value pair not found - " + part + " in `" + header + "`");
    let [name, value] = kv;
    if (value[0] === '"' && value[value.length - 1] === '"')
      out[name] = value.slice(1, -1).replace(/\\"/g, '"');
    else if (value[0] !== '"' && value[value.length - 1] !== '"')
      out[name] = value;
    else if (value[0] === '"' && value[value.length - 1] !== '"' || value[0] !== '"' && value[value.length - 1] === '"')
      throw new Error("malformed content-disposition header: mismatched quotations in `" + header + "`");
  }
  if (!out.name)
    throw new Error("malformed content-disposition header: missing field name in `" + header + "`");
  return out;
}
function parsePartHeaders(lines) {
  let entries = [], disposition = !1, line;
  for (; typeof (line = lines.shift()) < "u"; ) {
    let colon = line.indexOf(":");
    if (colon === -1)
      throw new Error("malformed multipart-form header: missing colon");
    let header = line.slice(0, colon).trim().toLowerCase(), value = line.slice(colon + 1).trim();
    switch (header) {
      case "content-disposition":
        disposition = !0, entries.push(...Object.entries(parseContentDisposition(value)));
        break;
      case "content-type":
        entries.push([
          "contentType",
          value
        ]);
    }
  }
  if (!disposition)
    throw new Error("malformed multipart-form header: missing content-disposition");
  return Object.fromEntries(entries);
}
async function readHeaderLines(it, needle) {
  let firstChunk = !0, lastTokenWasMatch = !1, headerLines = [[]], crlfSearch = new StreamSearch(CRLF);
  for (; ; ) {
    let result = await it.next();
    if (result.done)
      throw new Error("malformed multipart-form data: unexpected end of stream");
    if (firstChunk && result.value !== MATCH && arraysEqual(result.value.slice(0, 2), dash))
      return [
        void 0,
        new Uint8Array()
      ];
    let chunk;
    if (result.value !== MATCH)
      chunk = result.value;
    else if (!lastTokenWasMatch)
      chunk = needle;
    else
      throw new Error("malformed multipart-form data: unexpected boundary");
    if (!chunk.length)
      continue;
    firstChunk && (firstChunk = !1);
    let tokens = crlfSearch.feed(chunk);
    for (let [i, token] of tokens.entries()) {
      let isMatch = token === MATCH;
      if (!(!isMatch && !token.length)) {
        if (lastTokenWasMatch && isMatch)
          return tokens.push(crlfSearch.end()), [
            headerLines.filter((chunks) => chunks.length).map(mergeArrays2).map(arrayToString),
            mergeArrays(...tokens.slice(i + 1).map((token2) => token2 === MATCH ? CRLF : token2))
          ];
        (lastTokenWasMatch = isMatch) ? headerLines.push([]) : headerLines[headerLines.length - 1].push(token);
      }
    }
  }
}
async function* streamMultipart(body, boundary) {
  let needle = mergeArrays(dash, stringToArray(boundary)), it = new ReadableStreamSearch(needle, body)[Symbol.asyncIterator]();
  for (; ; ) {
    let result = await it.next();
    if (result.done)
      return;
    if (result.value === MATCH)
      break;
  }
  let crlfSearch = new StreamSearch(CRLF);
  for (; ; ) {
    let feedChunk = function(chunk) {
      let chunks = [];
      for (let token of crlfSearch.feed(chunk))
        trailingCRLF && chunks.push(CRLF), (trailingCRLF = token === MATCH) || chunks.push(token);
      return mergeArrays(...chunks);
    }, [headerLines, tail] = await readHeaderLines(it, needle);
    if (!headerLines)
      return;
    async function nextToken() {
      let result = await it.next();
      if (result.done)
        throw new Error("malformed multipart-form data: unexpected end of stream");
      return result;
    }
    let trailingCRLF = !1, done2 = !1;
    async function nextChunk() {
      let result = await nextToken(), chunk;
      if (result.value !== MATCH)
        chunk = result.value;
      else if (!trailingCRLF)
        chunk = CRLF;
      else
        return done2 = !0, { value: crlfSearch.end() };
      return { value: feedChunk(chunk) };
    }
    let bufferedChunks = [{ value: feedChunk(tail) }];
    for (yield {
      ...parsePartHeaders(headerLines),
      data: {
        [Symbol.asyncIterator]() {
          return this;
        },
        async next() {
          for (; ; ) {
            let result = bufferedChunks.shift();
            if (!result)
              break;
            if (result.value.length > 0)
              return result;
          }
          for (; ; ) {
            if (done2)
              return {
                done: done2,
                value: void 0
              };
            let result = await nextChunk();
            if (result.value.length > 0)
              return result;
          }
        }
      }
    }; !done2; )
      bufferedChunks.push(await nextChunk());
  }
}
var mergeArrays2, dash, CRLF, init_src = __esm({
  "node_modules/@web3-storage/multipart-parser/esm/src/index.js"() {
    init_search();
    init_utils();
    mergeArrays2 = Function.prototype.apply.bind(mergeArrays, void 0), dash = stringToArray("--"), CRLF = stringToArray(`\r
`);
  }
});

// node_modules/@remix-run/server-runtime/dist/esm/formData.js
function composeUploadHandlers(...handlers) {
  return async (part) => {
    for (let handler of handlers) {
      let value = await handler(part);
      if (typeof value < "u" && value !== null)
        return value;
    }
  };
}
async function parseMultipartFormData(request, uploadHandler) {
  let contentType = request.headers.get("Content-Type") || "", [type, boundary] = contentType.split(/\s*;\s*boundary=/);
  if (!request.body || !boundary || type !== "multipart/form-data")
    throw new TypeError("Could not parse content as FormData.");
  let formData = new FormData(), parts = streamMultipart(request.body, boundary);
  for await (let part of parts) {
    if (part.done)
      break;
    typeof part.filename == "string" && (part.filename = part.filename.split(/[/\\]/).pop());
    let value = await uploadHandler(part);
    typeof value < "u" && value !== null && formData.append(part.name, value);
  }
  return formData;
}
var init_formData = __esm({
  "node_modules/@remix-run/server-runtime/dist/esm/formData.js"() {
    init_src();
  }
});

// node_modules/@remix-run/server-runtime/dist/esm/responses.js
function isResponse(value) {
  return value != null && typeof value.status == "number" && typeof value.statusText == "string" && typeof value.headers == "object" && typeof value.body < "u";
}
function isRedirectResponse(response) {
  return redirectStatusCodes.has(response.status);
}
function isCatchResponse(response) {
  return response.headers.get("X-Remix-Catch") != null;
}
var json, redirect, redirectStatusCodes, init_responses = __esm({
  "node_modules/@remix-run/server-runtime/dist/esm/responses.js"() {
    json = (data, init2 = {}) => {
      let responseInit = typeof init2 == "number" ? {
        status: init2
      } : init2, headers = new Headers(responseInit.headers);
      return headers.has("Content-Type") || headers.set("Content-Type", "application/json; charset=utf-8"), new Response(JSON.stringify(data), {
        ...responseInit,
        headers
      });
    }, redirect = (url, init2 = 302) => {
      let responseInit = init2;
      typeof responseInit == "number" ? responseInit = {
        status: responseInit
      } : typeof responseInit.status > "u" && (responseInit.status = 302);
      let headers = new Headers(responseInit.headers);
      return headers.set("Location", url), new Response(null, {
        ...responseInit,
        headers
      });
    };
    redirectStatusCodes = /* @__PURE__ */ new Set([301, 302, 303, 307, 308]);
  }
});

// node_modules/@remix-run/server-runtime/dist/esm/data.js
async function callRouteAction({
  loadContext,
  match,
  request
}) {
  let action = match.route.module.action;
  if (!action) {
    let response = new Response(null, {
      status: 405
    });
    return response.headers.set("X-Remix-Catch", "yes"), response;
  }
  let result;
  try {
    result = await action({
      request: stripDataParam(stripIndexParam(request)),
      context: loadContext,
      params: match.params
    });
  } catch (error) {
    if (!isResponse(error))
      throw error;
    isRedirectResponse(error) || error.headers.set("X-Remix-Catch", "yes"), result = error;
  }
  if (result === void 0)
    throw new Error(`You defined an action for route "${match.route.id}" but didn't return anything from your \`action\` function. Please return a value or \`null\`.`);
  return isResponse(result) ? result : json(result);
}
async function callRouteLoader({
  loadContext,
  match,
  request
}) {
  let loader2 = match.route.module.loader;
  if (!loader2)
    throw new Error(`You made a ${request.method} request to ${request.url} but did not provide a default component or \`loader\` for route "${match.route.id}", so there is no way to handle the request.`);
  let result;
  try {
    result = await loader2({
      request: stripDataParam(stripIndexParam(request)),
      context: loadContext,
      params: match.params
    });
  } catch (error) {
    if (!isResponse(error))
      throw error;
    isRedirectResponse(error) || error.headers.set("X-Remix-Catch", "yes"), result = error;
  }
  if (result === void 0)
    throw new Error(`You defined a loader for route "${match.route.id}" but didn't return anything from your \`loader\` function. Please return a value or \`null\`.`);
  return isResponse(result) ? result : json(result);
}
function stripIndexParam(request) {
  let url = new URL(request.url), indexValues = url.searchParams.getAll("index");
  url.searchParams.delete("index");
  let indexValuesToKeep = [];
  for (let indexValue of indexValues)
    indexValue && indexValuesToKeep.push(indexValue);
  for (let toKeep of indexValuesToKeep)
    url.searchParams.append("index", toKeep);
  return new Request(url.href, request);
}
function stripDataParam(request) {
  let url = new URL(request.url);
  return url.searchParams.delete("_data"), new Request(url.href, request);
}
function extractData(response) {
  let contentType = response.headers.get("Content-Type");
  return contentType && /\bapplication\/json\b/.test(contentType) ? response.json() : response.text();
}
var init_data = __esm({
  "node_modules/@remix-run/server-runtime/dist/esm/data.js"() {
    init_responses();
  }
});

// node_modules/@remix-run/server-runtime/dist/esm/entry.js
function createEntryMatches(matches, routes2) {
  return matches.map((match) => ({
    params: match.params,
    pathname: match.pathname,
    route: routes2[match.route.id]
  }));
}
function createEntryRouteModules(manifest) {
  return Object.keys(manifest).reduce((memo2, routeId) => (memo2[routeId] = manifest[routeId].module, memo2), {});
}
var init_entry = __esm({
  "node_modules/@remix-run/server-runtime/dist/esm/entry.js"() {
  }
});

// node_modules/@remix-run/server-runtime/dist/esm/errors.js
async function serializeError(error) {
  return {
    message: error.message,
    stack: error.stack
  };
}
var init_errors = __esm({
  "node_modules/@remix-run/server-runtime/dist/esm/errors.js"() {
  }
});

// node_modules/set-cookie-parser/lib/set-cookie.js
var require_set_cookie = __commonJS({
  "node_modules/set-cookie-parser/lib/set-cookie.js"(exports, module) {
    "use strict";
    var defaultParseOptions = {
      decodeValues: !0,
      map: !1,
      silent: !1
    };
    function isNonEmptyString(str) {
      return typeof str == "string" && !!str.trim();
    }
    function parseString(setCookieValue, options) {
      var parts = setCookieValue.split(";").filter(isNonEmptyString), nameValuePairStr = parts.shift(), parsed = parseNameValuePair(nameValuePairStr), name = parsed.name, value = parsed.value;
      options = options ? Object.assign({}, defaultParseOptions, options) : defaultParseOptions;
      try {
        value = options.decodeValues ? decodeURIComponent(value) : value;
      } catch (e) {
        console.error(
          "set-cookie-parser encountered an error while decoding a cookie with value '" + value + "'. Set options.decodeValues to false to disable this feature.",
          e
        );
      }
      var cookie = {
        name,
        value
      };
      return parts.forEach(function(part) {
        var sides = part.split("="), key = sides.shift().trimLeft().toLowerCase(), value2 = sides.join("=");
        key === "expires" ? cookie.expires = new Date(value2) : key === "max-age" ? cookie.maxAge = parseInt(value2, 10) : key === "secure" ? cookie.secure = !0 : key === "httponly" ? cookie.httpOnly = !0 : key === "samesite" ? cookie.sameSite = value2 : cookie[key] = value2;
      }), cookie;
    }
    function parseNameValuePair(nameValuePairStr) {
      var name = "", value = "", nameValueArr = nameValuePairStr.split("=");
      return nameValueArr.length > 1 ? (name = nameValueArr.shift(), value = nameValueArr.join("=")) : value = nameValuePairStr, { name, value };
    }
    function parse2(input, options) {
      if (options = options ? Object.assign({}, defaultParseOptions, options) : defaultParseOptions, !input)
        return options.map ? {} : [];
      if (input.headers && input.headers["set-cookie"])
        input = input.headers["set-cookie"];
      else if (input.headers) {
        var sch = input.headers[Object.keys(input.headers).find(function(key) {
          return key.toLowerCase() === "set-cookie";
        })];
        !sch && input.headers.cookie && !options.silent && console.warn(
          "Warning: set-cookie-parser appears to have been called on a request object. It is designed to parse Set-Cookie headers from responses, not Cookie headers from requests. Set the option {silent: true} to suppress this warning."
        ), input = sch;
      }
      if (Array.isArray(input) || (input = [input]), options = options ? Object.assign({}, defaultParseOptions, options) : defaultParseOptions, options.map) {
        var cookies = {};
        return input.filter(isNonEmptyString).reduce(function(cookies2, str) {
          var cookie = parseString(str, options);
          return cookies2[cookie.name] = cookie, cookies2;
        }, cookies);
      } else
        return input.filter(isNonEmptyString).map(function(str) {
          return parseString(str, options);
        });
    }
    function splitCookiesString2(cookiesString) {
      if (Array.isArray(cookiesString))
        return cookiesString;
      if (typeof cookiesString != "string")
        return [];
      var cookiesStrings = [], pos = 0, start, ch, lastComma, nextStart, cookiesSeparatorFound;
      function skipWhitespace() {
        for (; pos < cookiesString.length && /\s/.test(cookiesString.charAt(pos)); )
          pos += 1;
        return pos < cookiesString.length;
      }
      function notSpecialChar() {
        return ch = cookiesString.charAt(pos), ch !== "=" && ch !== ";" && ch !== ",";
      }
      for (; pos < cookiesString.length; ) {
        for (start = pos, cookiesSeparatorFound = !1; skipWhitespace(); )
          if (ch = cookiesString.charAt(pos), ch === ",") {
            for (lastComma = pos, pos += 1, skipWhitespace(), nextStart = pos; pos < cookiesString.length && notSpecialChar(); )
              pos += 1;
            pos < cookiesString.length && cookiesString.charAt(pos) === "=" ? (cookiesSeparatorFound = !0, pos = nextStart, cookiesStrings.push(cookiesString.substring(start, lastComma)), start = pos) : pos = lastComma + 1;
          } else
            pos += 1;
        (!cookiesSeparatorFound || pos >= cookiesString.length) && cookiesStrings.push(cookiesString.substring(start, cookiesString.length));
      }
      return cookiesStrings;
    }
    module.exports = parse2;
    module.exports.parse = parse2;
    module.exports.parseString = parseString;
    module.exports.splitCookiesString = splitCookiesString2;
  }
});

// node_modules/@remix-run/server-runtime/dist/esm/headers.js
function getDocumentHeaders(build, matches, routeLoaderResponses, actionResponse) {
  return matches.reduce((parentHeaders, match, index) => {
    let routeModule = build.routes[match.route.id].module, routeLoaderResponse = routeLoaderResponses[match.route.id], loaderHeaders = routeLoaderResponse ? routeLoaderResponse.headers : new Headers(), actionHeaders = actionResponse ? actionResponse.headers : new Headers(), headers = new Headers(routeModule.headers ? typeof routeModule.headers == "function" ? routeModule.headers({
      loaderHeaders,
      parentHeaders,
      actionHeaders
    }) : routeModule.headers : void 0);
    return prependCookies(actionHeaders, headers), prependCookies(loaderHeaders, headers), prependCookies(parentHeaders, headers), headers;
  }, new Headers());
}
function prependCookies(parentHeaders, childHeaders) {
  let parentSetCookieString = parentHeaders.get("Set-Cookie");
  parentSetCookieString && (0, import_set_cookie_parser.splitCookiesString)(parentSetCookieString).forEach((cookie) => {
    childHeaders.append("Set-Cookie", cookie);
  });
}
var import_set_cookie_parser, init_headers = __esm({
  "node_modules/@remix-run/server-runtime/dist/esm/headers.js"() {
    import_set_cookie_parser = __toESM(require_set_cookie());
  }
});

// node_modules/@remix-run/server-runtime/dist/esm/mode.js
function isServerMode(value) {
  return value === ServerMode.Development || value === ServerMode.Production || value === ServerMode.Test;
}
var ServerMode, init_mode = __esm({
  "node_modules/@remix-run/server-runtime/dist/esm/mode.js"() {
    (function(ServerMode2) {
      ServerMode2.Development = "development", ServerMode2.Production = "production", ServerMode2.Test = "test";
    })(ServerMode || (ServerMode = {}));
  }
});

// node_modules/object-assign/index.js
var require_object_assign = __commonJS({
  "node_modules/object-assign/index.js"(exports, module) {
    "use strict";
    var getOwnPropertySymbols = Object.getOwnPropertySymbols, hasOwnProperty2 = Object.prototype.hasOwnProperty, propIsEnumerable = Object.prototype.propertyIsEnumerable;
    function toObject(val) {
      if (val == null)
        throw new TypeError("Object.assign cannot be called with null or undefined");
      return Object(val);
    }
    function shouldUseNative() {
      try {
        if (!Object.assign)
          return !1;
        var test1 = new String("abc");
        if (test1[5] = "de", Object.getOwnPropertyNames(test1)[0] === "5")
          return !1;
        for (var test2 = {}, i = 0; i < 10; i++)
          test2["_" + String.fromCharCode(i)] = i;
        var order2 = Object.getOwnPropertyNames(test2).map(function(n) {
          return test2[n];
        });
        if (order2.join("") !== "0123456789")
          return !1;
        var test3 = {};
        return "abcdefghijklmnopqrst".split("").forEach(function(letter) {
          test3[letter] = letter;
        }), Object.keys(Object.assign({}, test3)).join("") === "abcdefghijklmnopqrst";
      } catch {
        return !1;
      }
    }
    module.exports = shouldUseNative() ? Object.assign : function(target, source) {
      for (var from2, to = toObject(target), symbols, s = 1; s < arguments.length; s++) {
        from2 = Object(arguments[s]);
        for (var key in from2)
          hasOwnProperty2.call(from2, key) && (to[key] = from2[key]);
        if (getOwnPropertySymbols) {
          symbols = getOwnPropertySymbols(from2);
          for (var i = 0; i < symbols.length; i++)
            propIsEnumerable.call(from2, symbols[i]) && (to[symbols[i]] = from2[symbols[i]]);
        }
      }
      return to;
    };
  }
});

// node_modules/react/cjs/react.development.js
var require_react_development = __commonJS({
  "node_modules/react/cjs/react.development.js"(exports) {
    "use strict";
    (function() {
      "use strict";
      var _assign = require_object_assign(), ReactVersion = "17.0.2", REACT_ELEMENT_TYPE = 60103, REACT_PORTAL_TYPE = 60106;
      exports.Fragment = 60107, exports.StrictMode = 60108, exports.Profiler = 60114;
      var REACT_PROVIDER_TYPE = 60109, REACT_CONTEXT_TYPE = 60110, REACT_FORWARD_REF_TYPE = 60112;
      exports.Suspense = 60113;
      var REACT_SUSPENSE_LIST_TYPE = 60120, REACT_MEMO_TYPE = 60115, REACT_LAZY_TYPE = 60116, REACT_BLOCK_TYPE = 60121, REACT_SERVER_BLOCK_TYPE = 60122, REACT_FUNDAMENTAL_TYPE = 60117, REACT_SCOPE_TYPE = 60119, REACT_OPAQUE_ID_TYPE = 60128, REACT_DEBUG_TRACING_MODE_TYPE = 60129, REACT_OFFSCREEN_TYPE = 60130, REACT_LEGACY_HIDDEN_TYPE = 60131;
      if (typeof Symbol == "function" && Symbol.for) {
        var symbolFor = Symbol.for;
        REACT_ELEMENT_TYPE = symbolFor("react.element"), REACT_PORTAL_TYPE = symbolFor("react.portal"), exports.Fragment = symbolFor("react.fragment"), exports.StrictMode = symbolFor("react.strict_mode"), exports.Profiler = symbolFor("react.profiler"), REACT_PROVIDER_TYPE = symbolFor("react.provider"), REACT_CONTEXT_TYPE = symbolFor("react.context"), REACT_FORWARD_REF_TYPE = symbolFor("react.forward_ref"), exports.Suspense = symbolFor("react.suspense"), REACT_SUSPENSE_LIST_TYPE = symbolFor("react.suspense_list"), REACT_MEMO_TYPE = symbolFor("react.memo"), REACT_LAZY_TYPE = symbolFor("react.lazy"), REACT_BLOCK_TYPE = symbolFor("react.block"), REACT_SERVER_BLOCK_TYPE = symbolFor("react.server.block"), REACT_FUNDAMENTAL_TYPE = symbolFor("react.fundamental"), REACT_SCOPE_TYPE = symbolFor("react.scope"), REACT_OPAQUE_ID_TYPE = symbolFor("react.opaque.id"), REACT_DEBUG_TRACING_MODE_TYPE = symbolFor("react.debug_trace_mode"), REACT_OFFSCREEN_TYPE = symbolFor("react.offscreen"), REACT_LEGACY_HIDDEN_TYPE = symbolFor("react.legacy_hidden");
      }
      var MAYBE_ITERATOR_SYMBOL = typeof Symbol == "function" && Symbol.iterator, FAUX_ITERATOR_SYMBOL = "@@iterator";
      function getIteratorFn(maybeIterable) {
        if (maybeIterable === null || typeof maybeIterable != "object")
          return null;
        var maybeIterator = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL];
        return typeof maybeIterator == "function" ? maybeIterator : null;
      }
      var ReactCurrentDispatcher = {
        current: null
      }, ReactCurrentBatchConfig = {
        transition: 0
      }, ReactCurrentOwner = {
        current: null
      }, ReactDebugCurrentFrame = {}, currentExtraStackFrame = null;
      function setExtraStackFrame(stack) {
        currentExtraStackFrame = stack;
      }
      ReactDebugCurrentFrame.setExtraStackFrame = function(stack) {
        currentExtraStackFrame = stack;
      }, ReactDebugCurrentFrame.getCurrentStack = null, ReactDebugCurrentFrame.getStackAddendum = function() {
        var stack = "";
        currentExtraStackFrame && (stack += currentExtraStackFrame);
        var impl = ReactDebugCurrentFrame.getCurrentStack;
        return impl && (stack += impl() || ""), stack;
      };
      var IsSomeRendererActing = {
        current: !1
      }, ReactSharedInternals = {
        ReactCurrentDispatcher,
        ReactCurrentBatchConfig,
        ReactCurrentOwner,
        IsSomeRendererActing,
        assign: _assign
      };
      ReactSharedInternals.ReactDebugCurrentFrame = ReactDebugCurrentFrame;
      function warn(format2) {
        {
          for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++)
            args[_key - 1] = arguments[_key];
          printWarning("warn", format2, args);
        }
      }
      function error(format2) {
        {
          for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++)
            args[_key2 - 1] = arguments[_key2];
          printWarning("error", format2, args);
        }
      }
      function printWarning(level, format2, args) {
        {
          var ReactDebugCurrentFrame2 = ReactSharedInternals.ReactDebugCurrentFrame, stack = ReactDebugCurrentFrame2.getStackAddendum();
          stack !== "" && (format2 += "%s", args = args.concat([stack]));
          var argsWithFormat = args.map(function(item) {
            return "" + item;
          });
          argsWithFormat.unshift("Warning: " + format2), Function.prototype.apply.call(console[level], console, argsWithFormat);
        }
      }
      var didWarnStateUpdateForUnmountedComponent = {};
      function warnNoop(publicInstance, callerName) {
        {
          var _constructor = publicInstance.constructor, componentName = _constructor && (_constructor.displayName || _constructor.name) || "ReactClass", warningKey = componentName + "." + callerName;
          if (didWarnStateUpdateForUnmountedComponent[warningKey])
            return;
          error("Can't call %s on a component that is not yet mounted. This is a no-op, but it might indicate a bug in your application. Instead, assign to `this.state` directly or define a `state = {};` class property with the desired state in the %s component.", callerName, componentName), didWarnStateUpdateForUnmountedComponent[warningKey] = !0;
        }
      }
      var ReactNoopUpdateQueue = {
        isMounted: function(publicInstance) {
          return !1;
        },
        enqueueForceUpdate: function(publicInstance, callback, callerName) {
          warnNoop(publicInstance, "forceUpdate");
        },
        enqueueReplaceState: function(publicInstance, completeState, callback, callerName) {
          warnNoop(publicInstance, "replaceState");
        },
        enqueueSetState: function(publicInstance, partialState, callback, callerName) {
          warnNoop(publicInstance, "setState");
        }
      }, emptyObject = {};
      Object.freeze(emptyObject);
      function Component(props, context, updater) {
        this.props = props, this.context = context, this.refs = emptyObject, this.updater = updater || ReactNoopUpdateQueue;
      }
      Component.prototype.isReactComponent = {}, Component.prototype.setState = function(partialState, callback) {
        if (!(typeof partialState == "object" || typeof partialState == "function" || partialState == null))
          throw Error("setState(...): takes an object of state variables to update or a function which returns an object of state variables.");
        this.updater.enqueueSetState(this, partialState, callback, "setState");
      }, Component.prototype.forceUpdate = function(callback) {
        this.updater.enqueueForceUpdate(this, callback, "forceUpdate");
      };
      {
        var deprecatedAPIs = {
          isMounted: ["isMounted", "Instead, make sure to clean up subscriptions and pending requests in componentWillUnmount to prevent memory leaks."],
          replaceState: ["replaceState", "Refactor your code to use setState instead (see https://github.com/facebook/react/issues/3236)."]
        }, defineDeprecationWarning = function(methodName, info) {
          Object.defineProperty(Component.prototype, methodName, {
            get: function() {
              warn("%s(...) is deprecated in plain JavaScript React classes. %s", info[0], info[1]);
            }
          });
        };
        for (var fnName in deprecatedAPIs)
          deprecatedAPIs.hasOwnProperty(fnName) && defineDeprecationWarning(fnName, deprecatedAPIs[fnName]);
      }
      function ComponentDummy() {
      }
      ComponentDummy.prototype = Component.prototype;
      function PureComponent(props, context, updater) {
        this.props = props, this.context = context, this.refs = emptyObject, this.updater = updater || ReactNoopUpdateQueue;
      }
      var pureComponentPrototype = PureComponent.prototype = new ComponentDummy();
      pureComponentPrototype.constructor = PureComponent, _assign(pureComponentPrototype, Component.prototype), pureComponentPrototype.isPureReactComponent = !0;
      function createRef() {
        var refObject = {
          current: null
        };
        return Object.seal(refObject), refObject;
      }
      function getWrappedName2(outerType, innerType, wrapperName) {
        var functionName = innerType.displayName || innerType.name || "";
        return outerType.displayName || (functionName !== "" ? wrapperName + "(" + functionName + ")" : wrapperName);
      }
      function getContextName(type) {
        return type.displayName || "Context";
      }
      function getComponentName(type) {
        if (type == null)
          return null;
        if (typeof type.tag == "number" && error("Received an unexpected object in getComponentName(). This is likely a bug in React. Please file an issue."), typeof type == "function")
          return type.displayName || type.name || null;
        if (typeof type == "string")
          return type;
        switch (type) {
          case exports.Fragment:
            return "Fragment";
          case REACT_PORTAL_TYPE:
            return "Portal";
          case exports.Profiler:
            return "Profiler";
          case exports.StrictMode:
            return "StrictMode";
          case exports.Suspense:
            return "Suspense";
          case REACT_SUSPENSE_LIST_TYPE:
            return "SuspenseList";
        }
        if (typeof type == "object")
          switch (type.$$typeof) {
            case REACT_CONTEXT_TYPE:
              var context = type;
              return getContextName(context) + ".Consumer";
            case REACT_PROVIDER_TYPE:
              var provider = type;
              return getContextName(provider._context) + ".Provider";
            case REACT_FORWARD_REF_TYPE:
              return getWrappedName2(type, type.render, "ForwardRef");
            case REACT_MEMO_TYPE:
              return getComponentName(type.type);
            case REACT_BLOCK_TYPE:
              return getComponentName(type._render);
            case REACT_LAZY_TYPE: {
              var lazyComponent = type, payload = lazyComponent._payload, init2 = lazyComponent._init;
              try {
                return getComponentName(init2(payload));
              } catch {
                return null;
              }
            }
          }
        return null;
      }
      var hasOwnProperty2 = Object.prototype.hasOwnProperty, RESERVED_PROPS = {
        key: !0,
        ref: !0,
        __self: !0,
        __source: !0
      }, specialPropKeyWarningShown, specialPropRefWarningShown, didWarnAboutStringRefs;
      didWarnAboutStringRefs = {};
      function hasValidRef(config2) {
        if (hasOwnProperty2.call(config2, "ref")) {
          var getter = Object.getOwnPropertyDescriptor(config2, "ref").get;
          if (getter && getter.isReactWarning)
            return !1;
        }
        return config2.ref !== void 0;
      }
      function hasValidKey(config2) {
        if (hasOwnProperty2.call(config2, "key")) {
          var getter = Object.getOwnPropertyDescriptor(config2, "key").get;
          if (getter && getter.isReactWarning)
            return !1;
        }
        return config2.key !== void 0;
      }
      function defineKeyPropWarningGetter(props, displayName) {
        var warnAboutAccessingKey = function() {
          specialPropKeyWarningShown || (specialPropKeyWarningShown = !0, error("%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", displayName));
        };
        warnAboutAccessingKey.isReactWarning = !0, Object.defineProperty(props, "key", {
          get: warnAboutAccessingKey,
          configurable: !0
        });
      }
      function defineRefPropWarningGetter(props, displayName) {
        var warnAboutAccessingRef = function() {
          specialPropRefWarningShown || (specialPropRefWarningShown = !0, error("%s: `ref` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", displayName));
        };
        warnAboutAccessingRef.isReactWarning = !0, Object.defineProperty(props, "ref", {
          get: warnAboutAccessingRef,
          configurable: !0
        });
      }
      function warnIfStringRefCannotBeAutoConverted(config2) {
        if (typeof config2.ref == "string" && ReactCurrentOwner.current && config2.__self && ReactCurrentOwner.current.stateNode !== config2.__self) {
          var componentName = getComponentName(ReactCurrentOwner.current.type);
          didWarnAboutStringRefs[componentName] || (error('Component "%s" contains the string ref "%s". Support for string refs will be removed in a future major release. This case cannot be automatically converted to an arrow function. We ask you to manually fix this case by using useRef() or createRef() instead. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-string-ref', componentName, config2.ref), didWarnAboutStringRefs[componentName] = !0);
        }
      }
      var ReactElement = function(type, key, ref, self2, source, owner, props) {
        var element = {
          $$typeof: REACT_ELEMENT_TYPE,
          type,
          key,
          ref,
          props,
          _owner: owner
        };
        return element._store = {}, Object.defineProperty(element._store, "validated", {
          configurable: !1,
          enumerable: !1,
          writable: !0,
          value: !1
        }), Object.defineProperty(element, "_self", {
          configurable: !1,
          enumerable: !1,
          writable: !1,
          value: self2
        }), Object.defineProperty(element, "_source", {
          configurable: !1,
          enumerable: !1,
          writable: !1,
          value: source
        }), Object.freeze && (Object.freeze(element.props), Object.freeze(element)), element;
      };
      function createElement7(type, config2, children) {
        var propName, props = {}, key = null, ref = null, self2 = null, source = null;
        if (config2 != null) {
          hasValidRef(config2) && (ref = config2.ref, warnIfStringRefCannotBeAutoConverted(config2)), hasValidKey(config2) && (key = "" + config2.key), self2 = config2.__self === void 0 ? null : config2.__self, source = config2.__source === void 0 ? null : config2.__source;
          for (propName in config2)
            hasOwnProperty2.call(config2, propName) && !RESERVED_PROPS.hasOwnProperty(propName) && (props[propName] = config2[propName]);
        }
        var childrenLength = arguments.length - 2;
        if (childrenLength === 1)
          props.children = children;
        else if (childrenLength > 1) {
          for (var childArray = Array(childrenLength), i = 0; i < childrenLength; i++)
            childArray[i] = arguments[i + 2];
          Object.freeze && Object.freeze(childArray), props.children = childArray;
        }
        if (type && type.defaultProps) {
          var defaultProps2 = type.defaultProps;
          for (propName in defaultProps2)
            props[propName] === void 0 && (props[propName] = defaultProps2[propName]);
        }
        if (key || ref) {
          var displayName = typeof type == "function" ? type.displayName || type.name || "Unknown" : type;
          key && defineKeyPropWarningGetter(props, displayName), ref && defineRefPropWarningGetter(props, displayName);
        }
        return ReactElement(type, key, ref, self2, source, ReactCurrentOwner.current, props);
      }
      function cloneAndReplaceKey(oldElement, newKey) {
        var newElement = ReactElement(oldElement.type, newKey, oldElement.ref, oldElement._self, oldElement._source, oldElement._owner, oldElement.props);
        return newElement;
      }
      function cloneElement12(element, config2, children) {
        if (element == null)
          throw Error("React.cloneElement(...): The argument must be a React element, but you passed " + element + ".");
        var propName, props = _assign({}, element.props), key = element.key, ref = element.ref, self2 = element._self, source = element._source, owner = element._owner;
        if (config2 != null) {
          hasValidRef(config2) && (ref = config2.ref, owner = ReactCurrentOwner.current), hasValidKey(config2) && (key = "" + config2.key);
          var defaultProps2;
          element.type && element.type.defaultProps && (defaultProps2 = element.type.defaultProps);
          for (propName in config2)
            hasOwnProperty2.call(config2, propName) && !RESERVED_PROPS.hasOwnProperty(propName) && (config2[propName] === void 0 && defaultProps2 !== void 0 ? props[propName] = defaultProps2[propName] : props[propName] = config2[propName]);
        }
        var childrenLength = arguments.length - 2;
        if (childrenLength === 1)
          props.children = children;
        else if (childrenLength > 1) {
          for (var childArray = Array(childrenLength), i = 0; i < childrenLength; i++)
            childArray[i] = arguments[i + 2];
          props.children = childArray;
        }
        return ReactElement(element.type, key, ref, self2, source, owner, props);
      }
      function isValidElement9(object) {
        return typeof object == "object" && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;
      }
      var SEPARATOR = ".", SUBSEPARATOR = ":";
      function escape2(key) {
        var escapeRegex = /[=:]/g, escaperLookup = {
          "=": "=0",
          ":": "=2"
        }, escapedString = key.replace(escapeRegex, function(match) {
          return escaperLookup[match];
        });
        return "$" + escapedString;
      }
      var didWarnAboutMaps = !1, userProvidedKeyEscapeRegex = /\/+/g;
      function escapeUserProvidedKey(text) {
        return text.replace(userProvidedKeyEscapeRegex, "$&/");
      }
      function getElementKey(element, index) {
        return typeof element == "object" && element !== null && element.key != null ? escape2("" + element.key) : index.toString(36);
      }
      function mapIntoArray(children, array, escapedPrefix, nameSoFar, callback) {
        var type = typeof children;
        (type === "undefined" || type === "boolean") && (children = null);
        var invokeCallback = !1;
        if (children === null)
          invokeCallback = !0;
        else
          switch (type) {
            case "string":
            case "number":
              invokeCallback = !0;
              break;
            case "object":
              switch (children.$$typeof) {
                case REACT_ELEMENT_TYPE:
                case REACT_PORTAL_TYPE:
                  invokeCallback = !0;
              }
          }
        if (invokeCallback) {
          var _child = children, mappedChild = callback(_child), childKey = nameSoFar === "" ? SEPARATOR + getElementKey(_child, 0) : nameSoFar;
          if (Array.isArray(mappedChild)) {
            var escapedChildKey = "";
            childKey != null && (escapedChildKey = escapeUserProvidedKey(childKey) + "/"), mapIntoArray(mappedChild, array, escapedChildKey, "", function(c) {
              return c;
            });
          } else
            mappedChild != null && (isValidElement9(mappedChild) && (mappedChild = cloneAndReplaceKey(
              mappedChild,
              escapedPrefix + (mappedChild.key && (!_child || _child.key !== mappedChild.key) ? escapeUserProvidedKey("" + mappedChild.key) + "/" : "") + childKey
            )), array.push(mappedChild));
          return 1;
        }
        var child, nextName, subtreeCount = 0, nextNamePrefix = nameSoFar === "" ? SEPARATOR : nameSoFar + SUBSEPARATOR;
        if (Array.isArray(children))
          for (var i = 0; i < children.length; i++)
            child = children[i], nextName = nextNamePrefix + getElementKey(child, i), subtreeCount += mapIntoArray(child, array, escapedPrefix, nextName, callback);
        else {
          var iteratorFn = getIteratorFn(children);
          if (typeof iteratorFn == "function") {
            var iterableChildren = children;
            iteratorFn === iterableChildren.entries && (didWarnAboutMaps || warn("Using Maps as children is not supported. Use an array of keyed ReactElements instead."), didWarnAboutMaps = !0);
            for (var iterator = iteratorFn.call(iterableChildren), step, ii = 0; !(step = iterator.next()).done; )
              child = step.value, nextName = nextNamePrefix + getElementKey(child, ii++), subtreeCount += mapIntoArray(child, array, escapedPrefix, nextName, callback);
          } else if (type === "object") {
            var childrenString = "" + children;
            throw Error("Objects are not valid as a React child (found: " + (childrenString === "[object Object]" ? "object with keys {" + Object.keys(children).join(", ") + "}" : childrenString) + "). If you meant to render a collection of children, use an array instead.");
          }
        }
        return subtreeCount;
      }
      function mapChildren(children, func, context) {
        if (children == null)
          return children;
        var result = [], count = 0;
        return mapIntoArray(children, result, "", "", function(child) {
          return func.call(context, child, count++);
        }), result;
      }
      function countChildren(children) {
        var n = 0;
        return mapChildren(children, function() {
          n++;
        }), n;
      }
      function forEachChildren(children, forEachFunc, forEachContext) {
        mapChildren(children, function() {
          forEachFunc.apply(this, arguments);
        }, forEachContext);
      }
      function toArray(children) {
        return mapChildren(children, function(child) {
          return child;
        }) || [];
      }
      function onlyChild(children) {
        if (!isValidElement9(children))
          throw Error("React.Children.only expected to receive a single React element child.");
        return children;
      }
      function createContext12(defaultValue, calculateChangedBits) {
        calculateChangedBits === void 0 ? calculateChangedBits = null : calculateChangedBits !== null && typeof calculateChangedBits != "function" && error("createContext: Expected the optional second argument to be a function. Instead received: %s", calculateChangedBits);
        var context = {
          $$typeof: REACT_CONTEXT_TYPE,
          _calculateChangedBits: calculateChangedBits,
          _currentValue: defaultValue,
          _currentValue2: defaultValue,
          _threadCount: 0,
          Provider: null,
          Consumer: null
        };
        context.Provider = {
          $$typeof: REACT_PROVIDER_TYPE,
          _context: context
        };
        var hasWarnedAboutUsingNestedContextConsumers = !1, hasWarnedAboutUsingConsumerProvider = !1, hasWarnedAboutDisplayNameOnConsumer = !1;
        {
          var Consumer = {
            $$typeof: REACT_CONTEXT_TYPE,
            _context: context,
            _calculateChangedBits: context._calculateChangedBits
          };
          Object.defineProperties(Consumer, {
            Provider: {
              get: function() {
                return hasWarnedAboutUsingConsumerProvider || (hasWarnedAboutUsingConsumerProvider = !0, error("Rendering <Context.Consumer.Provider> is not supported and will be removed in a future major release. Did you mean to render <Context.Provider> instead?")), context.Provider;
              },
              set: function(_Provider) {
                context.Provider = _Provider;
              }
            },
            _currentValue: {
              get: function() {
                return context._currentValue;
              },
              set: function(_currentValue) {
                context._currentValue = _currentValue;
              }
            },
            _currentValue2: {
              get: function() {
                return context._currentValue2;
              },
              set: function(_currentValue2) {
                context._currentValue2 = _currentValue2;
              }
            },
            _threadCount: {
              get: function() {
                return context._threadCount;
              },
              set: function(_threadCount) {
                context._threadCount = _threadCount;
              }
            },
            Consumer: {
              get: function() {
                return hasWarnedAboutUsingNestedContextConsumers || (hasWarnedAboutUsingNestedContextConsumers = !0, error("Rendering <Context.Consumer.Consumer> is not supported and will be removed in a future major release. Did you mean to render <Context.Consumer> instead?")), context.Consumer;
              }
            },
            displayName: {
              get: function() {
                return context.displayName;
              },
              set: function(displayName) {
                hasWarnedAboutDisplayNameOnConsumer || (warn("Setting `displayName` on Context.Consumer has no effect. You should set it directly on the context with Context.displayName = '%s'.", displayName), hasWarnedAboutDisplayNameOnConsumer = !0);
              }
            }
          }), context.Consumer = Consumer;
        }
        return context._currentRenderer = null, context._currentRenderer2 = null, context;
      }
      var Uninitialized = -1, Pending = 0, Resolved = 1, Rejected = 2;
      function lazyInitializer(payload) {
        if (payload._status === Uninitialized) {
          var ctor = payload._result, thenable = ctor(), pending = payload;
          pending._status = Pending, pending._result = thenable, thenable.then(function(moduleObject) {
            if (payload._status === Pending) {
              var defaultExport = moduleObject.default;
              defaultExport === void 0 && error(`lazy: Expected the result of a dynamic import() call. Instead received: %s

Your code should look like: 
  const MyComponent = lazy(() => import('./MyComponent'))`, moduleObject);
              var resolved = payload;
              resolved._status = Resolved, resolved._result = defaultExport;
            }
          }, function(error2) {
            if (payload._status === Pending) {
              var rejected = payload;
              rejected._status = Rejected, rejected._result = error2;
            }
          });
        }
        if (payload._status === Resolved)
          return payload._result;
        throw payload._result;
      }
      function lazy(ctor) {
        var payload = {
          _status: -1,
          _result: ctor
        }, lazyType = {
          $$typeof: REACT_LAZY_TYPE,
          _payload: payload,
          _init: lazyInitializer
        };
        {
          var defaultProps2, propTypes;
          Object.defineProperties(lazyType, {
            defaultProps: {
              configurable: !0,
              get: function() {
                return defaultProps2;
              },
              set: function(newDefaultProps) {
                error("React.lazy(...): It is not supported to assign `defaultProps` to a lazy component import. Either specify them where the component is defined, or create a wrapping component around it."), defaultProps2 = newDefaultProps, Object.defineProperty(lazyType, "defaultProps", {
                  enumerable: !0
                });
              }
            },
            propTypes: {
              configurable: !0,
              get: function() {
                return propTypes;
              },
              set: function(newPropTypes) {
                error("React.lazy(...): It is not supported to assign `propTypes` to a lazy component import. Either specify them where the component is defined, or create a wrapping component around it."), propTypes = newPropTypes, Object.defineProperty(lazyType, "propTypes", {
                  enumerable: !0
                });
              }
            }
          });
        }
        return lazyType;
      }
      function forwardRef50(render) {
        render != null && render.$$typeof === REACT_MEMO_TYPE ? error("forwardRef requires a render function but received a `memo` component. Instead of forwardRef(memo(...)), use memo(forwardRef(...)).") : typeof render != "function" ? error("forwardRef requires a render function but was given %s.", render === null ? "null" : typeof render) : render.length !== 0 && render.length !== 2 && error("forwardRef render functions accept exactly two parameters: props and ref. %s", render.length === 1 ? "Did you forget to use the ref parameter?" : "Any additional parameter will be undefined."), render != null && (render.defaultProps != null || render.propTypes != null) && error("forwardRef render functions do not support propTypes or defaultProps. Did you accidentally pass a React component?");
        var elementType = {
          $$typeof: REACT_FORWARD_REF_TYPE,
          render
        };
        {
          var ownName;
          Object.defineProperty(elementType, "displayName", {
            enumerable: !1,
            configurable: !0,
            get: function() {
              return ownName;
            },
            set: function(name) {
              ownName = name, render.displayName == null && (render.displayName = name);
            }
          });
        }
        return elementType;
      }
      var enableScopeAPI = !1;
      function isValidElementType(type) {
        return !!(typeof type == "string" || typeof type == "function" || type === exports.Fragment || type === exports.Profiler || type === REACT_DEBUG_TRACING_MODE_TYPE || type === exports.StrictMode || type === exports.Suspense || type === REACT_SUSPENSE_LIST_TYPE || type === REACT_LEGACY_HIDDEN_TYPE || enableScopeAPI || typeof type == "object" && type !== null && (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_PROVIDER_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE || type.$$typeof === REACT_FUNDAMENTAL_TYPE || type.$$typeof === REACT_BLOCK_TYPE || type[0] === REACT_SERVER_BLOCK_TYPE));
      }
      function memo2(type, compare3) {
        isValidElementType(type) || error("memo: The first argument must be a component. Instead received: %s", type === null ? "null" : typeof type);
        var elementType = {
          $$typeof: REACT_MEMO_TYPE,
          type,
          compare: compare3 === void 0 ? null : compare3
        };
        {
          var ownName;
          Object.defineProperty(elementType, "displayName", {
            enumerable: !1,
            configurable: !0,
            get: function() {
              return ownName;
            },
            set: function(name) {
              ownName = name, type.displayName == null && (type.displayName = name);
            }
          });
        }
        return elementType;
      }
      function resolveDispatcher() {
        var dispatcher = ReactCurrentDispatcher.current;
        if (dispatcher === null)
          throw Error(`Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for one of the following reasons:
1. You might have mismatching versions of React and the renderer (such as React DOM)
2. You might be breaking the Rules of Hooks
3. You might have more than one copy of React in the same app
See https://reactjs.org/link/invalid-hook-call for tips about how to debug and fix this problem.`);
        return dispatcher;
      }
      function useContext11(Context2, unstable_observedBits) {
        var dispatcher = resolveDispatcher();
        if (unstable_observedBits !== void 0 && error("useContext() second argument is reserved for future use in React. Passing it is not supported. You passed: %s.%s", unstable_observedBits, typeof unstable_observedBits == "number" && Array.isArray(arguments[2]) ? `

Did you call array.map(useContext)? Calling Hooks inside a loop is not supported. Learn more at https://reactjs.org/link/rules-of-hooks` : ""), Context2._context !== void 0) {
          var realContext = Context2._context;
          realContext.Consumer === Context2 ? error("Calling useContext(Context.Consumer) is not supported, may cause bugs, and will be removed in a future major release. Did you mean to call useContext(Context) instead?") : realContext.Provider === Context2 && error("Calling useContext(Context.Provider) is not supported. Did you mean to call useContext(Context) instead?");
        }
        return dispatcher.useContext(Context2, unstable_observedBits);
      }
      function useState18(initialState) {
        var dispatcher = resolveDispatcher();
        return dispatcher.useState(initialState);
      }
      function useReducer(reducer, initialArg, init2) {
        var dispatcher = resolveDispatcher();
        return dispatcher.useReducer(reducer, initialArg, init2);
      }
      function useRef21(initialValue) {
        var dispatcher = resolveDispatcher();
        return dispatcher.useRef(initialValue);
      }
      function useEffect17(create, deps) {
        var dispatcher = resolveDispatcher();
        return dispatcher.useEffect(create, deps);
      }
      function useLayoutEffect5(create, deps) {
        var dispatcher = resolveDispatcher();
        return dispatcher.useLayoutEffect(create, deps);
      }
      function useCallback16(callback, deps) {
        var dispatcher = resolveDispatcher();
        return dispatcher.useCallback(callback, deps);
      }
      function useMemo8(create, deps) {
        var dispatcher = resolveDispatcher();
        return dispatcher.useMemo(create, deps);
      }
      function useImperativeHandle6(ref, create, deps) {
        var dispatcher = resolveDispatcher();
        return dispatcher.useImperativeHandle(ref, create, deps);
      }
      function useDebugValue3(value, formatterFn) {
        {
          var dispatcher = resolveDispatcher();
          return dispatcher.useDebugValue(value, formatterFn);
        }
      }
      var disabledDepth = 0, prevLog, prevInfo, prevWarn, prevError, prevGroup, prevGroupCollapsed, prevGroupEnd;
      function disabledLog() {
      }
      disabledLog.__reactDisabledLog = !0;
      function disableLogs() {
        {
          if (disabledDepth === 0) {
            prevLog = console.log, prevInfo = console.info, prevWarn = console.warn, prevError = console.error, prevGroup = console.group, prevGroupCollapsed = console.groupCollapsed, prevGroupEnd = console.groupEnd;
            var props = {
              configurable: !0,
              enumerable: !0,
              value: disabledLog,
              writable: !0
            };
            Object.defineProperties(console, {
              info: props,
              log: props,
              warn: props,
              error: props,
              group: props,
              groupCollapsed: props,
              groupEnd: props
            });
          }
          disabledDepth++;
        }
      }
      function reenableLogs() {
        {
          if (disabledDepth--, disabledDepth === 0) {
            var props = {
              configurable: !0,
              enumerable: !0,
              writable: !0
            };
            Object.defineProperties(console, {
              log: _assign({}, props, {
                value: prevLog
              }),
              info: _assign({}, props, {
                value: prevInfo
              }),
              warn: _assign({}, props, {
                value: prevWarn
              }),
              error: _assign({}, props, {
                value: prevError
              }),
              group: _assign({}, props, {
                value: prevGroup
              }),
              groupCollapsed: _assign({}, props, {
                value: prevGroupCollapsed
              }),
              groupEnd: _assign({}, props, {
                value: prevGroupEnd
              })
            });
          }
          disabledDepth < 0 && error("disabledDepth fell below zero. This is a bug in React. Please file an issue.");
        }
      }
      var ReactCurrentDispatcher$1 = ReactSharedInternals.ReactCurrentDispatcher, prefix;
      function describeBuiltInComponentFrame(name, source, ownerFn) {
        {
          if (prefix === void 0)
            try {
              throw Error();
            } catch (x) {
              var match = x.stack.trim().match(/\n( *(at )?)/);
              prefix = match && match[1] || "";
            }
          return `
` + prefix + name;
        }
      }
      var reentry = !1, componentFrameCache;
      {
        var PossiblyWeakMap = typeof WeakMap == "function" ? WeakMap : Map;
        componentFrameCache = new PossiblyWeakMap();
      }
      function describeNativeComponentFrame(fn, construct) {
        if (!fn || reentry)
          return "";
        {
          var frame = componentFrameCache.get(fn);
          if (frame !== void 0)
            return frame;
        }
        var control;
        reentry = !0;
        var previousPrepareStackTrace = Error.prepareStackTrace;
        Error.prepareStackTrace = void 0;
        var previousDispatcher;
        previousDispatcher = ReactCurrentDispatcher$1.current, ReactCurrentDispatcher$1.current = null, disableLogs();
        try {
          if (construct) {
            var Fake = function() {
              throw Error();
            };
            if (Object.defineProperty(Fake.prototype, "props", {
              set: function() {
                throw Error();
              }
            }), typeof Reflect == "object" && Reflect.construct) {
              try {
                Reflect.construct(Fake, []);
              } catch (x) {
                control = x;
              }
              Reflect.construct(fn, [], Fake);
            } else {
              try {
                Fake.call();
              } catch (x) {
                control = x;
              }
              fn.call(Fake.prototype);
            }
          } else {
            try {
              throw Error();
            } catch (x) {
              control = x;
            }
            fn();
          }
        } catch (sample) {
          if (sample && control && typeof sample.stack == "string") {
            for (var sampleLines = sample.stack.split(`
`), controlLines = control.stack.split(`
`), s = sampleLines.length - 1, c = controlLines.length - 1; s >= 1 && c >= 0 && sampleLines[s] !== controlLines[c]; )
              c--;
            for (; s >= 1 && c >= 0; s--, c--)
              if (sampleLines[s] !== controlLines[c]) {
                if (s !== 1 || c !== 1)
                  do
                    if (s--, c--, c < 0 || sampleLines[s] !== controlLines[c]) {
                      var _frame = `
` + sampleLines[s].replace(" at new ", " at ");
                      return typeof fn == "function" && componentFrameCache.set(fn, _frame), _frame;
                    }
                  while (s >= 1 && c >= 0);
                break;
              }
          }
        } finally {
          reentry = !1, ReactCurrentDispatcher$1.current = previousDispatcher, reenableLogs(), Error.prepareStackTrace = previousPrepareStackTrace;
        }
        var name = fn ? fn.displayName || fn.name : "", syntheticFrame = name ? describeBuiltInComponentFrame(name) : "";
        return typeof fn == "function" && componentFrameCache.set(fn, syntheticFrame), syntheticFrame;
      }
      function describeFunctionComponentFrame(fn, source, ownerFn) {
        return describeNativeComponentFrame(fn, !1);
      }
      function shouldConstruct(Component2) {
        var prototype = Component2.prototype;
        return !!(prototype && prototype.isReactComponent);
      }
      function describeUnknownElementTypeFrameInDEV(type, source, ownerFn) {
        if (type == null)
          return "";
        if (typeof type == "function")
          return describeNativeComponentFrame(type, shouldConstruct(type));
        if (typeof type == "string")
          return describeBuiltInComponentFrame(type);
        switch (type) {
          case exports.Suspense:
            return describeBuiltInComponentFrame("Suspense");
          case REACT_SUSPENSE_LIST_TYPE:
            return describeBuiltInComponentFrame("SuspenseList");
        }
        if (typeof type == "object")
          switch (type.$$typeof) {
            case REACT_FORWARD_REF_TYPE:
              return describeFunctionComponentFrame(type.render);
            case REACT_MEMO_TYPE:
              return describeUnknownElementTypeFrameInDEV(type.type, source, ownerFn);
            case REACT_BLOCK_TYPE:
              return describeFunctionComponentFrame(type._render);
            case REACT_LAZY_TYPE: {
              var lazyComponent = type, payload = lazyComponent._payload, init2 = lazyComponent._init;
              try {
                return describeUnknownElementTypeFrameInDEV(init2(payload), source, ownerFn);
              } catch {
              }
            }
          }
        return "";
      }
      var loggedTypeFailures = {}, ReactDebugCurrentFrame$1 = ReactSharedInternals.ReactDebugCurrentFrame;
      function setCurrentlyValidatingElement(element) {
        if (element) {
          var owner = element._owner, stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);
          ReactDebugCurrentFrame$1.setExtraStackFrame(stack);
        } else
          ReactDebugCurrentFrame$1.setExtraStackFrame(null);
      }
      function checkPropTypes(typeSpecs, values3, location, componentName, element) {
        {
          var has = Function.call.bind(Object.prototype.hasOwnProperty);
          for (var typeSpecName in typeSpecs)
            if (has(typeSpecs, typeSpecName)) {
              var error$1 = void 0;
              try {
                if (typeof typeSpecs[typeSpecName] != "function") {
                  var err = Error((componentName || "React class") + ": " + location + " type `" + typeSpecName + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof typeSpecs[typeSpecName] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.");
                  throw err.name = "Invariant Violation", err;
                }
                error$1 = typeSpecs[typeSpecName](values3, typeSpecName, componentName, location, null, "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED");
              } catch (ex) {
                error$1 = ex;
              }
              error$1 && !(error$1 instanceof Error) && (setCurrentlyValidatingElement(element), error("%s: type specification of %s `%s` is invalid; the type checker function must return `null` or an `Error` but returned a %s. You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).", componentName || "React class", location, typeSpecName, typeof error$1), setCurrentlyValidatingElement(null)), error$1 instanceof Error && !(error$1.message in loggedTypeFailures) && (loggedTypeFailures[error$1.message] = !0, setCurrentlyValidatingElement(element), error("Failed %s type: %s", location, error$1.message), setCurrentlyValidatingElement(null));
            }
        }
      }
      function setCurrentlyValidatingElement$1(element) {
        if (element) {
          var owner = element._owner, stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);
          setExtraStackFrame(stack);
        } else
          setExtraStackFrame(null);
      }
      var propTypesMisspellWarningShown;
      propTypesMisspellWarningShown = !1;
      function getDeclarationErrorAddendum() {
        if (ReactCurrentOwner.current) {
          var name = getComponentName(ReactCurrentOwner.current.type);
          if (name)
            return `

Check the render method of \`` + name + "`.";
        }
        return "";
      }
      function getSourceInfoErrorAddendum(source) {
        if (source !== void 0) {
          var fileName = source.fileName.replace(/^.*[\\\/]/, ""), lineNumber = source.lineNumber;
          return `

Check your code at ` + fileName + ":" + lineNumber + ".";
        }
        return "";
      }
      function getSourceInfoErrorAddendumForProps(elementProps) {
        return elementProps != null ? getSourceInfoErrorAddendum(elementProps.__source) : "";
      }
      var ownerHasKeyUseWarning = {};
      function getCurrentComponentErrorInfo(parentType) {
        var info = getDeclarationErrorAddendum();
        if (!info) {
          var parentName = typeof parentType == "string" ? parentType : parentType.displayName || parentType.name;
          parentName && (info = `

Check the top-level render call using <` + parentName + ">.");
        }
        return info;
      }
      function validateExplicitKey(element, parentType) {
        if (!(!element._store || element._store.validated || element.key != null)) {
          element._store.validated = !0;
          var currentComponentErrorInfo = getCurrentComponentErrorInfo(parentType);
          if (!ownerHasKeyUseWarning[currentComponentErrorInfo]) {
            ownerHasKeyUseWarning[currentComponentErrorInfo] = !0;
            var childOwner = "";
            element && element._owner && element._owner !== ReactCurrentOwner.current && (childOwner = " It was passed a child from " + getComponentName(element._owner.type) + "."), setCurrentlyValidatingElement$1(element), error('Each child in a list should have a unique "key" prop.%s%s See https://reactjs.org/link/warning-keys for more information.', currentComponentErrorInfo, childOwner), setCurrentlyValidatingElement$1(null);
          }
        }
      }
      function validateChildKeys(node, parentType) {
        if (typeof node == "object") {
          if (Array.isArray(node))
            for (var i = 0; i < node.length; i++) {
              var child = node[i];
              isValidElement9(child) && validateExplicitKey(child, parentType);
            }
          else if (isValidElement9(node))
            node._store && (node._store.validated = !0);
          else if (node) {
            var iteratorFn = getIteratorFn(node);
            if (typeof iteratorFn == "function" && iteratorFn !== node.entries)
              for (var iterator = iteratorFn.call(node), step; !(step = iterator.next()).done; )
                isValidElement9(step.value) && validateExplicitKey(step.value, parentType);
          }
        }
      }
      function validatePropTypes(element) {
        {
          var type = element.type;
          if (type == null || typeof type == "string")
            return;
          var propTypes;
          if (typeof type == "function")
            propTypes = type.propTypes;
          else if (typeof type == "object" && (type.$$typeof === REACT_FORWARD_REF_TYPE || type.$$typeof === REACT_MEMO_TYPE))
            propTypes = type.propTypes;
          else
            return;
          if (propTypes) {
            var name = getComponentName(type);
            checkPropTypes(propTypes, element.props, "prop", name, element);
          } else if (type.PropTypes !== void 0 && !propTypesMisspellWarningShown) {
            propTypesMisspellWarningShown = !0;
            var _name = getComponentName(type);
            error("Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?", _name || "Unknown");
          }
          typeof type.getDefaultProps == "function" && !type.getDefaultProps.isReactClassApproved && error("getDefaultProps is only used on classic React.createClass definitions. Use a static property named `defaultProps` instead.");
        }
      }
      function validateFragmentProps(fragment) {
        {
          for (var keys2 = Object.keys(fragment.props), i = 0; i < keys2.length; i++) {
            var key = keys2[i];
            if (key !== "children" && key !== "key") {
              setCurrentlyValidatingElement$1(fragment), error("Invalid prop `%s` supplied to `React.Fragment`. React.Fragment can only have `key` and `children` props.", key), setCurrentlyValidatingElement$1(null);
              break;
            }
          }
          fragment.ref !== null && (setCurrentlyValidatingElement$1(fragment), error("Invalid attribute `ref` supplied to `React.Fragment`."), setCurrentlyValidatingElement$1(null));
        }
      }
      function createElementWithValidation(type, props, children) {
        var validType = isValidElementType(type);
        if (!validType) {
          var info = "";
          (type === void 0 || typeof type == "object" && type !== null && Object.keys(type).length === 0) && (info += " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.");
          var sourceInfo = getSourceInfoErrorAddendumForProps(props);
          sourceInfo ? info += sourceInfo : info += getDeclarationErrorAddendum();
          var typeString;
          type === null ? typeString = "null" : Array.isArray(type) ? typeString = "array" : type !== void 0 && type.$$typeof === REACT_ELEMENT_TYPE ? (typeString = "<" + (getComponentName(type.type) || "Unknown") + " />", info = " Did you accidentally export a JSX literal instead of a component?") : typeString = typeof type, error("React.createElement: type is invalid -- expected a string (for built-in components) or a class/function (for composite components) but got: %s.%s", typeString, info);
        }
        var element = createElement7.apply(this, arguments);
        if (element == null)
          return element;
        if (validType)
          for (var i = 2; i < arguments.length; i++)
            validateChildKeys(arguments[i], type);
        return type === exports.Fragment ? validateFragmentProps(element) : validatePropTypes(element), element;
      }
      var didWarnAboutDeprecatedCreateFactory = !1;
      function createFactoryWithValidation(type) {
        var validatedFactory = createElementWithValidation.bind(null, type);
        return validatedFactory.type = type, didWarnAboutDeprecatedCreateFactory || (didWarnAboutDeprecatedCreateFactory = !0, warn("React.createFactory() is deprecated and will be removed in a future major release. Consider using JSX or use React.createElement() directly instead.")), Object.defineProperty(validatedFactory, "type", {
          enumerable: !1,
          get: function() {
            return warn("Factory.type is deprecated. Access the class directly before passing it to createFactory."), Object.defineProperty(this, "type", {
              value: type
            }), type;
          }
        }), validatedFactory;
      }
      function cloneElementWithValidation(element, props, children) {
        for (var newElement = cloneElement12.apply(this, arguments), i = 2; i < arguments.length; i++)
          validateChildKeys(arguments[i], newElement.type);
        return validatePropTypes(newElement), newElement;
      }
      try {
        var frozenObject = Object.freeze({});
      } catch {
      }
      var createElement$1 = createElementWithValidation, cloneElement$1 = cloneElementWithValidation, createFactory = createFactoryWithValidation, Children8 = {
        map: mapChildren,
        forEach: forEachChildren,
        count: countChildren,
        toArray,
        only: onlyChild
      };
      exports.Children = Children8, exports.Component = Component, exports.PureComponent = PureComponent, exports.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = ReactSharedInternals, exports.cloneElement = cloneElement$1, exports.createContext = createContext12, exports.createElement = createElement$1, exports.createFactory = createFactory, exports.createRef = createRef, exports.forwardRef = forwardRef50, exports.isValidElement = isValidElement9, exports.lazy = lazy, exports.memo = memo2, exports.useCallback = useCallback16, exports.useContext = useContext11, exports.useDebugValue = useDebugValue3, exports.useEffect = useEffect17, exports.useImperativeHandle = useImperativeHandle6, exports.useLayoutEffect = useLayoutEffect5, exports.useMemo = useMemo8, exports.useReducer = useReducer, exports.useRef = useRef21, exports.useState = useState18, exports.version = ReactVersion;
    })();
  }
});

// node_modules/react/index.js
var require_react = __commonJS({
  "node_modules/react/index.js"(exports, module) {
    "use strict";
    module.exports = require_react_development();
  }
});

// node_modules/@babel/runtime/helpers/esm/extends.js
function _extends() {
  return _extends = Object.assign ? Object.assign.bind() : function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source)
        Object.prototype.hasOwnProperty.call(source, key) && (target[key] = source[key]);
    }
    return target;
  }, _extends.apply(this, arguments);
}
var init_extends = __esm({
  "node_modules/@babel/runtime/helpers/esm/extends.js"() {
  }
});

// node_modules/history/index.js
function createPath(_ref) {
  var _ref$pathname = _ref.pathname, pathname = _ref$pathname === void 0 ? "/" : _ref$pathname, _ref$search = _ref.search, search = _ref$search === void 0 ? "" : _ref$search, _ref$hash = _ref.hash, hash = _ref$hash === void 0 ? "" : _ref$hash;
  return search && search !== "?" && (pathname += search.charAt(0) === "?" ? search : "?" + search), hash && hash !== "#" && (pathname += hash.charAt(0) === "#" ? hash : "#" + hash), pathname;
}
function parsePath(path) {
  var parsedPath = {};
  if (path) {
    var hashIndex = path.indexOf("#");
    hashIndex >= 0 && (parsedPath.hash = path.substr(hashIndex), path = path.substr(0, hashIndex));
    var searchIndex = path.indexOf("?");
    searchIndex >= 0 && (parsedPath.search = path.substr(searchIndex), path = path.substr(0, searchIndex)), path && (parsedPath.pathname = path);
  }
  return parsedPath;
}
var Action, init_history = __esm({
  "node_modules/history/index.js"() {
    init_extends();
    (function(Action2) {
      Action2.Pop = "POP", Action2.Push = "PUSH", Action2.Replace = "REPLACE";
    })(Action || (Action = {}));
  }
});

// node_modules/react-router/index.js
function invariant(cond, message) {
  if (!cond)
    throw new Error(message);
}
function warning(cond, message) {
  if (!cond) {
    typeof console < "u" && console.warn(message);
    try {
      throw new Error(message);
    } catch {
    }
  }
}
function warningOnce(key, cond, message) {
  !cond && !alreadyWarned2[key] && (alreadyWarned2[key] = !0, warning(!1, message));
}
function matchRoutes(routes2, locationArg, basename) {
  basename === void 0 && (basename = "/");
  let location = typeof locationArg == "string" ? parsePath(locationArg) : locationArg, pathname = stripBasename(location.pathname || "/", basename);
  if (pathname == null)
    return null;
  let branches = flattenRoutes(routes2);
  rankRouteBranches(branches);
  let matches = null;
  for (let i = 0; matches == null && i < branches.length; ++i)
    matches = matchRouteBranch(branches[i], pathname);
  return matches;
}
function flattenRoutes(routes2, branches, parentsMeta, parentPath) {
  return branches === void 0 && (branches = []), parentsMeta === void 0 && (parentsMeta = []), parentPath === void 0 && (parentPath = ""), routes2.forEach((route, index) => {
    let meta2 = {
      relativePath: route.path || "",
      caseSensitive: route.caseSensitive === !0,
      childrenIndex: index,
      route
    };
    meta2.relativePath.startsWith("/") && (meta2.relativePath.startsWith(parentPath) || invariant(!1, 'Absolute route path "' + meta2.relativePath + '" nested under path ' + ('"' + parentPath + '" is not valid. An absolute child route path ') + "must start with the combined path of all its parent routes."), meta2.relativePath = meta2.relativePath.slice(parentPath.length));
    let path = joinPaths([parentPath, meta2.relativePath]), routesMeta = parentsMeta.concat(meta2);
    route.children && route.children.length > 0 && (route.index === !0 && invariant(!1, "Index routes must not have child routes. Please remove " + ('all child routes from route path "' + path + '".')), flattenRoutes(route.children, branches, routesMeta, path)), !(route.path == null && !route.index) && branches.push({
      path,
      score: computeScore(path, route.index),
      routesMeta
    });
  }), branches;
}
function rankRouteBranches(branches) {
  branches.sort((a, b) => a.score !== b.score ? b.score - a.score : compareIndexes(a.routesMeta.map((meta2) => meta2.childrenIndex), b.routesMeta.map((meta2) => meta2.childrenIndex)));
}
function computeScore(path, index) {
  let segments = path.split("/"), initialScore = segments.length;
  return segments.some(isSplat) && (initialScore += splatPenalty), index && (initialScore += indexRouteValue), segments.filter((s) => !isSplat(s)).reduce((score, segment) => score + (paramRe.test(segment) ? dynamicSegmentValue : segment === "" ? emptySegmentValue : staticSegmentValue), initialScore);
}
function compareIndexes(a, b) {
  return a.length === b.length && a.slice(0, -1).every((n, i) => n === b[i]) ? a[a.length - 1] - b[b.length - 1] : 0;
}
function matchRouteBranch(branch, pathname) {
  let {
    routesMeta
  } = branch, matchedParams = {}, matchedPathname = "/", matches = [];
  for (let i = 0; i < routesMeta.length; ++i) {
    let meta2 = routesMeta[i], end = i === routesMeta.length - 1, remainingPathname = matchedPathname === "/" ? pathname : pathname.slice(matchedPathname.length) || "/", match = matchPath({
      path: meta2.relativePath,
      caseSensitive: meta2.caseSensitive,
      end
    }, remainingPathname);
    if (!match)
      return null;
    Object.assign(matchedParams, match.params);
    let route = meta2.route;
    matches.push({
      params: matchedParams,
      pathname: joinPaths([matchedPathname, match.pathname]),
      pathnameBase: normalizePathname(joinPaths([matchedPathname, match.pathnameBase])),
      route
    }), match.pathnameBase !== "/" && (matchedPathname = joinPaths([matchedPathname, match.pathnameBase]));
  }
  return matches;
}
function matchPath(pattern, pathname) {
  typeof pattern == "string" && (pattern = {
    path: pattern,
    caseSensitive: !1,
    end: !0
  });
  let [matcher, paramNames] = compilePath(pattern.path, pattern.caseSensitive, pattern.end), match = pathname.match(matcher);
  if (!match)
    return null;
  let matchedPathname = match[0], pathnameBase = matchedPathname.replace(/(.)\/+$/, "$1"), captureGroups = match.slice(1);
  return {
    params: paramNames.reduce((memo2, paramName, index) => {
      if (paramName === "*") {
        let splatValue = captureGroups[index] || "";
        pathnameBase = matchedPathname.slice(0, matchedPathname.length - splatValue.length).replace(/(.)\/+$/, "$1");
      }
      return memo2[paramName] = safelyDecodeURIComponent(captureGroups[index] || "", paramName), memo2;
    }, {}),
    pathname: matchedPathname,
    pathnameBase,
    pattern
  };
}
function compilePath(path, caseSensitive, end) {
  caseSensitive === void 0 && (caseSensitive = !1), end === void 0 && (end = !0), warning(path === "*" || !path.endsWith("*") || path.endsWith("/*"), 'Route path "' + path + '" will be treated as if it were ' + ('"' + path.replace(/\*$/, "/*") + '" because the `*` character must ') + "always follow a `/` in the pattern. To get rid of this warning, " + ('please change the route path to "' + path.replace(/\*$/, "/*") + '".'));
  let paramNames = [], regexpSource = "^" + path.replace(/\/*\*?$/, "").replace(/^\/*/, "/").replace(/[\\.*+^$?{}|()[\]]/g, "\\$&").replace(/:(\w+)/g, (_2, paramName) => (paramNames.push(paramName), "([^\\/]+)"));
  return path.endsWith("*") ? (paramNames.push("*"), regexpSource += path === "*" || path === "/*" ? "(.*)$" : "(?:\\/(.+)|\\/*)$") : regexpSource += end ? "\\/*$" : "(?:(?=[.~-]|%[0-9A-F]{2})|\\b|\\/|$)", [new RegExp(regexpSource, caseSensitive ? void 0 : "i"), paramNames];
}
function safelyDecodeURIComponent(value, paramName) {
  try {
    return decodeURIComponent(value);
  } catch (error) {
    return warning(!1, 'The value for the URL param "' + paramName + '" will not be decoded because' + (' the string "' + value + '" is a malformed URL segment. This is probably') + (" due to a bad percent encoding (" + error + ").")), value;
  }
}
function resolvePath(to, fromPathname) {
  fromPathname === void 0 && (fromPathname = "/");
  let {
    pathname: toPathname,
    search = "",
    hash = ""
  } = typeof to == "string" ? parsePath(to) : to;
  return {
    pathname: toPathname ? toPathname.startsWith("/") ? toPathname : resolvePathname(toPathname, fromPathname) : fromPathname,
    search: normalizeSearch(search),
    hash: normalizeHash(hash)
  };
}
function resolvePathname(relativePath, fromPathname) {
  let segments = fromPathname.replace(/\/+$/, "").split("/");
  return relativePath.split("/").forEach((segment) => {
    segment === ".." ? segments.length > 1 && segments.pop() : segment !== "." && segments.push(segment);
  }), segments.length > 1 ? segments.join("/") : "/";
}
function resolveTo(toArg, routePathnames, locationPathname) {
  let to = typeof toArg == "string" ? parsePath(toArg) : toArg, toPathname = toArg === "" || to.pathname === "" ? "/" : to.pathname, from2;
  if (toPathname == null)
    from2 = locationPathname;
  else {
    let routePathnameIndex = routePathnames.length - 1;
    if (toPathname.startsWith("..")) {
      let toSegments = toPathname.split("/");
      for (; toSegments[0] === ".."; )
        toSegments.shift(), routePathnameIndex -= 1;
      to.pathname = toSegments.join("/");
    }
    from2 = routePathnameIndex >= 0 ? routePathnames[routePathnameIndex] : "/";
  }
  let path = resolvePath(to, from2);
  return toPathname && toPathname !== "/" && toPathname.endsWith("/") && !path.pathname.endsWith("/") && (path.pathname += "/"), path;
}
function getToPathname(to) {
  return to === "" || to.pathname === "" ? "/" : typeof to == "string" ? parsePath(to).pathname : to.pathname;
}
function stripBasename(pathname, basename) {
  if (basename === "/")
    return pathname;
  if (!pathname.toLowerCase().startsWith(basename.toLowerCase()))
    return null;
  let nextChar = pathname.charAt(basename.length);
  return nextChar && nextChar !== "/" ? null : pathname.slice(basename.length) || "/";
}
function useHref(to) {
  useInRouterContext() || invariant(
    !1,
    "useHref() may be used only in the context of a <Router> component."
  );
  let {
    basename,
    navigator: navigator2
  } = (0, import_react.useContext)(NavigationContext), {
    hash,
    pathname,
    search
  } = useResolvedPath(to), joinedPathname = pathname;
  if (basename !== "/") {
    let toPathname = getToPathname(to), endsWithSlash = toPathname != null && toPathname.endsWith("/");
    joinedPathname = pathname === "/" ? basename + (endsWithSlash ? "/" : "") : joinPaths([basename, pathname]);
  }
  return navigator2.createHref({
    pathname: joinedPathname,
    search,
    hash
  });
}
function useInRouterContext() {
  return (0, import_react.useContext)(LocationContext) != null;
}
function useLocation() {
  return useInRouterContext() || invariant(
    !1,
    "useLocation() may be used only in the context of a <Router> component."
  ), (0, import_react.useContext)(LocationContext).location;
}
function useNavigate() {
  useInRouterContext() || invariant(
    !1,
    "useNavigate() may be used only in the context of a <Router> component."
  );
  let {
    basename,
    navigator: navigator2
  } = (0, import_react.useContext)(NavigationContext), {
    matches
  } = (0, import_react.useContext)(RouteContext), {
    pathname: locationPathname
  } = useLocation(), routePathnamesJson = JSON.stringify(matches.map((match) => match.pathnameBase)), activeRef = (0, import_react.useRef)(!1);
  return (0, import_react.useEffect)(() => {
    activeRef.current = !0;
  }), (0, import_react.useCallback)(function(to, options) {
    if (options === void 0 && (options = {}), warning(activeRef.current, "You should call navigate() in a React.useEffect(), not when your component is first rendered."), !activeRef.current)
      return;
    if (typeof to == "number") {
      navigator2.go(to);
      return;
    }
    let path = resolveTo(to, JSON.parse(routePathnamesJson), locationPathname);
    basename !== "/" && (path.pathname = joinPaths([basename, path.pathname])), (options.replace ? navigator2.replace : navigator2.push)(path, options.state);
  }, [basename, navigator2, routePathnamesJson, locationPathname]);
}
function useOutlet(context) {
  let outlet = (0, import_react.useContext)(RouteContext).outlet;
  return outlet && /* @__PURE__ */ (0, import_react.createElement)(OutletContext.Provider, {
    value: context
  }, outlet);
}
function useResolvedPath(to) {
  let {
    matches
  } = (0, import_react.useContext)(RouteContext), {
    pathname: locationPathname
  } = useLocation(), routePathnamesJson = JSON.stringify(matches.map((match) => match.pathnameBase));
  return (0, import_react.useMemo)(() => resolveTo(to, JSON.parse(routePathnamesJson), locationPathname), [to, routePathnamesJson, locationPathname]);
}
function useRoutes(routes2, locationArg) {
  useInRouterContext() || invariant(
    !1,
    "useRoutes() may be used only in the context of a <Router> component."
  );
  let {
    matches: parentMatches
  } = (0, import_react.useContext)(RouteContext), routeMatch = parentMatches[parentMatches.length - 1], parentParams = routeMatch ? routeMatch.params : {}, parentPathname = routeMatch ? routeMatch.pathname : "/", parentPathnameBase = routeMatch ? routeMatch.pathnameBase : "/", parentRoute = routeMatch && routeMatch.route;
  {
    let parentPath = parentRoute && parentRoute.path || "";
    warningOnce(parentPathname, !parentRoute || parentPath.endsWith("*"), "You rendered descendant <Routes> (or called `useRoutes()`) at " + ('"' + parentPathname + '" (under <Route path="' + parentPath + '">) but the ') + `parent route path has no trailing "*". This means if you navigate deeper, the parent won't match anymore and therefore the child routes will never render.

` + ('Please change the parent <Route path="' + parentPath + '"> to <Route ') + ('path="' + (parentPath === "/" ? "*" : parentPath + "/*") + '">.'));
  }
  let locationFromContext = useLocation(), location;
  if (locationArg) {
    var _parsedLocationArg$pa;
    let parsedLocationArg = typeof locationArg == "string" ? parsePath(locationArg) : locationArg;
    parentPathnameBase === "/" || ((_parsedLocationArg$pa = parsedLocationArg.pathname) == null ? void 0 : _parsedLocationArg$pa.startsWith(parentPathnameBase)) || invariant(!1, "When overriding the location using `<Routes location>` or `useRoutes(routes, location)`, the location pathname must begin with the portion of the URL pathname that was " + ('matched by all parent routes. The current pathname base is "' + parentPathnameBase + '" ') + ('but pathname "' + parsedLocationArg.pathname + '" was given in the `location` prop.')), location = parsedLocationArg;
  } else
    location = locationFromContext;
  let pathname = location.pathname || "/", remainingPathname = parentPathnameBase === "/" ? pathname : pathname.slice(parentPathnameBase.length) || "/", matches = matchRoutes(routes2, {
    pathname: remainingPathname
  });
  return warning(parentRoute || matches != null, 'No routes matched location "' + location.pathname + location.search + location.hash + '" '), warning(matches == null || matches[matches.length - 1].route.element !== void 0, 'Matched leaf route at location "' + location.pathname + location.search + location.hash + '" does not have an element. This means it will render an <Outlet /> with a null value by default resulting in an "empty" page.'), _renderMatches(matches && matches.map((match) => Object.assign({}, match, {
    params: Object.assign({}, parentParams, match.params),
    pathname: joinPaths([parentPathnameBase, match.pathname]),
    pathnameBase: match.pathnameBase === "/" ? parentPathnameBase : joinPaths([parentPathnameBase, match.pathnameBase])
  })), parentMatches);
}
function _renderMatches(matches, parentMatches) {
  return parentMatches === void 0 && (parentMatches = []), matches == null ? null : matches.reduceRight((outlet, match, index) => /* @__PURE__ */ (0, import_react.createElement)(RouteContext.Provider, {
    children: match.route.element !== void 0 ? match.route.element : outlet,
    value: {
      outlet,
      matches: parentMatches.concat(matches.slice(0, index + 1))
    }
  }), null);
}
function Outlet(props) {
  return useOutlet(props.context);
}
function Router(_ref3) {
  let {
    basename: basenameProp = "/",
    children = null,
    location: locationProp,
    navigationType = Action.Pop,
    navigator: navigator2,
    static: staticProp = !1
  } = _ref3;
  useInRouterContext() && invariant(!1, "You cannot render a <Router> inside another <Router>. You should never have more than one in your app.");
  let basename = normalizePathname(basenameProp), navigationContext = (0, import_react.useMemo)(() => ({
    basename,
    navigator: navigator2,
    static: staticProp
  }), [basename, navigator2, staticProp]);
  typeof locationProp == "string" && (locationProp = parsePath(locationProp));
  let {
    pathname = "/",
    search = "",
    hash = "",
    state = null,
    key = "default"
  } = locationProp, location = (0, import_react.useMemo)(() => {
    let trailingPathname = stripBasename(pathname, basename);
    return trailingPathname == null ? null : {
      pathname: trailingPathname,
      search,
      hash,
      state,
      key
    };
  }, [basename, pathname, search, hash, state, key]);
  return warning(location != null, '<Router basename="' + basename + '"> is not able to match the URL ' + ('"' + pathname + search + hash + '" because it does not start with the ') + "basename, so the <Router> won't render anything."), location == null ? null : /* @__PURE__ */ (0, import_react.createElement)(NavigationContext.Provider, {
    value: navigationContext
  }, /* @__PURE__ */ (0, import_react.createElement)(LocationContext.Provider, {
    children,
    value: {
      location,
      navigationType
    }
  }));
}
var import_react, NavigationContext, LocationContext, RouteContext, alreadyWarned2, paramRe, dynamicSegmentValue, indexRouteValue, emptySegmentValue, staticSegmentValue, splatPenalty, isSplat, joinPaths, normalizePathname, normalizeSearch, normalizeHash, OutletContext, init_react_router = __esm({
  "node_modules/react-router/index.js"() {
    init_history();
    init_history();
    import_react = __toESM(require_react());
    NavigationContext = /* @__PURE__ */ (0, import_react.createContext)(null);
    NavigationContext.displayName = "Navigation";
    LocationContext = /* @__PURE__ */ (0, import_react.createContext)(null);
    LocationContext.displayName = "Location";
    RouteContext = /* @__PURE__ */ (0, import_react.createContext)({
      outlet: null,
      matches: []
    });
    RouteContext.displayName = "Route";
    alreadyWarned2 = {};
    paramRe = /^:\w+$/, dynamicSegmentValue = 3, indexRouteValue = 2, emptySegmentValue = 1, staticSegmentValue = 10, splatPenalty = -2, isSplat = (s) => s === "*";
    joinPaths = (paths) => paths.join("/").replace(/\/\/+/g, "/"), normalizePathname = (pathname) => pathname.replace(/\/+$/, "").replace(/^\/*/, "/"), normalizeSearch = (search) => !search || search === "?" ? "" : search.startsWith("?") ? search : "?" + search, normalizeHash = (hash) => !hash || hash === "#" ? "" : hash.startsWith("#") ? hash : "#" + hash;
    OutletContext = /* @__PURE__ */ (0, import_react.createContext)(null);
  }
});

// node_modules/react-router-dom/index.js
function _extends2() {
  return _extends2 = Object.assign || function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source)
        Object.prototype.hasOwnProperty.call(source, key) && (target[key] = source[key]);
    }
    return target;
  }, _extends2.apply(this, arguments);
}
function _objectWithoutPropertiesLoose(source, excluded) {
  if (source == null)
    return {};
  var target = {}, sourceKeys = Object.keys(source), key, i;
  for (i = 0; i < sourceKeys.length; i++)
    key = sourceKeys[i], !(excluded.indexOf(key) >= 0) && (target[key] = source[key]);
  return target;
}
function HistoryRouter(_ref3) {
  let {
    basename,
    children,
    history
  } = _ref3, [state, setState] = (0, import_react2.useState)({
    action: history.action,
    location: history.location
  });
  return (0, import_react2.useLayoutEffect)(() => history.listen(setState), [history]), /* @__PURE__ */ (0, import_react2.createElement)(Router, {
    basename,
    children,
    location: state.location,
    navigationType: state.action,
    navigator: history
  });
}
function isModifiedEvent(event) {
  return !!(event.metaKey || event.altKey || event.ctrlKey || event.shiftKey);
}
function useLinkClickHandler(to, _temp) {
  let {
    target,
    replace: replaceProp,
    state
  } = _temp === void 0 ? {} : _temp, navigate = useNavigate(), location = useLocation(), path = useResolvedPath(to);
  return (0, import_react2.useCallback)((event) => {
    if (event.button === 0 && (!target || target === "_self") && !isModifiedEvent(event)) {
      event.preventDefault();
      let replace = !!replaceProp || createPath(location) === createPath(path);
      navigate(to, {
        replace,
        state
      });
    }
  }, [location, navigate, path, replaceProp, state, target, to]);
}
var import_react2, _excluded, _excluded2, Link, NavLink, init_react_router_dom = __esm({
  "node_modules/react-router-dom/index.js"() {
    import_react2 = __toESM(require_react());
    init_react_router();
    init_react_router();
    _excluded = ["onClick", "reloadDocument", "replace", "state", "target", "to"], _excluded2 = ["aria-current", "caseSensitive", "className", "end", "style", "to", "children"];
    HistoryRouter.displayName = "unstable_HistoryRouter";
    Link = /* @__PURE__ */ (0, import_react2.forwardRef)(function(_ref4, ref) {
      let {
        onClick,
        reloadDocument,
        replace = !1,
        state,
        target,
        to
      } = _ref4, rest = _objectWithoutPropertiesLoose(_ref4, _excluded), href = useHref(to), internalOnClick = useLinkClickHandler(to, {
        replace,
        state,
        target
      });
      function handleClick(event) {
        onClick && onClick(event), !event.defaultPrevented && !reloadDocument && internalOnClick(event);
      }
      return /* @__PURE__ */ (0, import_react2.createElement)("a", _extends2({}, rest, {
        href,
        onClick: handleClick,
        ref,
        target
      }));
    });
    Link.displayName = "Link";
    NavLink = /* @__PURE__ */ (0, import_react2.forwardRef)(function(_ref5, ref) {
      let {
        "aria-current": ariaCurrentProp = "page",
        caseSensitive = !1,
        className: classNameProp = "",
        end = !1,
        style: styleProp,
        to,
        children
      } = _ref5, rest = _objectWithoutPropertiesLoose(_ref5, _excluded2), location = useLocation(), path = useResolvedPath(to), locationPathname = location.pathname, toPathname = path.pathname;
      caseSensitive || (locationPathname = locationPathname.toLowerCase(), toPathname = toPathname.toLowerCase());
      let isActive = locationPathname === toPathname || !end && locationPathname.startsWith(toPathname) && locationPathname.charAt(toPathname.length) === "/", ariaCurrent = isActive ? ariaCurrentProp : void 0, className;
      typeof classNameProp == "function" ? className = classNameProp({
        isActive
      }) : className = [classNameProp, isActive ? "active" : null].filter(Boolean).join(" ");
      let style3 = typeof styleProp == "function" ? styleProp({
        isActive
      }) : styleProp;
      return /* @__PURE__ */ (0, import_react2.createElement)(Link, _extends2({}, rest, {
        "aria-current": ariaCurrent,
        className,
        ref,
        style: style3,
        to
      }), typeof children == "function" ? children({
        isActive
      }) : children);
    });
    NavLink.displayName = "NavLink";
  }
});

// node_modules/@remix-run/server-runtime/dist/esm/routeMatching.js
function matchServerRoutes(routes2, pathname) {
  let matches = matchRoutes(routes2, pathname);
  return matches ? matches.map((match) => ({
    params: match.params,
    pathname: match.pathname,
    route: match.route
  })) : null;
}
var init_routeMatching = __esm({
  "node_modules/@remix-run/server-runtime/dist/esm/routeMatching.js"() {
    init_react_router_dom();
  }
});

// node_modules/@remix-run/server-runtime/dist/esm/routes.js
function createRoutes(manifest, parentId) {
  return Object.entries(manifest).filter(([, route]) => route.parentId === parentId).map(([id, route]) => ({
    ...route,
    children: createRoutes(manifest, id)
  }));
}
var init_routes = __esm({
  "node_modules/@remix-run/server-runtime/dist/esm/routes.js"() {
  }
});

// node_modules/@remix-run/server-runtime/dist/esm/markup.js
function escapeHtml(html) {
  return html.replace(ESCAPE_REGEX, (match) => ESCAPE_LOOKUP[match]);
}
var ESCAPE_LOOKUP, ESCAPE_REGEX, init_markup = __esm({
  "node_modules/@remix-run/server-runtime/dist/esm/markup.js"() {
    ESCAPE_LOOKUP = {
      "&": "\\u0026",
      ">": "\\u003e",
      "<": "\\u003c",
      "\u2028": "\\u2028",
      "\u2029": "\\u2029"
    }, ESCAPE_REGEX = /[&><\u2028\u2029]/g;
  }
});

// node_modules/@remix-run/server-runtime/dist/esm/serverHandoff.js
function createServerHandoffString(serverHandoff) {
  return escapeHtml(JSON.stringify(serverHandoff));
}
var init_serverHandoff = __esm({
  "node_modules/@remix-run/server-runtime/dist/esm/serverHandoff.js"() {
    init_markup();
  }
});

// node_modules/@remix-run/server-runtime/dist/esm/server.js
async function handleDataRequest({
  handleDataRequest: handleDataRequest2,
  loadContext,
  matches,
  request,
  serverMode
}) {
  if (!isValidRequestMethod(request))
    return errorBoundaryError(new Error(`Invalid request method "${request.method}"`), 405);
  let url = new URL(request.url);
  if (!matches)
    return errorBoundaryError(new Error(`No route matches URL "${url.pathname}"`), 404);
  let response, match;
  try {
    if (isActionRequest(request))
      match = getRequestMatch(url, matches), response = await callRouteAction({
        loadContext,
        match,
        request
      });
    else {
      let routeId = url.searchParams.get("_data");
      if (!routeId)
        return errorBoundaryError(new Error("Missing route id in ?_data"), 403);
      let tempMatch = matches.find((match2) => match2.route.id === routeId);
      if (!tempMatch)
        return errorBoundaryError(new Error(`Route "${routeId}" does not match URL "${url.pathname}"`), 403);
      match = tempMatch, response = await callRouteLoader({
        loadContext,
        match,
        request
      });
    }
    if (isRedirectResponse(response)) {
      let headers = new Headers(response.headers);
      return headers.set("X-Remix-Redirect", headers.get("Location")), headers.delete("Location"), response.headers.get("Set-Cookie") !== null && headers.set("X-Remix-Revalidate", "yes"), new Response(null, {
        status: 204,
        headers
      });
    }
    return handleDataRequest2 && (response = await handleDataRequest2(response, {
      context: loadContext,
      params: match.params,
      request
    })), response;
  } catch (error) {
    return serverMode !== ServerMode.Test && console.error(error), serverMode === ServerMode.Development ? errorBoundaryError(error, 500) : errorBoundaryError(new Error("Unexpected Server Error"), 500);
  }
}
async function handleDocumentRequest({
  build,
  loadContext,
  matches,
  request,
  routes: routes2,
  serverMode
}) {
  let url = new URL(request.url), appState = {
    trackBoundaries: !0,
    trackCatchBoundaries: !0,
    catchBoundaryRouteId: null,
    renderBoundaryRouteId: null,
    loaderBoundaryRouteId: null,
    error: void 0,
    catch: void 0
  };
  isValidRequestMethod(request) ? matches || (appState.trackCatchBoundaries = !1, appState.catch = {
    data: null,
    status: 404,
    statusText: "Not Found"
  }) : (matches = null, appState.trackCatchBoundaries = !1, appState.catch = {
    data: null,
    status: 405,
    statusText: "Method Not Allowed"
  });
  let actionStatus, actionData, actionMatch, actionResponse;
  if (matches && isActionRequest(request)) {
    actionMatch = getRequestMatch(url, matches);
    try {
      if (actionResponse = await callRouteAction({
        loadContext,
        match: actionMatch,
        request
      }), isRedirectResponse(actionResponse))
        return actionResponse;
      actionStatus = {
        status: actionResponse.status,
        statusText: actionResponse.statusText
      }, isCatchResponse(actionResponse) ? (appState.catchBoundaryRouteId = getDeepestRouteIdWithBoundary(matches, "CatchBoundary"), appState.trackCatchBoundaries = !1, appState.catch = {
        ...actionStatus,
        data: await extractData(actionResponse)
      }) : actionData = {
        [actionMatch.route.id]: await extractData(actionResponse)
      };
    } catch (error) {
      appState.loaderBoundaryRouteId = getDeepestRouteIdWithBoundary(matches, "ErrorBoundary"), appState.trackBoundaries = !1, appState.error = await serializeError(error), serverMode !== ServerMode.Test && console.error(`There was an error running the action for route ${actionMatch.route.id}`);
    }
  }
  let routeModules = createEntryRouteModules(build.routes), matchesToLoad = matches || [];
  appState.catch ? matchesToLoad = getMatchesUpToDeepestBoundary(matchesToLoad, "CatchBoundary").slice(0, -1) : appState.error && (matchesToLoad = getMatchesUpToDeepestBoundary(matchesToLoad, "ErrorBoundary").slice(0, -1));
  let loaderRequest = new Request(request.url, {
    body: null,
    headers: request.headers,
    method: request.method,
    redirect: request.redirect,
    signal: request.signal
  }), routeLoaderResults = await Promise.allSettled(matchesToLoad.map((match) => match.route.module.loader ? callRouteLoader({
    loadContext,
    match,
    request: loaderRequest
  }) : Promise.resolve(void 0))), actionCatch = appState.catch, actionError = appState.error, actionCatchBoundaryRouteId = appState.catchBoundaryRouteId, actionLoaderBoundaryRouteId = appState.loaderBoundaryRouteId;
  appState.catch = void 0, appState.error = void 0;
  let routeLoaderResponses = {}, loaderStatusCodes = [], routeData = {};
  for (let index = 0; index < matchesToLoad.length; index++) {
    let match = matchesToLoad[index], result = routeLoaderResults[index], error = result.status === "rejected" ? result.reason : void 0, response = result.status === "fulfilled" ? result.value : void 0, isRedirect = response ? isRedirectResponse(response) : !1, isCatch = response ? isCatchResponse(response) : !1;
    if (appState.catch || appState.error)
      break;
    if (!actionCatch && !actionError && response && isRedirect)
      return response;
    if (match.route.module.CatchBoundary && (appState.catchBoundaryRouteId = match.route.id), match.route.module.ErrorBoundary && (appState.loaderBoundaryRouteId = match.route.id), error) {
      loaderStatusCodes.push(500), appState.trackBoundaries = !1, appState.error = await serializeError(error), serverMode !== ServerMode.Test && console.error(`There was an error running the data loader for route ${match.route.id}`);
      break;
    } else if (response)
      if (routeLoaderResponses[match.route.id] = response, loaderStatusCodes.push(response.status), isCatch) {
        appState.trackCatchBoundaries = !1, appState.catch = {
          data: await extractData(response),
          status: response.status,
          statusText: response.statusText
        };
        break;
      } else
        routeData[match.route.id] = await extractData(response);
  }
  appState.catch || (appState.catchBoundaryRouteId = actionCatchBoundaryRouteId), appState.error || (appState.loaderBoundaryRouteId = actionLoaderBoundaryRouteId), appState.catch = actionCatch || appState.catch, appState.error = actionError || appState.error;
  let renderableMatches = getRenderableMatches(matches, appState);
  if (!renderableMatches) {
    renderableMatches = [];
    let root = routes2[0];
    root != null && root.module.CatchBoundary && (appState.catchBoundaryRouteId = "root", renderableMatches.push({
      params: {},
      pathname: "",
      route: routes2[0]
    }));
  }
  let notOkResponse = actionStatus && actionStatus.status !== 200 ? actionStatus.status : loaderStatusCodes.find((status) => status !== 200), responseStatusCode = appState.error ? 500 : typeof notOkResponse == "number" ? notOkResponse : appState.catch ? appState.catch.status : 200, responseHeaders = getDocumentHeaders(build, renderableMatches, routeLoaderResponses, actionResponse), entryMatches = createEntryMatches(renderableMatches, build.assets.routes), serverHandoff = {
    actionData,
    appState,
    matches: entryMatches,
    routeData
  }, entryContext = {
    ...serverHandoff,
    manifest: build.assets,
    routeModules,
    serverHandoffString: createServerHandoffString(serverHandoff)
  }, handleDocumentRequest2 = build.entry.module.default;
  try {
    return await handleDocumentRequest2(request, responseStatusCode, responseHeaders, entryContext);
  } catch (error) {
    responseStatusCode = 500, appState.trackBoundaries = !1, appState.error = await serializeError(error), entryContext.serverHandoffString = createServerHandoffString(serverHandoff);
    try {
      return await handleDocumentRequest2(request, responseStatusCode, responseHeaders, entryContext);
    } catch (error2) {
      serverMode !== ServerMode.Test && console.error(error2);
      let message = "Unexpected Server Error";
      return serverMode === ServerMode.Development && (message += `

${String(error2)}`), new Response(message, {
        status: 500,
        headers: {
          "Content-Type": "text/plain"
        }
      });
    }
  }
}
async function handleResourceRequest({
  loadContext,
  matches,
  request,
  serverMode
}) {
  let match = matches.slice(-1)[0];
  try {
    return isActionRequest(request) ? await callRouteAction({
      match,
      loadContext,
      request
    }) : await callRouteLoader({
      match,
      loadContext,
      request
    });
  } catch (error) {
    serverMode !== ServerMode.Test && console.error(error);
    let message = "Unexpected Server Error";
    return serverMode === ServerMode.Development && (message += `

${String(error)}`), new Response(message, {
      status: 500,
      headers: {
        "Content-Type": "text/plain"
      }
    });
  }
}
function isActionRequest({
  method
}) {
  return validActionMethods.has(method.toUpperCase());
}
function isValidRequestMethod({
  method
}) {
  return validRequestMethods.has(method.toUpperCase());
}
async function errorBoundaryError(error, status) {
  return json(await serializeError(error), {
    status,
    headers: {
      "X-Remix-Error": "yes"
    }
  });
}
function isIndexRequestUrl(url) {
  for (let param of url.searchParams.getAll("index"))
    if (param === "")
      return !0;
  return !1;
}
function getRequestMatch(url, matches) {
  let match = matches.slice(-1)[0];
  return !isIndexRequestUrl(url) && match.route.id.endsWith("/index") ? matches.slice(-2)[0] : match;
}
function getDeepestRouteIdWithBoundary(matches, key) {
  let matched = getMatchesUpToDeepestBoundary(matches, key).slice(-1)[0];
  return matched ? matched.route.id : null;
}
function getMatchesUpToDeepestBoundary(matches, key) {
  let deepestBoundaryIndex = -1;
  return matches.forEach((match, index) => {
    match.route.module[key] && (deepestBoundaryIndex = index);
  }), deepestBoundaryIndex === -1 ? [] : matches.slice(0, deepestBoundaryIndex + 1);
}
function getRenderableMatches(matches, appState) {
  if (!matches)
    return null;
  if (!appState.catch && !appState.error)
    return matches;
  let lastRenderableIndex = -1;
  return matches.forEach((match, index) => {
    let id = match.route.id;
    (appState.renderBoundaryRouteId === id || appState.loaderBoundaryRouteId === id || appState.catchBoundaryRouteId === id) && (lastRenderableIndex = index);
  }), matches.slice(0, lastRenderableIndex + 1);
}
var createRequestHandler, validActionMethods, validRequestMethods, init_server = __esm({
  "node_modules/@remix-run/server-runtime/dist/esm/server.js"() {
    init_data();
    init_entry();
    init_errors();
    init_headers();
    init_mode();
    init_routeMatching();
    init_routes();
    init_responses();
    init_serverHandoff();
    createRequestHandler = (build, mode) => {
      let routes2 = createRoutes(build.routes), serverMode = isServerMode(mode) ? mode : ServerMode.Production;
      return async function(request, loadContext = {}) {
        let url = new URL(request.url), matches = matchServerRoutes(routes2, url.pathname), response;
        return url.searchParams.has("_data") ? response = await handleDataRequest({
          request,
          loadContext,
          matches,
          handleDataRequest: build.entry.module.handleDataRequest,
          serverMode
        }) : matches && !matches[matches.length - 1].route.module.default ? response = await handleResourceRequest({
          request,
          loadContext,
          matches,
          serverMode
        }) : response = await handleDocumentRequest({
          build,
          loadContext,
          matches,
          request,
          routes: routes2,
          serverMode
        }), request.method === "HEAD" ? new Response(null, {
          headers: response.headers,
          status: response.status,
          statusText: response.statusText
        }) : response;
      };
    };
    validActionMethods = /* @__PURE__ */ new Set(["POST", "PUT", "PATCH", "DELETE"]);
    validRequestMethods = /* @__PURE__ */ new Set(["GET", "HEAD", ...validActionMethods]);
  }
});

// node_modules/@remix-run/server-runtime/dist/esm/sessions.js
function flash(name) {
  return `__flash_${name}__`;
}
function warnOnceAboutSigningSessionCookie(cookie) {
  warnOnce(cookie.isSigned, `The "${cookie.name}" cookie is not signed, but session cookies should be signed to prevent tampering on the client before they are sent back to the server. See https://remix.run/api/remix#signing-cookies for more information.`);
}
var createSession, isSession, createSessionStorageFactory, init_sessions = __esm({
  "node_modules/@remix-run/server-runtime/dist/esm/sessions.js"() {
    init_cookies();
    init_warnings();
    createSession = (initialData = {}, id = "") => {
      let map = new Map(Object.entries(initialData));
      return {
        get id() {
          return id;
        },
        get data() {
          return Object.fromEntries(map);
        },
        has(name) {
          return map.has(name) || map.has(flash(name));
        },
        get(name) {
          if (map.has(name))
            return map.get(name);
          let flashName = flash(name);
          if (map.has(flashName)) {
            let value = map.get(flashName);
            return map.delete(flashName), value;
          }
        },
        set(name, value) {
          map.set(name, value);
        },
        flash(name, value) {
          map.set(flash(name), value);
        },
        unset(name) {
          map.delete(name);
        }
      };
    }, isSession = (object) => object != null && typeof object.id == "string" && typeof object.data < "u" && typeof object.has == "function" && typeof object.get == "function" && typeof object.set == "function" && typeof object.flash == "function" && typeof object.unset == "function", createSessionStorageFactory = (createCookie) => ({
      cookie: cookieArg,
      createData,
      readData,
      updateData,
      deleteData
    }) => {
      let cookie = isCookie(cookieArg) ? cookieArg : createCookie((cookieArg == null ? void 0 : cookieArg.name) || "__session", cookieArg);
      return warnOnceAboutSigningSessionCookie(cookie), {
        async getSession(cookieHeader, options) {
          let id = cookieHeader && await cookie.parse(cookieHeader, options), data = id && await readData(id);
          return createSession(data || {}, id || "");
        },
        async commitSession(session, options) {
          let {
            id,
            data
          } = session;
          return id ? await updateData(id, data, cookie.expires) : id = await createData(data, cookie.expires), cookie.serialize(id, options);
        },
        async destroySession(session, options) {
          return await deleteData(session.id), cookie.serialize("", {
            ...options,
            expires: new Date(0)
          });
        }
      };
    };
  }
});

// node_modules/@remix-run/server-runtime/dist/esm/sessions/cookieStorage.js
var createCookieSessionStorageFactory, init_cookieStorage = __esm({
  "node_modules/@remix-run/server-runtime/dist/esm/sessions/cookieStorage.js"() {
    init_cookies();
    init_sessions();
    createCookieSessionStorageFactory = (createCookie) => ({
      cookie: cookieArg
    } = {}) => {
      let cookie = isCookie(cookieArg) ? cookieArg : createCookie((cookieArg == null ? void 0 : cookieArg.name) || "__session", cookieArg);
      return warnOnceAboutSigningSessionCookie(cookie), {
        async getSession(cookieHeader, options) {
          return createSession(cookieHeader && await cookie.parse(cookieHeader, options) || {});
        },
        async commitSession(session, options) {
          let serializedCookie = await cookie.serialize(session.data, options);
          if (serializedCookie.length > 4096)
            throw new Error("Cookie length will exceed browser maximum. Length: " + serializedCookie.length);
          return serializedCookie;
        },
        async destroySession(_session, options) {
          return cookie.serialize("", {
            ...options,
            expires: new Date(0)
          });
        }
      };
    };
  }
});

// node_modules/@remix-run/server-runtime/dist/esm/sessions/memoryStorage.js
var createMemorySessionStorageFactory, init_memoryStorage = __esm({
  "node_modules/@remix-run/server-runtime/dist/esm/sessions/memoryStorage.js"() {
    createMemorySessionStorageFactory = (createSessionStorage) => ({
      cookie
    } = {}) => {
      let uniqueId = 0, map = /* @__PURE__ */ new Map();
      return createSessionStorage({
        cookie,
        async createData(data, expires) {
          let id = (++uniqueId).toString();
          return map.set(id, {
            data,
            expires
          }), id;
        },
        async readData(id) {
          if (map.has(id)) {
            let {
              data,
              expires
            } = map.get(id);
            if (!expires || expires > new Date())
              return data;
            expires && map.delete(id);
          }
          return null;
        },
        async updateData(id, data, expires) {
          map.set(id, {
            data,
            expires
          });
        },
        async deleteData(id) {
          map.delete(id);
        }
      });
    };
  }
});

// node_modules/@remix-run/server-runtime/dist/esm/upload/errors.js
var MaxPartSizeExceededError, init_errors2 = __esm({
  "node_modules/@remix-run/server-runtime/dist/esm/upload/errors.js"() {
    MaxPartSizeExceededError = class extends Error {
      constructor(field, maxBytes) {
        super(`Field "${field}" exceeded upload size of ${maxBytes} bytes.`), this.field = field, this.maxBytes = maxBytes;
      }
    };
  }
});

// node_modules/@remix-run/server-runtime/dist/esm/upload/memoryUploadHandler.js
function createMemoryUploadHandler({
  filter,
  maxPartSize = 3e6
} = {}) {
  return async ({
    filename,
    contentType,
    name,
    data
  }) => {
    if (filter && !await filter({
      filename,
      contentType,
      name
    }))
      return;
    let size = 0, chunks = [];
    for await (let chunk of data) {
      if (size += chunk.byteLength, size > maxPartSize)
        throw new MaxPartSizeExceededError(name, maxPartSize);
      chunks.push(chunk);
    }
    return typeof filename == "string" ? new File(chunks, filename, {
      type: contentType
    }) : await new Blob(chunks, {
      type: contentType
    }).text();
  };
}
var init_memoryUploadHandler = __esm({
  "node_modules/@remix-run/server-runtime/dist/esm/upload/memoryUploadHandler.js"() {
    init_errors2();
  }
});

// node_modules/@remix-run/server-runtime/dist/esm/index.js
var esm_exports = {};
__export(esm_exports, {
  MaxPartSizeExceededError: () => MaxPartSizeExceededError,
  createCookieFactory: () => createCookieFactory,
  createCookieSessionStorageFactory: () => createCookieSessionStorageFactory,
  createMemorySessionStorageFactory: () => createMemorySessionStorageFactory,
  createRequestHandler: () => createRequestHandler,
  createSession: () => createSession,
  createSessionStorageFactory: () => createSessionStorageFactory,
  isCookie: () => isCookie,
  isSession: () => isSession,
  json: () => json,
  redirect: () => redirect,
  unstable_composeUploadHandlers: () => composeUploadHandlers,
  unstable_createMemoryUploadHandler: () => createMemoryUploadHandler,
  unstable_parseMultipartFormData: () => parseMultipartFormData
});
var init_esm = __esm({
  "node_modules/@remix-run/server-runtime/dist/esm/index.js"() {
    init_cookies();
    init_formData();
    init_responses();
    init_server();
    init_sessions();
    init_cookieStorage();
    init_memoryStorage();
    init_memoryUploadHandler();
    init_errors2();
  }
});

// node_modules/@remix-run/cloudflare/dist/crypto.js
var require_crypto = __commonJS({
  "node_modules/@remix-run/cloudflare/dist/crypto.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: !0 });
    var encoder = new TextEncoder(), sign = async (value, secret) => {
      let key = await createKey(secret, ["sign"]), data = encoder.encode(value), signature = await crypto.subtle.sign("HMAC", key, data), hash = btoa(String.fromCharCode(...new Uint8Array(signature))).replace(/=+$/, "");
      return value + "." + hash;
    }, unsign = async (signed, secret) => {
      let index = signed.lastIndexOf("."), value = signed.slice(0, index), hash = signed.slice(index + 1), key = await createKey(secret, ["verify"]), data = encoder.encode(value), signature = byteStringToUint8Array(atob(hash));
      return await crypto.subtle.verify("HMAC", key, signature, data) ? value : !1;
    };
    async function createKey(secret, usages) {
      return await crypto.subtle.importKey("raw", encoder.encode(secret), {
        name: "HMAC",
        hash: "SHA-256"
      }, !1, usages);
    }
    function byteStringToUint8Array(byteString) {
      let array = new Uint8Array(byteString.length);
      for (let i = 0; i < byteString.length; i++)
        array[i] = byteString.charCodeAt(i);
      return array;
    }
    exports.sign = sign;
    exports.unsign = unsign;
  }
});

// node_modules/@remix-run/cloudflare/dist/implementations.js
var require_implementations = __commonJS({
  "node_modules/@remix-run/cloudflare/dist/implementations.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: !0 });
    var serverRuntime = (init_esm(), __toCommonJS(esm_exports)), crypto2 = require_crypto(), createCookie = serverRuntime.createCookieFactory({
      sign: crypto2.sign,
      unsign: crypto2.unsign
    }), createCookieSessionStorage = serverRuntime.createCookieSessionStorageFactory(createCookie), createSessionStorage = serverRuntime.createSessionStorageFactory(createCookie), createMemorySessionStorage = serverRuntime.createMemorySessionStorageFactory(createSessionStorage);
    exports.createCookie = createCookie;
    exports.createCookieSessionStorage = createCookieSessionStorage;
    exports.createMemorySessionStorage = createMemorySessionStorage;
    exports.createSessionStorage = createSessionStorage;
  }
});

// node_modules/@remix-run/cloudflare/dist/sessions/cloudflareKVSessionStorage.js
var require_cloudflareKVSessionStorage = __commonJS({
  "node_modules/@remix-run/cloudflare/dist/sessions/cloudflareKVSessionStorage.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: !0 });
    var implementations = require_implementations();
    function createCloudflareKVSessionStorage({
      cookie,
      kv
    }) {
      return implementations.createSessionStorage({
        cookie,
        async createData(data, expires) {
          for (; ; ) {
            let randomBytes = new Uint8Array(8);
            crypto.getRandomValues(randomBytes);
            let id = [...randomBytes].map((x) => x.toString(16).padStart(2, "0")).join("");
            if (!await kv.get(id, "json"))
              return await kv.put(id, JSON.stringify(data), {
                expiration: expires ? Math.round(expires.getTime() / 1e3) : void 0
              }), id;
          }
        },
        async readData(id) {
          let session = await kv.get(id);
          return session ? JSON.parse(session) : null;
        },
        async updateData(id, data, expires) {
          await kv.put(id, JSON.stringify(data), {
            expiration: expires ? Math.round(expires.getTime() / 1e3) : void 0
          });
        },
        async deleteData(id) {
          await kv.delete(id);
        }
      });
    }
    exports.createCloudflareKVSessionStorage = createCloudflareKVSessionStorage;
  }
});

// node_modules/@remix-run/cloudflare/dist/index.js
var require_dist = __commonJS({
  "node_modules/@remix-run/cloudflare/dist/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: !0 });
    var cloudflareKVSessionStorage = require_cloudflareKVSessionStorage(), implementations = require_implementations(), serverRuntime = (init_esm(), __toCommonJS(esm_exports));
    exports.createCloudflareKVSessionStorage = cloudflareKVSessionStorage.createCloudflareKVSessionStorage;
    exports.createCookie = implementations.createCookie;
    exports.createCookieSessionStorage = implementations.createCookieSessionStorage;
    exports.createMemorySessionStorage = implementations.createMemorySessionStorage;
    exports.createSessionStorage = implementations.createSessionStorage;
    Object.defineProperty(exports, "MaxPartSizeExceededError", {
      enumerable: !0,
      get: function() {
        return serverRuntime.MaxPartSizeExceededError;
      }
    });
    Object.defineProperty(exports, "createRequestHandler", {
      enumerable: !0,
      get: function() {
        return serverRuntime.createRequestHandler;
      }
    });
    Object.defineProperty(exports, "createSession", {
      enumerable: !0,
      get: function() {
        return serverRuntime.createSession;
      }
    });
    Object.defineProperty(exports, "isCookie", {
      enumerable: !0,
      get: function() {
        return serverRuntime.isCookie;
      }
    });
    Object.defineProperty(exports, "isSession", {
      enumerable: !0,
      get: function() {
        return serverRuntime.isSession;
      }
    });
    Object.defineProperty(exports, "json", {
      enumerable: !0,
      get: function() {
        return serverRuntime.json;
      }
    });
    Object.defineProperty(exports, "redirect", {
      enumerable: !0,
      get: function() {
        return serverRuntime.redirect;
      }
    });
    Object.defineProperty(exports, "unstable_composeUploadHandlers", {
      enumerable: !0,
      get: function() {
        return serverRuntime.unstable_composeUploadHandlers;
      }
    });
    Object.defineProperty(exports, "unstable_createMemoryUploadHandler", {
      enumerable: !0,
      get: function() {
        return serverRuntime.unstable_createMemoryUploadHandler;
      }
    });
    Object.defineProperty(exports, "unstable_parseMultipartFormData", {
      enumerable: !0,
      get: function() {
        return serverRuntime.unstable_parseMultipartFormData;
      }
    });
  }
});

// node-modules-polyfills:events
function EventHandlers() {
}
function EventEmitter() {
  EventEmitter.init.call(this);
}
function $getMaxListeners(that) {
  return that._maxListeners === void 0 ? EventEmitter.defaultMaxListeners : that._maxListeners;
}
function emitNone(handler, isFn, self2) {
  if (isFn)
    handler.call(self2);
  else
    for (var len = handler.length, listeners2 = arrayClone(handler, len), i = 0; i < len; ++i)
      listeners2[i].call(self2);
}
function emitOne(handler, isFn, self2, arg1) {
  if (isFn)
    handler.call(self2, arg1);
  else
    for (var len = handler.length, listeners2 = arrayClone(handler, len), i = 0; i < len; ++i)
      listeners2[i].call(self2, arg1);
}
function emitTwo(handler, isFn, self2, arg1, arg2) {
  if (isFn)
    handler.call(self2, arg1, arg2);
  else
    for (var len = handler.length, listeners2 = arrayClone(handler, len), i = 0; i < len; ++i)
      listeners2[i].call(self2, arg1, arg2);
}
function emitThree(handler, isFn, self2, arg1, arg2, arg3) {
  if (isFn)
    handler.call(self2, arg1, arg2, arg3);
  else
    for (var len = handler.length, listeners2 = arrayClone(handler, len), i = 0; i < len; ++i)
      listeners2[i].call(self2, arg1, arg2, arg3);
}
function emitMany(handler, isFn, self2, args) {
  if (isFn)
    handler.apply(self2, args);
  else
    for (var len = handler.length, listeners2 = arrayClone(handler, len), i = 0; i < len; ++i)
      listeners2[i].apply(self2, args);
}
function _addListener(target, type, listener, prepend) {
  var m, events, existing;
  if (typeof listener != "function")
    throw new TypeError('"listener" argument must be a function');
  if (events = target._events, events ? (events.newListener && (target.emit(
    "newListener",
    type,
    listener.listener ? listener.listener : listener
  ), events = target._events), existing = events[type]) : (events = target._events = new EventHandlers(), target._eventsCount = 0), !existing)
    existing = events[type] = listener, ++target._eventsCount;
  else if (typeof existing == "function" ? existing = events[type] = prepend ? [listener, existing] : [existing, listener] : prepend ? existing.unshift(listener) : existing.push(listener), !existing.warned && (m = $getMaxListeners(target), m && m > 0 && existing.length > m)) {
    existing.warned = !0;
    var w = new Error("Possible EventEmitter memory leak detected. " + existing.length + " " + type + " listeners added. Use emitter.setMaxListeners() to increase limit");
    w.name = "MaxListenersExceededWarning", w.emitter = target, w.type = type, w.count = existing.length, emitWarning(w);
  }
  return target;
}
function emitWarning(e) {
  typeof console.warn == "function" ? console.warn(e) : console.log(e);
}
function _onceWrap(target, type, listener) {
  var fired = !1;
  function g() {
    target.removeListener(type, g), fired || (fired = !0, listener.apply(target, arguments));
  }
  return g.listener = listener, g;
}
function listenerCount(type) {
  var events = this._events;
  if (events) {
    var evlistener = events[type];
    if (typeof evlistener == "function")
      return 1;
    if (evlistener)
      return evlistener.length;
  }
  return 0;
}
function spliceOne(list, index) {
  for (var i = index, k = i + 1, n = list.length; k < n; i += 1, k += 1)
    list[i] = list[k];
  list.pop();
}
function arrayClone(arr, i) {
  for (var copy2 = new Array(i); i--; )
    copy2[i] = arr[i];
  return copy2;
}
function unwrapListeners(arr) {
  for (var ret = new Array(arr.length), i = 0; i < ret.length; ++i)
    ret[i] = arr[i].listener || arr[i];
  return ret;
}
var domain, events_default, init_events = __esm({
  "node-modules-polyfills:events"() {
    "use strict";
    EventHandlers.prototype = /* @__PURE__ */ Object.create(null);
    events_default = EventEmitter;
    EventEmitter.EventEmitter = EventEmitter;
    EventEmitter.usingDomains = !1;
    EventEmitter.prototype.domain = void 0;
    EventEmitter.prototype._events = void 0;
    EventEmitter.prototype._maxListeners = void 0;
    EventEmitter.defaultMaxListeners = 10;
    EventEmitter.init = function() {
      this.domain = null, EventEmitter.usingDomains && domain.active && !(this instanceof domain.Domain) && (this.domain = domain.active), (!this._events || this._events === Object.getPrototypeOf(this)._events) && (this._events = new EventHandlers(), this._eventsCount = 0), this._maxListeners = this._maxListeners || void 0;
    };
    EventEmitter.prototype.setMaxListeners = function(n) {
      if (typeof n != "number" || n < 0 || isNaN(n))
        throw new TypeError('"n" argument must be a positive number');
      return this._maxListeners = n, this;
    };
    EventEmitter.prototype.getMaxListeners = function() {
      return $getMaxListeners(this);
    };
    EventEmitter.prototype.emit = function(type) {
      var er, handler, len, args, i, events, domain2, needDomainExit = !1, doError = type === "error";
      if (events = this._events, events)
        doError = doError && events.error == null;
      else if (!doError)
        return !1;
      if (domain2 = this.domain, doError) {
        if (er = arguments[1], domain2)
          er || (er = new Error('Uncaught, unspecified "error" event')), er.domainEmitter = this, er.domain = domain2, er.domainThrown = !1, domain2.emit("error", er);
        else {
          if (er instanceof Error)
            throw er;
          var err = new Error('Uncaught, unspecified "error" event. (' + er + ")");
          throw err.context = er, err;
        }
        return !1;
      }
      if (handler = events[type], !handler)
        return !1;
      var isFn = typeof handler == "function";
      switch (len = arguments.length, len) {
        case 1:
          emitNone(handler, isFn, this);
          break;
        case 2:
          emitOne(handler, isFn, this, arguments[1]);
          break;
        case 3:
          emitTwo(handler, isFn, this, arguments[1], arguments[2]);
          break;
        case 4:
          emitThree(handler, isFn, this, arguments[1], arguments[2], arguments[3]);
          break;
        default:
          for (args = new Array(len - 1), i = 1; i < len; i++)
            args[i - 1] = arguments[i];
          emitMany(handler, isFn, this, args);
      }
      return needDomainExit && domain2.exit(), !0;
    };
    EventEmitter.prototype.addListener = function(type, listener) {
      return _addListener(this, type, listener, !1);
    };
    EventEmitter.prototype.on = EventEmitter.prototype.addListener;
    EventEmitter.prototype.prependListener = function(type, listener) {
      return _addListener(this, type, listener, !0);
    };
    EventEmitter.prototype.once = function(type, listener) {
      if (typeof listener != "function")
        throw new TypeError('"listener" argument must be a function');
      return this.on(type, _onceWrap(this, type, listener)), this;
    };
    EventEmitter.prototype.prependOnceListener = function(type, listener) {
      if (typeof listener != "function")
        throw new TypeError('"listener" argument must be a function');
      return this.prependListener(type, _onceWrap(this, type, listener)), this;
    };
    EventEmitter.prototype.removeListener = function(type, listener) {
      var list, events, position2, i, originalListener;
      if (typeof listener != "function")
        throw new TypeError('"listener" argument must be a function');
      if (events = this._events, !events)
        return this;
      if (list = events[type], !list)
        return this;
      if (list === listener || list.listener && list.listener === listener)
        --this._eventsCount === 0 ? this._events = new EventHandlers() : (delete events[type], events.removeListener && this.emit("removeListener", type, list.listener || listener));
      else if (typeof list != "function") {
        for (position2 = -1, i = list.length; i-- > 0; )
          if (list[i] === listener || list[i].listener && list[i].listener === listener) {
            originalListener = list[i].listener, position2 = i;
            break;
          }
        if (position2 < 0)
          return this;
        if (list.length === 1) {
          if (list[0] = void 0, --this._eventsCount === 0)
            return this._events = new EventHandlers(), this;
          delete events[type];
        } else
          spliceOne(list, position2);
        events.removeListener && this.emit("removeListener", type, originalListener || listener);
      }
      return this;
    };
    EventEmitter.prototype.removeAllListeners = function(type) {
      var listeners2, events;
      if (events = this._events, !events)
        return this;
      if (!events.removeListener)
        return arguments.length === 0 ? (this._events = new EventHandlers(), this._eventsCount = 0) : events[type] && (--this._eventsCount === 0 ? this._events = new EventHandlers() : delete events[type]), this;
      if (arguments.length === 0) {
        for (var keys2 = Object.keys(events), i = 0, key; i < keys2.length; ++i)
          key = keys2[i], key !== "removeListener" && this.removeAllListeners(key);
        return this.removeAllListeners("removeListener"), this._events = new EventHandlers(), this._eventsCount = 0, this;
      }
      if (listeners2 = events[type], typeof listeners2 == "function")
        this.removeListener(type, listeners2);
      else if (listeners2)
        do
          this.removeListener(type, listeners2[listeners2.length - 1]);
        while (listeners2[0]);
      return this;
    };
    EventEmitter.prototype.listeners = function(type) {
      var evlistener, ret, events = this._events;
      return events ? (evlistener = events[type], evlistener ? typeof evlistener == "function" ? ret = [evlistener.listener || evlistener] : ret = unwrapListeners(evlistener) : ret = []) : ret = [], ret;
    };
    EventEmitter.listenerCount = function(emitter, type) {
      return typeof emitter.listenerCount == "function" ? emitter.listenerCount(type) : listenerCount.call(emitter, type);
    };
    EventEmitter.prototype.listenerCount = listenerCount;
    EventEmitter.prototype.eventNames = function() {
      return this._eventsCount > 0 ? Reflect.ownKeys(this._events) : [];
    };
  }
});

// node-modules-polyfills:process
function defaultSetTimout() {
  throw new Error("setTimeout has not been defined");
}
function defaultClearTimeout() {
  throw new Error("clearTimeout has not been defined");
}
function runTimeout(fun) {
  if (cachedSetTimeout === setTimeout)
    return setTimeout(fun, 0);
  if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout)
    return cachedSetTimeout = setTimeout, setTimeout(fun, 0);
  try {
    return cachedSetTimeout(fun, 0);
  } catch {
    try {
      return cachedSetTimeout.call(null, fun, 0);
    } catch {
      return cachedSetTimeout.call(this, fun, 0);
    }
  }
}
function runClearTimeout(marker) {
  if (cachedClearTimeout === clearTimeout)
    return clearTimeout(marker);
  if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout)
    return cachedClearTimeout = clearTimeout, clearTimeout(marker);
  try {
    return cachedClearTimeout(marker);
  } catch {
    try {
      return cachedClearTimeout.call(null, marker);
    } catch {
      return cachedClearTimeout.call(this, marker);
    }
  }
}
function cleanUpNextTick() {
  !draining || !currentQueue || (draining = !1, currentQueue.length ? queue = currentQueue.concat(queue) : queueIndex = -1, queue.length && drainQueue());
}
function drainQueue() {
  if (!draining) {
    var timeout2 = runTimeout(cleanUpNextTick);
    draining = !0;
    for (var len = queue.length; len; ) {
      for (currentQueue = queue, queue = []; ++queueIndex < len; )
        currentQueue && currentQueue[queueIndex].run();
      queueIndex = -1, len = queue.length;
    }
    currentQueue = null, draining = !1, runClearTimeout(timeout2);
  }
}
function nextTick(fun) {
  var args = new Array(arguments.length - 1);
  if (arguments.length > 1)
    for (var i = 1; i < arguments.length; i++)
      args[i - 1] = arguments[i];
  queue.push(new Item(fun, args)), queue.length === 1 && !draining && runTimeout(drainQueue);
}
function Item(fun, array) {
  this.fun = fun, this.array = array;
}
function noop() {
}
function binding(name) {
  throw new Error("process.binding is not supported");
}
function cwd() {
  return "/";
}
function chdir(dir) {
  throw new Error("process.chdir is not supported");
}
function umask() {
  return 0;
}
function hrtime(previousTimestamp) {
  var clocktime = performanceNow.call(performance2) * 1e-3, seconds = Math.floor(clocktime), nanoseconds = Math.floor(clocktime % 1 * 1e9);
  return previousTimestamp && (seconds = seconds - previousTimestamp[0], nanoseconds = nanoseconds - previousTimestamp[1], nanoseconds < 0 && (seconds--, nanoseconds += 1e9)), [seconds, nanoseconds];
}
function uptime() {
  var currentTime = new Date(), dif = currentTime - startTime;
  return dif / 1e3;
}
var cachedSetTimeout, cachedClearTimeout, queue, draining, currentQueue, queueIndex, title, platform, browser, env, argv, version, versions, release, config, on, addListener2, once2, off, removeListener2, removeAllListeners2, emit2, performance2, performanceNow, startTime, browser$1, process_default, init_process = __esm({
  "node-modules-polyfills:process"() {
    cachedSetTimeout = defaultSetTimout, cachedClearTimeout = defaultClearTimeout;
    typeof globalThis.setTimeout == "function" && (cachedSetTimeout = setTimeout);
    typeof globalThis.clearTimeout == "function" && (cachedClearTimeout = clearTimeout);
    queue = [], draining = !1, queueIndex = -1;
    Item.prototype.run = function() {
      this.fun.apply(null, this.array);
    };
    title = "browser", platform = "browser", browser = !0, env = {}, argv = [], version = "", versions = {}, release = {}, config = {};
    on = noop, addListener2 = noop, once2 = noop, off = noop, removeListener2 = noop, removeAllListeners2 = noop, emit2 = noop;
    performance2 = globalThis.performance || {}, performanceNow = performance2.now || performance2.mozNow || performance2.msNow || performance2.oNow || performance2.webkitNow || function() {
      return new Date().getTime();
    };
    startTime = new Date();
    browser$1 = {
      nextTick,
      title,
      browser,
      env,
      argv,
      version,
      versions,
      on,
      addListener: addListener2,
      once: once2,
      off,
      removeListener: removeListener2,
      removeAllListeners: removeAllListeners2,
      emit: emit2,
      binding,
      cwd,
      chdir,
      umask,
      hrtime,
      platform,
      release,
      config,
      uptime
    }, process_default = browser$1;
  }
});

// node_modules/rollup-plugin-node-polyfills/polyfills/inherits.js
var inherits, inherits_default, init_inherits = __esm({
  "node_modules/rollup-plugin-node-polyfills/polyfills/inherits.js"() {
    typeof Object.create == "function" ? inherits = function(ctor, superCtor) {
      ctor.super_ = superCtor, ctor.prototype = Object.create(superCtor.prototype, {
        constructor: {
          value: ctor,
          enumerable: !1,
          writable: !0,
          configurable: !0
        }
      });
    } : inherits = function(ctor, superCtor) {
      ctor.super_ = superCtor;
      var TempCtor = function() {
      };
      TempCtor.prototype = superCtor.prototype, ctor.prototype = new TempCtor(), ctor.prototype.constructor = ctor;
    };
    inherits_default = inherits;
  }
});

// node-modules-polyfills:util
function format(f) {
  if (!isString(f)) {
    for (var objects = [], i = 0; i < arguments.length; i++)
      objects.push(inspect(arguments[i]));
    return objects.join(" ");
  }
  for (var i = 1, args = arguments, len = args.length, str = String(f).replace(formatRegExp, function(x2) {
    if (x2 === "%%")
      return "%";
    if (i >= len)
      return x2;
    switch (x2) {
      case "%s":
        return String(args[i++]);
      case "%d":
        return Number(args[i++]);
      case "%j":
        try {
          return JSON.stringify(args[i++]);
        } catch {
          return "[Circular]";
        }
      default:
        return x2;
    }
  }), x = args[i]; i < len; x = args[++i])
    isNull(x) || !isObject(x) ? str += " " + x : str += " " + inspect(x);
  return str;
}
function deprecate(fn, msg) {
  if (isUndefined(globalThis.process))
    return function() {
      return deprecate(fn, msg).apply(this, arguments);
    };
  if (process_default.noDeprecation === !0)
    return fn;
  var warned = !1;
  function deprecated() {
    if (!warned) {
      if (process_default.throwDeprecation)
        throw new Error(msg);
      process_default.traceDeprecation ? console.trace(msg) : console.error(msg), warned = !0;
    }
    return fn.apply(this, arguments);
  }
  return deprecated;
}
function debuglog(set) {
  if (isUndefined(debugEnviron) && (debugEnviron = process_default.env.NODE_DEBUG || ""), set = set.toUpperCase(), !debugs[set])
    if (new RegExp("\\b" + set + "\\b", "i").test(debugEnviron)) {
      var pid = 0;
      debugs[set] = function() {
        var msg = format.apply(null, arguments);
        console.error("%s %d: %s", set, pid, msg);
      };
    } else
      debugs[set] = function() {
      };
  return debugs[set];
}
function inspect(obj, opts) {
  var ctx = {
    seen: [],
    stylize: stylizeNoColor
  };
  return arguments.length >= 3 && (ctx.depth = arguments[2]), arguments.length >= 4 && (ctx.colors = arguments[3]), isBoolean(opts) ? ctx.showHidden = opts : opts && _extend(ctx, opts), isUndefined(ctx.showHidden) && (ctx.showHidden = !1), isUndefined(ctx.depth) && (ctx.depth = 2), isUndefined(ctx.colors) && (ctx.colors = !1), isUndefined(ctx.customInspect) && (ctx.customInspect = !0), ctx.colors && (ctx.stylize = stylizeWithColor), formatValue(ctx, obj, ctx.depth);
}
function stylizeWithColor(str, styleType) {
  var style3 = inspect.styles[styleType];
  return style3 ? "\x1B[" + inspect.colors[style3][0] + "m" + str + "\x1B[" + inspect.colors[style3][1] + "m" : str;
}
function stylizeNoColor(str, styleType) {
  return str;
}
function arrayToHash(array) {
  var hash = {};
  return array.forEach(function(val, idx) {
    hash[val] = !0;
  }), hash;
}
function formatValue(ctx, value, recurseTimes) {
  if (ctx.customInspect && value && isFunction(value.inspect) && value.inspect !== inspect && !(value.constructor && value.constructor.prototype === value)) {
    var ret = value.inspect(recurseTimes, ctx);
    return isString(ret) || (ret = formatValue(ctx, ret, recurseTimes)), ret;
  }
  var primitive = formatPrimitive(ctx, value);
  if (primitive)
    return primitive;
  var keys2 = Object.keys(value), visibleKeys = arrayToHash(keys2);
  if (ctx.showHidden && (keys2 = Object.getOwnPropertyNames(value)), isError(value) && (keys2.indexOf("message") >= 0 || keys2.indexOf("description") >= 0))
    return formatError(value);
  if (keys2.length === 0) {
    if (isFunction(value)) {
      var name = value.name ? ": " + value.name : "";
      return ctx.stylize("[Function" + name + "]", "special");
    }
    if (isRegExp(value))
      return ctx.stylize(RegExp.prototype.toString.call(value), "regexp");
    if (isDate(value))
      return ctx.stylize(Date.prototype.toString.call(value), "date");
    if (isError(value))
      return formatError(value);
  }
  var base = "", array = !1, braces = ["{", "}"];
  if (isArray(value) && (array = !0, braces = ["[", "]"]), isFunction(value)) {
    var n = value.name ? ": " + value.name : "";
    base = " [Function" + n + "]";
  }
  if (isRegExp(value) && (base = " " + RegExp.prototype.toString.call(value)), isDate(value) && (base = " " + Date.prototype.toUTCString.call(value)), isError(value) && (base = " " + formatError(value)), keys2.length === 0 && (!array || value.length == 0))
    return braces[0] + base + braces[1];
  if (recurseTimes < 0)
    return isRegExp(value) ? ctx.stylize(RegExp.prototype.toString.call(value), "regexp") : ctx.stylize("[Object]", "special");
  ctx.seen.push(value);
  var output;
  return array ? output = formatArray(ctx, value, recurseTimes, visibleKeys, keys2) : output = keys2.map(function(key) {
    return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);
  }), ctx.seen.pop(), reduceToSingleString(output, base, braces);
}
function formatPrimitive(ctx, value) {
  if (isUndefined(value))
    return ctx.stylize("undefined", "undefined");
  if (isString(value)) {
    var simple = "'" + JSON.stringify(value).replace(/^"|"$/g, "").replace(/'/g, "\\'").replace(/\\"/g, '"') + "'";
    return ctx.stylize(simple, "string");
  }
  if (isNumber(value))
    return ctx.stylize("" + value, "number");
  if (isBoolean(value))
    return ctx.stylize("" + value, "boolean");
  if (isNull(value))
    return ctx.stylize("null", "null");
}
function formatError(value) {
  return "[" + Error.prototype.toString.call(value) + "]";
}
function formatArray(ctx, value, recurseTimes, visibleKeys, keys2) {
  for (var output = [], i = 0, l = value.length; i < l; ++i)
    hasOwnProperty(value, String(i)) ? output.push(formatProperty(
      ctx,
      value,
      recurseTimes,
      visibleKeys,
      String(i),
      !0
    )) : output.push("");
  return keys2.forEach(function(key) {
    key.match(/^\d+$/) || output.push(formatProperty(
      ctx,
      value,
      recurseTimes,
      visibleKeys,
      key,
      !0
    ));
  }), output;
}
function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {
  var name, str, desc;
  if (desc = Object.getOwnPropertyDescriptor(value, key) || { value: value[key] }, desc.get ? desc.set ? str = ctx.stylize("[Getter/Setter]", "special") : str = ctx.stylize("[Getter]", "special") : desc.set && (str = ctx.stylize("[Setter]", "special")), hasOwnProperty(visibleKeys, key) || (name = "[" + key + "]"), str || (ctx.seen.indexOf(desc.value) < 0 ? (isNull(recurseTimes) ? str = formatValue(ctx, desc.value, null) : str = formatValue(ctx, desc.value, recurseTimes - 1), str.indexOf(`
`) > -1 && (array ? str = str.split(`
`).map(function(line) {
    return "  " + line;
  }).join(`
`).substr(2) : str = `
` + str.split(`
`).map(function(line) {
    return "   " + line;
  }).join(`
`))) : str = ctx.stylize("[Circular]", "special")), isUndefined(name)) {
    if (array && key.match(/^\d+$/))
      return str;
    name = JSON.stringify("" + key), name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/) ? (name = name.substr(1, name.length - 2), name = ctx.stylize(name, "name")) : (name = name.replace(/'/g, "\\'").replace(/\\"/g, '"').replace(/(^"|"$)/g, "'"), name = ctx.stylize(name, "string"));
  }
  return name + ": " + str;
}
function reduceToSingleString(output, base, braces) {
  var numLinesEst = 0, length = output.reduce(function(prev, cur) {
    return numLinesEst++, cur.indexOf(`
`) >= 0 && numLinesEst++, prev + cur.replace(/\u001b\[\d\d?m/g, "").length + 1;
  }, 0);
  return length > 60 ? braces[0] + (base === "" ? "" : base + `
 `) + " " + output.join(`,
  `) + " " + braces[1] : braces[0] + base + " " + output.join(", ") + " " + braces[1];
}
function isArray(ar) {
  return Array.isArray(ar);
}
function isBoolean(arg) {
  return typeof arg == "boolean";
}
function isNull(arg) {
  return arg === null;
}
function isNumber(arg) {
  return typeof arg == "number";
}
function isString(arg) {
  return typeof arg == "string";
}
function isUndefined(arg) {
  return arg === void 0;
}
function isRegExp(re) {
  return isObject(re) && objectToString(re) === "[object RegExp]";
}
function isObject(arg) {
  return typeof arg == "object" && arg !== null;
}
function isDate(d) {
  return isObject(d) && objectToString(d) === "[object Date]";
}
function isError(e) {
  return isObject(e) && (objectToString(e) === "[object Error]" || e instanceof Error);
}
function isFunction(arg) {
  return typeof arg == "function";
}
function objectToString(o) {
  return Object.prototype.toString.call(o);
}
function _extend(origin, add) {
  if (!add || !isObject(add))
    return origin;
  for (var keys2 = Object.keys(add), i = keys2.length; i--; )
    origin[keys2[i]] = add[keys2[i]];
  return origin;
}
function hasOwnProperty(obj, prop) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
}
var formatRegExp, debugs, debugEnviron, init_util = __esm({
  "node-modules-polyfills:util"() {
    init_process();
    init_inherits();
    formatRegExp = /%[sdj%]/g;
    debugs = {};
    inspect.colors = {
      bold: [1, 22],
      italic: [3, 23],
      underline: [4, 24],
      inverse: [7, 27],
      white: [37, 39],
      grey: [90, 39],
      black: [30, 39],
      blue: [34, 39],
      cyan: [36, 39],
      green: [32, 39],
      magenta: [35, 39],
      red: [31, 39],
      yellow: [33, 39]
    };
    inspect.styles = {
      special: "cyan",
      number: "yellow",
      boolean: "yellow",
      undefined: "grey",
      null: "bold",
      string: "green",
      date: "magenta",
      regexp: "red"
    };
  }
});

// node-modules-polyfills:buffer
function init() {
  inited = !0;
  for (var code = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", i = 0, len = code.length; i < len; ++i)
    lookup[i] = code[i], revLookup[code.charCodeAt(i)] = i;
  revLookup["-".charCodeAt(0)] = 62, revLookup["_".charCodeAt(0)] = 63;
}
function toByteArray(b64) {
  inited || init();
  var i, j, l, tmp, placeHolders, arr, len = b64.length;
  if (len % 4 > 0)
    throw new Error("Invalid string. Length must be a multiple of 4");
  placeHolders = b64[len - 2] === "=" ? 2 : b64[len - 1] === "=" ? 1 : 0, arr = new Arr(len * 3 / 4 - placeHolders), l = placeHolders > 0 ? len - 4 : len;
  var L = 0;
  for (i = 0, j = 0; i < l; i += 4, j += 3)
    tmp = revLookup[b64.charCodeAt(i)] << 18 | revLookup[b64.charCodeAt(i + 1)] << 12 | revLookup[b64.charCodeAt(i + 2)] << 6 | revLookup[b64.charCodeAt(i + 3)], arr[L++] = tmp >> 16 & 255, arr[L++] = tmp >> 8 & 255, arr[L++] = tmp & 255;
  return placeHolders === 2 ? (tmp = revLookup[b64.charCodeAt(i)] << 2 | revLookup[b64.charCodeAt(i + 1)] >> 4, arr[L++] = tmp & 255) : placeHolders === 1 && (tmp = revLookup[b64.charCodeAt(i)] << 10 | revLookup[b64.charCodeAt(i + 1)] << 4 | revLookup[b64.charCodeAt(i + 2)] >> 2, arr[L++] = tmp >> 8 & 255, arr[L++] = tmp & 255), arr;
}
function tripletToBase64(num) {
  return lookup[num >> 18 & 63] + lookup[num >> 12 & 63] + lookup[num >> 6 & 63] + lookup[num & 63];
}
function encodeChunk(uint8, start, end) {
  for (var tmp, output = [], i = start; i < end; i += 3)
    tmp = (uint8[i] << 16) + (uint8[i + 1] << 8) + uint8[i + 2], output.push(tripletToBase64(tmp));
  return output.join("");
}
function fromByteArray(uint8) {
  inited || init();
  for (var tmp, len = uint8.length, extraBytes = len % 3, output = "", parts = [], maxChunkLength = 16383, i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength)
    parts.push(encodeChunk(uint8, i, i + maxChunkLength > len2 ? len2 : i + maxChunkLength));
  return extraBytes === 1 ? (tmp = uint8[len - 1], output += lookup[tmp >> 2], output += lookup[tmp << 4 & 63], output += "==") : extraBytes === 2 && (tmp = (uint8[len - 2] << 8) + uint8[len - 1], output += lookup[tmp >> 10], output += lookup[tmp >> 4 & 63], output += lookup[tmp << 2 & 63], output += "="), parts.push(output), parts.join("");
}
function read(buffer, offset, isLE, mLen, nBytes) {
  var e, m, eLen = nBytes * 8 - mLen - 1, eMax = (1 << eLen) - 1, eBias = eMax >> 1, nBits = -7, i = isLE ? nBytes - 1 : 0, d = isLE ? -1 : 1, s = buffer[offset + i];
  for (i += d, e = s & (1 << -nBits) - 1, s >>= -nBits, nBits += eLen; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8)
    ;
  for (m = e & (1 << -nBits) - 1, e >>= -nBits, nBits += mLen; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8)
    ;
  if (e === 0)
    e = 1 - eBias;
  else {
    if (e === eMax)
      return m ? NaN : (s ? -1 : 1) * (1 / 0);
    m = m + Math.pow(2, mLen), e = e - eBias;
  }
  return (s ? -1 : 1) * m * Math.pow(2, e - mLen);
}
function write(buffer, value, offset, isLE, mLen, nBytes) {
  var e, m, c, eLen = nBytes * 8 - mLen - 1, eMax = (1 << eLen) - 1, eBias = eMax >> 1, rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0, i = isLE ? 0 : nBytes - 1, d = isLE ? 1 : -1, s = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;
  for (value = Math.abs(value), isNaN(value) || value === 1 / 0 ? (m = isNaN(value) ? 1 : 0, e = eMax) : (e = Math.floor(Math.log(value) / Math.LN2), value * (c = Math.pow(2, -e)) < 1 && (e--, c *= 2), e + eBias >= 1 ? value += rt / c : value += rt * Math.pow(2, 1 - eBias), value * c >= 2 && (e++, c /= 2), e + eBias >= eMax ? (m = 0, e = eMax) : e + eBias >= 1 ? (m = (value * c - 1) * Math.pow(2, mLen), e = e + eBias) : (m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen), e = 0)); mLen >= 8; buffer[offset + i] = m & 255, i += d, m /= 256, mLen -= 8)
    ;
  for (e = e << mLen | m, eLen += mLen; eLen > 0; buffer[offset + i] = e & 255, i += d, e /= 256, eLen -= 8)
    ;
  buffer[offset + i - d] |= s * 128;
}
function kMaxLength() {
  return Buffer2.TYPED_ARRAY_SUPPORT ? 2147483647 : 1073741823;
}
function createBuffer(that, length) {
  if (kMaxLength() < length)
    throw new RangeError("Invalid typed array length");
  return Buffer2.TYPED_ARRAY_SUPPORT ? (that = new Uint8Array(length), that.__proto__ = Buffer2.prototype) : (that === null && (that = new Buffer2(length)), that.length = length), that;
}
function Buffer2(arg, encodingOrOffset, length) {
  if (!Buffer2.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer2))
    return new Buffer2(arg, encodingOrOffset, length);
  if (typeof arg == "number") {
    if (typeof encodingOrOffset == "string")
      throw new Error(
        "If encoding is specified then the first argument must be a string"
      );
    return allocUnsafe(this, arg);
  }
  return from(this, arg, encodingOrOffset, length);
}
function from(that, value, encodingOrOffset, length) {
  if (typeof value == "number")
    throw new TypeError('"value" argument must not be a number');
  return typeof ArrayBuffer < "u" && value instanceof ArrayBuffer ? fromArrayBuffer(that, value, encodingOrOffset, length) : typeof value == "string" ? fromString(that, value, encodingOrOffset) : fromObject(that, value);
}
function assertSize(size) {
  if (typeof size != "number")
    throw new TypeError('"size" argument must be a number');
  if (size < 0)
    throw new RangeError('"size" argument must not be negative');
}
function alloc(that, size, fill2, encoding) {
  return assertSize(size), size <= 0 ? createBuffer(that, size) : fill2 !== void 0 ? typeof encoding == "string" ? createBuffer(that, size).fill(fill2, encoding) : createBuffer(that, size).fill(fill2) : createBuffer(that, size);
}
function allocUnsafe(that, size) {
  if (assertSize(size), that = createBuffer(that, size < 0 ? 0 : checked(size) | 0), !Buffer2.TYPED_ARRAY_SUPPORT)
    for (var i = 0; i < size; ++i)
      that[i] = 0;
  return that;
}
function fromString(that, string, encoding) {
  if ((typeof encoding != "string" || encoding === "") && (encoding = "utf8"), !Buffer2.isEncoding(encoding))
    throw new TypeError('"encoding" must be a valid string encoding');
  var length = byteLength(string, encoding) | 0;
  that = createBuffer(that, length);
  var actual = that.write(string, encoding);
  return actual !== length && (that = that.slice(0, actual)), that;
}
function fromArrayLike(that, array) {
  var length = array.length < 0 ? 0 : checked(array.length) | 0;
  that = createBuffer(that, length);
  for (var i = 0; i < length; i += 1)
    that[i] = array[i] & 255;
  return that;
}
function fromArrayBuffer(that, array, byteOffset, length) {
  if (array.byteLength, byteOffset < 0 || array.byteLength < byteOffset)
    throw new RangeError("'offset' is out of bounds");
  if (array.byteLength < byteOffset + (length || 0))
    throw new RangeError("'length' is out of bounds");
  return byteOffset === void 0 && length === void 0 ? array = new Uint8Array(array) : length === void 0 ? array = new Uint8Array(array, byteOffset) : array = new Uint8Array(array, byteOffset, length), Buffer2.TYPED_ARRAY_SUPPORT ? (that = array, that.__proto__ = Buffer2.prototype) : that = fromArrayLike(that, array), that;
}
function fromObject(that, obj) {
  if (internalIsBuffer(obj)) {
    var len = checked(obj.length) | 0;
    return that = createBuffer(that, len), that.length === 0 || obj.copy(that, 0, 0, len), that;
  }
  if (obj) {
    if (typeof ArrayBuffer < "u" && obj.buffer instanceof ArrayBuffer || "length" in obj)
      return typeof obj.length != "number" || isnan(obj.length) ? createBuffer(that, 0) : fromArrayLike(that, obj);
    if (obj.type === "Buffer" && isArray2(obj.data))
      return fromArrayLike(that, obj.data);
  }
  throw new TypeError("First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.");
}
function checked(length) {
  if (length >= kMaxLength())
    throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + kMaxLength().toString(16) + " bytes");
  return length | 0;
}
function internalIsBuffer(b) {
  return !!(b != null && b._isBuffer);
}
function byteLength(string, encoding) {
  if (internalIsBuffer(string))
    return string.length;
  if (typeof ArrayBuffer < "u" && typeof ArrayBuffer.isView == "function" && (ArrayBuffer.isView(string) || string instanceof ArrayBuffer))
    return string.byteLength;
  typeof string != "string" && (string = "" + string);
  var len = string.length;
  if (len === 0)
    return 0;
  for (var loweredCase = !1; ; )
    switch (encoding) {
      case "ascii":
      case "latin1":
      case "binary":
        return len;
      case "utf8":
      case "utf-8":
      case void 0:
        return utf8ToBytes(string).length;
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
        return len * 2;
      case "hex":
        return len >>> 1;
      case "base64":
        return base64ToBytes(string).length;
      default:
        if (loweredCase)
          return utf8ToBytes(string).length;
        encoding = ("" + encoding).toLowerCase(), loweredCase = !0;
    }
}
function slowToString(encoding, start, end) {
  var loweredCase = !1;
  if ((start === void 0 || start < 0) && (start = 0), start > this.length || ((end === void 0 || end > this.length) && (end = this.length), end <= 0) || (end >>>= 0, start >>>= 0, end <= start))
    return "";
  for (encoding || (encoding = "utf8"); ; )
    switch (encoding) {
      case "hex":
        return hexSlice(this, start, end);
      case "utf8":
      case "utf-8":
        return utf8Slice(this, start, end);
      case "ascii":
        return asciiSlice(this, start, end);
      case "latin1":
      case "binary":
        return latin1Slice(this, start, end);
      case "base64":
        return base64Slice(this, start, end);
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
        return utf16leSlice(this, start, end);
      default:
        if (loweredCase)
          throw new TypeError("Unknown encoding: " + encoding);
        encoding = (encoding + "").toLowerCase(), loweredCase = !0;
    }
}
function swap(b, n, m) {
  var i = b[n];
  b[n] = b[m], b[m] = i;
}
function bidirectionalIndexOf(buffer, val, byteOffset, encoding, dir) {
  if (buffer.length === 0)
    return -1;
  if (typeof byteOffset == "string" ? (encoding = byteOffset, byteOffset = 0) : byteOffset > 2147483647 ? byteOffset = 2147483647 : byteOffset < -2147483648 && (byteOffset = -2147483648), byteOffset = +byteOffset, isNaN(byteOffset) && (byteOffset = dir ? 0 : buffer.length - 1), byteOffset < 0 && (byteOffset = buffer.length + byteOffset), byteOffset >= buffer.length) {
    if (dir)
      return -1;
    byteOffset = buffer.length - 1;
  } else if (byteOffset < 0)
    if (dir)
      byteOffset = 0;
    else
      return -1;
  if (typeof val == "string" && (val = Buffer2.from(val, encoding)), internalIsBuffer(val))
    return val.length === 0 ? -1 : arrayIndexOf(buffer, val, byteOffset, encoding, dir);
  if (typeof val == "number")
    return val = val & 255, Buffer2.TYPED_ARRAY_SUPPORT && typeof Uint8Array.prototype.indexOf == "function" ? dir ? Uint8Array.prototype.indexOf.call(buffer, val, byteOffset) : Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset) : arrayIndexOf(buffer, [val], byteOffset, encoding, dir);
  throw new TypeError("val must be string, number or Buffer");
}
function arrayIndexOf(arr, val, byteOffset, encoding, dir) {
  var indexSize = 1, arrLength = arr.length, valLength = val.length;
  if (encoding !== void 0 && (encoding = String(encoding).toLowerCase(), encoding === "ucs2" || encoding === "ucs-2" || encoding === "utf16le" || encoding === "utf-16le")) {
    if (arr.length < 2 || val.length < 2)
      return -1;
    indexSize = 2, arrLength /= 2, valLength /= 2, byteOffset /= 2;
  }
  function read2(buf, i2) {
    return indexSize === 1 ? buf[i2] : buf.readUInt16BE(i2 * indexSize);
  }
  var i;
  if (dir) {
    var foundIndex = -1;
    for (i = byteOffset; i < arrLength; i++)
      if (read2(arr, i) === read2(val, foundIndex === -1 ? 0 : i - foundIndex)) {
        if (foundIndex === -1 && (foundIndex = i), i - foundIndex + 1 === valLength)
          return foundIndex * indexSize;
      } else
        foundIndex !== -1 && (i -= i - foundIndex), foundIndex = -1;
  } else
    for (byteOffset + valLength > arrLength && (byteOffset = arrLength - valLength), i = byteOffset; i >= 0; i--) {
      for (var found = !0, j = 0; j < valLength; j++)
        if (read2(arr, i + j) !== read2(val, j)) {
          found = !1;
          break;
        }
      if (found)
        return i;
    }
  return -1;
}
function hexWrite(buf, string, offset, length) {
  offset = Number(offset) || 0;
  var remaining = buf.length - offset;
  length ? (length = Number(length), length > remaining && (length = remaining)) : length = remaining;
  var strLen = string.length;
  if (strLen % 2 !== 0)
    throw new TypeError("Invalid hex string");
  length > strLen / 2 && (length = strLen / 2);
  for (var i = 0; i < length; ++i) {
    var parsed = parseInt(string.substr(i * 2, 2), 16);
    if (isNaN(parsed))
      return i;
    buf[offset + i] = parsed;
  }
  return i;
}
function utf8Write(buf, string, offset, length) {
  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length);
}
function asciiWrite(buf, string, offset, length) {
  return blitBuffer(asciiToBytes(string), buf, offset, length);
}
function latin1Write(buf, string, offset, length) {
  return asciiWrite(buf, string, offset, length);
}
function base64Write(buf, string, offset, length) {
  return blitBuffer(base64ToBytes(string), buf, offset, length);
}
function ucs2Write(buf, string, offset, length) {
  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length);
}
function base64Slice(buf, start, end) {
  return start === 0 && end === buf.length ? fromByteArray(buf) : fromByteArray(buf.slice(start, end));
}
function utf8Slice(buf, start, end) {
  end = Math.min(buf.length, end);
  for (var res = [], i = start; i < end; ) {
    var firstByte = buf[i], codePoint = null, bytesPerSequence = firstByte > 239 ? 4 : firstByte > 223 ? 3 : firstByte > 191 ? 2 : 1;
    if (i + bytesPerSequence <= end) {
      var secondByte, thirdByte, fourthByte, tempCodePoint;
      switch (bytesPerSequence) {
        case 1:
          firstByte < 128 && (codePoint = firstByte);
          break;
        case 2:
          secondByte = buf[i + 1], (secondByte & 192) === 128 && (tempCodePoint = (firstByte & 31) << 6 | secondByte & 63, tempCodePoint > 127 && (codePoint = tempCodePoint));
          break;
        case 3:
          secondByte = buf[i + 1], thirdByte = buf[i + 2], (secondByte & 192) === 128 && (thirdByte & 192) === 128 && (tempCodePoint = (firstByte & 15) << 12 | (secondByte & 63) << 6 | thirdByte & 63, tempCodePoint > 2047 && (tempCodePoint < 55296 || tempCodePoint > 57343) && (codePoint = tempCodePoint));
          break;
        case 4:
          secondByte = buf[i + 1], thirdByte = buf[i + 2], fourthByte = buf[i + 3], (secondByte & 192) === 128 && (thirdByte & 192) === 128 && (fourthByte & 192) === 128 && (tempCodePoint = (firstByte & 15) << 18 | (secondByte & 63) << 12 | (thirdByte & 63) << 6 | fourthByte & 63, tempCodePoint > 65535 && tempCodePoint < 1114112 && (codePoint = tempCodePoint));
      }
    }
    codePoint === null ? (codePoint = 65533, bytesPerSequence = 1) : codePoint > 65535 && (codePoint -= 65536, res.push(codePoint >>> 10 & 1023 | 55296), codePoint = 56320 | codePoint & 1023), res.push(codePoint), i += bytesPerSequence;
  }
  return decodeCodePointsArray(res);
}
function decodeCodePointsArray(codePoints) {
  var len = codePoints.length;
  if (len <= MAX_ARGUMENTS_LENGTH)
    return String.fromCharCode.apply(String, codePoints);
  for (var res = "", i = 0; i < len; )
    res += String.fromCharCode.apply(
      String,
      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
    );
  return res;
}
function asciiSlice(buf, start, end) {
  var ret = "";
  end = Math.min(buf.length, end);
  for (var i = start; i < end; ++i)
    ret += String.fromCharCode(buf[i] & 127);
  return ret;
}
function latin1Slice(buf, start, end) {
  var ret = "";
  end = Math.min(buf.length, end);
  for (var i = start; i < end; ++i)
    ret += String.fromCharCode(buf[i]);
  return ret;
}
function hexSlice(buf, start, end) {
  var len = buf.length;
  (!start || start < 0) && (start = 0), (!end || end < 0 || end > len) && (end = len);
  for (var out = "", i = start; i < end; ++i)
    out += toHex(buf[i]);
  return out;
}
function utf16leSlice(buf, start, end) {
  for (var bytes = buf.slice(start, end), res = "", i = 0; i < bytes.length; i += 2)
    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256);
  return res;
}
function checkOffset(offset, ext, length) {
  if (offset % 1 !== 0 || offset < 0)
    throw new RangeError("offset is not uint");
  if (offset + ext > length)
    throw new RangeError("Trying to access beyond buffer length");
}
function checkInt(buf, value, offset, ext, max, min) {
  if (!internalIsBuffer(buf))
    throw new TypeError('"buffer" argument must be a Buffer instance');
  if (value > max || value < min)
    throw new RangeError('"value" argument is out of bounds');
  if (offset + ext > buf.length)
    throw new RangeError("Index out of range");
}
function objectWriteUInt16(buf, value, offset, littleEndian) {
  value < 0 && (value = 65535 + value + 1);
  for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; ++i)
    buf[offset + i] = (value & 255 << 8 * (littleEndian ? i : 1 - i)) >>> (littleEndian ? i : 1 - i) * 8;
}
function objectWriteUInt32(buf, value, offset, littleEndian) {
  value < 0 && (value = 4294967295 + value + 1);
  for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; ++i)
    buf[offset + i] = value >>> (littleEndian ? i : 3 - i) * 8 & 255;
}
function checkIEEE754(buf, value, offset, ext, max, min) {
  if (offset + ext > buf.length)
    throw new RangeError("Index out of range");
  if (offset < 0)
    throw new RangeError("Index out of range");
}
function writeFloat(buf, value, offset, littleEndian, noAssert) {
  return noAssert || checkIEEE754(buf, value, offset, 4), write(buf, value, offset, littleEndian, 23, 4), offset + 4;
}
function writeDouble(buf, value, offset, littleEndian, noAssert) {
  return noAssert || checkIEEE754(buf, value, offset, 8), write(buf, value, offset, littleEndian, 52, 8), offset + 8;
}
function base64clean(str) {
  if (str = stringtrim(str).replace(INVALID_BASE64_RE, ""), str.length < 2)
    return "";
  for (; str.length % 4 !== 0; )
    str = str + "=";
  return str;
}
function stringtrim(str) {
  return str.trim ? str.trim() : str.replace(/^\s+|\s+$/g, "");
}
function toHex(n) {
  return n < 16 ? "0" + n.toString(16) : n.toString(16);
}
function utf8ToBytes(string, units) {
  units = units || 1 / 0;
  for (var codePoint, length = string.length, leadSurrogate = null, bytes = [], i = 0; i < length; ++i) {
    if (codePoint = string.charCodeAt(i), codePoint > 55295 && codePoint < 57344) {
      if (!leadSurrogate) {
        if (codePoint > 56319) {
          (units -= 3) > -1 && bytes.push(239, 191, 189);
          continue;
        } else if (i + 1 === length) {
          (units -= 3) > -1 && bytes.push(239, 191, 189);
          continue;
        }
        leadSurrogate = codePoint;
        continue;
      }
      if (codePoint < 56320) {
        (units -= 3) > -1 && bytes.push(239, 191, 189), leadSurrogate = codePoint;
        continue;
      }
      codePoint = (leadSurrogate - 55296 << 10 | codePoint - 56320) + 65536;
    } else
      leadSurrogate && (units -= 3) > -1 && bytes.push(239, 191, 189);
    if (leadSurrogate = null, codePoint < 128) {
      if ((units -= 1) < 0)
        break;
      bytes.push(codePoint);
    } else if (codePoint < 2048) {
      if ((units -= 2) < 0)
        break;
      bytes.push(
        codePoint >> 6 | 192,
        codePoint & 63 | 128
      );
    } else if (codePoint < 65536) {
      if ((units -= 3) < 0)
        break;
      bytes.push(
        codePoint >> 12 | 224,
        codePoint >> 6 & 63 | 128,
        codePoint & 63 | 128
      );
    } else if (codePoint < 1114112) {
      if ((units -= 4) < 0)
        break;
      bytes.push(
        codePoint >> 18 | 240,
        codePoint >> 12 & 63 | 128,
        codePoint >> 6 & 63 | 128,
        codePoint & 63 | 128
      );
    } else
      throw new Error("Invalid code point");
  }
  return bytes;
}
function asciiToBytes(str) {
  for (var byteArray = [], i = 0; i < str.length; ++i)
    byteArray.push(str.charCodeAt(i) & 255);
  return byteArray;
}
function utf16leToBytes(str, units) {
  for (var c, hi, lo, byteArray = [], i = 0; i < str.length && !((units -= 2) < 0); ++i)
    c = str.charCodeAt(i), hi = c >> 8, lo = c % 256, byteArray.push(lo), byteArray.push(hi);
  return byteArray;
}
function base64ToBytes(str) {
  return toByteArray(base64clean(str));
}
function blitBuffer(src, dst, offset, length) {
  for (var i = 0; i < length && !(i + offset >= dst.length || i >= src.length); ++i)
    dst[i + offset] = src[i];
  return i;
}
function isnan(val) {
  return val !== val;
}
function isBuffer(obj) {
  return obj != null && (!!obj._isBuffer || isFastBuffer(obj) || isSlowBuffer(obj));
}
function isFastBuffer(obj) {
  return !!obj.constructor && typeof obj.constructor.isBuffer == "function" && obj.constructor.isBuffer(obj);
}
function isSlowBuffer(obj) {
  return typeof obj.readFloatLE == "function" && typeof obj.slice == "function" && isFastBuffer(obj.slice(0, 0));
}
var lookup, revLookup, Arr, inited, toString, isArray2, INSPECT_MAX_BYTES, _kMaxLength, MAX_ARGUMENTS_LENGTH, INVALID_BASE64_RE, init_buffer = __esm({
  "node-modules-polyfills:buffer"() {
    lookup = [], revLookup = [], Arr = typeof Uint8Array < "u" ? Uint8Array : Array, inited = !1;
    toString = {}.toString, isArray2 = Array.isArray || function(arr) {
      return toString.call(arr) == "[object Array]";
    };
    INSPECT_MAX_BYTES = 50;
    Buffer2.TYPED_ARRAY_SUPPORT = globalThis.TYPED_ARRAY_SUPPORT !== void 0 ? globalThis.TYPED_ARRAY_SUPPORT : !0;
    _kMaxLength = kMaxLength();
    Buffer2.poolSize = 8192;
    Buffer2._augment = function(arr) {
      return arr.__proto__ = Buffer2.prototype, arr;
    };
    Buffer2.from = function(value, encodingOrOffset, length) {
      return from(null, value, encodingOrOffset, length);
    };
    Buffer2.TYPED_ARRAY_SUPPORT && (Buffer2.prototype.__proto__ = Uint8Array.prototype, Buffer2.__proto__ = Uint8Array);
    Buffer2.alloc = function(size, fill2, encoding) {
      return alloc(null, size, fill2, encoding);
    };
    Buffer2.allocUnsafe = function(size) {
      return allocUnsafe(null, size);
    };
    Buffer2.allocUnsafeSlow = function(size) {
      return allocUnsafe(null, size);
    };
    Buffer2.isBuffer = isBuffer;
    Buffer2.compare = function(a, b) {
      if (!internalIsBuffer(a) || !internalIsBuffer(b))
        throw new TypeError("Arguments must be Buffers");
      if (a === b)
        return 0;
      for (var x = a.length, y = b.length, i = 0, len = Math.min(x, y); i < len; ++i)
        if (a[i] !== b[i]) {
          x = a[i], y = b[i];
          break;
        }
      return x < y ? -1 : y < x ? 1 : 0;
    };
    Buffer2.isEncoding = function(encoding) {
      switch (String(encoding).toLowerCase()) {
        case "hex":
        case "utf8":
        case "utf-8":
        case "ascii":
        case "latin1":
        case "binary":
        case "base64":
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return !0;
        default:
          return !1;
      }
    };
    Buffer2.concat = function(list, length) {
      if (!isArray2(list))
        throw new TypeError('"list" argument must be an Array of Buffers');
      if (list.length === 0)
        return Buffer2.alloc(0);
      var i;
      if (length === void 0)
        for (length = 0, i = 0; i < list.length; ++i)
          length += list[i].length;
      var buffer = Buffer2.allocUnsafe(length), pos = 0;
      for (i = 0; i < list.length; ++i) {
        var buf = list[i];
        if (!internalIsBuffer(buf))
          throw new TypeError('"list" argument must be an Array of Buffers');
        buf.copy(buffer, pos), pos += buf.length;
      }
      return buffer;
    };
    Buffer2.byteLength = byteLength;
    Buffer2.prototype._isBuffer = !0;
    Buffer2.prototype.swap16 = function() {
      var len = this.length;
      if (len % 2 !== 0)
        throw new RangeError("Buffer size must be a multiple of 16-bits");
      for (var i = 0; i < len; i += 2)
        swap(this, i, i + 1);
      return this;
    };
    Buffer2.prototype.swap32 = function() {
      var len = this.length;
      if (len % 4 !== 0)
        throw new RangeError("Buffer size must be a multiple of 32-bits");
      for (var i = 0; i < len; i += 4)
        swap(this, i, i + 3), swap(this, i + 1, i + 2);
      return this;
    };
    Buffer2.prototype.swap64 = function() {
      var len = this.length;
      if (len % 8 !== 0)
        throw new RangeError("Buffer size must be a multiple of 64-bits");
      for (var i = 0; i < len; i += 8)
        swap(this, i, i + 7), swap(this, i + 1, i + 6), swap(this, i + 2, i + 5), swap(this, i + 3, i + 4);
      return this;
    };
    Buffer2.prototype.toString = function() {
      var length = this.length | 0;
      return length === 0 ? "" : arguments.length === 0 ? utf8Slice(this, 0, length) : slowToString.apply(this, arguments);
    };
    Buffer2.prototype.equals = function(b) {
      if (!internalIsBuffer(b))
        throw new TypeError("Argument must be a Buffer");
      return this === b ? !0 : Buffer2.compare(this, b) === 0;
    };
    Buffer2.prototype.inspect = function() {
      var str = "", max = INSPECT_MAX_BYTES;
      return this.length > 0 && (str = this.toString("hex", 0, max).match(/.{2}/g).join(" "), this.length > max && (str += " ... ")), "<Buffer " + str + ">";
    };
    Buffer2.prototype.compare = function(target, start, end, thisStart, thisEnd) {
      if (!internalIsBuffer(target))
        throw new TypeError("Argument must be a Buffer");
      if (start === void 0 && (start = 0), end === void 0 && (end = target ? target.length : 0), thisStart === void 0 && (thisStart = 0), thisEnd === void 0 && (thisEnd = this.length), start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length)
        throw new RangeError("out of range index");
      if (thisStart >= thisEnd && start >= end)
        return 0;
      if (thisStart >= thisEnd)
        return -1;
      if (start >= end)
        return 1;
      if (start >>>= 0, end >>>= 0, thisStart >>>= 0, thisEnd >>>= 0, this === target)
        return 0;
      for (var x = thisEnd - thisStart, y = end - start, len = Math.min(x, y), thisCopy = this.slice(thisStart, thisEnd), targetCopy = target.slice(start, end), i = 0; i < len; ++i)
        if (thisCopy[i] !== targetCopy[i]) {
          x = thisCopy[i], y = targetCopy[i];
          break;
        }
      return x < y ? -1 : y < x ? 1 : 0;
    };
    Buffer2.prototype.includes = function(val, byteOffset, encoding) {
      return this.indexOf(val, byteOffset, encoding) !== -1;
    };
    Buffer2.prototype.indexOf = function(val, byteOffset, encoding) {
      return bidirectionalIndexOf(this, val, byteOffset, encoding, !0);
    };
    Buffer2.prototype.lastIndexOf = function(val, byteOffset, encoding) {
      return bidirectionalIndexOf(this, val, byteOffset, encoding, !1);
    };
    Buffer2.prototype.write = function(string, offset, length, encoding) {
      if (offset === void 0)
        encoding = "utf8", length = this.length, offset = 0;
      else if (length === void 0 && typeof offset == "string")
        encoding = offset, length = this.length, offset = 0;
      else if (isFinite(offset))
        offset = offset | 0, isFinite(length) ? (length = length | 0, encoding === void 0 && (encoding = "utf8")) : (encoding = length, length = void 0);
      else
        throw new Error(
          "Buffer.write(string, encoding, offset[, length]) is no longer supported"
        );
      var remaining = this.length - offset;
      if ((length === void 0 || length > remaining) && (length = remaining), string.length > 0 && (length < 0 || offset < 0) || offset > this.length)
        throw new RangeError("Attempt to write outside buffer bounds");
      encoding || (encoding = "utf8");
      for (var loweredCase = !1; ; )
        switch (encoding) {
          case "hex":
            return hexWrite(this, string, offset, length);
          case "utf8":
          case "utf-8":
            return utf8Write(this, string, offset, length);
          case "ascii":
            return asciiWrite(this, string, offset, length);
          case "latin1":
          case "binary":
            return latin1Write(this, string, offset, length);
          case "base64":
            return base64Write(this, string, offset, length);
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return ucs2Write(this, string, offset, length);
          default:
            if (loweredCase)
              throw new TypeError("Unknown encoding: " + encoding);
            encoding = ("" + encoding).toLowerCase(), loweredCase = !0;
        }
    };
    Buffer2.prototype.toJSON = function() {
      return {
        type: "Buffer",
        data: Array.prototype.slice.call(this._arr || this, 0)
      };
    };
    MAX_ARGUMENTS_LENGTH = 4096;
    Buffer2.prototype.slice = function(start, end) {
      var len = this.length;
      start = ~~start, end = end === void 0 ? len : ~~end, start < 0 ? (start += len, start < 0 && (start = 0)) : start > len && (start = len), end < 0 ? (end += len, end < 0 && (end = 0)) : end > len && (end = len), end < start && (end = start);
      var newBuf;
      if (Buffer2.TYPED_ARRAY_SUPPORT)
        newBuf = this.subarray(start, end), newBuf.__proto__ = Buffer2.prototype;
      else {
        var sliceLen = end - start;
        newBuf = new Buffer2(sliceLen, void 0);
        for (var i = 0; i < sliceLen; ++i)
          newBuf[i] = this[i + start];
      }
      return newBuf;
    };
    Buffer2.prototype.readUIntLE = function(offset, byteLength2, noAssert) {
      offset = offset | 0, byteLength2 = byteLength2 | 0, noAssert || checkOffset(offset, byteLength2, this.length);
      for (var val = this[offset], mul = 1, i = 0; ++i < byteLength2 && (mul *= 256); )
        val += this[offset + i] * mul;
      return val;
    };
    Buffer2.prototype.readUIntBE = function(offset, byteLength2, noAssert) {
      offset = offset | 0, byteLength2 = byteLength2 | 0, noAssert || checkOffset(offset, byteLength2, this.length);
      for (var val = this[offset + --byteLength2], mul = 1; byteLength2 > 0 && (mul *= 256); )
        val += this[offset + --byteLength2] * mul;
      return val;
    };
    Buffer2.prototype.readUInt8 = function(offset, noAssert) {
      return noAssert || checkOffset(offset, 1, this.length), this[offset];
    };
    Buffer2.prototype.readUInt16LE = function(offset, noAssert) {
      return noAssert || checkOffset(offset, 2, this.length), this[offset] | this[offset + 1] << 8;
    };
    Buffer2.prototype.readUInt16BE = function(offset, noAssert) {
      return noAssert || checkOffset(offset, 2, this.length), this[offset] << 8 | this[offset + 1];
    };
    Buffer2.prototype.readUInt32LE = function(offset, noAssert) {
      return noAssert || checkOffset(offset, 4, this.length), (this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16) + this[offset + 3] * 16777216;
    };
    Buffer2.prototype.readUInt32BE = function(offset, noAssert) {
      return noAssert || checkOffset(offset, 4, this.length), this[offset] * 16777216 + (this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3]);
    };
    Buffer2.prototype.readIntLE = function(offset, byteLength2, noAssert) {
      offset = offset | 0, byteLength2 = byteLength2 | 0, noAssert || checkOffset(offset, byteLength2, this.length);
      for (var val = this[offset], mul = 1, i = 0; ++i < byteLength2 && (mul *= 256); )
        val += this[offset + i] * mul;
      return mul *= 128, val >= mul && (val -= Math.pow(2, 8 * byteLength2)), val;
    };
    Buffer2.prototype.readIntBE = function(offset, byteLength2, noAssert) {
      offset = offset | 0, byteLength2 = byteLength2 | 0, noAssert || checkOffset(offset, byteLength2, this.length);
      for (var i = byteLength2, mul = 1, val = this[offset + --i]; i > 0 && (mul *= 256); )
        val += this[offset + --i] * mul;
      return mul *= 128, val >= mul && (val -= Math.pow(2, 8 * byteLength2)), val;
    };
    Buffer2.prototype.readInt8 = function(offset, noAssert) {
      return noAssert || checkOffset(offset, 1, this.length), this[offset] & 128 ? (255 - this[offset] + 1) * -1 : this[offset];
    };
    Buffer2.prototype.readInt16LE = function(offset, noAssert) {
      noAssert || checkOffset(offset, 2, this.length);
      var val = this[offset] | this[offset + 1] << 8;
      return val & 32768 ? val | 4294901760 : val;
    };
    Buffer2.prototype.readInt16BE = function(offset, noAssert) {
      noAssert || checkOffset(offset, 2, this.length);
      var val = this[offset + 1] | this[offset] << 8;
      return val & 32768 ? val | 4294901760 : val;
    };
    Buffer2.prototype.readInt32LE = function(offset, noAssert) {
      return noAssert || checkOffset(offset, 4, this.length), this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16 | this[offset + 3] << 24;
    };
    Buffer2.prototype.readInt32BE = function(offset, noAssert) {
      return noAssert || checkOffset(offset, 4, this.length), this[offset] << 24 | this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3];
    };
    Buffer2.prototype.readFloatLE = function(offset, noAssert) {
      return noAssert || checkOffset(offset, 4, this.length), read(this, offset, !0, 23, 4);
    };
    Buffer2.prototype.readFloatBE = function(offset, noAssert) {
      return noAssert || checkOffset(offset, 4, this.length), read(this, offset, !1, 23, 4);
    };
    Buffer2.prototype.readDoubleLE = function(offset, noAssert) {
      return noAssert || checkOffset(offset, 8, this.length), read(this, offset, !0, 52, 8);
    };
    Buffer2.prototype.readDoubleBE = function(offset, noAssert) {
      return noAssert || checkOffset(offset, 8, this.length), read(this, offset, !1, 52, 8);
    };
    Buffer2.prototype.writeUIntLE = function(value, offset, byteLength2, noAssert) {
      if (value = +value, offset = offset | 0, byteLength2 = byteLength2 | 0, !noAssert) {
        var maxBytes = Math.pow(2, 8 * byteLength2) - 1;
        checkInt(this, value, offset, byteLength2, maxBytes, 0);
      }
      var mul = 1, i = 0;
      for (this[offset] = value & 255; ++i < byteLength2 && (mul *= 256); )
        this[offset + i] = value / mul & 255;
      return offset + byteLength2;
    };
    Buffer2.prototype.writeUIntBE = function(value, offset, byteLength2, noAssert) {
      if (value = +value, offset = offset | 0, byteLength2 = byteLength2 | 0, !noAssert) {
        var maxBytes = Math.pow(2, 8 * byteLength2) - 1;
        checkInt(this, value, offset, byteLength2, maxBytes, 0);
      }
      var i = byteLength2 - 1, mul = 1;
      for (this[offset + i] = value & 255; --i >= 0 && (mul *= 256); )
        this[offset + i] = value / mul & 255;
      return offset + byteLength2;
    };
    Buffer2.prototype.writeUInt8 = function(value, offset, noAssert) {
      return value = +value, offset = offset | 0, noAssert || checkInt(this, value, offset, 1, 255, 0), Buffer2.TYPED_ARRAY_SUPPORT || (value = Math.floor(value)), this[offset] = value & 255, offset + 1;
    };
    Buffer2.prototype.writeUInt16LE = function(value, offset, noAssert) {
      return value = +value, offset = offset | 0, noAssert || checkInt(this, value, offset, 2, 65535, 0), Buffer2.TYPED_ARRAY_SUPPORT ? (this[offset] = value & 255, this[offset + 1] = value >>> 8) : objectWriteUInt16(this, value, offset, !0), offset + 2;
    };
    Buffer2.prototype.writeUInt16BE = function(value, offset, noAssert) {
      return value = +value, offset = offset | 0, noAssert || checkInt(this, value, offset, 2, 65535, 0), Buffer2.TYPED_ARRAY_SUPPORT ? (this[offset] = value >>> 8, this[offset + 1] = value & 255) : objectWriteUInt16(this, value, offset, !1), offset + 2;
    };
    Buffer2.prototype.writeUInt32LE = function(value, offset, noAssert) {
      return value = +value, offset = offset | 0, noAssert || checkInt(this, value, offset, 4, 4294967295, 0), Buffer2.TYPED_ARRAY_SUPPORT ? (this[offset + 3] = value >>> 24, this[offset + 2] = value >>> 16, this[offset + 1] = value >>> 8, this[offset] = value & 255) : objectWriteUInt32(this, value, offset, !0), offset + 4;
    };
    Buffer2.prototype.writeUInt32BE = function(value, offset, noAssert) {
      return value = +value, offset = offset | 0, noAssert || checkInt(this, value, offset, 4, 4294967295, 0), Buffer2.TYPED_ARRAY_SUPPORT ? (this[offset] = value >>> 24, this[offset + 1] = value >>> 16, this[offset + 2] = value >>> 8, this[offset + 3] = value & 255) : objectWriteUInt32(this, value, offset, !1), offset + 4;
    };
    Buffer2.prototype.writeIntLE = function(value, offset, byteLength2, noAssert) {
      if (value = +value, offset = offset | 0, !noAssert) {
        var limit = Math.pow(2, 8 * byteLength2 - 1);
        checkInt(this, value, offset, byteLength2, limit - 1, -limit);
      }
      var i = 0, mul = 1, sub = 0;
      for (this[offset] = value & 255; ++i < byteLength2 && (mul *= 256); )
        value < 0 && sub === 0 && this[offset + i - 1] !== 0 && (sub = 1), this[offset + i] = (value / mul >> 0) - sub & 255;
      return offset + byteLength2;
    };
    Buffer2.prototype.writeIntBE = function(value, offset, byteLength2, noAssert) {
      if (value = +value, offset = offset | 0, !noAssert) {
        var limit = Math.pow(2, 8 * byteLength2 - 1);
        checkInt(this, value, offset, byteLength2, limit - 1, -limit);
      }
      var i = byteLength2 - 1, mul = 1, sub = 0;
      for (this[offset + i] = value & 255; --i >= 0 && (mul *= 256); )
        value < 0 && sub === 0 && this[offset + i + 1] !== 0 && (sub = 1), this[offset + i] = (value / mul >> 0) - sub & 255;
      return offset + byteLength2;
    };
    Buffer2.prototype.writeInt8 = function(value, offset, noAssert) {
      return value = +value, offset = offset | 0, noAssert || checkInt(this, value, offset, 1, 127, -128), Buffer2.TYPED_ARRAY_SUPPORT || (value = Math.floor(value)), value < 0 && (value = 255 + value + 1), this[offset] = value & 255, offset + 1;
    };
    Buffer2.prototype.writeInt16LE = function(value, offset, noAssert) {
      return value = +value, offset = offset | 0, noAssert || checkInt(this, value, offset, 2, 32767, -32768), Buffer2.TYPED_ARRAY_SUPPORT ? (this[offset] = value & 255, this[offset + 1] = value >>> 8) : objectWriteUInt16(this, value, offset, !0), offset + 2;
    };
    Buffer2.prototype.writeInt16BE = function(value, offset, noAssert) {
      return value = +value, offset = offset | 0, noAssert || checkInt(this, value, offset, 2, 32767, -32768), Buffer2.TYPED_ARRAY_SUPPORT ? (this[offset] = value >>> 8, this[offset + 1] = value & 255) : objectWriteUInt16(this, value, offset, !1), offset + 2;
    };
    Buffer2.prototype.writeInt32LE = function(value, offset, noAssert) {
      return value = +value, offset = offset | 0, noAssert || checkInt(this, value, offset, 4, 2147483647, -2147483648), Buffer2.TYPED_ARRAY_SUPPORT ? (this[offset] = value & 255, this[offset + 1] = value >>> 8, this[offset + 2] = value >>> 16, this[offset + 3] = value >>> 24) : objectWriteUInt32(this, value, offset, !0), offset + 4;
    };
    Buffer2.prototype.writeInt32BE = function(value, offset, noAssert) {
      return value = +value, offset = offset | 0, noAssert || checkInt(this, value, offset, 4, 2147483647, -2147483648), value < 0 && (value = 4294967295 + value + 1), Buffer2.TYPED_ARRAY_SUPPORT ? (this[offset] = value >>> 24, this[offset + 1] = value >>> 16, this[offset + 2] = value >>> 8, this[offset + 3] = value & 255) : objectWriteUInt32(this, value, offset, !1), offset + 4;
    };
    Buffer2.prototype.writeFloatLE = function(value, offset, noAssert) {
      return writeFloat(this, value, offset, !0, noAssert);
    };
    Buffer2.prototype.writeFloatBE = function(value, offset, noAssert) {
      return writeFloat(this, value, offset, !1, noAssert);
    };
    Buffer2.prototype.writeDoubleLE = function(value, offset, noAssert) {
      return writeDouble(this, value, offset, !0, noAssert);
    };
    Buffer2.prototype.writeDoubleBE = function(value, offset, noAssert) {
      return writeDouble(this, value, offset, !1, noAssert);
    };
    Buffer2.prototype.copy = function(target, targetStart, start, end) {
      if (start || (start = 0), !end && end !== 0 && (end = this.length), targetStart >= target.length && (targetStart = target.length), targetStart || (targetStart = 0), end > 0 && end < start && (end = start), end === start || target.length === 0 || this.length === 0)
        return 0;
      if (targetStart < 0)
        throw new RangeError("targetStart out of bounds");
      if (start < 0 || start >= this.length)
        throw new RangeError("sourceStart out of bounds");
      if (end < 0)
        throw new RangeError("sourceEnd out of bounds");
      end > this.length && (end = this.length), target.length - targetStart < end - start && (end = target.length - targetStart + start);
      var len = end - start, i;
      if (this === target && start < targetStart && targetStart < end)
        for (i = len - 1; i >= 0; --i)
          target[i + targetStart] = this[i + start];
      else if (len < 1e3 || !Buffer2.TYPED_ARRAY_SUPPORT)
        for (i = 0; i < len; ++i)
          target[i + targetStart] = this[i + start];
      else
        Uint8Array.prototype.set.call(
          target,
          this.subarray(start, start + len),
          targetStart
        );
      return len;
    };
    Buffer2.prototype.fill = function(val, start, end, encoding) {
      if (typeof val == "string") {
        if (typeof start == "string" ? (encoding = start, start = 0, end = this.length) : typeof end == "string" && (encoding = end, end = this.length), val.length === 1) {
          var code = val.charCodeAt(0);
          code < 256 && (val = code);
        }
        if (encoding !== void 0 && typeof encoding != "string")
          throw new TypeError("encoding must be a string");
        if (typeof encoding == "string" && !Buffer2.isEncoding(encoding))
          throw new TypeError("Unknown encoding: " + encoding);
      } else
        typeof val == "number" && (val = val & 255);
      if (start < 0 || this.length < start || this.length < end)
        throw new RangeError("Out of range index");
      if (end <= start)
        return this;
      start = start >>> 0, end = end === void 0 ? this.length : end >>> 0, val || (val = 0);
      var i;
      if (typeof val == "number")
        for (i = start; i < end; ++i)
          this[i] = val;
      else {
        var bytes = internalIsBuffer(val) ? val : utf8ToBytes(new Buffer2(val, encoding).toString()), len = bytes.length;
        for (i = 0; i < end - start; ++i)
          this[i + start] = bytes[i % len];
      }
      return this;
    };
    INVALID_BASE64_RE = /[^+\/0-9A-Za-z-_]/g;
  }
});

// node_modules/rollup-plugin-node-polyfills/polyfills/readable-stream/buffer-list.js
function BufferList() {
  this.head = null, this.tail = null, this.length = 0;
}
var buffer_list_default, init_buffer_list = __esm({
  "node_modules/rollup-plugin-node-polyfills/polyfills/readable-stream/buffer-list.js"() {
    init_buffer();
    buffer_list_default = BufferList;
    BufferList.prototype.push = function(v) {
      var entry2 = { data: v, next: null };
      this.length > 0 ? this.tail.next = entry2 : this.head = entry2, this.tail = entry2, ++this.length;
    };
    BufferList.prototype.unshift = function(v) {
      var entry2 = { data: v, next: this.head };
      this.length === 0 && (this.tail = entry2), this.head = entry2, ++this.length;
    };
    BufferList.prototype.shift = function() {
      if (this.length !== 0) {
        var ret = this.head.data;
        return this.length === 1 ? this.head = this.tail = null : this.head = this.head.next, --this.length, ret;
      }
    };
    BufferList.prototype.clear = function() {
      this.head = this.tail = null, this.length = 0;
    };
    BufferList.prototype.join = function(s) {
      if (this.length === 0)
        return "";
      for (var p = this.head, ret = "" + p.data; p = p.next; )
        ret += s + p.data;
      return ret;
    };
    BufferList.prototype.concat = function(n) {
      if (this.length === 0)
        return Buffer2.alloc(0);
      if (this.length === 1)
        return this.head.data;
      for (var ret = Buffer2.allocUnsafe(n >>> 0), p = this.head, i = 0; p; )
        p.data.copy(ret, i), i += p.data.length, p = p.next;
      return ret;
    };
  }
});

// node-modules-polyfills:string_decoder
function assertEncoding(encoding) {
  if (encoding && !isBufferEncoding(encoding))
    throw new Error("Unknown encoding: " + encoding);
}
function StringDecoder(encoding) {
  switch (this.encoding = (encoding || "utf8").toLowerCase().replace(/[-_]/, ""), assertEncoding(encoding), this.encoding) {
    case "utf8":
      this.surrogateSize = 3;
      break;
    case "ucs2":
    case "utf16le":
      this.surrogateSize = 2, this.detectIncompleteChar = utf16DetectIncompleteChar;
      break;
    case "base64":
      this.surrogateSize = 3, this.detectIncompleteChar = base64DetectIncompleteChar;
      break;
    default:
      this.write = passThroughWrite;
      return;
  }
  this.charBuffer = new Buffer2(6), this.charReceived = 0, this.charLength = 0;
}
function passThroughWrite(buffer) {
  return buffer.toString(this.encoding);
}
function utf16DetectIncompleteChar(buffer) {
  this.charReceived = buffer.length % 2, this.charLength = this.charReceived ? 2 : 0;
}
function base64DetectIncompleteChar(buffer) {
  this.charReceived = buffer.length % 3, this.charLength = this.charReceived ? 3 : 0;
}
var isBufferEncoding, init_string_decoder = __esm({
  "node-modules-polyfills:string_decoder"() {
    init_buffer();
    isBufferEncoding = Buffer2.isEncoding || function(encoding) {
      switch (encoding && encoding.toLowerCase()) {
        case "hex":
        case "utf8":
        case "utf-8":
        case "ascii":
        case "binary":
        case "base64":
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
        case "raw":
          return !0;
        default:
          return !1;
      }
    };
    StringDecoder.prototype.write = function(buffer) {
      for (var charStr = ""; this.charLength; ) {
        var available = buffer.length >= this.charLength - this.charReceived ? this.charLength - this.charReceived : buffer.length;
        if (buffer.copy(this.charBuffer, this.charReceived, 0, available), this.charReceived += available, this.charReceived < this.charLength)
          return "";
        buffer = buffer.slice(available, buffer.length), charStr = this.charBuffer.slice(0, this.charLength).toString(this.encoding);
        var charCode = charStr.charCodeAt(charStr.length - 1);
        if (charCode >= 55296 && charCode <= 56319) {
          this.charLength += this.surrogateSize, charStr = "";
          continue;
        }
        if (this.charReceived = this.charLength = 0, buffer.length === 0)
          return charStr;
        break;
      }
      this.detectIncompleteChar(buffer);
      var end = buffer.length;
      this.charLength && (buffer.copy(this.charBuffer, 0, buffer.length - this.charReceived, end), end -= this.charReceived), charStr += buffer.toString(this.encoding, 0, end);
      var end = charStr.length - 1, charCode = charStr.charCodeAt(end);
      if (charCode >= 55296 && charCode <= 56319) {
        var size = this.surrogateSize;
        return this.charLength += size, this.charReceived += size, this.charBuffer.copy(this.charBuffer, size, 0, size), buffer.copy(this.charBuffer, 0, 0, size), charStr.substring(0, end);
      }
      return charStr;
    };
    StringDecoder.prototype.detectIncompleteChar = function(buffer) {
      for (var i = buffer.length >= 3 ? 3 : buffer.length; i > 0; i--) {
        var c = buffer[buffer.length - i];
        if (i == 1 && c >> 5 == 6) {
          this.charLength = 2;
          break;
        }
        if (i <= 2 && c >> 4 == 14) {
          this.charLength = 3;
          break;
        }
        if (i <= 3 && c >> 3 == 30) {
          this.charLength = 4;
          break;
        }
      }
      this.charReceived = i;
    };
    StringDecoder.prototype.end = function(buffer) {
      var res = "";
      if (buffer && buffer.length && (res = this.write(buffer)), this.charReceived) {
        var cr = this.charReceived, buf = this.charBuffer, enc = this.encoding;
        res += buf.slice(0, cr).toString(enc);
      }
      return res;
    };
  }
});

// node_modules/rollup-plugin-node-polyfills/polyfills/readable-stream/readable.js
function prependListener2(emitter, event, fn) {
  if (typeof emitter.prependListener == "function")
    return emitter.prependListener(event, fn);
  !emitter._events || !emitter._events[event] ? emitter.on(event, fn) : Array.isArray(emitter._events[event]) ? emitter._events[event].unshift(fn) : emitter._events[event] = [fn, emitter._events[event]];
}
function listenerCount2(emitter, type) {
  return emitter.listeners(type).length;
}
function ReadableState(options, stream) {
  options = options || {}, this.objectMode = !!options.objectMode, stream instanceof Duplex && (this.objectMode = this.objectMode || !!options.readableObjectMode);
  var hwm = options.highWaterMark, defaultHwm = this.objectMode ? 16 : 16 * 1024;
  this.highWaterMark = hwm || hwm === 0 ? hwm : defaultHwm, this.highWaterMark = ~~this.highWaterMark, this.buffer = new buffer_list_default(), this.length = 0, this.pipes = null, this.pipesCount = 0, this.flowing = null, this.ended = !1, this.endEmitted = !1, this.reading = !1, this.sync = !0, this.needReadable = !1, this.emittedReadable = !1, this.readableListening = !1, this.resumeScheduled = !1, this.defaultEncoding = options.defaultEncoding || "utf8", this.ranOut = !1, this.awaitDrain = 0, this.readingMore = !1, this.decoder = null, this.encoding = null, options.encoding && (this.decoder = new StringDecoder(options.encoding), this.encoding = options.encoding);
}
function Readable(options) {
  if (!(this instanceof Readable))
    return new Readable(options);
  this._readableState = new ReadableState(options, this), this.readable = !0, options && typeof options.read == "function" && (this._read = options.read), events_default.call(this);
}
function readableAddChunk(stream, state, chunk, encoding, addToFront) {
  var er = chunkInvalid(state, chunk);
  if (er)
    stream.emit("error", er);
  else if (chunk === null)
    state.reading = !1, onEofChunk(stream, state);
  else if (state.objectMode || chunk && chunk.length > 0)
    if (state.ended && !addToFront) {
      var e = new Error("stream.push() after EOF");
      stream.emit("error", e);
    } else if (state.endEmitted && addToFront) {
      var _e = new Error("stream.unshift() after end event");
      stream.emit("error", _e);
    } else {
      var skipAdd;
      state.decoder && !addToFront && !encoding && (chunk = state.decoder.write(chunk), skipAdd = !state.objectMode && chunk.length === 0), addToFront || (state.reading = !1), skipAdd || (state.flowing && state.length === 0 && !state.sync ? (stream.emit("data", chunk), stream.read(0)) : (state.length += state.objectMode ? 1 : chunk.length, addToFront ? state.buffer.unshift(chunk) : state.buffer.push(chunk), state.needReadable && emitReadable(stream))), maybeReadMore(stream, state);
    }
  else
    addToFront || (state.reading = !1);
  return needMoreData(state);
}
function needMoreData(state) {
  return !state.ended && (state.needReadable || state.length < state.highWaterMark || state.length === 0);
}
function computeNewHighWaterMark(n) {
  return n >= MAX_HWM ? n = MAX_HWM : (n--, n |= n >>> 1, n |= n >>> 2, n |= n >>> 4, n |= n >>> 8, n |= n >>> 16, n++), n;
}
function howMuchToRead(n, state) {
  return n <= 0 || state.length === 0 && state.ended ? 0 : state.objectMode ? 1 : n !== n ? state.flowing && state.length ? state.buffer.head.data.length : state.length : (n > state.highWaterMark && (state.highWaterMark = computeNewHighWaterMark(n)), n <= state.length ? n : state.ended ? state.length : (state.needReadable = !0, 0));
}
function chunkInvalid(state, chunk) {
  var er = null;
  return !Buffer.isBuffer(chunk) && typeof chunk != "string" && chunk !== null && chunk !== void 0 && !state.objectMode && (er = new TypeError("Invalid non-string/buffer chunk")), er;
}
function onEofChunk(stream, state) {
  if (!state.ended) {
    if (state.decoder) {
      var chunk = state.decoder.end();
      chunk && chunk.length && (state.buffer.push(chunk), state.length += state.objectMode ? 1 : chunk.length);
    }
    state.ended = !0, emitReadable(stream);
  }
}
function emitReadable(stream) {
  var state = stream._readableState;
  state.needReadable = !1, state.emittedReadable || (debug("emitReadable", state.flowing), state.emittedReadable = !0, state.sync ? nextTick(emitReadable_, stream) : emitReadable_(stream));
}
function emitReadable_(stream) {
  debug("emit readable"), stream.emit("readable"), flow(stream);
}
function maybeReadMore(stream, state) {
  state.readingMore || (state.readingMore = !0, nextTick(maybeReadMore_, stream, state));
}
function maybeReadMore_(stream, state) {
  for (var len = state.length; !state.reading && !state.flowing && !state.ended && state.length < state.highWaterMark && (debug("maybeReadMore read 0"), stream.read(0), len !== state.length); )
    len = state.length;
  state.readingMore = !1;
}
function pipeOnDrain(src) {
  return function() {
    var state = src._readableState;
    debug("pipeOnDrain", state.awaitDrain), state.awaitDrain && state.awaitDrain--, state.awaitDrain === 0 && src.listeners("data").length && (state.flowing = !0, flow(src));
  };
}
function nReadingNextTick(self2) {
  debug("readable nexttick read 0"), self2.read(0);
}
function resume(stream, state) {
  state.resumeScheduled || (state.resumeScheduled = !0, nextTick(resume_, stream, state));
}
function resume_(stream, state) {
  state.reading || (debug("resume read 0"), stream.read(0)), state.resumeScheduled = !1, state.awaitDrain = 0, stream.emit("resume"), flow(stream), state.flowing && !state.reading && stream.read(0);
}
function flow(stream) {
  var state = stream._readableState;
  for (debug("flow", state.flowing); state.flowing && stream.read() !== null; )
    ;
}
function fromList(n, state) {
  if (state.length === 0)
    return null;
  var ret;
  return state.objectMode ? ret = state.buffer.shift() : !n || n >= state.length ? (state.decoder ? ret = state.buffer.join("") : state.buffer.length === 1 ? ret = state.buffer.head.data : ret = state.buffer.concat(state.length), state.buffer.clear()) : ret = fromListPartial(n, state.buffer, state.decoder), ret;
}
function fromListPartial(n, list, hasStrings) {
  var ret;
  return n < list.head.data.length ? (ret = list.head.data.slice(0, n), list.head.data = list.head.data.slice(n)) : n === list.head.data.length ? ret = list.shift() : ret = hasStrings ? copyFromBufferString(n, list) : copyFromBuffer(n, list), ret;
}
function copyFromBufferString(n, list) {
  var p = list.head, c = 1, ret = p.data;
  for (n -= ret.length; p = p.next; ) {
    var str = p.data, nb = n > str.length ? str.length : n;
    if (nb === str.length ? ret += str : ret += str.slice(0, n), n -= nb, n === 0) {
      nb === str.length ? (++c, p.next ? list.head = p.next : list.head = list.tail = null) : (list.head = p, p.data = str.slice(nb));
      break;
    }
    ++c;
  }
  return list.length -= c, ret;
}
function copyFromBuffer(n, list) {
  var ret = Buffer.allocUnsafe(n), p = list.head, c = 1;
  for (p.data.copy(ret), n -= p.data.length; p = p.next; ) {
    var buf = p.data, nb = n > buf.length ? buf.length : n;
    if (buf.copy(ret, ret.length - n, 0, nb), n -= nb, n === 0) {
      nb === buf.length ? (++c, p.next ? list.head = p.next : list.head = list.tail = null) : (list.head = p, p.data = buf.slice(nb));
      break;
    }
    ++c;
  }
  return list.length -= c, ret;
}
function endReadable(stream) {
  var state = stream._readableState;
  if (state.length > 0)
    throw new Error('"endReadable()" called on non-empty stream');
  state.endEmitted || (state.ended = !0, nextTick(endReadableNT, state, stream));
}
function endReadableNT(state, stream) {
  !state.endEmitted && state.length === 0 && (state.endEmitted = !0, stream.readable = !1, stream.emit("end"));
}
function forEach(xs, f) {
  for (var i = 0, l = xs.length; i < l; i++)
    f(xs[i], i);
}
function indexOf2(xs, x) {
  for (var i = 0, l = xs.length; i < l; i++)
    if (xs[i] === x)
      return i;
  return -1;
}
var debug, MAX_HWM, init_readable = __esm({
  "node_modules/rollup-plugin-node-polyfills/polyfills/readable-stream/readable.js"() {
    "use strict";
    init_events();
    init_util();
    init_buffer_list();
    init_string_decoder();
    init_duplex();
    init_process();
    Readable.ReadableState = ReadableState;
    debug = debuglog("stream");
    inherits_default(Readable, events_default);
    Readable.prototype.push = function(chunk, encoding) {
      var state = this._readableState;
      return !state.objectMode && typeof chunk == "string" && (encoding = encoding || state.defaultEncoding, encoding !== state.encoding && (chunk = Buffer.from(chunk, encoding), encoding = "")), readableAddChunk(this, state, chunk, encoding, !1);
    };
    Readable.prototype.unshift = function(chunk) {
      var state = this._readableState;
      return readableAddChunk(this, state, chunk, "", !0);
    };
    Readable.prototype.isPaused = function() {
      return this._readableState.flowing === !1;
    };
    Readable.prototype.setEncoding = function(enc) {
      return this._readableState.decoder = new StringDecoder(enc), this._readableState.encoding = enc, this;
    };
    MAX_HWM = 8388608;
    Readable.prototype.read = function(n) {
      debug("read", n), n = parseInt(n, 10);
      var state = this._readableState, nOrig = n;
      if (n !== 0 && (state.emittedReadable = !1), n === 0 && state.needReadable && (state.length >= state.highWaterMark || state.ended))
        return debug("read: emitReadable", state.length, state.ended), state.length === 0 && state.ended ? endReadable(this) : emitReadable(this), null;
      if (n = howMuchToRead(n, state), n === 0 && state.ended)
        return state.length === 0 && endReadable(this), null;
      var doRead = state.needReadable;
      debug("need readable", doRead), (state.length === 0 || state.length - n < state.highWaterMark) && (doRead = !0, debug("length less than watermark", doRead)), state.ended || state.reading ? (doRead = !1, debug("reading or ended", doRead)) : doRead && (debug("do read"), state.reading = !0, state.sync = !0, state.length === 0 && (state.needReadable = !0), this._read(state.highWaterMark), state.sync = !1, state.reading || (n = howMuchToRead(nOrig, state)));
      var ret;
      return n > 0 ? ret = fromList(n, state) : ret = null, ret === null ? (state.needReadable = !0, n = 0) : state.length -= n, state.length === 0 && (state.ended || (state.needReadable = !0), nOrig !== n && state.ended && endReadable(this)), ret !== null && this.emit("data", ret), ret;
    };
    Readable.prototype._read = function(n) {
      this.emit("error", new Error("not implemented"));
    };
    Readable.prototype.pipe = function(dest, pipeOpts) {
      var src = this, state = this._readableState;
      switch (state.pipesCount) {
        case 0:
          state.pipes = dest;
          break;
        case 1:
          state.pipes = [state.pipes, dest];
          break;
        default:
          state.pipes.push(dest);
          break;
      }
      state.pipesCount += 1, debug("pipe count=%d opts=%j", state.pipesCount, pipeOpts);
      var doEnd = !pipeOpts || pipeOpts.end !== !1, endFn = doEnd ? onend2 : cleanup;
      state.endEmitted ? nextTick(endFn) : src.once("end", endFn), dest.on("unpipe", onunpipe);
      function onunpipe(readable) {
        debug("onunpipe"), readable === src && cleanup();
      }
      function onend2() {
        debug("onend"), dest.end();
      }
      var ondrain = pipeOnDrain(src);
      dest.on("drain", ondrain);
      var cleanedUp = !1;
      function cleanup() {
        debug("cleanup"), dest.removeListener("close", onclose), dest.removeListener("finish", onfinish), dest.removeListener("drain", ondrain), dest.removeListener("error", onerror), dest.removeListener("unpipe", onunpipe), src.removeListener("end", onend2), src.removeListener("end", cleanup), src.removeListener("data", ondata), cleanedUp = !0, state.awaitDrain && (!dest._writableState || dest._writableState.needDrain) && ondrain();
      }
      var increasedAwaitDrain = !1;
      src.on("data", ondata);
      function ondata(chunk) {
        debug("ondata"), increasedAwaitDrain = !1;
        var ret = dest.write(chunk);
        ret === !1 && !increasedAwaitDrain && ((state.pipesCount === 1 && state.pipes === dest || state.pipesCount > 1 && indexOf2(state.pipes, dest) !== -1) && !cleanedUp && (debug("false write response, pause", src._readableState.awaitDrain), src._readableState.awaitDrain++, increasedAwaitDrain = !0), src.pause());
      }
      function onerror(er) {
        debug("onerror", er), unpipe(), dest.removeListener("error", onerror), listenerCount2(dest, "error") === 0 && dest.emit("error", er);
      }
      prependListener2(dest, "error", onerror);
      function onclose() {
        dest.removeListener("finish", onfinish), unpipe();
      }
      dest.once("close", onclose);
      function onfinish() {
        debug("onfinish"), dest.removeListener("close", onclose), unpipe();
      }
      dest.once("finish", onfinish);
      function unpipe() {
        debug("unpipe"), src.unpipe(dest);
      }
      return dest.emit("pipe", src), state.flowing || (debug("pipe resume"), src.resume()), dest;
    };
    Readable.prototype.unpipe = function(dest) {
      var state = this._readableState;
      if (state.pipesCount === 0)
        return this;
      if (state.pipesCount === 1)
        return dest && dest !== state.pipes ? this : (dest || (dest = state.pipes), state.pipes = null, state.pipesCount = 0, state.flowing = !1, dest && dest.emit("unpipe", this), this);
      if (!dest) {
        var dests = state.pipes, len = state.pipesCount;
        state.pipes = null, state.pipesCount = 0, state.flowing = !1;
        for (var _i = 0; _i < len; _i++)
          dests[_i].emit("unpipe", this);
        return this;
      }
      var i = indexOf2(state.pipes, dest);
      return i === -1 ? this : (state.pipes.splice(i, 1), state.pipesCount -= 1, state.pipesCount === 1 && (state.pipes = state.pipes[0]), dest.emit("unpipe", this), this);
    };
    Readable.prototype.on = function(ev, fn) {
      var res = events_default.prototype.on.call(this, ev, fn);
      if (ev === "data")
        this._readableState.flowing !== !1 && this.resume();
      else if (ev === "readable") {
        var state = this._readableState;
        !state.endEmitted && !state.readableListening && (state.readableListening = state.needReadable = !0, state.emittedReadable = !1, state.reading ? state.length && emitReadable(this, state) : nextTick(nReadingNextTick, this));
      }
      return res;
    };
    Readable.prototype.addListener = Readable.prototype.on;
    Readable.prototype.resume = function() {
      var state = this._readableState;
      return state.flowing || (debug("resume"), state.flowing = !0, resume(this, state)), this;
    };
    Readable.prototype.pause = function() {
      return debug("call pause flowing=%j", this._readableState.flowing), this._readableState.flowing !== !1 && (debug("pause"), this._readableState.flowing = !1, this.emit("pause")), this;
    };
    Readable.prototype.wrap = function(stream) {
      var state = this._readableState, paused = !1, self2 = this;
      stream.on("end", function() {
        if (debug("wrapped end"), state.decoder && !state.ended) {
          var chunk = state.decoder.end();
          chunk && chunk.length && self2.push(chunk);
        }
        self2.push(null);
      }), stream.on("data", function(chunk) {
        if (debug("wrapped data"), state.decoder && (chunk = state.decoder.write(chunk)), !(state.objectMode && chunk == null) && !(!state.objectMode && (!chunk || !chunk.length))) {
          var ret = self2.push(chunk);
          ret || (paused = !0, stream.pause());
        }
      });
      for (var i in stream)
        this[i] === void 0 && typeof stream[i] == "function" && (this[i] = function(method) {
          return function() {
            return stream[method].apply(stream, arguments);
          };
        }(i));
      var events = ["error", "close", "destroy", "pause", "resume"];
      return forEach(events, function(ev) {
        stream.on(ev, self2.emit.bind(self2, ev));
      }), self2._read = function(n) {
        debug("wrapped _read", n), paused && (paused = !1, stream.resume());
      }, self2;
    };
    Readable._fromList = fromList;
  }
});

// node_modules/rollup-plugin-node-polyfills/polyfills/readable-stream/writable.js
function nop() {
}
function WriteReq(chunk, encoding, cb) {
  this.chunk = chunk, this.encoding = encoding, this.callback = cb, this.next = null;
}
function WritableState(options, stream) {
  Object.defineProperty(this, "buffer", {
    get: deprecate(function() {
      return this.getBuffer();
    }, "_writableState.buffer is deprecated. Use _writableState.getBuffer instead.")
  }), options = options || {}, this.objectMode = !!options.objectMode, stream instanceof Duplex && (this.objectMode = this.objectMode || !!options.writableObjectMode);
  var hwm = options.highWaterMark, defaultHwm = this.objectMode ? 16 : 16 * 1024;
  this.highWaterMark = hwm || hwm === 0 ? hwm : defaultHwm, this.highWaterMark = ~~this.highWaterMark, this.needDrain = !1, this.ending = !1, this.ended = !1, this.finished = !1;
  var noDecode = options.decodeStrings === !1;
  this.decodeStrings = !noDecode, this.defaultEncoding = options.defaultEncoding || "utf8", this.length = 0, this.writing = !1, this.corked = 0, this.sync = !0, this.bufferProcessing = !1, this.onwrite = function(er) {
    onwrite(stream, er);
  }, this.writecb = null, this.writelen = 0, this.bufferedRequest = null, this.lastBufferedRequest = null, this.pendingcb = 0, this.prefinished = !1, this.errorEmitted = !1, this.bufferedRequestCount = 0, this.corkedRequestsFree = new CorkedRequest(this);
}
function Writable(options) {
  if (!(this instanceof Writable) && !(this instanceof Duplex))
    return new Writable(options);
  this._writableState = new WritableState(options, this), this.writable = !0, options && (typeof options.write == "function" && (this._write = options.write), typeof options.writev == "function" && (this._writev = options.writev)), EventEmitter.call(this);
}
function writeAfterEnd(stream, cb) {
  var er = new Error("write after end");
  stream.emit("error", er), nextTick(cb, er);
}
function validChunk(stream, state, chunk, cb) {
  var valid = !0, er = !1;
  return chunk === null ? er = new TypeError("May not write null values to stream") : !Buffer2.isBuffer(chunk) && typeof chunk != "string" && chunk !== void 0 && !state.objectMode && (er = new TypeError("Invalid non-string/buffer chunk")), er && (stream.emit("error", er), nextTick(cb, er), valid = !1), valid;
}
function decodeChunk(state, chunk, encoding) {
  return !state.objectMode && state.decodeStrings !== !1 && typeof chunk == "string" && (chunk = Buffer2.from(chunk, encoding)), chunk;
}
function writeOrBuffer(stream, state, chunk, encoding, cb) {
  chunk = decodeChunk(state, chunk, encoding), Buffer2.isBuffer(chunk) && (encoding = "buffer");
  var len = state.objectMode ? 1 : chunk.length;
  state.length += len;
  var ret = state.length < state.highWaterMark;
  if (ret || (state.needDrain = !0), state.writing || state.corked) {
    var last = state.lastBufferedRequest;
    state.lastBufferedRequest = new WriteReq(chunk, encoding, cb), last ? last.next = state.lastBufferedRequest : state.bufferedRequest = state.lastBufferedRequest, state.bufferedRequestCount += 1;
  } else
    doWrite(stream, state, !1, len, chunk, encoding, cb);
  return ret;
}
function doWrite(stream, state, writev, len, chunk, encoding, cb) {
  state.writelen = len, state.writecb = cb, state.writing = !0, state.sync = !0, writev ? stream._writev(chunk, state.onwrite) : stream._write(chunk, encoding, state.onwrite), state.sync = !1;
}
function onwriteError(stream, state, sync, er, cb) {
  --state.pendingcb, sync ? nextTick(cb, er) : cb(er), stream._writableState.errorEmitted = !0, stream.emit("error", er);
}
function onwriteStateUpdate(state) {
  state.writing = !1, state.writecb = null, state.length -= state.writelen, state.writelen = 0;
}
function onwrite(stream, er) {
  var state = stream._writableState, sync = state.sync, cb = state.writecb;
  if (onwriteStateUpdate(state), er)
    onwriteError(stream, state, sync, er, cb);
  else {
    var finished = needFinish(state);
    !finished && !state.corked && !state.bufferProcessing && state.bufferedRequest && clearBuffer(stream, state), sync ? nextTick(afterWrite, stream, state, finished, cb) : afterWrite(stream, state, finished, cb);
  }
}
function afterWrite(stream, state, finished, cb) {
  finished || onwriteDrain(stream, state), state.pendingcb--, cb(), finishMaybe(stream, state);
}
function onwriteDrain(stream, state) {
  state.length === 0 && state.needDrain && (state.needDrain = !1, stream.emit("drain"));
}
function clearBuffer(stream, state) {
  state.bufferProcessing = !0;
  var entry2 = state.bufferedRequest;
  if (stream._writev && entry2 && entry2.next) {
    var l = state.bufferedRequestCount, buffer = new Array(l), holder = state.corkedRequestsFree;
    holder.entry = entry2;
    for (var count = 0; entry2; )
      buffer[count] = entry2, entry2 = entry2.next, count += 1;
    doWrite(stream, state, !0, state.length, buffer, "", holder.finish), state.pendingcb++, state.lastBufferedRequest = null, holder.next ? (state.corkedRequestsFree = holder.next, holder.next = null) : state.corkedRequestsFree = new CorkedRequest(state);
  } else {
    for (; entry2; ) {
      var chunk = entry2.chunk, encoding = entry2.encoding, cb = entry2.callback, len = state.objectMode ? 1 : chunk.length;
      if (doWrite(stream, state, !1, len, chunk, encoding, cb), entry2 = entry2.next, state.writing)
        break;
    }
    entry2 === null && (state.lastBufferedRequest = null);
  }
  state.bufferedRequestCount = 0, state.bufferedRequest = entry2, state.bufferProcessing = !1;
}
function needFinish(state) {
  return state.ending && state.length === 0 && state.bufferedRequest === null && !state.finished && !state.writing;
}
function prefinish(stream, state) {
  state.prefinished || (state.prefinished = !0, stream.emit("prefinish"));
}
function finishMaybe(stream, state) {
  var need = needFinish(state);
  return need && (state.pendingcb === 0 ? (prefinish(stream, state), state.finished = !0, stream.emit("finish")) : prefinish(stream, state)), need;
}
function endWritable(stream, state, cb) {
  state.ending = !0, finishMaybe(stream, state), cb && (state.finished ? nextTick(cb) : stream.once("finish", cb)), state.ended = !0, stream.writable = !1;
}
function CorkedRequest(state) {
  var _this = this;
  this.next = null, this.entry = null, this.finish = function(err) {
    var entry2 = _this.entry;
    for (_this.entry = null; entry2; ) {
      var cb = entry2.callback;
      state.pendingcb--, cb(err), entry2 = entry2.next;
    }
    state.corkedRequestsFree ? state.corkedRequestsFree.next = _this : state.corkedRequestsFree = _this;
  };
}
var init_writable = __esm({
  "node_modules/rollup-plugin-node-polyfills/polyfills/readable-stream/writable.js"() {
    init_util();
    init_buffer();
    init_events();
    init_duplex();
    init_process();
    Writable.WritableState = WritableState;
    inherits_default(Writable, EventEmitter);
    WritableState.prototype.getBuffer = function() {
      for (var current = this.bufferedRequest, out = []; current; )
        out.push(current), current = current.next;
      return out;
    };
    Writable.prototype.pipe = function() {
      this.emit("error", new Error("Cannot pipe, not readable"));
    };
    Writable.prototype.write = function(chunk, encoding, cb) {
      var state = this._writableState, ret = !1;
      return typeof encoding == "function" && (cb = encoding, encoding = null), Buffer2.isBuffer(chunk) ? encoding = "buffer" : encoding || (encoding = state.defaultEncoding), typeof cb != "function" && (cb = nop), state.ended ? writeAfterEnd(this, cb) : validChunk(this, state, chunk, cb) && (state.pendingcb++, ret = writeOrBuffer(this, state, chunk, encoding, cb)), ret;
    };
    Writable.prototype.cork = function() {
      var state = this._writableState;
      state.corked++;
    };
    Writable.prototype.uncork = function() {
      var state = this._writableState;
      state.corked && (state.corked--, !state.writing && !state.corked && !state.finished && !state.bufferProcessing && state.bufferedRequest && clearBuffer(this, state));
    };
    Writable.prototype.setDefaultEncoding = function(encoding) {
      if (typeof encoding == "string" && (encoding = encoding.toLowerCase()), !(["hex", "utf8", "utf-8", "ascii", "binary", "base64", "ucs2", "ucs-2", "utf16le", "utf-16le", "raw"].indexOf((encoding + "").toLowerCase()) > -1))
        throw new TypeError("Unknown encoding: " + encoding);
      return this._writableState.defaultEncoding = encoding, this;
    };
    Writable.prototype._write = function(chunk, encoding, cb) {
      cb(new Error("not implemented"));
    };
    Writable.prototype._writev = null;
    Writable.prototype.end = function(chunk, encoding, cb) {
      var state = this._writableState;
      typeof chunk == "function" ? (cb = chunk, chunk = null, encoding = null) : typeof encoding == "function" && (cb = encoding, encoding = null), chunk != null && this.write(chunk, encoding), state.corked && (state.corked = 1, this.uncork()), !state.ending && !state.finished && endWritable(this, state, cb);
    };
  }
});

// node_modules/rollup-plugin-node-polyfills/polyfills/readable-stream/duplex.js
function Duplex(options) {
  if (!(this instanceof Duplex))
    return new Duplex(options);
  Readable.call(this, options), Writable.call(this, options), options && options.readable === !1 && (this.readable = !1), options && options.writable === !1 && (this.writable = !1), this.allowHalfOpen = !0, options && options.allowHalfOpen === !1 && (this.allowHalfOpen = !1), this.once("end", onend);
}
function onend() {
  this.allowHalfOpen || this._writableState.ended || nextTick(onEndNT, this);
}
function onEndNT(self2) {
  self2.end();
}
var keys, method, v, init_duplex = __esm({
  "node_modules/rollup-plugin-node-polyfills/polyfills/readable-stream/duplex.js"() {
    init_util();
    init_process();
    init_readable();
    init_writable();
    inherits_default(Duplex, Readable);
    keys = Object.keys(Writable.prototype);
    for (v = 0; v < keys.length; v++)
      method = keys[v], Duplex.prototype[method] || (Duplex.prototype[method] = Writable.prototype[method]);
  }
});

// node_modules/rollup-plugin-node-polyfills/polyfills/readable-stream/transform.js
function TransformState(stream) {
  this.afterTransform = function(er, data) {
    return afterTransform(stream, er, data);
  }, this.needTransform = !1, this.transforming = !1, this.writecb = null, this.writechunk = null, this.writeencoding = null;
}
function afterTransform(stream, er, data) {
  var ts = stream._transformState;
  ts.transforming = !1;
  var cb = ts.writecb;
  if (!cb)
    return stream.emit("error", new Error("no writecb in Transform class"));
  ts.writechunk = null, ts.writecb = null, data != null && stream.push(data), cb(er);
  var rs = stream._readableState;
  rs.reading = !1, (rs.needReadable || rs.length < rs.highWaterMark) && stream._read(rs.highWaterMark);
}
function Transform(options) {
  if (!(this instanceof Transform))
    return new Transform(options);
  Duplex.call(this, options), this._transformState = new TransformState(this);
  var stream = this;
  this._readableState.needReadable = !0, this._readableState.sync = !1, options && (typeof options.transform == "function" && (this._transform = options.transform), typeof options.flush == "function" && (this._flush = options.flush)), this.once("prefinish", function() {
    typeof this._flush == "function" ? this._flush(function(er) {
      done(stream, er);
    }) : done(stream);
  });
}
function done(stream, er) {
  if (er)
    return stream.emit("error", er);
  var ws = stream._writableState, ts = stream._transformState;
  if (ws.length)
    throw new Error("Calling transform done when ws.length != 0");
  if (ts.transforming)
    throw new Error("Calling transform done when still transforming");
  return stream.push(null);
}
var init_transform = __esm({
  "node_modules/rollup-plugin-node-polyfills/polyfills/readable-stream/transform.js"() {
    init_duplex();
    init_util();
    inherits_default(Transform, Duplex);
    Transform.prototype.push = function(chunk, encoding) {
      return this._transformState.needTransform = !1, Duplex.prototype.push.call(this, chunk, encoding);
    };
    Transform.prototype._transform = function(chunk, encoding, cb) {
      throw new Error("Not implemented");
    };
    Transform.prototype._write = function(chunk, encoding, cb) {
      var ts = this._transformState;
      if (ts.writecb = cb, ts.writechunk = chunk, ts.writeencoding = encoding, !ts.transforming) {
        var rs = this._readableState;
        (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark) && this._read(rs.highWaterMark);
      }
    };
    Transform.prototype._read = function(n) {
      var ts = this._transformState;
      ts.writechunk !== null && ts.writecb && !ts.transforming ? (ts.transforming = !0, this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform)) : ts.needTransform = !0;
    };
  }
});

// node_modules/rollup-plugin-node-polyfills/polyfills/readable-stream/passthrough.js
function PassThrough(options) {
  if (!(this instanceof PassThrough))
    return new PassThrough(options);
  Transform.call(this, options);
}
var init_passthrough = __esm({
  "node_modules/rollup-plugin-node-polyfills/polyfills/readable-stream/passthrough.js"() {
    init_transform();
    init_util();
    inherits_default(PassThrough, Transform);
    PassThrough.prototype._transform = function(chunk, encoding, cb) {
      cb(null, chunk);
    };
  }
});

// node-modules-polyfills:stream
var stream_exports = {};
__export(stream_exports, {
  Duplex: () => Duplex,
  PassThrough: () => PassThrough,
  Readable: () => Readable,
  Stream: () => Stream,
  Transform: () => Transform,
  Writable: () => Writable,
  default: () => stream_default
});
function Stream() {
  events_default.call(this);
}
var stream_default, init_stream = __esm({
  "node-modules-polyfills:stream"() {
    init_events();
    init_util();
    init_duplex();
    init_readable();
    init_writable();
    init_transform();
    init_passthrough();
    inherits_default(Stream, events_default);
    Stream.Readable = Readable;
    Stream.Writable = Writable;
    Stream.Duplex = Duplex;
    Stream.Transform = Transform;
    Stream.PassThrough = PassThrough;
    Stream.Stream = Stream;
    stream_default = Stream;
    Stream.prototype.pipe = function(dest, options) {
      var source = this;
      function ondata(chunk) {
        dest.writable && dest.write(chunk) === !1 && source.pause && source.pause();
      }
      source.on("data", ondata);
      function ondrain() {
        source.readable && source.resume && source.resume();
      }
      dest.on("drain", ondrain), !dest._isStdio && (!options || options.end !== !1) && (source.on("end", onend2), source.on("close", onclose));
      var didOnEnd = !1;
      function onend2() {
        didOnEnd || (didOnEnd = !0, dest.end());
      }
      function onclose() {
        didOnEnd || (didOnEnd = !0, typeof dest.destroy == "function" && dest.destroy());
      }
      function onerror(er) {
        if (cleanup(), events_default.listenerCount(this, "error") === 0)
          throw er;
      }
      source.on("error", onerror), dest.on("error", onerror);
      function cleanup() {
        source.removeListener("data", ondata), dest.removeListener("drain", ondrain), source.removeListener("end", onend2), source.removeListener("close", onclose), source.removeListener("error", onerror), dest.removeListener("error", onerror), source.removeListener("end", cleanup), source.removeListener("close", cleanup), dest.removeListener("close", cleanup);
      }
      return source.on("end", cleanup), source.on("close", cleanup), dest.on("close", cleanup), dest.emit("pipe", source), dest;
    };
  }
});

// node-modules-polyfills-commonjs:stream
var require_stream = __commonJS({
  "node-modules-polyfills-commonjs:stream"(exports, module) {
    var polyfill = (init_stream(), __toCommonJS(stream_exports));
    if (polyfill && polyfill.default) {
      module.exports = polyfill.default;
      for (let k in polyfill)
        module.exports[k] = polyfill[k];
    } else
      polyfill && (module.exports = polyfill);
  }
});

// node_modules/react-dom/cjs/react-dom-server.node.development.js
var require_react_dom_server_node_development = __commonJS({
  "node_modules/react-dom/cjs/react-dom-server.node.development.js"(exports) {
    "use strict";
    (function() {
      "use strict";
      var React90 = require_react(), _assign = require_object_assign(), stream = require_stream(), ReactVersion = "17.0.2";
      function formatProdErrorMessage(code) {
        for (var url = "https://reactjs.org/docs/error-decoder.html?invariant=" + code, i2 = 1; i2 < arguments.length; i2++)
          url += "&args[]=" + encodeURIComponent(arguments[i2]);
        return "Minified React error #" + code + "; visit " + url + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings.";
      }
      var ReactSharedInternals = React90.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
      function warn(format2) {
        {
          for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++)
            args[_key - 1] = arguments[_key];
          printWarning("warn", format2, args);
        }
      }
      function error(format2) {
        {
          for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++)
            args[_key2 - 1] = arguments[_key2];
          printWarning("error", format2, args);
        }
      }
      function printWarning(level, format2, args) {
        {
          var ReactDebugCurrentFrame2 = ReactSharedInternals.ReactDebugCurrentFrame, stack = ReactDebugCurrentFrame2.getStackAddendum();
          stack !== "" && (format2 += "%s", args = args.concat([stack]));
          var argsWithFormat = args.map(function(item) {
            return "" + item;
          });
          argsWithFormat.unshift("Warning: " + format2), Function.prototype.apply.call(console[level], console, argsWithFormat);
        }
      }
      var REACT_ELEMENT_TYPE = 60103, REACT_PORTAL_TYPE = 60106, REACT_FRAGMENT_TYPE = 60107, REACT_STRICT_MODE_TYPE = 60108, REACT_PROFILER_TYPE = 60114, REACT_PROVIDER_TYPE = 60109, REACT_CONTEXT_TYPE = 60110, REACT_FORWARD_REF_TYPE = 60112, REACT_SUSPENSE_TYPE = 60113, REACT_SUSPENSE_LIST_TYPE = 60120, REACT_MEMO_TYPE = 60115, REACT_LAZY_TYPE = 60116, REACT_BLOCK_TYPE = 60121, REACT_SERVER_BLOCK_TYPE = 60122, REACT_FUNDAMENTAL_TYPE = 60117, REACT_SCOPE_TYPE = 60119, REACT_OPAQUE_ID_TYPE = 60128, REACT_DEBUG_TRACING_MODE_TYPE = 60129, REACT_OFFSCREEN_TYPE = 60130, REACT_LEGACY_HIDDEN_TYPE = 60131;
      if (typeof Symbol == "function" && Symbol.for) {
        var symbolFor = Symbol.for;
        REACT_ELEMENT_TYPE = symbolFor("react.element"), REACT_PORTAL_TYPE = symbolFor("react.portal"), REACT_FRAGMENT_TYPE = symbolFor("react.fragment"), REACT_STRICT_MODE_TYPE = symbolFor("react.strict_mode"), REACT_PROFILER_TYPE = symbolFor("react.profiler"), REACT_PROVIDER_TYPE = symbolFor("react.provider"), REACT_CONTEXT_TYPE = symbolFor("react.context"), REACT_FORWARD_REF_TYPE = symbolFor("react.forward_ref"), REACT_SUSPENSE_TYPE = symbolFor("react.suspense"), REACT_SUSPENSE_LIST_TYPE = symbolFor("react.suspense_list"), REACT_MEMO_TYPE = symbolFor("react.memo"), REACT_LAZY_TYPE = symbolFor("react.lazy"), REACT_BLOCK_TYPE = symbolFor("react.block"), REACT_SERVER_BLOCK_TYPE = symbolFor("react.server.block"), REACT_FUNDAMENTAL_TYPE = symbolFor("react.fundamental"), REACT_SCOPE_TYPE = symbolFor("react.scope"), REACT_OPAQUE_ID_TYPE = symbolFor("react.opaque.id"), REACT_DEBUG_TRACING_MODE_TYPE = symbolFor("react.debug_trace_mode"), REACT_OFFSCREEN_TYPE = symbolFor("react.offscreen"), REACT_LEGACY_HIDDEN_TYPE = symbolFor("react.legacy_hidden");
      }
      function getWrappedName2(outerType, innerType, wrapperName) {
        var functionName = innerType.displayName || innerType.name || "";
        return outerType.displayName || (functionName !== "" ? wrapperName + "(" + functionName + ")" : wrapperName);
      }
      function getContextName(type) {
        return type.displayName || "Context";
      }
      function getComponentName(type) {
        if (type == null)
          return null;
        if (typeof type.tag == "number" && error("Received an unexpected object in getComponentName(). This is likely a bug in React. Please file an issue."), typeof type == "function")
          return type.displayName || type.name || null;
        if (typeof type == "string")
          return type;
        switch (type) {
          case REACT_FRAGMENT_TYPE:
            return "Fragment";
          case REACT_PORTAL_TYPE:
            return "Portal";
          case REACT_PROFILER_TYPE:
            return "Profiler";
          case REACT_STRICT_MODE_TYPE:
            return "StrictMode";
          case REACT_SUSPENSE_TYPE:
            return "Suspense";
          case REACT_SUSPENSE_LIST_TYPE:
            return "SuspenseList";
        }
        if (typeof type == "object")
          switch (type.$$typeof) {
            case REACT_CONTEXT_TYPE:
              var context = type;
              return getContextName(context) + ".Consumer";
            case REACT_PROVIDER_TYPE:
              var provider = type;
              return getContextName(provider._context) + ".Provider";
            case REACT_FORWARD_REF_TYPE:
              return getWrappedName2(type, type.render, "ForwardRef");
            case REACT_MEMO_TYPE:
              return getComponentName(type.type);
            case REACT_BLOCK_TYPE:
              return getComponentName(type._render);
            case REACT_LAZY_TYPE: {
              var lazyComponent = type, payload = lazyComponent._payload, init2 = lazyComponent._init;
              try {
                return getComponentName(init2(payload));
              } catch {
                return null;
              }
            }
          }
        return null;
      }
      var enableSuspenseServerRenderer = !1, disabledDepth = 0, prevLog, prevInfo, prevWarn, prevError, prevGroup, prevGroupCollapsed, prevGroupEnd;
      function disabledLog() {
      }
      disabledLog.__reactDisabledLog = !0;
      function disableLogs() {
        {
          if (disabledDepth === 0) {
            prevLog = console.log, prevInfo = console.info, prevWarn = console.warn, prevError = console.error, prevGroup = console.group, prevGroupCollapsed = console.groupCollapsed, prevGroupEnd = console.groupEnd;
            var props = {
              configurable: !0,
              enumerable: !0,
              value: disabledLog,
              writable: !0
            };
            Object.defineProperties(console, {
              info: props,
              log: props,
              warn: props,
              error: props,
              group: props,
              groupCollapsed: props,
              groupEnd: props
            });
          }
          disabledDepth++;
        }
      }
      function reenableLogs() {
        {
          if (disabledDepth--, disabledDepth === 0) {
            var props = {
              configurable: !0,
              enumerable: !0,
              writable: !0
            };
            Object.defineProperties(console, {
              log: _assign({}, props, {
                value: prevLog
              }),
              info: _assign({}, props, {
                value: prevInfo
              }),
              warn: _assign({}, props, {
                value: prevWarn
              }),
              error: _assign({}, props, {
                value: prevError
              }),
              group: _assign({}, props, {
                value: prevGroup
              }),
              groupCollapsed: _assign({}, props, {
                value: prevGroupCollapsed
              }),
              groupEnd: _assign({}, props, {
                value: prevGroupEnd
              })
            });
          }
          disabledDepth < 0 && error("disabledDepth fell below zero. This is a bug in React. Please file an issue.");
        }
      }
      var ReactCurrentDispatcher = ReactSharedInternals.ReactCurrentDispatcher, prefix;
      function describeBuiltInComponentFrame(name, source, ownerFn) {
        {
          if (prefix === void 0)
            try {
              throw Error();
            } catch (x) {
              var match = x.stack.trim().match(/\n( *(at )?)/);
              prefix = match && match[1] || "";
            }
          return `
` + prefix + name;
        }
      }
      var reentry = !1, componentFrameCache;
      {
        var PossiblyWeakMap = typeof WeakMap == "function" ? WeakMap : Map;
        componentFrameCache = new PossiblyWeakMap();
      }
      function describeNativeComponentFrame(fn, construct) {
        if (!fn || reentry)
          return "";
        {
          var frame = componentFrameCache.get(fn);
          if (frame !== void 0)
            return frame;
        }
        var control;
        reentry = !0;
        var previousPrepareStackTrace = Error.prepareStackTrace;
        Error.prepareStackTrace = void 0;
        var previousDispatcher;
        previousDispatcher = ReactCurrentDispatcher.current, ReactCurrentDispatcher.current = null, disableLogs();
        try {
          if (construct) {
            var Fake = function() {
              throw Error();
            };
            if (Object.defineProperty(Fake.prototype, "props", {
              set: function() {
                throw Error();
              }
            }), typeof Reflect == "object" && Reflect.construct) {
              try {
                Reflect.construct(Fake, []);
              } catch (x) {
                control = x;
              }
              Reflect.construct(fn, [], Fake);
            } else {
              try {
                Fake.call();
              } catch (x) {
                control = x;
              }
              fn.call(Fake.prototype);
            }
          } else {
            try {
              throw Error();
            } catch (x) {
              control = x;
            }
            fn();
          }
        } catch (sample) {
          if (sample && control && typeof sample.stack == "string") {
            for (var sampleLines = sample.stack.split(`
`), controlLines = control.stack.split(`
`), s = sampleLines.length - 1, c = controlLines.length - 1; s >= 1 && c >= 0 && sampleLines[s] !== controlLines[c]; )
              c--;
            for (; s >= 1 && c >= 0; s--, c--)
              if (sampleLines[s] !== controlLines[c]) {
                if (s !== 1 || c !== 1)
                  do
                    if (s--, c--, c < 0 || sampleLines[s] !== controlLines[c]) {
                      var _frame = `
` + sampleLines[s].replace(" at new ", " at ");
                      return typeof fn == "function" && componentFrameCache.set(fn, _frame), _frame;
                    }
                  while (s >= 1 && c >= 0);
                break;
              }
          }
        } finally {
          reentry = !1, ReactCurrentDispatcher.current = previousDispatcher, reenableLogs(), Error.prepareStackTrace = previousPrepareStackTrace;
        }
        var name = fn ? fn.displayName || fn.name : "", syntheticFrame = name ? describeBuiltInComponentFrame(name) : "";
        return typeof fn == "function" && componentFrameCache.set(fn, syntheticFrame), syntheticFrame;
      }
      function describeFunctionComponentFrame(fn, source, ownerFn) {
        return describeNativeComponentFrame(fn, !1);
      }
      function shouldConstruct(Component) {
        var prototype = Component.prototype;
        return !!(prototype && prototype.isReactComponent);
      }
      function describeUnknownElementTypeFrameInDEV(type, source, ownerFn) {
        if (type == null)
          return "";
        if (typeof type == "function")
          return describeNativeComponentFrame(type, shouldConstruct(type));
        if (typeof type == "string")
          return describeBuiltInComponentFrame(type);
        switch (type) {
          case REACT_SUSPENSE_TYPE:
            return describeBuiltInComponentFrame("Suspense");
          case REACT_SUSPENSE_LIST_TYPE:
            return describeBuiltInComponentFrame("SuspenseList");
        }
        if (typeof type == "object")
          switch (type.$$typeof) {
            case REACT_FORWARD_REF_TYPE:
              return describeFunctionComponentFrame(type.render);
            case REACT_MEMO_TYPE:
              return describeUnknownElementTypeFrameInDEV(type.type, source, ownerFn);
            case REACT_BLOCK_TYPE:
              return describeFunctionComponentFrame(type._render);
            case REACT_LAZY_TYPE: {
              var lazyComponent = type, payload = lazyComponent._payload, init2 = lazyComponent._init;
              try {
                return describeUnknownElementTypeFrameInDEV(init2(payload), source, ownerFn);
              } catch {
              }
            }
          }
        return "";
      }
      var loggedTypeFailures = {}, ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;
      function setCurrentlyValidatingElement(element) {
        if (element) {
          var owner = element._owner, stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);
          ReactDebugCurrentFrame.setExtraStackFrame(stack);
        } else
          ReactDebugCurrentFrame.setExtraStackFrame(null);
      }
      function checkPropTypes(typeSpecs, values3, location, componentName, element) {
        {
          var has = Function.call.bind(Object.prototype.hasOwnProperty);
          for (var typeSpecName in typeSpecs)
            if (has(typeSpecs, typeSpecName)) {
              var error$1 = void 0;
              try {
                if (typeof typeSpecs[typeSpecName] != "function") {
                  var err = Error((componentName || "React class") + ": " + location + " type `" + typeSpecName + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof typeSpecs[typeSpecName] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.");
                  throw err.name = "Invariant Violation", err;
                }
                error$1 = typeSpecs[typeSpecName](values3, typeSpecName, componentName, location, null, "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED");
              } catch (ex) {
                error$1 = ex;
              }
              error$1 && !(error$1 instanceof Error) && (setCurrentlyValidatingElement(element), error("%s: type specification of %s `%s` is invalid; the type checker function must return `null` or an `Error` but returned a %s. You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).", componentName || "React class", location, typeSpecName, typeof error$1), setCurrentlyValidatingElement(null)), error$1 instanceof Error && !(error$1.message in loggedTypeFailures) && (loggedTypeFailures[error$1.message] = !0, setCurrentlyValidatingElement(element), error("Failed %s type: %s", location, error$1.message), setCurrentlyValidatingElement(null));
            }
        }
      }
      var didWarnAboutInvalidateContextType;
      didWarnAboutInvalidateContextType = /* @__PURE__ */ new Set();
      var emptyObject = {};
      Object.freeze(emptyObject);
      function maskContext(type, context) {
        var contextTypes = type.contextTypes;
        if (!contextTypes)
          return emptyObject;
        var maskedContext = {};
        for (var contextName in contextTypes)
          maskedContext[contextName] = context[contextName];
        return maskedContext;
      }
      function checkContextTypes(typeSpecs, values3, location) {
        checkPropTypes(typeSpecs, values3, location, "Component");
      }
      function validateContextBounds(context, threadID) {
        for (var i2 = context._threadCount | 0; i2 <= threadID; i2++)
          context[i2] = context._currentValue2, context._threadCount = i2 + 1;
      }
      function processContext(type, context, threadID, isClass) {
        if (isClass) {
          var contextType = type.contextType;
          if ("contextType" in type) {
            var isValid = contextType === null || contextType !== void 0 && contextType.$$typeof === REACT_CONTEXT_TYPE && contextType._context === void 0;
            if (!isValid && !didWarnAboutInvalidateContextType.has(type)) {
              didWarnAboutInvalidateContextType.add(type);
              var addendum = "";
              contextType === void 0 ? addendum = " However, it is set to undefined. This can be caused by a typo or by mixing up named and default imports. This can also happen due to a circular dependency, so try moving the createContext() call to a separate file." : typeof contextType != "object" ? addendum = " However, it is set to a " + typeof contextType + "." : contextType.$$typeof === REACT_PROVIDER_TYPE ? addendum = " Did you accidentally pass the Context.Provider instead?" : contextType._context !== void 0 ? addendum = " Did you accidentally pass the Context.Consumer instead?" : addendum = " However, it is set to an object with keys {" + Object.keys(contextType).join(", ") + "}.", error("%s defines an invalid contextType. contextType should point to the Context object returned by React.createContext().%s", getComponentName(type) || "Component", addendum);
            }
          }
          if (typeof contextType == "object" && contextType !== null)
            return validateContextBounds(contextType, threadID), contextType[threadID];
          {
            var maskedContext = maskContext(type, context);
            return type.contextTypes && checkContextTypes(type.contextTypes, maskedContext, "context"), maskedContext;
          }
        } else {
          var _maskedContext = maskContext(type, context);
          return type.contextTypes && checkContextTypes(type.contextTypes, _maskedContext, "context"), _maskedContext;
        }
      }
      for (var nextAvailableThreadIDs = new Uint16Array(16), i = 0; i < 15; i++)
        nextAvailableThreadIDs[i] = i + 1;
      nextAvailableThreadIDs[15] = 0;
      function growThreadCountAndReturnNextAvailable() {
        var oldArray = nextAvailableThreadIDs, oldSize = oldArray.length, newSize = oldSize * 2;
        if (!(newSize <= 65536))
          throw Error("Maximum number of concurrent React renderers exceeded. This can happen if you are not properly destroying the Readable provided by React. Ensure that you call .destroy() on it if you no longer want to read from it, and did not read to the end. If you use .pipe() this should be automatic.");
        var newArray = new Uint16Array(newSize);
        newArray.set(oldArray), nextAvailableThreadIDs = newArray, nextAvailableThreadIDs[0] = oldSize + 1;
        for (var _i = oldSize; _i < newSize - 1; _i++)
          nextAvailableThreadIDs[_i] = _i + 1;
        return nextAvailableThreadIDs[newSize - 1] = 0, oldSize;
      }
      function allocThreadID() {
        var nextID = nextAvailableThreadIDs[0];
        return nextID === 0 ? growThreadCountAndReturnNextAvailable() : (nextAvailableThreadIDs[0] = nextAvailableThreadIDs[nextID], nextID);
      }
      function freeThreadID(id) {
        nextAvailableThreadIDs[id] = nextAvailableThreadIDs[0], nextAvailableThreadIDs[0] = id;
      }
      var RESERVED = 0, STRING = 1, BOOLEANISH_STRING = 2, BOOLEAN = 3, OVERLOADED_BOOLEAN = 4, NUMERIC = 5, POSITIVE_NUMERIC = 6, ATTRIBUTE_NAME_START_CHAR = ":A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD", ATTRIBUTE_NAME_CHAR = ATTRIBUTE_NAME_START_CHAR + "\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040", ROOT_ATTRIBUTE_NAME = "data-reactroot", VALID_ATTRIBUTE_NAME_REGEX = new RegExp("^[" + ATTRIBUTE_NAME_START_CHAR + "][" + ATTRIBUTE_NAME_CHAR + "]*$"), hasOwnProperty2 = Object.prototype.hasOwnProperty, illegalAttributeNameCache = {}, validatedAttributeNameCache = {};
      function isAttributeNameSafe(attributeName) {
        return hasOwnProperty2.call(validatedAttributeNameCache, attributeName) ? !0 : hasOwnProperty2.call(illegalAttributeNameCache, attributeName) ? !1 : VALID_ATTRIBUTE_NAME_REGEX.test(attributeName) ? (validatedAttributeNameCache[attributeName] = !0, !0) : (illegalAttributeNameCache[attributeName] = !0, error("Invalid attribute name: `%s`", attributeName), !1);
      }
      function shouldIgnoreAttribute(name, propertyInfo, isCustomComponentTag) {
        return propertyInfo !== null ? propertyInfo.type === RESERVED : isCustomComponentTag ? !1 : name.length > 2 && (name[0] === "o" || name[0] === "O") && (name[1] === "n" || name[1] === "N");
      }
      function shouldRemoveAttributeWithWarning(name, value, propertyInfo, isCustomComponentTag) {
        if (propertyInfo !== null && propertyInfo.type === RESERVED)
          return !1;
        switch (typeof value) {
          case "function":
          case "symbol":
            return !0;
          case "boolean": {
            if (isCustomComponentTag)
              return !1;
            if (propertyInfo !== null)
              return !propertyInfo.acceptsBooleans;
            var prefix2 = name.toLowerCase().slice(0, 5);
            return prefix2 !== "data-" && prefix2 !== "aria-";
          }
          default:
            return !1;
        }
      }
      function shouldRemoveAttribute(name, value, propertyInfo, isCustomComponentTag) {
        if (value === null || typeof value > "u" || shouldRemoveAttributeWithWarning(name, value, propertyInfo, isCustomComponentTag))
          return !0;
        if (isCustomComponentTag)
          return !1;
        if (propertyInfo !== null)
          switch (propertyInfo.type) {
            case BOOLEAN:
              return !value;
            case OVERLOADED_BOOLEAN:
              return value === !1;
            case NUMERIC:
              return isNaN(value);
            case POSITIVE_NUMERIC:
              return isNaN(value) || value < 1;
          }
        return !1;
      }
      function getPropertyInfo(name) {
        return properties2.hasOwnProperty(name) ? properties2[name] : null;
      }
      function PropertyInfoRecord(name, type, mustUseProperty, attributeName, attributeNamespace, sanitizeURL2, removeEmptyString) {
        this.acceptsBooleans = type === BOOLEANISH_STRING || type === BOOLEAN || type === OVERLOADED_BOOLEAN, this.attributeName = attributeName, this.attributeNamespace = attributeNamespace, this.mustUseProperty = mustUseProperty, this.propertyName = name, this.type = type, this.sanitizeURL = sanitizeURL2, this.removeEmptyString = removeEmptyString;
      }
      var properties2 = {}, reservedProps = [
        "children",
        "dangerouslySetInnerHTML",
        "defaultValue",
        "defaultChecked",
        "innerHTML",
        "suppressContentEditableWarning",
        "suppressHydrationWarning",
        "style"
      ];
      reservedProps.forEach(function(name) {
        properties2[name] = new PropertyInfoRecord(
          name,
          RESERVED,
          !1,
          name,
          null,
          !1,
          !1
        );
      }), [["acceptCharset", "accept-charset"], ["className", "class"], ["htmlFor", "for"], ["httpEquiv", "http-equiv"]].forEach(function(_ref) {
        var name = _ref[0], attributeName = _ref[1];
        properties2[name] = new PropertyInfoRecord(
          name,
          STRING,
          !1,
          attributeName,
          null,
          !1,
          !1
        );
      }), ["contentEditable", "draggable", "spellCheck", "value"].forEach(function(name) {
        properties2[name] = new PropertyInfoRecord(
          name,
          BOOLEANISH_STRING,
          !1,
          name.toLowerCase(),
          null,
          !1,
          !1
        );
      }), ["autoReverse", "externalResourcesRequired", "focusable", "preserveAlpha"].forEach(function(name) {
        properties2[name] = new PropertyInfoRecord(
          name,
          BOOLEANISH_STRING,
          !1,
          name,
          null,
          !1,
          !1
        );
      }), [
        "allowFullScreen",
        "async",
        "autoFocus",
        "autoPlay",
        "controls",
        "default",
        "defer",
        "disabled",
        "disablePictureInPicture",
        "disableRemotePlayback",
        "formNoValidate",
        "hidden",
        "loop",
        "noModule",
        "noValidate",
        "open",
        "playsInline",
        "readOnly",
        "required",
        "reversed",
        "scoped",
        "seamless",
        "itemScope"
      ].forEach(function(name) {
        properties2[name] = new PropertyInfoRecord(
          name,
          BOOLEAN,
          !1,
          name.toLowerCase(),
          null,
          !1,
          !1
        );
      }), [
        "checked",
        "multiple",
        "muted",
        "selected"
      ].forEach(function(name) {
        properties2[name] = new PropertyInfoRecord(
          name,
          BOOLEAN,
          !0,
          name,
          null,
          !1,
          !1
        );
      }), [
        "capture",
        "download"
      ].forEach(function(name) {
        properties2[name] = new PropertyInfoRecord(
          name,
          OVERLOADED_BOOLEAN,
          !1,
          name,
          null,
          !1,
          !1
        );
      }), [
        "cols",
        "rows",
        "size",
        "span"
      ].forEach(function(name) {
        properties2[name] = new PropertyInfoRecord(
          name,
          POSITIVE_NUMERIC,
          !1,
          name,
          null,
          !1,
          !1
        );
      }), ["rowSpan", "start"].forEach(function(name) {
        properties2[name] = new PropertyInfoRecord(
          name,
          NUMERIC,
          !1,
          name.toLowerCase(),
          null,
          !1,
          !1
        );
      });
      var CAMELIZE = /[\-\:]([a-z])/g, capitalize2 = function(token) {
        return token[1].toUpperCase();
      };
      [
        "accent-height",
        "alignment-baseline",
        "arabic-form",
        "baseline-shift",
        "cap-height",
        "clip-path",
        "clip-rule",
        "color-interpolation",
        "color-interpolation-filters",
        "color-profile",
        "color-rendering",
        "dominant-baseline",
        "enable-background",
        "fill-opacity",
        "fill-rule",
        "flood-color",
        "flood-opacity",
        "font-family",
        "font-size",
        "font-size-adjust",
        "font-stretch",
        "font-style",
        "font-variant",
        "font-weight",
        "glyph-name",
        "glyph-orientation-horizontal",
        "glyph-orientation-vertical",
        "horiz-adv-x",
        "horiz-origin-x",
        "image-rendering",
        "letter-spacing",
        "lighting-color",
        "marker-end",
        "marker-mid",
        "marker-start",
        "overline-position",
        "overline-thickness",
        "paint-order",
        "panose-1",
        "pointer-events",
        "rendering-intent",
        "shape-rendering",
        "stop-color",
        "stop-opacity",
        "strikethrough-position",
        "strikethrough-thickness",
        "stroke-dasharray",
        "stroke-dashoffset",
        "stroke-linecap",
        "stroke-linejoin",
        "stroke-miterlimit",
        "stroke-opacity",
        "stroke-width",
        "text-anchor",
        "text-decoration",
        "text-rendering",
        "underline-position",
        "underline-thickness",
        "unicode-bidi",
        "unicode-range",
        "units-per-em",
        "v-alphabetic",
        "v-hanging",
        "v-ideographic",
        "v-mathematical",
        "vector-effect",
        "vert-adv-y",
        "vert-origin-x",
        "vert-origin-y",
        "word-spacing",
        "writing-mode",
        "xmlns:xlink",
        "x-height"
      ].forEach(function(attributeName) {
        var name = attributeName.replace(CAMELIZE, capitalize2);
        properties2[name] = new PropertyInfoRecord(
          name,
          STRING,
          !1,
          attributeName,
          null,
          !1,
          !1
        );
      }), [
        "xlink:actuate",
        "xlink:arcrole",
        "xlink:role",
        "xlink:show",
        "xlink:title",
        "xlink:type"
      ].forEach(function(attributeName) {
        var name = attributeName.replace(CAMELIZE, capitalize2);
        properties2[name] = new PropertyInfoRecord(
          name,
          STRING,
          !1,
          attributeName,
          "http://www.w3.org/1999/xlink",
          !1,
          !1
        );
      }), [
        "xml:base",
        "xml:lang",
        "xml:space"
      ].forEach(function(attributeName) {
        var name = attributeName.replace(CAMELIZE, capitalize2);
        properties2[name] = new PropertyInfoRecord(
          name,
          STRING,
          !1,
          attributeName,
          "http://www.w3.org/XML/1998/namespace",
          !1,
          !1
        );
      }), ["tabIndex", "crossOrigin"].forEach(function(attributeName) {
        properties2[attributeName] = new PropertyInfoRecord(
          attributeName,
          STRING,
          !1,
          attributeName.toLowerCase(),
          null,
          !1,
          !1
        );
      });
      var xlinkHref = "xlinkHref";
      properties2[xlinkHref] = new PropertyInfoRecord(
        "xlinkHref",
        STRING,
        !1,
        "xlink:href",
        "http://www.w3.org/1999/xlink",
        !0,
        !1
      ), ["src", "href", "action", "formAction"].forEach(function(attributeName) {
        properties2[attributeName] = new PropertyInfoRecord(
          attributeName,
          STRING,
          !1,
          attributeName.toLowerCase(),
          null,
          !0,
          !0
        );
      });
      var isJavaScriptProtocol = /^[\u0000-\u001F ]*j[\r\n\t]*a[\r\n\t]*v[\r\n\t]*a[\r\n\t]*s[\r\n\t]*c[\r\n\t]*r[\r\n\t]*i[\r\n\t]*p[\r\n\t]*t[\r\n\t]*\:/i, didWarn = !1;
      function sanitizeURL(url) {
        !didWarn && isJavaScriptProtocol.test(url) && (didWarn = !0, error("A future version of React will block javascript: URLs as a security precaution. Use event handlers instead if you can. If you need to generate unsafe HTML try using dangerouslySetInnerHTML instead. React was passed %s.", JSON.stringify(url)));
      }
      var matchHtmlRegExp = /["'&<>]/;
      function escapeHtml2(string) {
        var str = "" + string, match = matchHtmlRegExp.exec(str);
        if (!match)
          return str;
        var escape2, html = "", index, lastIndex = 0;
        for (index = match.index; index < str.length; index++) {
          switch (str.charCodeAt(index)) {
            case 34:
              escape2 = "&quot;";
              break;
            case 38:
              escape2 = "&amp;";
              break;
            case 39:
              escape2 = "&#x27;";
              break;
            case 60:
              escape2 = "&lt;";
              break;
            case 62:
              escape2 = "&gt;";
              break;
            default:
              continue;
          }
          lastIndex !== index && (html += str.substring(lastIndex, index)), lastIndex = index + 1, html += escape2;
        }
        return lastIndex !== index ? html + str.substring(lastIndex, index) : html;
      }
      function escapeTextForBrowser(text) {
        return typeof text == "boolean" || typeof text == "number" ? "" + text : escapeHtml2(text);
      }
      function quoteAttributeValueForBrowser(value) {
        return '"' + escapeTextForBrowser(value) + '"';
      }
      function createMarkupForRoot() {
        return ROOT_ATTRIBUTE_NAME + '=""';
      }
      function createMarkupForProperty(name, value) {
        var propertyInfo = getPropertyInfo(name);
        if (name !== "style" && shouldIgnoreAttribute(name, propertyInfo, !1) || shouldRemoveAttribute(name, value, propertyInfo, !1))
          return "";
        if (propertyInfo !== null) {
          var attributeName = propertyInfo.attributeName, type = propertyInfo.type;
          return type === BOOLEAN || type === OVERLOADED_BOOLEAN && value === !0 ? attributeName + '=""' : (propertyInfo.sanitizeURL && (value = "" + value, sanitizeURL(value)), attributeName + "=" + quoteAttributeValueForBrowser(value));
        } else if (isAttributeNameSafe(name))
          return name + "=" + quoteAttributeValueForBrowser(value);
        return "";
      }
      function createMarkupForCustomAttribute(name, value) {
        return !isAttributeNameSafe(name) || value == null ? "" : name + "=" + quoteAttributeValueForBrowser(value);
      }
      function is(x, y) {
        return x === y && (x !== 0 || 1 / x === 1 / y) || x !== x && y !== y;
      }
      var objectIs = typeof Object.is == "function" ? Object.is : is, currentlyRenderingComponent = null, firstWorkInProgressHook = null, workInProgressHook = null, isReRender = !1, didScheduleRenderPhaseUpdate = !1, renderPhaseUpdates = null, numberOfReRenders = 0, RE_RENDER_LIMIT = 25, isInHookUserCodeInDev = !1, currentHookNameInDev;
      function resolveCurrentlyRenderingComponent() {
        if (currentlyRenderingComponent === null)
          throw Error(`Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for one of the following reasons:
1. You might have mismatching versions of React and the renderer (such as React DOM)
2. You might be breaking the Rules of Hooks
3. You might have more than one copy of React in the same app
See https://reactjs.org/link/invalid-hook-call for tips about how to debug and fix this problem.`);
        return isInHookUserCodeInDev && error("Do not call Hooks inside useEffect(...), useMemo(...), or other built-in Hooks. You can only call Hooks at the top level of your React function. For more information, see https://reactjs.org/link/rules-of-hooks"), currentlyRenderingComponent;
      }
      function areHookInputsEqual(nextDeps, prevDeps) {
        if (prevDeps === null)
          return error("%s received a final argument during this render, but not during the previous render. Even though the final argument is optional, its type cannot change between renders.", currentHookNameInDev), !1;
        nextDeps.length !== prevDeps.length && error(`The final argument passed to %s changed size between renders. The order and size of this array must remain constant.

Previous: %s
Incoming: %s`, currentHookNameInDev, "[" + nextDeps.join(", ") + "]", "[" + prevDeps.join(", ") + "]");
        for (var i2 = 0; i2 < prevDeps.length && i2 < nextDeps.length; i2++)
          if (!objectIs(nextDeps[i2], prevDeps[i2]))
            return !1;
        return !0;
      }
      function createHook() {
        if (numberOfReRenders > 0)
          throw Error("Rendered more hooks than during the previous render");
        return {
          memoizedState: null,
          queue: null,
          next: null
        };
      }
      function createWorkInProgressHook() {
        return workInProgressHook === null ? firstWorkInProgressHook === null ? (isReRender = !1, firstWorkInProgressHook = workInProgressHook = createHook()) : (isReRender = !0, workInProgressHook = firstWorkInProgressHook) : workInProgressHook.next === null ? (isReRender = !1, workInProgressHook = workInProgressHook.next = createHook()) : (isReRender = !0, workInProgressHook = workInProgressHook.next), workInProgressHook;
      }
      function prepareToUseHooks(componentIdentity) {
        currentlyRenderingComponent = componentIdentity, isInHookUserCodeInDev = !1;
      }
      function finishHooks(Component, props, children, refOrContext) {
        for (; didScheduleRenderPhaseUpdate; )
          didScheduleRenderPhaseUpdate = !1, numberOfReRenders += 1, workInProgressHook = null, children = Component(props, refOrContext);
        return resetHooksState(), children;
      }
      function resetHooksState() {
        isInHookUserCodeInDev = !1, currentlyRenderingComponent = null, didScheduleRenderPhaseUpdate = !1, firstWorkInProgressHook = null, numberOfReRenders = 0, renderPhaseUpdates = null, workInProgressHook = null;
      }
      function readContext(context, observedBits) {
        var threadID = currentPartialRenderer.threadID;
        return validateContextBounds(context, threadID), isInHookUserCodeInDev && error("Context can only be read while React is rendering. In classes, you can read it in the render method or getDerivedStateFromProps. In function components, you can read it directly in the function body, but not inside Hooks like useReducer() or useMemo()."), context[threadID];
      }
      function useContext11(context, observedBits) {
        currentHookNameInDev = "useContext", resolveCurrentlyRenderingComponent();
        var threadID = currentPartialRenderer.threadID;
        return validateContextBounds(context, threadID), context[threadID];
      }
      function basicStateReducer(state, action) {
        return typeof action == "function" ? action(state) : action;
      }
      function useState18(initialState) {
        return currentHookNameInDev = "useState", useReducer(
          basicStateReducer,
          initialState
        );
      }
      function useReducer(reducer, initialArg, init2) {
        if (reducer !== basicStateReducer && (currentHookNameInDev = "useReducer"), currentlyRenderingComponent = resolveCurrentlyRenderingComponent(), workInProgressHook = createWorkInProgressHook(), isReRender) {
          var queue2 = workInProgressHook.queue, dispatch = queue2.dispatch;
          if (renderPhaseUpdates !== null) {
            var firstRenderPhaseUpdate = renderPhaseUpdates.get(queue2);
            if (firstRenderPhaseUpdate !== void 0) {
              renderPhaseUpdates.delete(queue2);
              var newState = workInProgressHook.memoizedState, update = firstRenderPhaseUpdate;
              do {
                var action = update.action;
                isInHookUserCodeInDev = !0, newState = reducer(newState, action), isInHookUserCodeInDev = !1, update = update.next;
              } while (update !== null);
              return workInProgressHook.memoizedState = newState, [newState, dispatch];
            }
          }
          return [workInProgressHook.memoizedState, dispatch];
        } else {
          isInHookUserCodeInDev = !0;
          var initialState;
          reducer === basicStateReducer ? initialState = typeof initialArg == "function" ? initialArg() : initialArg : initialState = init2 !== void 0 ? init2(initialArg) : initialArg, isInHookUserCodeInDev = !1, workInProgressHook.memoizedState = initialState;
          var _queue = workInProgressHook.queue = {
            last: null,
            dispatch: null
          }, _dispatch = _queue.dispatch = dispatchAction.bind(null, currentlyRenderingComponent, _queue);
          return [workInProgressHook.memoizedState, _dispatch];
        }
      }
      function useMemo8(nextCreate, deps) {
        currentlyRenderingComponent = resolveCurrentlyRenderingComponent(), workInProgressHook = createWorkInProgressHook();
        var nextDeps = deps === void 0 ? null : deps;
        if (workInProgressHook !== null) {
          var prevState = workInProgressHook.memoizedState;
          if (prevState !== null && nextDeps !== null) {
            var prevDeps = prevState[1];
            if (areHookInputsEqual(nextDeps, prevDeps))
              return prevState[0];
          }
        }
        isInHookUserCodeInDev = !0;
        var nextValue = nextCreate();
        return isInHookUserCodeInDev = !1, workInProgressHook.memoizedState = [nextValue, nextDeps], nextValue;
      }
      function useRef21(initialValue) {
        currentlyRenderingComponent = resolveCurrentlyRenderingComponent(), workInProgressHook = createWorkInProgressHook();
        var previousRef = workInProgressHook.memoizedState;
        if (previousRef === null) {
          var ref = {
            current: initialValue
          };
          return Object.seal(ref), workInProgressHook.memoizedState = ref, ref;
        } else
          return previousRef;
      }
      function useLayoutEffect5(create, inputs) {
        currentHookNameInDev = "useLayoutEffect", error("useLayoutEffect does nothing on the server, because its effect cannot be encoded into the server renderer's output format. This will lead to a mismatch between the initial, non-hydrated UI and the intended UI. To avoid this, useLayoutEffect should only be used in components that render exclusively on the client. See https://reactjs.org/link/uselayouteffect-ssr for common fixes.");
      }
      function dispatchAction(componentIdentity, queue2, action) {
        if (!(numberOfReRenders < RE_RENDER_LIMIT))
          throw Error("Too many re-renders. React limits the number of renders to prevent an infinite loop.");
        if (componentIdentity === currentlyRenderingComponent) {
          didScheduleRenderPhaseUpdate = !0;
          var update = {
            action,
            next: null
          };
          renderPhaseUpdates === null && (renderPhaseUpdates = /* @__PURE__ */ new Map());
          var firstRenderPhaseUpdate = renderPhaseUpdates.get(queue2);
          if (firstRenderPhaseUpdate === void 0)
            renderPhaseUpdates.set(queue2, update);
          else {
            for (var lastRenderPhaseUpdate = firstRenderPhaseUpdate; lastRenderPhaseUpdate.next !== null; )
              lastRenderPhaseUpdate = lastRenderPhaseUpdate.next;
            lastRenderPhaseUpdate.next = update;
          }
        }
      }
      function useCallback16(callback, deps) {
        return useMemo8(function() {
          return callback;
        }, deps);
      }
      function useMutableSource(source, getSnapshot, subscribe) {
        return resolveCurrentlyRenderingComponent(), getSnapshot(source._source);
      }
      function useDeferredValue(value) {
        return resolveCurrentlyRenderingComponent(), value;
      }
      function useTransition2() {
        resolveCurrentlyRenderingComponent();
        var startTransition = function(callback) {
          callback();
        };
        return [startTransition, !1];
      }
      function useOpaqueIdentifier() {
        return (currentPartialRenderer.identifierPrefix || "") + "R:" + (currentPartialRenderer.uniqueID++).toString(36);
      }
      function noop3() {
      }
      var currentPartialRenderer = null;
      function setCurrentPartialRenderer(renderer) {
        currentPartialRenderer = renderer;
      }
      var Dispatcher = {
        readContext,
        useContext: useContext11,
        useMemo: useMemo8,
        useReducer,
        useRef: useRef21,
        useState: useState18,
        useLayoutEffect: useLayoutEffect5,
        useCallback: useCallback16,
        useImperativeHandle: noop3,
        useEffect: noop3,
        useDebugValue: noop3,
        useDeferredValue,
        useTransition: useTransition2,
        useOpaqueIdentifier,
        useMutableSource
      }, HTML_NAMESPACE = "http://www.w3.org/1999/xhtml", MATH_NAMESPACE = "http://www.w3.org/1998/Math/MathML", SVG_NAMESPACE = "http://www.w3.org/2000/svg", Namespaces = {
        html: HTML_NAMESPACE,
        mathml: MATH_NAMESPACE,
        svg: SVG_NAMESPACE
      };
      function getIntrinsicNamespace(type) {
        switch (type) {
          case "svg":
            return SVG_NAMESPACE;
          case "math":
            return MATH_NAMESPACE;
          default:
            return HTML_NAMESPACE;
        }
      }
      function getChildNamespace(parentNamespace, type) {
        return parentNamespace == null || parentNamespace === HTML_NAMESPACE ? getIntrinsicNamespace(type) : parentNamespace === SVG_NAMESPACE && type === "foreignObject" ? HTML_NAMESPACE : parentNamespace;
      }
      var hasReadOnlyValue = {
        button: !0,
        checkbox: !0,
        image: !0,
        hidden: !0,
        radio: !0,
        reset: !0,
        submit: !0
      };
      function checkControlledValueProps(tagName, props) {
        hasReadOnlyValue[props.type] || props.onChange || props.onInput || props.readOnly || props.disabled || props.value == null || error("You provided a `value` prop to a form field without an `onChange` handler. This will render a read-only field. If the field should be mutable use `defaultValue`. Otherwise, set either `onChange` or `readOnly`."), props.onChange || props.readOnly || props.disabled || props.checked == null || error("You provided a `checked` prop to a form field without an `onChange` handler. This will render a read-only field. If the field should be mutable use `defaultChecked`. Otherwise, set either `onChange` or `readOnly`.");
      }
      var omittedCloseTags = {
        area: !0,
        base: !0,
        br: !0,
        col: !0,
        embed: !0,
        hr: !0,
        img: !0,
        input: !0,
        keygen: !0,
        link: !0,
        meta: !0,
        param: !0,
        source: !0,
        track: !0,
        wbr: !0
      }, voidElementTags = _assign({
        menuitem: !0
      }, omittedCloseTags), HTML = "__html";
      function assertValidProps(tag, props) {
        if (!!props) {
          if (voidElementTags[tag] && !(props.children == null && props.dangerouslySetInnerHTML == null))
            throw Error(tag + " is a void element tag and must neither have `children` nor use `dangerouslySetInnerHTML`.");
          if (props.dangerouslySetInnerHTML != null) {
            if (props.children != null)
              throw Error("Can only set one of `children` or `props.dangerouslySetInnerHTML`.");
            if (!(typeof props.dangerouslySetInnerHTML == "object" && HTML in props.dangerouslySetInnerHTML))
              throw Error("`props.dangerouslySetInnerHTML` must be in the form `{__html: ...}`. Please visit https://reactjs.org/link/dangerously-set-inner-html for more information.");
          }
          if (!props.suppressContentEditableWarning && props.contentEditable && props.children != null && error("A component is `contentEditable` and contains `children` managed by React. It is now your responsibility to guarantee that none of those nodes are unexpectedly modified or duplicated. This is probably not intentional."), !(props.style == null || typeof props.style == "object"))
            throw Error("The `style` prop expects a mapping from style properties to values, not a string. For example, style={{marginRight: spacing + 'em'}} when using JSX.");
        }
      }
      var isUnitlessNumber = {
        animationIterationCount: !0,
        borderImageOutset: !0,
        borderImageSlice: !0,
        borderImageWidth: !0,
        boxFlex: !0,
        boxFlexGroup: !0,
        boxOrdinalGroup: !0,
        columnCount: !0,
        columns: !0,
        flex: !0,
        flexGrow: !0,
        flexPositive: !0,
        flexShrink: !0,
        flexNegative: !0,
        flexOrder: !0,
        gridArea: !0,
        gridRow: !0,
        gridRowEnd: !0,
        gridRowSpan: !0,
        gridRowStart: !0,
        gridColumn: !0,
        gridColumnEnd: !0,
        gridColumnSpan: !0,
        gridColumnStart: !0,
        fontWeight: !0,
        lineClamp: !0,
        lineHeight: !0,
        opacity: !0,
        order: !0,
        orphans: !0,
        tabSize: !0,
        widows: !0,
        zIndex: !0,
        zoom: !0,
        fillOpacity: !0,
        floodOpacity: !0,
        stopOpacity: !0,
        strokeDasharray: !0,
        strokeDashoffset: !0,
        strokeMiterlimit: !0,
        strokeOpacity: !0,
        strokeWidth: !0
      };
      function prefixKey(prefix2, key) {
        return prefix2 + key.charAt(0).toUpperCase() + key.substring(1);
      }
      var prefixes = ["Webkit", "ms", "Moz", "O"];
      Object.keys(isUnitlessNumber).forEach(function(prop) {
        prefixes.forEach(function(prefix2) {
          isUnitlessNumber[prefixKey(prefix2, prop)] = isUnitlessNumber[prop];
        });
      });
      function dangerousStyleValue(name, value, isCustomProperty) {
        var isEmpty6 = value == null || typeof value == "boolean" || value === "";
        return isEmpty6 ? "" : !isCustomProperty && typeof value == "number" && value !== 0 && !(isUnitlessNumber.hasOwnProperty(name) && isUnitlessNumber[name]) ? value + "px" : ("" + value).trim();
      }
      var uppercasePattern = /([A-Z])/g, msPattern = /^ms-/;
      function hyphenateStyleName(name) {
        return name.replace(uppercasePattern, "-$1").toLowerCase().replace(msPattern, "-ms-");
      }
      function isCustomComponent(tagName, props) {
        if (tagName.indexOf("-") === -1)
          return typeof props.is == "string";
        switch (tagName) {
          case "annotation-xml":
          case "color-profile":
          case "font-face":
          case "font-face-src":
          case "font-face-uri":
          case "font-face-format":
          case "font-face-name":
          case "missing-glyph":
            return !1;
          default:
            return !0;
        }
      }
      var warnValidStyle = function() {
      };
      {
        var badVendoredStyleNamePattern = /^(?:webkit|moz|o)[A-Z]/, msPattern$1 = /^-ms-/, hyphenPattern = /-(.)/g, badStyleValueWithSemicolonPattern = /;\s*$/, warnedStyleNames = {}, warnedStyleValues = {}, warnedForNaNValue = !1, warnedForInfinityValue = !1, camelize = function(string) {
          return string.replace(hyphenPattern, function(_2, character) {
            return character.toUpperCase();
          });
        }, warnHyphenatedStyleName = function(name) {
          warnedStyleNames.hasOwnProperty(name) && warnedStyleNames[name] || (warnedStyleNames[name] = !0, error(
            "Unsupported style property %s. Did you mean %s?",
            name,
            camelize(name.replace(msPattern$1, "ms-"))
          ));
        }, warnBadVendoredStyleName = function(name) {
          warnedStyleNames.hasOwnProperty(name) && warnedStyleNames[name] || (warnedStyleNames[name] = !0, error("Unsupported vendor-prefixed style property %s. Did you mean %s?", name, name.charAt(0).toUpperCase() + name.slice(1)));
        }, warnStyleValueWithSemicolon = function(name, value) {
          warnedStyleValues.hasOwnProperty(value) && warnedStyleValues[value] || (warnedStyleValues[value] = !0, error(`Style property values shouldn't contain a semicolon. Try "%s: %s" instead.`, name, value.replace(badStyleValueWithSemicolonPattern, "")));
        }, warnStyleValueIsNaN = function(name, value) {
          warnedForNaNValue || (warnedForNaNValue = !0, error("`NaN` is an invalid value for the `%s` css style property.", name));
        }, warnStyleValueIsInfinity = function(name, value) {
          warnedForInfinityValue || (warnedForInfinityValue = !0, error("`Infinity` is an invalid value for the `%s` css style property.", name));
        };
        warnValidStyle = function(name, value) {
          name.indexOf("-") > -1 ? warnHyphenatedStyleName(name) : badVendoredStyleNamePattern.test(name) ? warnBadVendoredStyleName(name) : badStyleValueWithSemicolonPattern.test(value) && warnStyleValueWithSemicolon(name, value), typeof value == "number" && (isNaN(value) ? warnStyleValueIsNaN(name, value) : isFinite(value) || warnStyleValueIsInfinity(name, value));
        };
      }
      var warnValidStyle$1 = warnValidStyle, ariaProperties = {
        "aria-current": 0,
        "aria-details": 0,
        "aria-disabled": 0,
        "aria-hidden": 0,
        "aria-invalid": 0,
        "aria-keyshortcuts": 0,
        "aria-label": 0,
        "aria-roledescription": 0,
        "aria-autocomplete": 0,
        "aria-checked": 0,
        "aria-expanded": 0,
        "aria-haspopup": 0,
        "aria-level": 0,
        "aria-modal": 0,
        "aria-multiline": 0,
        "aria-multiselectable": 0,
        "aria-orientation": 0,
        "aria-placeholder": 0,
        "aria-pressed": 0,
        "aria-readonly": 0,
        "aria-required": 0,
        "aria-selected": 0,
        "aria-sort": 0,
        "aria-valuemax": 0,
        "aria-valuemin": 0,
        "aria-valuenow": 0,
        "aria-valuetext": 0,
        "aria-atomic": 0,
        "aria-busy": 0,
        "aria-live": 0,
        "aria-relevant": 0,
        "aria-dropeffect": 0,
        "aria-grabbed": 0,
        "aria-activedescendant": 0,
        "aria-colcount": 0,
        "aria-colindex": 0,
        "aria-colspan": 0,
        "aria-controls": 0,
        "aria-describedby": 0,
        "aria-errormessage": 0,
        "aria-flowto": 0,
        "aria-labelledby": 0,
        "aria-owns": 0,
        "aria-posinset": 0,
        "aria-rowcount": 0,
        "aria-rowindex": 0,
        "aria-rowspan": 0,
        "aria-setsize": 0
      }, warnedProperties = {}, rARIA = new RegExp("^(aria)-[" + ATTRIBUTE_NAME_CHAR + "]*$"), rARIACamel = new RegExp("^(aria)[A-Z][" + ATTRIBUTE_NAME_CHAR + "]*$"), hasOwnProperty$1 = Object.prototype.hasOwnProperty;
      function validateProperty(tagName, name) {
        {
          if (hasOwnProperty$1.call(warnedProperties, name) && warnedProperties[name])
            return !0;
          if (rARIACamel.test(name)) {
            var ariaName = "aria-" + name.slice(4).toLowerCase(), correctName = ariaProperties.hasOwnProperty(ariaName) ? ariaName : null;
            if (correctName == null)
              return error("Invalid ARIA attribute `%s`. ARIA attributes follow the pattern aria-* and must be lowercase.", name), warnedProperties[name] = !0, !0;
            if (name !== correctName)
              return error("Invalid ARIA attribute `%s`. Did you mean `%s`?", name, correctName), warnedProperties[name] = !0, !0;
          }
          if (rARIA.test(name)) {
            var lowerCasedName = name.toLowerCase(), standardName = ariaProperties.hasOwnProperty(lowerCasedName) ? lowerCasedName : null;
            if (standardName == null)
              return warnedProperties[name] = !0, !1;
            if (name !== standardName)
              return error("Unknown ARIA attribute `%s`. Did you mean `%s`?", name, standardName), warnedProperties[name] = !0, !0;
          }
        }
        return !0;
      }
      function warnInvalidARIAProps(type, props) {
        {
          var invalidProps = [];
          for (var key in props) {
            var isValid = validateProperty(type, key);
            isValid || invalidProps.push(key);
          }
          var unknownPropString = invalidProps.map(function(prop) {
            return "`" + prop + "`";
          }).join(", ");
          invalidProps.length === 1 ? error("Invalid aria prop %s on <%s> tag. For details, see https://reactjs.org/link/invalid-aria-props", unknownPropString, type) : invalidProps.length > 1 && error("Invalid aria props %s on <%s> tag. For details, see https://reactjs.org/link/invalid-aria-props", unknownPropString, type);
        }
      }
      function validateProperties(type, props) {
        isCustomComponent(type, props) || warnInvalidARIAProps(type, props);
      }
      var didWarnValueNull = !1;
      function validateProperties$1(type, props) {
        {
          if (type !== "input" && type !== "textarea" && type !== "select")
            return;
          props != null && props.value === null && !didWarnValueNull && (didWarnValueNull = !0, type === "select" && props.multiple ? error("`value` prop on `%s` should not be null. Consider using an empty array when `multiple` is set to `true` to clear the component or `undefined` for uncontrolled components.", type) : error("`value` prop on `%s` should not be null. Consider using an empty string to clear the component or `undefined` for uncontrolled components.", type));
        }
      }
      var possibleStandardNames = {
        accept: "accept",
        acceptcharset: "acceptCharset",
        "accept-charset": "acceptCharset",
        accesskey: "accessKey",
        action: "action",
        allowfullscreen: "allowFullScreen",
        alt: "alt",
        as: "as",
        async: "async",
        autocapitalize: "autoCapitalize",
        autocomplete: "autoComplete",
        autocorrect: "autoCorrect",
        autofocus: "autoFocus",
        autoplay: "autoPlay",
        autosave: "autoSave",
        capture: "capture",
        cellpadding: "cellPadding",
        cellspacing: "cellSpacing",
        challenge: "challenge",
        charset: "charSet",
        checked: "checked",
        children: "children",
        cite: "cite",
        class: "className",
        classid: "classID",
        classname: "className",
        cols: "cols",
        colspan: "colSpan",
        content: "content",
        contenteditable: "contentEditable",
        contextmenu: "contextMenu",
        controls: "controls",
        controlslist: "controlsList",
        coords: "coords",
        crossorigin: "crossOrigin",
        dangerouslysetinnerhtml: "dangerouslySetInnerHTML",
        data: "data",
        datetime: "dateTime",
        default: "default",
        defaultchecked: "defaultChecked",
        defaultvalue: "defaultValue",
        defer: "defer",
        dir: "dir",
        disabled: "disabled",
        disablepictureinpicture: "disablePictureInPicture",
        disableremoteplayback: "disableRemotePlayback",
        download: "download",
        draggable: "draggable",
        enctype: "encType",
        enterkeyhint: "enterKeyHint",
        for: "htmlFor",
        form: "form",
        formmethod: "formMethod",
        formaction: "formAction",
        formenctype: "formEncType",
        formnovalidate: "formNoValidate",
        formtarget: "formTarget",
        frameborder: "frameBorder",
        headers: "headers",
        height: "height",
        hidden: "hidden",
        high: "high",
        href: "href",
        hreflang: "hrefLang",
        htmlfor: "htmlFor",
        httpequiv: "httpEquiv",
        "http-equiv": "httpEquiv",
        icon: "icon",
        id: "id",
        innerhtml: "innerHTML",
        inputmode: "inputMode",
        integrity: "integrity",
        is: "is",
        itemid: "itemID",
        itemprop: "itemProp",
        itemref: "itemRef",
        itemscope: "itemScope",
        itemtype: "itemType",
        keyparams: "keyParams",
        keytype: "keyType",
        kind: "kind",
        label: "label",
        lang: "lang",
        list: "list",
        loop: "loop",
        low: "low",
        manifest: "manifest",
        marginwidth: "marginWidth",
        marginheight: "marginHeight",
        max: "max",
        maxlength: "maxLength",
        media: "media",
        mediagroup: "mediaGroup",
        method: "method",
        min: "min",
        minlength: "minLength",
        multiple: "multiple",
        muted: "muted",
        name: "name",
        nomodule: "noModule",
        nonce: "nonce",
        novalidate: "noValidate",
        open: "open",
        optimum: "optimum",
        pattern: "pattern",
        placeholder: "placeholder",
        playsinline: "playsInline",
        poster: "poster",
        preload: "preload",
        profile: "profile",
        radiogroup: "radioGroup",
        readonly: "readOnly",
        referrerpolicy: "referrerPolicy",
        rel: "rel",
        required: "required",
        reversed: "reversed",
        role: "role",
        rows: "rows",
        rowspan: "rowSpan",
        sandbox: "sandbox",
        scope: "scope",
        scoped: "scoped",
        scrolling: "scrolling",
        seamless: "seamless",
        selected: "selected",
        shape: "shape",
        size: "size",
        sizes: "sizes",
        span: "span",
        spellcheck: "spellCheck",
        src: "src",
        srcdoc: "srcDoc",
        srclang: "srcLang",
        srcset: "srcSet",
        start: "start",
        step: "step",
        style: "style",
        summary: "summary",
        tabindex: "tabIndex",
        target: "target",
        title: "title",
        type: "type",
        usemap: "useMap",
        value: "value",
        width: "width",
        wmode: "wmode",
        wrap: "wrap",
        about: "about",
        accentheight: "accentHeight",
        "accent-height": "accentHeight",
        accumulate: "accumulate",
        additive: "additive",
        alignmentbaseline: "alignmentBaseline",
        "alignment-baseline": "alignmentBaseline",
        allowreorder: "allowReorder",
        alphabetic: "alphabetic",
        amplitude: "amplitude",
        arabicform: "arabicForm",
        "arabic-form": "arabicForm",
        ascent: "ascent",
        attributename: "attributeName",
        attributetype: "attributeType",
        autoreverse: "autoReverse",
        azimuth: "azimuth",
        basefrequency: "baseFrequency",
        baselineshift: "baselineShift",
        "baseline-shift": "baselineShift",
        baseprofile: "baseProfile",
        bbox: "bbox",
        begin: "begin",
        bias: "bias",
        by: "by",
        calcmode: "calcMode",
        capheight: "capHeight",
        "cap-height": "capHeight",
        clip: "clip",
        clippath: "clipPath",
        "clip-path": "clipPath",
        clippathunits: "clipPathUnits",
        cliprule: "clipRule",
        "clip-rule": "clipRule",
        color: "color",
        colorinterpolation: "colorInterpolation",
        "color-interpolation": "colorInterpolation",
        colorinterpolationfilters: "colorInterpolationFilters",
        "color-interpolation-filters": "colorInterpolationFilters",
        colorprofile: "colorProfile",
        "color-profile": "colorProfile",
        colorrendering: "colorRendering",
        "color-rendering": "colorRendering",
        contentscripttype: "contentScriptType",
        contentstyletype: "contentStyleType",
        cursor: "cursor",
        cx: "cx",
        cy: "cy",
        d: "d",
        datatype: "datatype",
        decelerate: "decelerate",
        descent: "descent",
        diffuseconstant: "diffuseConstant",
        direction: "direction",
        display: "display",
        divisor: "divisor",
        dominantbaseline: "dominantBaseline",
        "dominant-baseline": "dominantBaseline",
        dur: "dur",
        dx: "dx",
        dy: "dy",
        edgemode: "edgeMode",
        elevation: "elevation",
        enablebackground: "enableBackground",
        "enable-background": "enableBackground",
        end: "end",
        exponent: "exponent",
        externalresourcesrequired: "externalResourcesRequired",
        fill: "fill",
        fillopacity: "fillOpacity",
        "fill-opacity": "fillOpacity",
        fillrule: "fillRule",
        "fill-rule": "fillRule",
        filter: "filter",
        filterres: "filterRes",
        filterunits: "filterUnits",
        floodopacity: "floodOpacity",
        "flood-opacity": "floodOpacity",
        floodcolor: "floodColor",
        "flood-color": "floodColor",
        focusable: "focusable",
        fontfamily: "fontFamily",
        "font-family": "fontFamily",
        fontsize: "fontSize",
        "font-size": "fontSize",
        fontsizeadjust: "fontSizeAdjust",
        "font-size-adjust": "fontSizeAdjust",
        fontstretch: "fontStretch",
        "font-stretch": "fontStretch",
        fontstyle: "fontStyle",
        "font-style": "fontStyle",
        fontvariant: "fontVariant",
        "font-variant": "fontVariant",
        fontweight: "fontWeight",
        "font-weight": "fontWeight",
        format: "format",
        from: "from",
        fx: "fx",
        fy: "fy",
        g1: "g1",
        g2: "g2",
        glyphname: "glyphName",
        "glyph-name": "glyphName",
        glyphorientationhorizontal: "glyphOrientationHorizontal",
        "glyph-orientation-horizontal": "glyphOrientationHorizontal",
        glyphorientationvertical: "glyphOrientationVertical",
        "glyph-orientation-vertical": "glyphOrientationVertical",
        glyphref: "glyphRef",
        gradienttransform: "gradientTransform",
        gradientunits: "gradientUnits",
        hanging: "hanging",
        horizadvx: "horizAdvX",
        "horiz-adv-x": "horizAdvX",
        horizoriginx: "horizOriginX",
        "horiz-origin-x": "horizOriginX",
        ideographic: "ideographic",
        imagerendering: "imageRendering",
        "image-rendering": "imageRendering",
        in2: "in2",
        in: "in",
        inlist: "inlist",
        intercept: "intercept",
        k1: "k1",
        k2: "k2",
        k3: "k3",
        k4: "k4",
        k: "k",
        kernelmatrix: "kernelMatrix",
        kernelunitlength: "kernelUnitLength",
        kerning: "kerning",
        keypoints: "keyPoints",
        keysplines: "keySplines",
        keytimes: "keyTimes",
        lengthadjust: "lengthAdjust",
        letterspacing: "letterSpacing",
        "letter-spacing": "letterSpacing",
        lightingcolor: "lightingColor",
        "lighting-color": "lightingColor",
        limitingconeangle: "limitingConeAngle",
        local: "local",
        markerend: "markerEnd",
        "marker-end": "markerEnd",
        markerheight: "markerHeight",
        markermid: "markerMid",
        "marker-mid": "markerMid",
        markerstart: "markerStart",
        "marker-start": "markerStart",
        markerunits: "markerUnits",
        markerwidth: "markerWidth",
        mask: "mask",
        maskcontentunits: "maskContentUnits",
        maskunits: "maskUnits",
        mathematical: "mathematical",
        mode: "mode",
        numoctaves: "numOctaves",
        offset: "offset",
        opacity: "opacity",
        operator: "operator",
        order: "order",
        orient: "orient",
        orientation: "orientation",
        origin: "origin",
        overflow: "overflow",
        overlineposition: "overlinePosition",
        "overline-position": "overlinePosition",
        overlinethickness: "overlineThickness",
        "overline-thickness": "overlineThickness",
        paintorder: "paintOrder",
        "paint-order": "paintOrder",
        panose1: "panose1",
        "panose-1": "panose1",
        pathlength: "pathLength",
        patterncontentunits: "patternContentUnits",
        patterntransform: "patternTransform",
        patternunits: "patternUnits",
        pointerevents: "pointerEvents",
        "pointer-events": "pointerEvents",
        points: "points",
        pointsatx: "pointsAtX",
        pointsaty: "pointsAtY",
        pointsatz: "pointsAtZ",
        prefix: "prefix",
        preservealpha: "preserveAlpha",
        preserveaspectratio: "preserveAspectRatio",
        primitiveunits: "primitiveUnits",
        property: "property",
        r: "r",
        radius: "radius",
        refx: "refX",
        refy: "refY",
        renderingintent: "renderingIntent",
        "rendering-intent": "renderingIntent",
        repeatcount: "repeatCount",
        repeatdur: "repeatDur",
        requiredextensions: "requiredExtensions",
        requiredfeatures: "requiredFeatures",
        resource: "resource",
        restart: "restart",
        result: "result",
        results: "results",
        rotate: "rotate",
        rx: "rx",
        ry: "ry",
        scale: "scale",
        security: "security",
        seed: "seed",
        shaperendering: "shapeRendering",
        "shape-rendering": "shapeRendering",
        slope: "slope",
        spacing: "spacing",
        specularconstant: "specularConstant",
        specularexponent: "specularExponent",
        speed: "speed",
        spreadmethod: "spreadMethod",
        startoffset: "startOffset",
        stddeviation: "stdDeviation",
        stemh: "stemh",
        stemv: "stemv",
        stitchtiles: "stitchTiles",
        stopcolor: "stopColor",
        "stop-color": "stopColor",
        stopopacity: "stopOpacity",
        "stop-opacity": "stopOpacity",
        strikethroughposition: "strikethroughPosition",
        "strikethrough-position": "strikethroughPosition",
        strikethroughthickness: "strikethroughThickness",
        "strikethrough-thickness": "strikethroughThickness",
        string: "string",
        stroke: "stroke",
        strokedasharray: "strokeDasharray",
        "stroke-dasharray": "strokeDasharray",
        strokedashoffset: "strokeDashoffset",
        "stroke-dashoffset": "strokeDashoffset",
        strokelinecap: "strokeLinecap",
        "stroke-linecap": "strokeLinecap",
        strokelinejoin: "strokeLinejoin",
        "stroke-linejoin": "strokeLinejoin",
        strokemiterlimit: "strokeMiterlimit",
        "stroke-miterlimit": "strokeMiterlimit",
        strokewidth: "strokeWidth",
        "stroke-width": "strokeWidth",
        strokeopacity: "strokeOpacity",
        "stroke-opacity": "strokeOpacity",
        suppresscontenteditablewarning: "suppressContentEditableWarning",
        suppresshydrationwarning: "suppressHydrationWarning",
        surfacescale: "surfaceScale",
        systemlanguage: "systemLanguage",
        tablevalues: "tableValues",
        targetx: "targetX",
        targety: "targetY",
        textanchor: "textAnchor",
        "text-anchor": "textAnchor",
        textdecoration: "textDecoration",
        "text-decoration": "textDecoration",
        textlength: "textLength",
        textrendering: "textRendering",
        "text-rendering": "textRendering",
        to: "to",
        transform: "transform",
        typeof: "typeof",
        u1: "u1",
        u2: "u2",
        underlineposition: "underlinePosition",
        "underline-position": "underlinePosition",
        underlinethickness: "underlineThickness",
        "underline-thickness": "underlineThickness",
        unicode: "unicode",
        unicodebidi: "unicodeBidi",
        "unicode-bidi": "unicodeBidi",
        unicoderange: "unicodeRange",
        "unicode-range": "unicodeRange",
        unitsperem: "unitsPerEm",
        "units-per-em": "unitsPerEm",
        unselectable: "unselectable",
        valphabetic: "vAlphabetic",
        "v-alphabetic": "vAlphabetic",
        values: "values",
        vectoreffect: "vectorEffect",
        "vector-effect": "vectorEffect",
        version: "version",
        vertadvy: "vertAdvY",
        "vert-adv-y": "vertAdvY",
        vertoriginx: "vertOriginX",
        "vert-origin-x": "vertOriginX",
        vertoriginy: "vertOriginY",
        "vert-origin-y": "vertOriginY",
        vhanging: "vHanging",
        "v-hanging": "vHanging",
        videographic: "vIdeographic",
        "v-ideographic": "vIdeographic",
        viewbox: "viewBox",
        viewtarget: "viewTarget",
        visibility: "visibility",
        vmathematical: "vMathematical",
        "v-mathematical": "vMathematical",
        vocab: "vocab",
        widths: "widths",
        wordspacing: "wordSpacing",
        "word-spacing": "wordSpacing",
        writingmode: "writingMode",
        "writing-mode": "writingMode",
        x1: "x1",
        x2: "x2",
        x: "x",
        xchannelselector: "xChannelSelector",
        xheight: "xHeight",
        "x-height": "xHeight",
        xlinkactuate: "xlinkActuate",
        "xlink:actuate": "xlinkActuate",
        xlinkarcrole: "xlinkArcrole",
        "xlink:arcrole": "xlinkArcrole",
        xlinkhref: "xlinkHref",
        "xlink:href": "xlinkHref",
        xlinkrole: "xlinkRole",
        "xlink:role": "xlinkRole",
        xlinkshow: "xlinkShow",
        "xlink:show": "xlinkShow",
        xlinktitle: "xlinkTitle",
        "xlink:title": "xlinkTitle",
        xlinktype: "xlinkType",
        "xlink:type": "xlinkType",
        xmlbase: "xmlBase",
        "xml:base": "xmlBase",
        xmllang: "xmlLang",
        "xml:lang": "xmlLang",
        xmlns: "xmlns",
        "xml:space": "xmlSpace",
        xmlnsxlink: "xmlnsXlink",
        "xmlns:xlink": "xmlnsXlink",
        xmlspace: "xmlSpace",
        y1: "y1",
        y2: "y2",
        y: "y",
        ychannelselector: "yChannelSelector",
        z: "z",
        zoomandpan: "zoomAndPan"
      }, validateProperty$1 = function() {
      };
      {
        var warnedProperties$1 = {}, _hasOwnProperty = Object.prototype.hasOwnProperty, EVENT_NAME_REGEX = /^on./, INVALID_EVENT_NAME_REGEX = /^on[^A-Z]/, rARIA$1 = new RegExp("^(aria)-[" + ATTRIBUTE_NAME_CHAR + "]*$"), rARIACamel$1 = new RegExp("^(aria)[A-Z][" + ATTRIBUTE_NAME_CHAR + "]*$");
        validateProperty$1 = function(tagName, name, value, eventRegistry) {
          if (_hasOwnProperty.call(warnedProperties$1, name) && warnedProperties$1[name])
            return !0;
          var lowerCasedName = name.toLowerCase();
          if (lowerCasedName === "onfocusin" || lowerCasedName === "onfocusout")
            return error("React uses onFocus and onBlur instead of onFocusIn and onFocusOut. All React events are normalized to bubble, so onFocusIn and onFocusOut are not needed/supported by React."), warnedProperties$1[name] = !0, !0;
          if (eventRegistry != null) {
            var registrationNameDependencies = eventRegistry.registrationNameDependencies, possibleRegistrationNames = eventRegistry.possibleRegistrationNames;
            if (registrationNameDependencies.hasOwnProperty(name))
              return !0;
            var registrationName = possibleRegistrationNames.hasOwnProperty(lowerCasedName) ? possibleRegistrationNames[lowerCasedName] : null;
            if (registrationName != null)
              return error("Invalid event handler property `%s`. Did you mean `%s`?", name, registrationName), warnedProperties$1[name] = !0, !0;
            if (EVENT_NAME_REGEX.test(name))
              return error("Unknown event handler property `%s`. It will be ignored.", name), warnedProperties$1[name] = !0, !0;
          } else if (EVENT_NAME_REGEX.test(name))
            return INVALID_EVENT_NAME_REGEX.test(name) && error("Invalid event handler property `%s`. React events use the camelCase naming convention, for example `onClick`.", name), warnedProperties$1[name] = !0, !0;
          if (rARIA$1.test(name) || rARIACamel$1.test(name))
            return !0;
          if (lowerCasedName === "innerhtml")
            return error("Directly setting property `innerHTML` is not permitted. For more information, lookup documentation on `dangerouslySetInnerHTML`."), warnedProperties$1[name] = !0, !0;
          if (lowerCasedName === "aria")
            return error("The `aria` attribute is reserved for future use in React. Pass individual `aria-` attributes instead."), warnedProperties$1[name] = !0, !0;
          if (lowerCasedName === "is" && value !== null && value !== void 0 && typeof value != "string")
            return error("Received a `%s` for a string attribute `is`. If this is expected, cast the value to a string.", typeof value), warnedProperties$1[name] = !0, !0;
          if (typeof value == "number" && isNaN(value))
            return error("Received NaN for the `%s` attribute. If this is expected, cast the value to a string.", name), warnedProperties$1[name] = !0, !0;
          var propertyInfo = getPropertyInfo(name), isReserved = propertyInfo !== null && propertyInfo.type === RESERVED;
          if (possibleStandardNames.hasOwnProperty(lowerCasedName)) {
            var standardName = possibleStandardNames[lowerCasedName];
            if (standardName !== name)
              return error("Invalid DOM property `%s`. Did you mean `%s`?", name, standardName), warnedProperties$1[name] = !0, !0;
          } else if (!isReserved && name !== lowerCasedName)
            return error("React does not recognize the `%s` prop on a DOM element. If you intentionally want it to appear in the DOM as a custom attribute, spell it as lowercase `%s` instead. If you accidentally passed it from a parent component, remove it from the DOM element.", name, lowerCasedName), warnedProperties$1[name] = !0, !0;
          return typeof value == "boolean" && shouldRemoveAttributeWithWarning(name, value, propertyInfo, !1) ? (value ? error('Received `%s` for a non-boolean attribute `%s`.\n\nIf you want to write it to the DOM, pass a string instead: %s="%s" or %s={value.toString()}.', value, name, name, value, name) : error('Received `%s` for a non-boolean attribute `%s`.\n\nIf you want to write it to the DOM, pass a string instead: %s="%s" or %s={value.toString()}.\n\nIf you used to conditionally omit it with %s={condition && value}, pass %s={condition ? value : undefined} instead.', value, name, name, value, name, name, name), warnedProperties$1[name] = !0, !0) : isReserved ? !0 : shouldRemoveAttributeWithWarning(name, value, propertyInfo, !1) ? (warnedProperties$1[name] = !0, !1) : ((value === "false" || value === "true") && propertyInfo !== null && propertyInfo.type === BOOLEAN && (error("Received the string `%s` for the boolean attribute `%s`. %s Did you mean %s={%s}?", value, name, value === "false" ? "The browser will interpret it as a truthy value." : 'Although this works, it will not work as expected if you pass the string "false".', name, value), warnedProperties$1[name] = !0), !0);
        };
      }
      var warnUnknownProperties = function(type, props, eventRegistry) {
        {
          var unknownProps = [];
          for (var key in props) {
            var isValid = validateProperty$1(type, key, props[key], eventRegistry);
            isValid || unknownProps.push(key);
          }
          var unknownPropString = unknownProps.map(function(prop) {
            return "`" + prop + "`";
          }).join(", ");
          unknownProps.length === 1 ? error("Invalid value for prop %s on <%s> tag. Either remove it from the element, or pass a string or number value to keep it in the DOM. For details, see https://reactjs.org/link/attribute-behavior ", unknownPropString, type) : unknownProps.length > 1 && error("Invalid values for props %s on <%s> tag. Either remove them from the element, or pass a string or number value to keep them in the DOM. For details, see https://reactjs.org/link/attribute-behavior ", unknownPropString, type);
        }
      };
      function validateProperties$2(type, props, eventRegistry) {
        isCustomComponent(type, props) || warnUnknownProperties(type, props, eventRegistry);
      }
      var toArray = React90.Children.toArray, currentDebugStacks = [], ReactCurrentDispatcher$1 = ReactSharedInternals.ReactCurrentDispatcher, ReactDebugCurrentFrame$1, prevGetCurrentStackImpl = null, getCurrentServerStackImpl = function() {
        return "";
      }, describeStackFrame = function(element) {
        return "";
      }, validatePropertiesInDevelopment = function(type, props) {
      }, pushCurrentDebugStack = function(stack) {
      }, pushElementToDebugStack = function(element) {
      }, popCurrentDebugStack = function() {
      }, hasWarnedAboutUsingContextAsConsumer = !1;
      ReactDebugCurrentFrame$1 = ReactSharedInternals.ReactDebugCurrentFrame, validatePropertiesInDevelopment = function(type, props) {
        validateProperties(type, props), validateProperties$1(type, props), validateProperties$2(type, props, null);
      }, describeStackFrame = function(element) {
        return describeUnknownElementTypeFrameInDEV(element.type, element._source, null);
      }, pushCurrentDebugStack = function(stack) {
        currentDebugStacks.push(stack), currentDebugStacks.length === 1 && (prevGetCurrentStackImpl = ReactDebugCurrentFrame$1.getCurrentStack, ReactDebugCurrentFrame$1.getCurrentStack = getCurrentServerStackImpl);
      }, pushElementToDebugStack = function(element) {
        var stack = currentDebugStacks[currentDebugStacks.length - 1], frame = stack[stack.length - 1];
        frame.debugElementStack.push(element);
      }, popCurrentDebugStack = function() {
        currentDebugStacks.pop(), currentDebugStacks.length === 0 && (ReactDebugCurrentFrame$1.getCurrentStack = prevGetCurrentStackImpl, prevGetCurrentStackImpl = null);
      }, getCurrentServerStackImpl = function() {
        if (currentDebugStacks.length === 0)
          return "";
        for (var frames = currentDebugStacks[currentDebugStacks.length - 1], stack = "", i2 = frames.length - 1; i2 >= 0; i2--)
          for (var frame = frames[i2], debugElementStack = frame.debugElementStack, ii = debugElementStack.length - 1; ii >= 0; ii--)
            stack += describeStackFrame(debugElementStack[ii]);
        return stack;
      };
      var didWarnDefaultInputValue = !1, didWarnDefaultChecked = !1, didWarnDefaultSelectValue = !1, didWarnDefaultTextareaValue = !1, didWarnInvalidOptionChildren = !1, didWarnAboutNoopUpdateForComponent = {}, didWarnAboutBadClass = {}, didWarnAboutModulePatternComponent = {}, didWarnAboutDeprecatedWillMount = {}, didWarnAboutUndefinedDerivedState = {}, didWarnAboutUninitializedState = {}, valuePropNames = ["value", "defaultValue"], newlineEatingTags = {
        listing: !0,
        pre: !0,
        textarea: !0
      }, VALID_TAG_REGEX = /^[a-zA-Z][a-zA-Z:_\.\-\d]*$/, validatedTagCache = {};
      function validateDangerousTag(tag) {
        if (!validatedTagCache.hasOwnProperty(tag)) {
          if (!VALID_TAG_REGEX.test(tag))
            throw Error("Invalid tag: " + tag);
          validatedTagCache[tag] = !0;
        }
      }
      var styleNameCache = {}, processStyleName = function(styleName) {
        if (styleNameCache.hasOwnProperty(styleName))
          return styleNameCache[styleName];
        var result = hyphenateStyleName(styleName);
        return styleNameCache[styleName] = result, result;
      };
      function createMarkupForStyles(styles4) {
        var serialized = "", delimiter = "";
        for (var styleName in styles4)
          if (!!styles4.hasOwnProperty(styleName)) {
            var isCustomProperty = styleName.indexOf("--") === 0, styleValue = styles4[styleName];
            isCustomProperty || warnValidStyle$1(styleName, styleValue), styleValue != null && (serialized += delimiter + (isCustomProperty ? styleName : processStyleName(styleName)) + ":", serialized += dangerousStyleValue(styleName, styleValue, isCustomProperty), delimiter = ";");
          }
        return serialized || null;
      }
      function warnNoop(publicInstance, callerName) {
        {
          var _constructor = publicInstance.constructor, componentName = _constructor && getComponentName(_constructor) || "ReactClass", warningKey = componentName + "." + callerName;
          if (didWarnAboutNoopUpdateForComponent[warningKey])
            return;
          error(`%s(...): Can only update a mounting component. This usually means you called %s() outside componentWillMount() on the server. This is a no-op.

Please check the code for the %s component.`, callerName, callerName, componentName), didWarnAboutNoopUpdateForComponent[warningKey] = !0;
        }
      }
      function shouldConstruct$1(Component) {
        return Component.prototype && Component.prototype.isReactComponent;
      }
      function getNonChildrenInnerMarkup(props) {
        var innerHTML = props.dangerouslySetInnerHTML;
        if (innerHTML != null) {
          if (innerHTML.__html != null)
            return innerHTML.__html;
        } else {
          var content = props.children;
          if (typeof content == "string" || typeof content == "number")
            return escapeTextForBrowser(content);
        }
        return null;
      }
      function flattenTopLevelChildren(children) {
        if (!React90.isValidElement(children))
          return toArray(children);
        var element = children;
        if (element.type !== REACT_FRAGMENT_TYPE)
          return [element];
        var fragmentChildren = element.props.children;
        if (!React90.isValidElement(fragmentChildren))
          return toArray(fragmentChildren);
        var fragmentChildElement = fragmentChildren;
        return [fragmentChildElement];
      }
      function flattenOptionChildren(children) {
        if (children == null)
          return children;
        var content = "";
        return React90.Children.forEach(children, function(child) {
          child != null && (content += child, !didWarnInvalidOptionChildren && typeof child != "string" && typeof child != "number" && (didWarnInvalidOptionChildren = !0, error("Only strings and numbers are supported as <option> children.")));
        }), content;
      }
      var hasOwnProperty$2 = Object.prototype.hasOwnProperty, STYLE = "style", RESERVED_PROPS = {
        children: null,
        dangerouslySetInnerHTML: null,
        suppressContentEditableWarning: null,
        suppressHydrationWarning: null
      };
      function createOpenTagMarkup(tagVerbatim, tagLowercase, props, namespace, makeStaticMarkup, isRootElement) {
        var ret = "<" + tagVerbatim, isCustomComponent$1 = isCustomComponent(tagLowercase, props);
        for (var propKey in props)
          if (!!hasOwnProperty$2.call(props, propKey)) {
            var propValue = props[propKey];
            if (propValue != null) {
              propKey === STYLE && (propValue = createMarkupForStyles(propValue));
              var markup = null;
              isCustomComponent$1 ? RESERVED_PROPS.hasOwnProperty(propKey) || (markup = createMarkupForCustomAttribute(propKey, propValue)) : markup = createMarkupForProperty(propKey, propValue), markup && (ret += " " + markup);
            }
          }
        return makeStaticMarkup || isRootElement && (ret += " " + createMarkupForRoot()), ret;
      }
      function validateRenderResult(child, type) {
        if (child === void 0)
          throw Error((getComponentName(type) || "Component") + "(...): Nothing was returned from render. This usually means a return statement is missing. Or, to render nothing, return null.");
      }
      function resolve(child, context, threadID) {
        for (; React90.isValidElement(child); ) {
          var element = child, Component = element.type;
          if (pushElementToDebugStack(element), typeof Component != "function")
            break;
          processChild(element, Component);
        }
        function processChild(element2, Component2) {
          var isClass = shouldConstruct$1(Component2), publicContext = processContext(Component2, context, threadID, isClass), queue2 = [], replace = !1, updater = {
            isMounted: function(publicInstance) {
              return !1;
            },
            enqueueForceUpdate: function(publicInstance) {
              if (queue2 === null)
                return warnNoop(publicInstance, "forceUpdate"), null;
            },
            enqueueReplaceState: function(publicInstance, completeState) {
              replace = !0, queue2 = [completeState];
            },
            enqueueSetState: function(publicInstance, currentPartialState) {
              if (queue2 === null)
                return warnNoop(publicInstance, "setState"), null;
              queue2.push(currentPartialState);
            }
          }, inst;
          if (isClass) {
            if (inst = new Component2(element2.props, publicContext, updater), typeof Component2.getDerivedStateFromProps == "function") {
              if (inst.state === null || inst.state === void 0) {
                var componentName = getComponentName(Component2) || "Unknown";
                didWarnAboutUninitializedState[componentName] || (error("`%s` uses `getDerivedStateFromProps` but its initial state is %s. This is not recommended. Instead, define the initial state by assigning an object to `this.state` in the constructor of `%s`. This ensures that `getDerivedStateFromProps` arguments have a consistent shape.", componentName, inst.state === null ? "null" : "undefined", componentName), didWarnAboutUninitializedState[componentName] = !0);
              }
              var partialState = Component2.getDerivedStateFromProps.call(null, element2.props, inst.state);
              if (partialState === void 0) {
                var _componentName = getComponentName(Component2) || "Unknown";
                didWarnAboutUndefinedDerivedState[_componentName] || (error("%s.getDerivedStateFromProps(): A valid state object (or null) must be returned. You have returned undefined.", _componentName), didWarnAboutUndefinedDerivedState[_componentName] = !0);
              }
              partialState != null && (inst.state = _assign({}, inst.state, partialState));
            }
          } else {
            if (Component2.prototype && typeof Component2.prototype.render == "function") {
              var _componentName2 = getComponentName(Component2) || "Unknown";
              didWarnAboutBadClass[_componentName2] || (error("The <%s /> component appears to have a render method, but doesn't extend React.Component. This is likely to cause errors. Change %s to extend React.Component instead.", _componentName2, _componentName2), didWarnAboutBadClass[_componentName2] = !0);
            }
            var componentIdentity = {};
            if (prepareToUseHooks(componentIdentity), inst = Component2(element2.props, publicContext, updater), inst = finishHooks(Component2, element2.props, inst, publicContext), inst != null && inst.render != null) {
              var _componentName3 = getComponentName(Component2) || "Unknown";
              didWarnAboutModulePatternComponent[_componentName3] || (error("The <%s /> component appears to be a function component that returns a class instance. Change %s to a class that extends React.Component instead. If you can't use a class try assigning the prototype on the function as a workaround. `%s.prototype = React.Component.prototype`. Don't use an arrow function since it cannot be called with `new` by React.", _componentName3, _componentName3, _componentName3), didWarnAboutModulePatternComponent[_componentName3] = !0);
            }
            if (inst == null || inst.render == null) {
              child = inst, validateRenderResult(child, Component2);
              return;
            }
          }
          inst.props = element2.props, inst.context = publicContext, inst.updater = updater;
          var initialState = inst.state;
          if (initialState === void 0 && (inst.state = initialState = null), typeof inst.UNSAFE_componentWillMount == "function" || typeof inst.componentWillMount == "function") {
            if (typeof inst.componentWillMount == "function") {
              if (inst.componentWillMount.__suppressDeprecationWarning !== !0) {
                var _componentName4 = getComponentName(Component2) || "Unknown";
                didWarnAboutDeprecatedWillMount[_componentName4] || (warn(
                  `componentWillMount has been renamed, and is not recommended for use. See https://reactjs.org/link/unsafe-component-lifecycles for details.

* Move code from componentWillMount to componentDidMount (preferred in most cases) or the constructor.

Please update the following components: %s`,
                  _componentName4
                ), didWarnAboutDeprecatedWillMount[_componentName4] = !0);
              }
              typeof Component2.getDerivedStateFromProps != "function" && inst.componentWillMount();
            }
            if (typeof inst.UNSAFE_componentWillMount == "function" && typeof Component2.getDerivedStateFromProps != "function" && inst.UNSAFE_componentWillMount(), queue2.length) {
              var oldQueue = queue2, oldReplace = replace;
              if (queue2 = null, replace = !1, oldReplace && oldQueue.length === 1)
                inst.state = oldQueue[0];
              else {
                for (var nextState = oldReplace ? oldQueue[0] : inst.state, dontMutate = !0, i2 = oldReplace ? 1 : 0; i2 < oldQueue.length; i2++) {
                  var partial = oldQueue[i2], _partialState = typeof partial == "function" ? partial.call(inst, nextState, element2.props, publicContext) : partial;
                  _partialState != null && (dontMutate ? (dontMutate = !1, nextState = _assign({}, nextState, _partialState)) : _assign(nextState, _partialState));
                }
                inst.state = nextState;
              }
            } else
              queue2 = null;
          }
          child = inst.render(), child === void 0 && inst.render._isMockFunction && (child = null), validateRenderResult(child, Component2);
          var childContext;
          {
            if (typeof inst.getChildContext == "function") {
              var _childContextTypes = Component2.childContextTypes;
              if (typeof _childContextTypes == "object") {
                childContext = inst.getChildContext();
                for (var contextKey in childContext)
                  if (!(contextKey in _childContextTypes))
                    throw Error((getComponentName(Component2) || "Unknown") + '.getChildContext(): key "' + contextKey + '" is not defined in childContextTypes.');
              } else
                error("%s.getChildContext(): childContextTypes must be defined in order to use getChildContext().", getComponentName(Component2) || "Unknown");
            }
            childContext && (context = _assign({}, context, childContext));
          }
        }
        return {
          child,
          context
        };
      }
      var ReactDOMServerRenderer = /* @__PURE__ */ function() {
        function ReactDOMServerRenderer2(children, makeStaticMarkup, options) {
          var flatChildren = flattenTopLevelChildren(children), topFrame = {
            type: null,
            domNamespace: Namespaces.html,
            children: flatChildren,
            childIndex: 0,
            context: emptyObject,
            footer: ""
          };
          topFrame.debugElementStack = [], this.threadID = allocThreadID(), this.stack = [topFrame], this.exhausted = !1, this.currentSelectValue = null, this.previousWasTextNode = !1, this.makeStaticMarkup = makeStaticMarkup, this.suspenseDepth = 0, this.contextIndex = -1, this.contextStack = [], this.contextValueStack = [], this.uniqueID = 0, this.identifierPrefix = options && options.identifierPrefix || "", this.contextProviderStack = [];
        }
        var _proto = ReactDOMServerRenderer2.prototype;
        return _proto.destroy = function() {
          this.exhausted || (this.exhausted = !0, this.clearProviders(), freeThreadID(this.threadID));
        }, _proto.pushProvider = function(provider) {
          var index = ++this.contextIndex, context = provider.type._context, threadID = this.threadID;
          validateContextBounds(context, threadID);
          var previousValue = context[threadID];
          this.contextStack[index] = context, this.contextValueStack[index] = previousValue, this.contextProviderStack[index] = provider, context[threadID] = provider.props.value;
        }, _proto.popProvider = function(provider) {
          var index = this.contextIndex;
          (index < 0 || provider !== this.contextProviderStack[index]) && error("Unexpected pop.");
          var context = this.contextStack[index], previousValue = this.contextValueStack[index];
          this.contextStack[index] = null, this.contextValueStack[index] = null, this.contextProviderStack[index] = null, this.contextIndex--, context[this.threadID] = previousValue;
        }, _proto.clearProviders = function() {
          for (var index = this.contextIndex; index >= 0; index--) {
            var context = this.contextStack[index], previousValue = this.contextValueStack[index];
            context[this.threadID] = previousValue;
          }
        }, _proto.read = function(bytes) {
          if (this.exhausted)
            return null;
          var prevPartialRenderer = currentPartialRenderer;
          setCurrentPartialRenderer(this);
          var prevDispatcher = ReactCurrentDispatcher$1.current;
          ReactCurrentDispatcher$1.current = Dispatcher;
          try {
            for (var out = [""], suspended = !1; out[0].length < bytes; ) {
              if (this.stack.length === 0) {
                this.exhausted = !0, freeThreadID(this.threadID);
                break;
              }
              var frame = this.stack[this.stack.length - 1];
              if (suspended || frame.childIndex >= frame.children.length) {
                var footer = frame.footer;
                if (footer !== "" && (this.previousWasTextNode = !1), this.stack.pop(), frame.type === "select")
                  this.currentSelectValue = null;
                else if (frame.type != null && frame.type.type != null && frame.type.type.$$typeof === REACT_PROVIDER_TYPE) {
                  var provider = frame.type;
                  this.popProvider(provider);
                } else if (frame.type === REACT_SUSPENSE_TYPE) {
                  this.suspenseDepth--;
                  var buffered = out.pop();
                  if (suspended) {
                    suspended = !1;
                    var fallbackFrame = frame.fallbackFrame;
                    if (!fallbackFrame)
                      throw Error("ReactDOMServer did not find an internal fallback frame for Suspense. This is a bug in React. Please file an issue.");
                    this.stack.push(fallbackFrame), out[this.suspenseDepth] += "<!--$!-->";
                    continue;
                  } else
                    out[this.suspenseDepth] += buffered;
                }
                out[this.suspenseDepth] += footer;
                continue;
              }
              var child = frame.children[frame.childIndex++], outBuffer = "";
              pushCurrentDebugStack(this.stack), frame.debugElementStack.length = 0;
              try {
                outBuffer += this.render(child, frame.context, frame.domNamespace);
              } catch (err) {
                if (err != null && typeof err.then == "function")
                  if (enableSuspenseServerRenderer) {
                    if (!(this.suspenseDepth > 0))
                      throw Error(`A React component suspended while rendering, but no fallback UI was specified.

Add a <Suspense fallback=...> component higher in the tree to provide a loading indicator or placeholder to display.`);
                    suspended = !0;
                  } else
                    throw Error("ReactDOMServer does not yet support Suspense.");
                else
                  throw err;
              } finally {
                popCurrentDebugStack();
              }
              out.length <= this.suspenseDepth && out.push(""), out[this.suspenseDepth] += outBuffer;
            }
            return out[0];
          } finally {
            ReactCurrentDispatcher$1.current = prevDispatcher, setCurrentPartialRenderer(prevPartialRenderer), resetHooksState();
          }
        }, _proto.render = function(child, context, parentNamespace) {
          if (typeof child == "string" || typeof child == "number") {
            var text = "" + child;
            return text === "" ? "" : this.makeStaticMarkup ? escapeTextForBrowser(text) : this.previousWasTextNode ? "<!-- -->" + escapeTextForBrowser(text) : (this.previousWasTextNode = !0, escapeTextForBrowser(text));
          } else {
            var nextChild, _resolve = resolve(child, context, this.threadID);
            if (nextChild = _resolve.child, context = _resolve.context, nextChild === null || nextChild === !1)
              return "";
            if (!React90.isValidElement(nextChild)) {
              if (nextChild != null && nextChild.$$typeof != null) {
                var $$typeof = nextChild.$$typeof;
                throw Error($$typeof === REACT_PORTAL_TYPE ? "Portals are not currently supported by the server renderer. Render them conditionally so that they only appear on the client render." : "Unknown element-like object type: " + $$typeof.toString() + ". This is likely a bug in React. Please file an issue.");
              }
              var nextChildren = toArray(nextChild), frame = {
                type: null,
                domNamespace: parentNamespace,
                children: nextChildren,
                childIndex: 0,
                context,
                footer: ""
              };
              return frame.debugElementStack = [], this.stack.push(frame), "";
            }
            var nextElement = nextChild, elementType = nextElement.type;
            if (typeof elementType == "string")
              return this.renderDOM(nextElement, context, parentNamespace);
            switch (elementType) {
              case REACT_LEGACY_HIDDEN_TYPE:
              case REACT_DEBUG_TRACING_MODE_TYPE:
              case REACT_STRICT_MODE_TYPE:
              case REACT_PROFILER_TYPE:
              case REACT_SUSPENSE_LIST_TYPE:
              case REACT_FRAGMENT_TYPE: {
                var _nextChildren = toArray(nextChild.props.children), _frame = {
                  type: null,
                  domNamespace: parentNamespace,
                  children: _nextChildren,
                  childIndex: 0,
                  context,
                  footer: ""
                };
                return _frame.debugElementStack = [], this.stack.push(_frame), "";
              }
              case REACT_SUSPENSE_TYPE:
                throw Error("ReactDOMServer does not yet support Suspense.");
              case REACT_SCOPE_TYPE:
                throw Error("ReactDOMServer does not yet support scope components.");
            }
            if (typeof elementType == "object" && elementType !== null)
              switch (elementType.$$typeof) {
                case REACT_FORWARD_REF_TYPE: {
                  var element = nextChild, _nextChildren5, componentIdentity = {};
                  prepareToUseHooks(componentIdentity), _nextChildren5 = elementType.render(element.props, element.ref), _nextChildren5 = finishHooks(elementType.render, element.props, _nextChildren5, element.ref), _nextChildren5 = toArray(_nextChildren5);
                  var _frame5 = {
                    type: null,
                    domNamespace: parentNamespace,
                    children: _nextChildren5,
                    childIndex: 0,
                    context,
                    footer: ""
                  };
                  return _frame5.debugElementStack = [], this.stack.push(_frame5), "";
                }
                case REACT_MEMO_TYPE: {
                  var _element = nextChild, _nextChildren6 = [React90.createElement(elementType.type, _assign({
                    ref: _element.ref
                  }, _element.props))], _frame6 = {
                    type: null,
                    domNamespace: parentNamespace,
                    children: _nextChildren6,
                    childIndex: 0,
                    context,
                    footer: ""
                  };
                  return _frame6.debugElementStack = [], this.stack.push(_frame6), "";
                }
                case REACT_PROVIDER_TYPE: {
                  var provider = nextChild, nextProps = provider.props, _nextChildren7 = toArray(nextProps.children), _frame7 = {
                    type: provider,
                    domNamespace: parentNamespace,
                    children: _nextChildren7,
                    childIndex: 0,
                    context,
                    footer: ""
                  };
                  return _frame7.debugElementStack = [], this.pushProvider(provider), this.stack.push(_frame7), "";
                }
                case REACT_CONTEXT_TYPE: {
                  var reactContext = nextChild.type;
                  reactContext._context === void 0 ? reactContext !== reactContext.Consumer && (hasWarnedAboutUsingContextAsConsumer || (hasWarnedAboutUsingContextAsConsumer = !0, error("Rendering <Context> directly is not supported and will be removed in a future major release. Did you mean to render <Context.Consumer> instead?"))) : reactContext = reactContext._context;
                  var _nextProps = nextChild.props, threadID = this.threadID;
                  validateContextBounds(reactContext, threadID);
                  var nextValue = reactContext[threadID], _nextChildren8 = toArray(_nextProps.children(nextValue)), _frame8 = {
                    type: nextChild,
                    domNamespace: parentNamespace,
                    children: _nextChildren8,
                    childIndex: 0,
                    context,
                    footer: ""
                  };
                  return _frame8.debugElementStack = [], this.stack.push(_frame8), "";
                }
                case REACT_FUNDAMENTAL_TYPE:
                  throw Error("ReactDOMServer does not yet support the fundamental API.");
                case REACT_LAZY_TYPE: {
                  var _element2 = nextChild, lazyComponent = nextChild.type, payload = lazyComponent._payload, init2 = lazyComponent._init, result = init2(payload), _nextChildren10 = [React90.createElement(result, _assign({
                    ref: _element2.ref
                  }, _element2.props))], _frame10 = {
                    type: null,
                    domNamespace: parentNamespace,
                    children: _nextChildren10,
                    childIndex: 0,
                    context,
                    footer: ""
                  };
                  return _frame10.debugElementStack = [], this.stack.push(_frame10), "";
                }
              }
            var info = "";
            {
              var owner = nextElement._owner;
              (elementType === void 0 || typeof elementType == "object" && elementType !== null && Object.keys(elementType).length === 0) && (info += " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.");
              var ownerName = owner ? getComponentName(owner) : null;
              ownerName && (info += `

Check the render method of \`` + ownerName + "`.");
            }
            throw Error("Element type is invalid: expected a string (for built-in components) or a class/function (for composite components) but got: " + (elementType == null ? elementType : typeof elementType) + "." + info);
          }
        }, _proto.renderDOM = function(element, context, parentNamespace) {
          var tag = element.type.toLowerCase(), namespace = parentNamespace;
          parentNamespace === Namespaces.html && (namespace = getIntrinsicNamespace(tag)), namespace === Namespaces.html && tag !== element.type && error("<%s /> is using incorrect casing. Use PascalCase for React components, or lowercase for HTML elements.", element.type), validateDangerousTag(tag);
          var props = element.props;
          if (tag === "input")
            checkControlledValueProps("input", props), props.checked !== void 0 && props.defaultChecked !== void 0 && !didWarnDefaultChecked && (error("%s contains an input of type %s with both checked and defaultChecked props. Input elements must be either controlled or uncontrolled (specify either the checked prop, or the defaultChecked prop, but not both). Decide between using a controlled or uncontrolled input element and remove one of these props. More info: https://reactjs.org/link/controlled-components", "A component", props.type), didWarnDefaultChecked = !0), props.value !== void 0 && props.defaultValue !== void 0 && !didWarnDefaultInputValue && (error("%s contains an input of type %s with both value and defaultValue props. Input elements must be either controlled or uncontrolled (specify either the value prop, or the defaultValue prop, but not both). Decide between using a controlled or uncontrolled input element and remove one of these props. More info: https://reactjs.org/link/controlled-components", "A component", props.type), didWarnDefaultInputValue = !0), props = _assign({
              type: void 0
            }, props, {
              defaultChecked: void 0,
              defaultValue: void 0,
              value: props.value != null ? props.value : props.defaultValue,
              checked: props.checked != null ? props.checked : props.defaultChecked
            });
          else if (tag === "textarea") {
            checkControlledValueProps("textarea", props), props.value !== void 0 && props.defaultValue !== void 0 && !didWarnDefaultTextareaValue && (error("Textarea elements must be either controlled or uncontrolled (specify either the value prop, or the defaultValue prop, but not both). Decide between using a controlled or uncontrolled textarea and remove one of these props. More info: https://reactjs.org/link/controlled-components"), didWarnDefaultTextareaValue = !0);
            var initialValue = props.value;
            if (initialValue == null) {
              var defaultValue = props.defaultValue, textareaChildren = props.children;
              if (textareaChildren != null) {
                if (error("Use the `defaultValue` or `value` props instead of setting children on <textarea>."), defaultValue != null)
                  throw Error("If you supply `defaultValue` on a <textarea>, do not pass children.");
                if (Array.isArray(textareaChildren)) {
                  if (!(textareaChildren.length <= 1))
                    throw Error("<textarea> can only have at most one child.");
                  textareaChildren = textareaChildren[0];
                }
                defaultValue = "" + textareaChildren;
              }
              defaultValue == null && (defaultValue = ""), initialValue = defaultValue;
            }
            props = _assign({}, props, {
              value: void 0,
              children: "" + initialValue
            });
          } else if (tag === "select") {
            {
              checkControlledValueProps("select", props);
              for (var i2 = 0; i2 < valuePropNames.length; i2++) {
                var propName = valuePropNames[i2];
                if (props[propName] != null) {
                  var isArray3 = Array.isArray(props[propName]);
                  props.multiple && !isArray3 ? error("The `%s` prop supplied to <select> must be an array if `multiple` is true.", propName) : !props.multiple && isArray3 && error("The `%s` prop supplied to <select> must be a scalar value if `multiple` is false.", propName);
                }
              }
              props.value !== void 0 && props.defaultValue !== void 0 && !didWarnDefaultSelectValue && (error("Select elements must be either controlled or uncontrolled (specify either the value prop, or the defaultValue prop, but not both). Decide between using a controlled or uncontrolled select element and remove one of these props. More info: https://reactjs.org/link/controlled-components"), didWarnDefaultSelectValue = !0);
            }
            this.currentSelectValue = props.value != null ? props.value : props.defaultValue, props = _assign({}, props, {
              value: void 0
            });
          } else if (tag === "option") {
            var selected = null, selectValue = this.currentSelectValue, optionChildren = flattenOptionChildren(props.children);
            if (selectValue != null) {
              var value;
              if (props.value != null ? value = props.value + "" : value = optionChildren, selected = !1, Array.isArray(selectValue)) {
                for (var j = 0; j < selectValue.length; j++)
                  if ("" + selectValue[j] === value) {
                    selected = !0;
                    break;
                  }
              } else
                selected = "" + selectValue === value;
              props = _assign({
                selected: void 0,
                children: void 0
              }, props, {
                selected,
                children: optionChildren
              });
            }
          }
          validatePropertiesInDevelopment(tag, props), assertValidProps(tag, props);
          var out = createOpenTagMarkup(element.type, tag, props, namespace, this.makeStaticMarkup, this.stack.length === 1), footer = "";
          omittedCloseTags.hasOwnProperty(tag) ? out += "/>" : (out += ">", footer = "</" + element.type + ">");
          var children, innerMarkup = getNonChildrenInnerMarkup(props);
          innerMarkup != null ? (children = [], newlineEatingTags.hasOwnProperty(tag) && innerMarkup.charAt(0) === `
` && (out += `
`), out += innerMarkup) : children = toArray(props.children);
          var frame = {
            domNamespace: getChildNamespace(parentNamespace, element.type),
            type: tag,
            children,
            childIndex: 0,
            context,
            footer
          };
          return frame.debugElementStack = [], this.stack.push(frame), this.previousWasTextNode = !1, out;
        }, ReactDOMServerRenderer2;
      }();
      function renderToString2(element, options) {
        var renderer = new ReactDOMServerRenderer(element, !1, options);
        try {
          var markup = renderer.read(1 / 0);
          return markup;
        } finally {
          renderer.destroy();
        }
      }
      function renderToStaticMarkup(element, options) {
        var renderer = new ReactDOMServerRenderer(element, !0, options);
        try {
          var markup = renderer.read(1 / 0);
          return markup;
        } finally {
          renderer.destroy();
        }
      }
      function _inheritsLoose2(subClass, superClass) {
        subClass.prototype = Object.create(superClass.prototype), subClass.prototype.constructor = subClass, subClass.__proto__ = superClass;
      }
      var ReactMarkupReadableStream = /* @__PURE__ */ function(_Readable) {
        _inheritsLoose2(ReactMarkupReadableStream2, _Readable);
        function ReactMarkupReadableStream2(element, makeStaticMarkup, options) {
          var _this;
          return _this = _Readable.call(this, {}) || this, _this.partialRenderer = new ReactDOMServerRenderer(element, makeStaticMarkup, options), _this;
        }
        var _proto = ReactMarkupReadableStream2.prototype;
        return _proto._destroy = function(err, callback) {
          this.partialRenderer.destroy(), callback(err);
        }, _proto._read = function(size) {
          try {
            this.push(this.partialRenderer.read(size));
          } catch (err) {
            this.destroy(err);
          }
        }, ReactMarkupReadableStream2;
      }(stream.Readable);
      function renderToNodeStream(element, options) {
        return new ReactMarkupReadableStream(element, !1, options);
      }
      function renderToStaticNodeStream(element, options) {
        return new ReactMarkupReadableStream(element, !0, options);
      }
      exports.renderToNodeStream = renderToNodeStream, exports.renderToStaticMarkup = renderToStaticMarkup, exports.renderToStaticNodeStream = renderToStaticNodeStream, exports.renderToString = renderToString2, exports.version = ReactVersion;
    })();
  }
});

// node_modules/react-dom/server.node.js
var require_server_node = __commonJS({
  "node_modules/react-dom/server.node.js"(exports, module) {
    "use strict";
    module.exports = require_react_dom_server_node_development();
  }
});

// node_modules/react-dom/server.js
var require_server = __commonJS({
  "node_modules/react-dom/server.js"(exports, module) {
    "use strict";
    module.exports = require_server_node();
  }
});

// node_modules/react/cjs/react-jsx-dev-runtime.development.js
var require_react_jsx_dev_runtime_development = __commonJS({
  "node_modules/react/cjs/react-jsx-dev-runtime.development.js"(exports) {
    "use strict";
    (function() {
      "use strict";
      var React90 = require_react(), _assign = require_object_assign(), REACT_ELEMENT_TYPE = 60103, REACT_PORTAL_TYPE = 60106;
      exports.Fragment = 60107;
      var REACT_STRICT_MODE_TYPE = 60108, REACT_PROFILER_TYPE = 60114, REACT_PROVIDER_TYPE = 60109, REACT_CONTEXT_TYPE = 60110, REACT_FORWARD_REF_TYPE = 60112, REACT_SUSPENSE_TYPE = 60113, REACT_SUSPENSE_LIST_TYPE = 60120, REACT_MEMO_TYPE = 60115, REACT_LAZY_TYPE = 60116, REACT_BLOCK_TYPE = 60121, REACT_SERVER_BLOCK_TYPE = 60122, REACT_FUNDAMENTAL_TYPE = 60117, REACT_SCOPE_TYPE = 60119, REACT_OPAQUE_ID_TYPE = 60128, REACT_DEBUG_TRACING_MODE_TYPE = 60129, REACT_OFFSCREEN_TYPE = 60130, REACT_LEGACY_HIDDEN_TYPE = 60131;
      if (typeof Symbol == "function" && Symbol.for) {
        var symbolFor = Symbol.for;
        REACT_ELEMENT_TYPE = symbolFor("react.element"), REACT_PORTAL_TYPE = symbolFor("react.portal"), exports.Fragment = symbolFor("react.fragment"), REACT_STRICT_MODE_TYPE = symbolFor("react.strict_mode"), REACT_PROFILER_TYPE = symbolFor("react.profiler"), REACT_PROVIDER_TYPE = symbolFor("react.provider"), REACT_CONTEXT_TYPE = symbolFor("react.context"), REACT_FORWARD_REF_TYPE = symbolFor("react.forward_ref"), REACT_SUSPENSE_TYPE = symbolFor("react.suspense"), REACT_SUSPENSE_LIST_TYPE = symbolFor("react.suspense_list"), REACT_MEMO_TYPE = symbolFor("react.memo"), REACT_LAZY_TYPE = symbolFor("react.lazy"), REACT_BLOCK_TYPE = symbolFor("react.block"), REACT_SERVER_BLOCK_TYPE = symbolFor("react.server.block"), REACT_FUNDAMENTAL_TYPE = symbolFor("react.fundamental"), REACT_SCOPE_TYPE = symbolFor("react.scope"), REACT_OPAQUE_ID_TYPE = symbolFor("react.opaque.id"), REACT_DEBUG_TRACING_MODE_TYPE = symbolFor("react.debug_trace_mode"), REACT_OFFSCREEN_TYPE = symbolFor("react.offscreen"), REACT_LEGACY_HIDDEN_TYPE = symbolFor("react.legacy_hidden");
      }
      var MAYBE_ITERATOR_SYMBOL = typeof Symbol == "function" && Symbol.iterator, FAUX_ITERATOR_SYMBOL = "@@iterator";
      function getIteratorFn(maybeIterable) {
        if (maybeIterable === null || typeof maybeIterable != "object")
          return null;
        var maybeIterator = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL];
        return typeof maybeIterator == "function" ? maybeIterator : null;
      }
      var ReactSharedInternals = React90.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
      function error(format2) {
        {
          for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++)
            args[_key2 - 1] = arguments[_key2];
          printWarning("error", format2, args);
        }
      }
      function printWarning(level, format2, args) {
        {
          var ReactDebugCurrentFrame2 = ReactSharedInternals.ReactDebugCurrentFrame, stack = ReactDebugCurrentFrame2.getStackAddendum();
          stack !== "" && (format2 += "%s", args = args.concat([stack]));
          var argsWithFormat = args.map(function(item) {
            return "" + item;
          });
          argsWithFormat.unshift("Warning: " + format2), Function.prototype.apply.call(console[level], console, argsWithFormat);
        }
      }
      var enableScopeAPI = !1;
      function isValidElementType(type) {
        return !!(typeof type == "string" || typeof type == "function" || type === exports.Fragment || type === REACT_PROFILER_TYPE || type === REACT_DEBUG_TRACING_MODE_TYPE || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || type === REACT_LEGACY_HIDDEN_TYPE || enableScopeAPI || typeof type == "object" && type !== null && (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_PROVIDER_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE || type.$$typeof === REACT_FUNDAMENTAL_TYPE || type.$$typeof === REACT_BLOCK_TYPE || type[0] === REACT_SERVER_BLOCK_TYPE));
      }
      function getWrappedName2(outerType, innerType, wrapperName) {
        var functionName = innerType.displayName || innerType.name || "";
        return outerType.displayName || (functionName !== "" ? wrapperName + "(" + functionName + ")" : wrapperName);
      }
      function getContextName(type) {
        return type.displayName || "Context";
      }
      function getComponentName(type) {
        if (type == null)
          return null;
        if (typeof type.tag == "number" && error("Received an unexpected object in getComponentName(). This is likely a bug in React. Please file an issue."), typeof type == "function")
          return type.displayName || type.name || null;
        if (typeof type == "string")
          return type;
        switch (type) {
          case exports.Fragment:
            return "Fragment";
          case REACT_PORTAL_TYPE:
            return "Portal";
          case REACT_PROFILER_TYPE:
            return "Profiler";
          case REACT_STRICT_MODE_TYPE:
            return "StrictMode";
          case REACT_SUSPENSE_TYPE:
            return "Suspense";
          case REACT_SUSPENSE_LIST_TYPE:
            return "SuspenseList";
        }
        if (typeof type == "object")
          switch (type.$$typeof) {
            case REACT_CONTEXT_TYPE:
              var context = type;
              return getContextName(context) + ".Consumer";
            case REACT_PROVIDER_TYPE:
              var provider = type;
              return getContextName(provider._context) + ".Provider";
            case REACT_FORWARD_REF_TYPE:
              return getWrappedName2(type, type.render, "ForwardRef");
            case REACT_MEMO_TYPE:
              return getComponentName(type.type);
            case REACT_BLOCK_TYPE:
              return getComponentName(type._render);
            case REACT_LAZY_TYPE: {
              var lazyComponent = type, payload = lazyComponent._payload, init2 = lazyComponent._init;
              try {
                return getComponentName(init2(payload));
              } catch {
                return null;
              }
            }
          }
        return null;
      }
      var disabledDepth = 0, prevLog, prevInfo, prevWarn, prevError, prevGroup, prevGroupCollapsed, prevGroupEnd;
      function disabledLog() {
      }
      disabledLog.__reactDisabledLog = !0;
      function disableLogs() {
        {
          if (disabledDepth === 0) {
            prevLog = console.log, prevInfo = console.info, prevWarn = console.warn, prevError = console.error, prevGroup = console.group, prevGroupCollapsed = console.groupCollapsed, prevGroupEnd = console.groupEnd;
            var props = {
              configurable: !0,
              enumerable: !0,
              value: disabledLog,
              writable: !0
            };
            Object.defineProperties(console, {
              info: props,
              log: props,
              warn: props,
              error: props,
              group: props,
              groupCollapsed: props,
              groupEnd: props
            });
          }
          disabledDepth++;
        }
      }
      function reenableLogs() {
        {
          if (disabledDepth--, disabledDepth === 0) {
            var props = {
              configurable: !0,
              enumerable: !0,
              writable: !0
            };
            Object.defineProperties(console, {
              log: _assign({}, props, {
                value: prevLog
              }),
              info: _assign({}, props, {
                value: prevInfo
              }),
              warn: _assign({}, props, {
                value: prevWarn
              }),
              error: _assign({}, props, {
                value: prevError
              }),
              group: _assign({}, props, {
                value: prevGroup
              }),
              groupCollapsed: _assign({}, props, {
                value: prevGroupCollapsed
              }),
              groupEnd: _assign({}, props, {
                value: prevGroupEnd
              })
            });
          }
          disabledDepth < 0 && error("disabledDepth fell below zero. This is a bug in React. Please file an issue.");
        }
      }
      var ReactCurrentDispatcher = ReactSharedInternals.ReactCurrentDispatcher, prefix;
      function describeBuiltInComponentFrame(name, source, ownerFn) {
        {
          if (prefix === void 0)
            try {
              throw Error();
            } catch (x) {
              var match = x.stack.trim().match(/\n( *(at )?)/);
              prefix = match && match[1] || "";
            }
          return `
` + prefix + name;
        }
      }
      var reentry = !1, componentFrameCache;
      {
        var PossiblyWeakMap = typeof WeakMap == "function" ? WeakMap : Map;
        componentFrameCache = new PossiblyWeakMap();
      }
      function describeNativeComponentFrame(fn, construct) {
        if (!fn || reentry)
          return "";
        {
          var frame = componentFrameCache.get(fn);
          if (frame !== void 0)
            return frame;
        }
        var control;
        reentry = !0;
        var previousPrepareStackTrace = Error.prepareStackTrace;
        Error.prepareStackTrace = void 0;
        var previousDispatcher;
        previousDispatcher = ReactCurrentDispatcher.current, ReactCurrentDispatcher.current = null, disableLogs();
        try {
          if (construct) {
            var Fake = function() {
              throw Error();
            };
            if (Object.defineProperty(Fake.prototype, "props", {
              set: function() {
                throw Error();
              }
            }), typeof Reflect == "object" && Reflect.construct) {
              try {
                Reflect.construct(Fake, []);
              } catch (x) {
                control = x;
              }
              Reflect.construct(fn, [], Fake);
            } else {
              try {
                Fake.call();
              } catch (x) {
                control = x;
              }
              fn.call(Fake.prototype);
            }
          } else {
            try {
              throw Error();
            } catch (x) {
              control = x;
            }
            fn();
          }
        } catch (sample) {
          if (sample && control && typeof sample.stack == "string") {
            for (var sampleLines = sample.stack.split(`
`), controlLines = control.stack.split(`
`), s = sampleLines.length - 1, c = controlLines.length - 1; s >= 1 && c >= 0 && sampleLines[s] !== controlLines[c]; )
              c--;
            for (; s >= 1 && c >= 0; s--, c--)
              if (sampleLines[s] !== controlLines[c]) {
                if (s !== 1 || c !== 1)
                  do
                    if (s--, c--, c < 0 || sampleLines[s] !== controlLines[c]) {
                      var _frame = `
` + sampleLines[s].replace(" at new ", " at ");
                      return typeof fn == "function" && componentFrameCache.set(fn, _frame), _frame;
                    }
                  while (s >= 1 && c >= 0);
                break;
              }
          }
        } finally {
          reentry = !1, ReactCurrentDispatcher.current = previousDispatcher, reenableLogs(), Error.prepareStackTrace = previousPrepareStackTrace;
        }
        var name = fn ? fn.displayName || fn.name : "", syntheticFrame = name ? describeBuiltInComponentFrame(name) : "";
        return typeof fn == "function" && componentFrameCache.set(fn, syntheticFrame), syntheticFrame;
      }
      function describeFunctionComponentFrame(fn, source, ownerFn) {
        return describeNativeComponentFrame(fn, !1);
      }
      function shouldConstruct(Component) {
        var prototype = Component.prototype;
        return !!(prototype && prototype.isReactComponent);
      }
      function describeUnknownElementTypeFrameInDEV(type, source, ownerFn) {
        if (type == null)
          return "";
        if (typeof type == "function")
          return describeNativeComponentFrame(type, shouldConstruct(type));
        if (typeof type == "string")
          return describeBuiltInComponentFrame(type);
        switch (type) {
          case REACT_SUSPENSE_TYPE:
            return describeBuiltInComponentFrame("Suspense");
          case REACT_SUSPENSE_LIST_TYPE:
            return describeBuiltInComponentFrame("SuspenseList");
        }
        if (typeof type == "object")
          switch (type.$$typeof) {
            case REACT_FORWARD_REF_TYPE:
              return describeFunctionComponentFrame(type.render);
            case REACT_MEMO_TYPE:
              return describeUnknownElementTypeFrameInDEV(type.type, source, ownerFn);
            case REACT_BLOCK_TYPE:
              return describeFunctionComponentFrame(type._render);
            case REACT_LAZY_TYPE: {
              var lazyComponent = type, payload = lazyComponent._payload, init2 = lazyComponent._init;
              try {
                return describeUnknownElementTypeFrameInDEV(init2(payload), source, ownerFn);
              } catch {
              }
            }
          }
        return "";
      }
      var loggedTypeFailures = {}, ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;
      function setCurrentlyValidatingElement(element) {
        if (element) {
          var owner = element._owner, stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);
          ReactDebugCurrentFrame.setExtraStackFrame(stack);
        } else
          ReactDebugCurrentFrame.setExtraStackFrame(null);
      }
      function checkPropTypes(typeSpecs, values3, location, componentName, element) {
        {
          var has = Function.call.bind(Object.prototype.hasOwnProperty);
          for (var typeSpecName in typeSpecs)
            if (has(typeSpecs, typeSpecName)) {
              var error$1 = void 0;
              try {
                if (typeof typeSpecs[typeSpecName] != "function") {
                  var err = Error((componentName || "React class") + ": " + location + " type `" + typeSpecName + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof typeSpecs[typeSpecName] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.");
                  throw err.name = "Invariant Violation", err;
                }
                error$1 = typeSpecs[typeSpecName](values3, typeSpecName, componentName, location, null, "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED");
              } catch (ex) {
                error$1 = ex;
              }
              error$1 && !(error$1 instanceof Error) && (setCurrentlyValidatingElement(element), error("%s: type specification of %s `%s` is invalid; the type checker function must return `null` or an `Error` but returned a %s. You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).", componentName || "React class", location, typeSpecName, typeof error$1), setCurrentlyValidatingElement(null)), error$1 instanceof Error && !(error$1.message in loggedTypeFailures) && (loggedTypeFailures[error$1.message] = !0, setCurrentlyValidatingElement(element), error("Failed %s type: %s", location, error$1.message), setCurrentlyValidatingElement(null));
            }
        }
      }
      var ReactCurrentOwner = ReactSharedInternals.ReactCurrentOwner, hasOwnProperty2 = Object.prototype.hasOwnProperty, RESERVED_PROPS = {
        key: !0,
        ref: !0,
        __self: !0,
        __source: !0
      }, specialPropKeyWarningShown, specialPropRefWarningShown, didWarnAboutStringRefs;
      didWarnAboutStringRefs = {};
      function hasValidRef(config2) {
        if (hasOwnProperty2.call(config2, "ref")) {
          var getter = Object.getOwnPropertyDescriptor(config2, "ref").get;
          if (getter && getter.isReactWarning)
            return !1;
        }
        return config2.ref !== void 0;
      }
      function hasValidKey(config2) {
        if (hasOwnProperty2.call(config2, "key")) {
          var getter = Object.getOwnPropertyDescriptor(config2, "key").get;
          if (getter && getter.isReactWarning)
            return !1;
        }
        return config2.key !== void 0;
      }
      function warnIfStringRefCannotBeAutoConverted(config2, self2) {
        if (typeof config2.ref == "string" && ReactCurrentOwner.current && self2 && ReactCurrentOwner.current.stateNode !== self2) {
          var componentName = getComponentName(ReactCurrentOwner.current.type);
          didWarnAboutStringRefs[componentName] || (error('Component "%s" contains the string ref "%s". Support for string refs will be removed in a future major release. This case cannot be automatically converted to an arrow function. We ask you to manually fix this case by using useRef() or createRef() instead. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-string-ref', getComponentName(ReactCurrentOwner.current.type), config2.ref), didWarnAboutStringRefs[componentName] = !0);
        }
      }
      function defineKeyPropWarningGetter(props, displayName) {
        {
          var warnAboutAccessingKey = function() {
            specialPropKeyWarningShown || (specialPropKeyWarningShown = !0, error("%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", displayName));
          };
          warnAboutAccessingKey.isReactWarning = !0, Object.defineProperty(props, "key", {
            get: warnAboutAccessingKey,
            configurable: !0
          });
        }
      }
      function defineRefPropWarningGetter(props, displayName) {
        {
          var warnAboutAccessingRef = function() {
            specialPropRefWarningShown || (specialPropRefWarningShown = !0, error("%s: `ref` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", displayName));
          };
          warnAboutAccessingRef.isReactWarning = !0, Object.defineProperty(props, "ref", {
            get: warnAboutAccessingRef,
            configurable: !0
          });
        }
      }
      var ReactElement = function(type, key, ref, self2, source, owner, props) {
        var element = {
          $$typeof: REACT_ELEMENT_TYPE,
          type,
          key,
          ref,
          props,
          _owner: owner
        };
        return element._store = {}, Object.defineProperty(element._store, "validated", {
          configurable: !1,
          enumerable: !1,
          writable: !0,
          value: !1
        }), Object.defineProperty(element, "_self", {
          configurable: !1,
          enumerable: !1,
          writable: !1,
          value: self2
        }), Object.defineProperty(element, "_source", {
          configurable: !1,
          enumerable: !1,
          writable: !1,
          value: source
        }), Object.freeze && (Object.freeze(element.props), Object.freeze(element)), element;
      };
      function jsxDEV7(type, config2, maybeKey, source, self2) {
        {
          var propName, props = {}, key = null, ref = null;
          maybeKey !== void 0 && (key = "" + maybeKey), hasValidKey(config2) && (key = "" + config2.key), hasValidRef(config2) && (ref = config2.ref, warnIfStringRefCannotBeAutoConverted(config2, self2));
          for (propName in config2)
            hasOwnProperty2.call(config2, propName) && !RESERVED_PROPS.hasOwnProperty(propName) && (props[propName] = config2[propName]);
          if (type && type.defaultProps) {
            var defaultProps2 = type.defaultProps;
            for (propName in defaultProps2)
              props[propName] === void 0 && (props[propName] = defaultProps2[propName]);
          }
          if (key || ref) {
            var displayName = typeof type == "function" ? type.displayName || type.name || "Unknown" : type;
            key && defineKeyPropWarningGetter(props, displayName), ref && defineRefPropWarningGetter(props, displayName);
          }
          return ReactElement(type, key, ref, self2, source, ReactCurrentOwner.current, props);
        }
      }
      var ReactCurrentOwner$1 = ReactSharedInternals.ReactCurrentOwner, ReactDebugCurrentFrame$1 = ReactSharedInternals.ReactDebugCurrentFrame;
      function setCurrentlyValidatingElement$1(element) {
        if (element) {
          var owner = element._owner, stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);
          ReactDebugCurrentFrame$1.setExtraStackFrame(stack);
        } else
          ReactDebugCurrentFrame$1.setExtraStackFrame(null);
      }
      var propTypesMisspellWarningShown;
      propTypesMisspellWarningShown = !1;
      function isValidElement9(object) {
        return typeof object == "object" && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;
      }
      function getDeclarationErrorAddendum() {
        {
          if (ReactCurrentOwner$1.current) {
            var name = getComponentName(ReactCurrentOwner$1.current.type);
            if (name)
              return `

Check the render method of \`` + name + "`.";
          }
          return "";
        }
      }
      function getSourceInfoErrorAddendum(source) {
        {
          if (source !== void 0) {
            var fileName = source.fileName.replace(/^.*[\\\/]/, ""), lineNumber = source.lineNumber;
            return `

Check your code at ` + fileName + ":" + lineNumber + ".";
          }
          return "";
        }
      }
      var ownerHasKeyUseWarning = {};
      function getCurrentComponentErrorInfo(parentType) {
        {
          var info = getDeclarationErrorAddendum();
          if (!info) {
            var parentName = typeof parentType == "string" ? parentType : parentType.displayName || parentType.name;
            parentName && (info = `

Check the top-level render call using <` + parentName + ">.");
          }
          return info;
        }
      }
      function validateExplicitKey(element, parentType) {
        {
          if (!element._store || element._store.validated || element.key != null)
            return;
          element._store.validated = !0;
          var currentComponentErrorInfo = getCurrentComponentErrorInfo(parentType);
          if (ownerHasKeyUseWarning[currentComponentErrorInfo])
            return;
          ownerHasKeyUseWarning[currentComponentErrorInfo] = !0;
          var childOwner = "";
          element && element._owner && element._owner !== ReactCurrentOwner$1.current && (childOwner = " It was passed a child from " + getComponentName(element._owner.type) + "."), setCurrentlyValidatingElement$1(element), error('Each child in a list should have a unique "key" prop.%s%s See https://reactjs.org/link/warning-keys for more information.', currentComponentErrorInfo, childOwner), setCurrentlyValidatingElement$1(null);
        }
      }
      function validateChildKeys(node, parentType) {
        {
          if (typeof node != "object")
            return;
          if (Array.isArray(node))
            for (var i = 0; i < node.length; i++) {
              var child = node[i];
              isValidElement9(child) && validateExplicitKey(child, parentType);
            }
          else if (isValidElement9(node))
            node._store && (node._store.validated = !0);
          else if (node) {
            var iteratorFn = getIteratorFn(node);
            if (typeof iteratorFn == "function" && iteratorFn !== node.entries)
              for (var iterator = iteratorFn.call(node), step; !(step = iterator.next()).done; )
                isValidElement9(step.value) && validateExplicitKey(step.value, parentType);
          }
        }
      }
      function validatePropTypes(element) {
        {
          var type = element.type;
          if (type == null || typeof type == "string")
            return;
          var propTypes;
          if (typeof type == "function")
            propTypes = type.propTypes;
          else if (typeof type == "object" && (type.$$typeof === REACT_FORWARD_REF_TYPE || type.$$typeof === REACT_MEMO_TYPE))
            propTypes = type.propTypes;
          else
            return;
          if (propTypes) {
            var name = getComponentName(type);
            checkPropTypes(propTypes, element.props, "prop", name, element);
          } else if (type.PropTypes !== void 0 && !propTypesMisspellWarningShown) {
            propTypesMisspellWarningShown = !0;
            var _name = getComponentName(type);
            error("Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?", _name || "Unknown");
          }
          typeof type.getDefaultProps == "function" && !type.getDefaultProps.isReactClassApproved && error("getDefaultProps is only used on classic React.createClass definitions. Use a static property named `defaultProps` instead.");
        }
      }
      function validateFragmentProps(fragment) {
        {
          for (var keys2 = Object.keys(fragment.props), i = 0; i < keys2.length; i++) {
            var key = keys2[i];
            if (key !== "children" && key !== "key") {
              setCurrentlyValidatingElement$1(fragment), error("Invalid prop `%s` supplied to `React.Fragment`. React.Fragment can only have `key` and `children` props.", key), setCurrentlyValidatingElement$1(null);
              break;
            }
          }
          fragment.ref !== null && (setCurrentlyValidatingElement$1(fragment), error("Invalid attribute `ref` supplied to `React.Fragment`."), setCurrentlyValidatingElement$1(null));
        }
      }
      function jsxWithValidation(type, props, key, isStaticChildren, source, self2) {
        {
          var validType = isValidElementType(type);
          if (!validType) {
            var info = "";
            (type === void 0 || typeof type == "object" && type !== null && Object.keys(type).length === 0) && (info += " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.");
            var sourceInfo = getSourceInfoErrorAddendum(source);
            sourceInfo ? info += sourceInfo : info += getDeclarationErrorAddendum();
            var typeString;
            type === null ? typeString = "null" : Array.isArray(type) ? typeString = "array" : type !== void 0 && type.$$typeof === REACT_ELEMENT_TYPE ? (typeString = "<" + (getComponentName(type.type) || "Unknown") + " />", info = " Did you accidentally export a JSX literal instead of a component?") : typeString = typeof type, error("React.jsx: type is invalid -- expected a string (for built-in components) or a class/function (for composite components) but got: %s.%s", typeString, info);
          }
          var element = jsxDEV7(type, props, key, source, self2);
          if (element == null)
            return element;
          if (validType) {
            var children = props.children;
            if (children !== void 0)
              if (isStaticChildren)
                if (Array.isArray(children)) {
                  for (var i = 0; i < children.length; i++)
                    validateChildKeys(children[i], type);
                  Object.freeze && Object.freeze(children);
                } else
                  error("React.jsx: Static children should always be an array. You are likely explicitly calling React.jsxs or React.jsxDEV. Use the Babel transform instead.");
              else
                validateChildKeys(children, type);
          }
          return type === exports.Fragment ? validateFragmentProps(element) : validatePropTypes(element), element;
        }
      }
      var jsxDEV$1 = jsxWithValidation;
      exports.jsxDEV = jsxDEV$1;
    })();
  }
});

// node_modules/react/jsx-dev-runtime.js
var require_jsx_dev_runtime = __commonJS({
  "node_modules/react/jsx-dev-runtime.js"(exports, module) {
    "use strict";
    module.exports = require_react_jsx_dev_runtime_development();
  }
});

// node_modules/@babel/runtime/helpers/esm/objectWithoutPropertiesLoose.js
function _objectWithoutPropertiesLoose2(source, excluded) {
  if (source == null)
    return {};
  var target = {}, sourceKeys = Object.keys(source), key, i;
  for (i = 0; i < sourceKeys.length; i++)
    key = sourceKeys[i], !(excluded.indexOf(key) >= 0) && (target[key] = source[key]);
  return target;
}
var init_objectWithoutPropertiesLoose = __esm({
  "node_modules/@babel/runtime/helpers/esm/objectWithoutPropertiesLoose.js"() {
  }
});

// node_modules/prop-types/node_modules/react-is/cjs/react-is.development.js
var require_react_is_development = __commonJS({
  "node_modules/prop-types/node_modules/react-is/cjs/react-is.development.js"(exports) {
    "use strict";
    (function() {
      "use strict";
      var hasSymbol = typeof Symbol == "function" && Symbol.for, REACT_ELEMENT_TYPE = hasSymbol ? Symbol.for("react.element") : 60103, REACT_PORTAL_TYPE = hasSymbol ? Symbol.for("react.portal") : 60106, REACT_FRAGMENT_TYPE = hasSymbol ? Symbol.for("react.fragment") : 60107, REACT_STRICT_MODE_TYPE = hasSymbol ? Symbol.for("react.strict_mode") : 60108, REACT_PROFILER_TYPE = hasSymbol ? Symbol.for("react.profiler") : 60114, REACT_PROVIDER_TYPE = hasSymbol ? Symbol.for("react.provider") : 60109, REACT_CONTEXT_TYPE = hasSymbol ? Symbol.for("react.context") : 60110, REACT_ASYNC_MODE_TYPE = hasSymbol ? Symbol.for("react.async_mode") : 60111, REACT_CONCURRENT_MODE_TYPE = hasSymbol ? Symbol.for("react.concurrent_mode") : 60111, REACT_FORWARD_REF_TYPE = hasSymbol ? Symbol.for("react.forward_ref") : 60112, REACT_SUSPENSE_TYPE = hasSymbol ? Symbol.for("react.suspense") : 60113, REACT_SUSPENSE_LIST_TYPE = hasSymbol ? Symbol.for("react.suspense_list") : 60120, REACT_MEMO_TYPE = hasSymbol ? Symbol.for("react.memo") : 60115, REACT_LAZY_TYPE = hasSymbol ? Symbol.for("react.lazy") : 60116, REACT_BLOCK_TYPE = hasSymbol ? Symbol.for("react.block") : 60121, REACT_FUNDAMENTAL_TYPE = hasSymbol ? Symbol.for("react.fundamental") : 60117, REACT_RESPONDER_TYPE = hasSymbol ? Symbol.for("react.responder") : 60118, REACT_SCOPE_TYPE = hasSymbol ? Symbol.for("react.scope") : 60119;
      function isValidElementType(type) {
        return typeof type == "string" || typeof type == "function" || type === REACT_FRAGMENT_TYPE || type === REACT_CONCURRENT_MODE_TYPE || type === REACT_PROFILER_TYPE || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || typeof type == "object" && type !== null && (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_PROVIDER_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE || type.$$typeof === REACT_FUNDAMENTAL_TYPE || type.$$typeof === REACT_RESPONDER_TYPE || type.$$typeof === REACT_SCOPE_TYPE || type.$$typeof === REACT_BLOCK_TYPE);
      }
      function typeOf(object) {
        if (typeof object == "object" && object !== null) {
          var $$typeof = object.$$typeof;
          switch ($$typeof) {
            case REACT_ELEMENT_TYPE:
              var type = object.type;
              switch (type) {
                case REACT_ASYNC_MODE_TYPE:
                case REACT_CONCURRENT_MODE_TYPE:
                case REACT_FRAGMENT_TYPE:
                case REACT_PROFILER_TYPE:
                case REACT_STRICT_MODE_TYPE:
                case REACT_SUSPENSE_TYPE:
                  return type;
                default:
                  var $$typeofType = type && type.$$typeof;
                  switch ($$typeofType) {
                    case REACT_CONTEXT_TYPE:
                    case REACT_FORWARD_REF_TYPE:
                    case REACT_LAZY_TYPE:
                    case REACT_MEMO_TYPE:
                    case REACT_PROVIDER_TYPE:
                      return $$typeofType;
                    default:
                      return $$typeof;
                  }
              }
            case REACT_PORTAL_TYPE:
              return $$typeof;
          }
        }
      }
      var AsyncMode = REACT_ASYNC_MODE_TYPE, ConcurrentMode = REACT_CONCURRENT_MODE_TYPE, ContextConsumer = REACT_CONTEXT_TYPE, ContextProvider = REACT_PROVIDER_TYPE, Element2 = REACT_ELEMENT_TYPE, ForwardRef2 = REACT_FORWARD_REF_TYPE, Fragment11 = REACT_FRAGMENT_TYPE, Lazy = REACT_LAZY_TYPE, Memo2 = REACT_MEMO_TYPE, Portal3 = REACT_PORTAL_TYPE, Profiler = REACT_PROFILER_TYPE, StrictMode = REACT_STRICT_MODE_TYPE, Suspense = REACT_SUSPENSE_TYPE, hasWarnedAboutDeprecatedIsAsyncMode = !1;
      function isAsyncMode(object) {
        return hasWarnedAboutDeprecatedIsAsyncMode || (hasWarnedAboutDeprecatedIsAsyncMode = !0, console.warn("The ReactIs.isAsyncMode() alias has been deprecated, and will be removed in React 17+. Update your code to use ReactIs.isConcurrentMode() instead. It has the exact same API.")), isConcurrentMode(object) || typeOf(object) === REACT_ASYNC_MODE_TYPE;
      }
      function isConcurrentMode(object) {
        return typeOf(object) === REACT_CONCURRENT_MODE_TYPE;
      }
      function isContextConsumer(object) {
        return typeOf(object) === REACT_CONTEXT_TYPE;
      }
      function isContextProvider(object) {
        return typeOf(object) === REACT_PROVIDER_TYPE;
      }
      function isElement(object) {
        return typeof object == "object" && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;
      }
      function isForwardRef(object) {
        return typeOf(object) === REACT_FORWARD_REF_TYPE;
      }
      function isFragment4(object) {
        return typeOf(object) === REACT_FRAGMENT_TYPE;
      }
      function isLazy(object) {
        return typeOf(object) === REACT_LAZY_TYPE;
      }
      function isMemo(object) {
        return typeOf(object) === REACT_MEMO_TYPE;
      }
      function isPortal(object) {
        return typeOf(object) === REACT_PORTAL_TYPE;
      }
      function isProfiler(object) {
        return typeOf(object) === REACT_PROFILER_TYPE;
      }
      function isStrictMode(object) {
        return typeOf(object) === REACT_STRICT_MODE_TYPE;
      }
      function isSuspense(object) {
        return typeOf(object) === REACT_SUSPENSE_TYPE;
      }
      exports.AsyncMode = AsyncMode, exports.ConcurrentMode = ConcurrentMode, exports.ContextConsumer = ContextConsumer, exports.ContextProvider = ContextProvider, exports.Element = Element2, exports.ForwardRef = ForwardRef2, exports.Fragment = Fragment11, exports.Lazy = Lazy, exports.Memo = Memo2, exports.Portal = Portal3, exports.Profiler = Profiler, exports.StrictMode = StrictMode, exports.Suspense = Suspense, exports.isAsyncMode = isAsyncMode, exports.isConcurrentMode = isConcurrentMode, exports.isContextConsumer = isContextConsumer, exports.isContextProvider = isContextProvider, exports.isElement = isElement, exports.isForwardRef = isForwardRef, exports.isFragment = isFragment4, exports.isLazy = isLazy, exports.isMemo = isMemo, exports.isPortal = isPortal, exports.isProfiler = isProfiler, exports.isStrictMode = isStrictMode, exports.isSuspense = isSuspense, exports.isValidElementType = isValidElementType, exports.typeOf = typeOf;
    })();
  }
});

// node_modules/prop-types/node_modules/react-is/index.js
var require_react_is = __commonJS({
  "node_modules/prop-types/node_modules/react-is/index.js"(exports, module) {
    "use strict";
    module.exports = require_react_is_development();
  }
});

// node_modules/prop-types/lib/ReactPropTypesSecret.js
var require_ReactPropTypesSecret = __commonJS({
  "node_modules/prop-types/lib/ReactPropTypesSecret.js"(exports, module) {
    "use strict";
    var ReactPropTypesSecret = "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED";
    module.exports = ReactPropTypesSecret;
  }
});

// node_modules/prop-types/lib/has.js
var require_has = __commonJS({
  "node_modules/prop-types/lib/has.js"(exports, module) {
    module.exports = Function.call.bind(Object.prototype.hasOwnProperty);
  }
});

// node_modules/prop-types/checkPropTypes.js
var require_checkPropTypes = __commonJS({
  "node_modules/prop-types/checkPropTypes.js"(exports, module) {
    "use strict";
    var printWarning = function() {
    };
    ReactPropTypesSecret = require_ReactPropTypesSecret(), loggedTypeFailures = {}, has = require_has(), printWarning = function(text) {
      var message = "Warning: " + text;
      typeof console < "u" && console.error(message);
      try {
        throw new Error(message);
      } catch {
      }
    };
    var ReactPropTypesSecret, loggedTypeFailures, has;
    function checkPropTypes(typeSpecs, values3, location, componentName, getStack) {
      for (var typeSpecName in typeSpecs)
        if (has(typeSpecs, typeSpecName)) {
          var error;
          try {
            if (typeof typeSpecs[typeSpecName] != "function") {
              var err = Error(
                (componentName || "React class") + ": " + location + " type `" + typeSpecName + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof typeSpecs[typeSpecName] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`."
              );
              throw err.name = "Invariant Violation", err;
            }
            error = typeSpecs[typeSpecName](values3, typeSpecName, componentName, location, null, ReactPropTypesSecret);
          } catch (ex) {
            error = ex;
          }
          if (error && !(error instanceof Error) && printWarning(
            (componentName || "React class") + ": type specification of " + location + " `" + typeSpecName + "` is invalid; the type checker function must return `null` or an `Error` but returned a " + typeof error + ". You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument)."
          ), error instanceof Error && !(error.message in loggedTypeFailures)) {
            loggedTypeFailures[error.message] = !0;
            var stack = getStack ? getStack() : "";
            printWarning(
              "Failed " + location + " type: " + error.message + (stack ?? "")
            );
          }
        }
    }
    checkPropTypes.resetWarningCache = function() {
      loggedTypeFailures = {};
    };
    module.exports = checkPropTypes;
  }
});

// node_modules/prop-types/factoryWithTypeCheckers.js
var require_factoryWithTypeCheckers = __commonJS({
  "node_modules/prop-types/factoryWithTypeCheckers.js"(exports, module) {
    "use strict";
    var ReactIs = require_react_is(), assign = require_object_assign(), ReactPropTypesSecret = require_ReactPropTypesSecret(), has = require_has(), checkPropTypes = require_checkPropTypes(), printWarning = function() {
    };
    printWarning = function(text) {
      var message = "Warning: " + text;
      typeof console < "u" && console.error(message);
      try {
        throw new Error(message);
      } catch {
      }
    };
    function emptyFunctionThatReturnsNull() {
      return null;
    }
    module.exports = function(isValidElement9, throwOnDirectAccess) {
      var ITERATOR_SYMBOL = typeof Symbol == "function" && Symbol.iterator, FAUX_ITERATOR_SYMBOL = "@@iterator";
      function getIteratorFn(maybeIterable) {
        var iteratorFn = maybeIterable && (ITERATOR_SYMBOL && maybeIterable[ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL]);
        if (typeof iteratorFn == "function")
          return iteratorFn;
      }
      var ANONYMOUS = "<<anonymous>>", ReactPropTypes = {
        array: createPrimitiveTypeChecker("array"),
        bigint: createPrimitiveTypeChecker("bigint"),
        bool: createPrimitiveTypeChecker("boolean"),
        func: createPrimitiveTypeChecker("function"),
        number: createPrimitiveTypeChecker("number"),
        object: createPrimitiveTypeChecker("object"),
        string: createPrimitiveTypeChecker("string"),
        symbol: createPrimitiveTypeChecker("symbol"),
        any: createAnyTypeChecker(),
        arrayOf: createArrayOfTypeChecker,
        element: createElementTypeChecker(),
        elementType: createElementTypeTypeChecker(),
        instanceOf: createInstanceTypeChecker,
        node: createNodeChecker(),
        objectOf: createObjectOfTypeChecker,
        oneOf: createEnumTypeChecker,
        oneOfType: createUnionTypeChecker,
        shape: createShapeTypeChecker,
        exact: createStrictShapeTypeChecker
      };
      function is(x, y) {
        return x === y ? x !== 0 || 1 / x === 1 / y : x !== x && y !== y;
      }
      function PropTypeError(message, data) {
        this.message = message, this.data = data && typeof data == "object" ? data : {}, this.stack = "";
      }
      PropTypeError.prototype = Error.prototype;
      function createChainableTypeChecker(validate) {
        var manualPropTypeCallCache = {}, manualPropTypeWarningCount = 0;
        function checkType(isRequired, props, propName, componentName, location, propFullName, secret) {
          if (componentName = componentName || ANONYMOUS, propFullName = propFullName || propName, secret !== ReactPropTypesSecret) {
            if (throwOnDirectAccess) {
              var err = new Error(
                "Calling PropTypes validators directly is not supported by the `prop-types` package. Use `PropTypes.checkPropTypes()` to call them. Read more at http://fb.me/use-check-prop-types"
              );
              throw err.name = "Invariant Violation", err;
            } else if (typeof console < "u") {
              var cacheKey = componentName + ":" + propName;
              !manualPropTypeCallCache[cacheKey] && manualPropTypeWarningCount < 3 && (printWarning(
                "You are manually calling a React.PropTypes validation function for the `" + propFullName + "` prop on `" + componentName + "`. This is deprecated and will throw in the standalone `prop-types` package. You may be seeing this warning due to a third-party PropTypes library. See https://fb.me/react-warning-dont-call-proptypes for details."
              ), manualPropTypeCallCache[cacheKey] = !0, manualPropTypeWarningCount++);
            }
          }
          return props[propName] == null ? isRequired ? props[propName] === null ? new PropTypeError("The " + location + " `" + propFullName + "` is marked as required " + ("in `" + componentName + "`, but its value is `null`.")) : new PropTypeError("The " + location + " `" + propFullName + "` is marked as required in " + ("`" + componentName + "`, but its value is `undefined`.")) : null : validate(props, propName, componentName, location, propFullName);
        }
        var chainedCheckType = checkType.bind(null, !1);
        return chainedCheckType.isRequired = checkType.bind(null, !0), chainedCheckType;
      }
      function createPrimitiveTypeChecker(expectedType) {
        function validate(props, propName, componentName, location, propFullName, secret) {
          var propValue = props[propName], propType = getPropType(propValue);
          if (propType !== expectedType) {
            var preciseType = getPreciseType(propValue);
            return new PropTypeError(
              "Invalid " + location + " `" + propFullName + "` of type " + ("`" + preciseType + "` supplied to `" + componentName + "`, expected ") + ("`" + expectedType + "`."),
              { expectedType }
            );
          }
          return null;
        }
        return createChainableTypeChecker(validate);
      }
      function createAnyTypeChecker() {
        return createChainableTypeChecker(emptyFunctionThatReturnsNull);
      }
      function createArrayOfTypeChecker(typeChecker) {
        function validate(props, propName, componentName, location, propFullName) {
          if (typeof typeChecker != "function")
            return new PropTypeError("Property `" + propFullName + "` of component `" + componentName + "` has invalid PropType notation inside arrayOf.");
          var propValue = props[propName];
          if (!Array.isArray(propValue)) {
            var propType = getPropType(propValue);
            return new PropTypeError("Invalid " + location + " `" + propFullName + "` of type " + ("`" + propType + "` supplied to `" + componentName + "`, expected an array."));
          }
          for (var i = 0; i < propValue.length; i++) {
            var error = typeChecker(propValue, i, componentName, location, propFullName + "[" + i + "]", ReactPropTypesSecret);
            if (error instanceof Error)
              return error;
          }
          return null;
        }
        return createChainableTypeChecker(validate);
      }
      function createElementTypeChecker() {
        function validate(props, propName, componentName, location, propFullName) {
          var propValue = props[propName];
          if (!isValidElement9(propValue)) {
            var propType = getPropType(propValue);
            return new PropTypeError("Invalid " + location + " `" + propFullName + "` of type " + ("`" + propType + "` supplied to `" + componentName + "`, expected a single ReactElement."));
          }
          return null;
        }
        return createChainableTypeChecker(validate);
      }
      function createElementTypeTypeChecker() {
        function validate(props, propName, componentName, location, propFullName) {
          var propValue = props[propName];
          if (!ReactIs.isValidElementType(propValue)) {
            var propType = getPropType(propValue);
            return new PropTypeError("Invalid " + location + " `" + propFullName + "` of type " + ("`" + propType + "` supplied to `" + componentName + "`, expected a single ReactElement type."));
          }
          return null;
        }
        return createChainableTypeChecker(validate);
      }
      function createInstanceTypeChecker(expectedClass) {
        function validate(props, propName, componentName, location, propFullName) {
          if (!(props[propName] instanceof expectedClass)) {
            var expectedClassName = expectedClass.name || ANONYMOUS, actualClassName = getClassName(props[propName]);
            return new PropTypeError("Invalid " + location + " `" + propFullName + "` of type " + ("`" + actualClassName + "` supplied to `" + componentName + "`, expected ") + ("instance of `" + expectedClassName + "`."));
          }
          return null;
        }
        return createChainableTypeChecker(validate);
      }
      function createEnumTypeChecker(expectedValues) {
        if (!Array.isArray(expectedValues))
          return arguments.length > 1 ? printWarning(
            "Invalid arguments supplied to oneOf, expected an array, got " + arguments.length + " arguments. A common mistake is to write oneOf(x, y, z) instead of oneOf([x, y, z])."
          ) : printWarning("Invalid argument supplied to oneOf, expected an array."), emptyFunctionThatReturnsNull;
        function validate(props, propName, componentName, location, propFullName) {
          for (var propValue = props[propName], i = 0; i < expectedValues.length; i++)
            if (is(propValue, expectedValues[i]))
              return null;
          var valuesString = JSON.stringify(expectedValues, function(key, value) {
            var type = getPreciseType(value);
            return type === "symbol" ? String(value) : value;
          });
          return new PropTypeError("Invalid " + location + " `" + propFullName + "` of value `" + String(propValue) + "` " + ("supplied to `" + componentName + "`, expected one of " + valuesString + "."));
        }
        return createChainableTypeChecker(validate);
      }
      function createObjectOfTypeChecker(typeChecker) {
        function validate(props, propName, componentName, location, propFullName) {
          if (typeof typeChecker != "function")
            return new PropTypeError("Property `" + propFullName + "` of component `" + componentName + "` has invalid PropType notation inside objectOf.");
          var propValue = props[propName], propType = getPropType(propValue);
          if (propType !== "object")
            return new PropTypeError("Invalid " + location + " `" + propFullName + "` of type " + ("`" + propType + "` supplied to `" + componentName + "`, expected an object."));
          for (var key in propValue)
            if (has(propValue, key)) {
              var error = typeChecker(propValue, key, componentName, location, propFullName + "." + key, ReactPropTypesSecret);
              if (error instanceof Error)
                return error;
            }
          return null;
        }
        return createChainableTypeChecker(validate);
      }
      function createUnionTypeChecker(arrayOfTypeCheckers) {
        if (!Array.isArray(arrayOfTypeCheckers))
          return printWarning("Invalid argument supplied to oneOfType, expected an instance of array."), emptyFunctionThatReturnsNull;
        for (var i = 0; i < arrayOfTypeCheckers.length; i++) {
          var checker = arrayOfTypeCheckers[i];
          if (typeof checker != "function")
            return printWarning(
              "Invalid argument supplied to oneOfType. Expected an array of check functions, but received " + getPostfixForTypeWarning(checker) + " at index " + i + "."
            ), emptyFunctionThatReturnsNull;
        }
        function validate(props, propName, componentName, location, propFullName) {
          for (var expectedTypes = [], i2 = 0; i2 < arrayOfTypeCheckers.length; i2++) {
            var checker2 = arrayOfTypeCheckers[i2], checkerResult = checker2(props, propName, componentName, location, propFullName, ReactPropTypesSecret);
            if (checkerResult == null)
              return null;
            checkerResult.data && has(checkerResult.data, "expectedType") && expectedTypes.push(checkerResult.data.expectedType);
          }
          var expectedTypesMessage = expectedTypes.length > 0 ? ", expected one of type [" + expectedTypes.join(", ") + "]" : "";
          return new PropTypeError("Invalid " + location + " `" + propFullName + "` supplied to " + ("`" + componentName + "`" + expectedTypesMessage + "."));
        }
        return createChainableTypeChecker(validate);
      }
      function createNodeChecker() {
        function validate(props, propName, componentName, location, propFullName) {
          return isNode(props[propName]) ? null : new PropTypeError("Invalid " + location + " `" + propFullName + "` supplied to " + ("`" + componentName + "`, expected a ReactNode."));
        }
        return createChainableTypeChecker(validate);
      }
      function invalidValidatorError(componentName, location, propFullName, key, type) {
        return new PropTypeError(
          (componentName || "React class") + ": " + location + " type `" + propFullName + "." + key + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + type + "`."
        );
      }
      function createShapeTypeChecker(shapeTypes) {
        function validate(props, propName, componentName, location, propFullName) {
          var propValue = props[propName], propType = getPropType(propValue);
          if (propType !== "object")
            return new PropTypeError("Invalid " + location + " `" + propFullName + "` of type `" + propType + "` " + ("supplied to `" + componentName + "`, expected `object`."));
          for (var key in shapeTypes) {
            var checker = shapeTypes[key];
            if (typeof checker != "function")
              return invalidValidatorError(componentName, location, propFullName, key, getPreciseType(checker));
            var error = checker(propValue, key, componentName, location, propFullName + "." + key, ReactPropTypesSecret);
            if (error)
              return error;
          }
          return null;
        }
        return createChainableTypeChecker(validate);
      }
      function createStrictShapeTypeChecker(shapeTypes) {
        function validate(props, propName, componentName, location, propFullName) {
          var propValue = props[propName], propType = getPropType(propValue);
          if (propType !== "object")
            return new PropTypeError("Invalid " + location + " `" + propFullName + "` of type `" + propType + "` " + ("supplied to `" + componentName + "`, expected `object`."));
          var allKeys = assign({}, props[propName], shapeTypes);
          for (var key in allKeys) {
            var checker = shapeTypes[key];
            if (has(shapeTypes, key) && typeof checker != "function")
              return invalidValidatorError(componentName, location, propFullName, key, getPreciseType(checker));
            if (!checker)
              return new PropTypeError(
                "Invalid " + location + " `" + propFullName + "` key `" + key + "` supplied to `" + componentName + "`.\nBad object: " + JSON.stringify(props[propName], null, "  ") + `
Valid keys: ` + JSON.stringify(Object.keys(shapeTypes), null, "  ")
              );
            var error = checker(propValue, key, componentName, location, propFullName + "." + key, ReactPropTypesSecret);
            if (error)
              return error;
          }
          return null;
        }
        return createChainableTypeChecker(validate);
      }
      function isNode(propValue) {
        switch (typeof propValue) {
          case "number":
          case "string":
          case "undefined":
            return !0;
          case "boolean":
            return !propValue;
          case "object":
            if (Array.isArray(propValue))
              return propValue.every(isNode);
            if (propValue === null || isValidElement9(propValue))
              return !0;
            var iteratorFn = getIteratorFn(propValue);
            if (iteratorFn) {
              var iterator = iteratorFn.call(propValue), step;
              if (iteratorFn !== propValue.entries) {
                for (; !(step = iterator.next()).done; )
                  if (!isNode(step.value))
                    return !1;
              } else
                for (; !(step = iterator.next()).done; ) {
                  var entry2 = step.value;
                  if (entry2 && !isNode(entry2[1]))
                    return !1;
                }
            } else
              return !1;
            return !0;
          default:
            return !1;
        }
      }
      function isSymbol(propType, propValue) {
        return propType === "symbol" ? !0 : propValue ? propValue["@@toStringTag"] === "Symbol" || typeof Symbol == "function" && propValue instanceof Symbol : !1;
      }
      function getPropType(propValue) {
        var propType = typeof propValue;
        return Array.isArray(propValue) ? "array" : propValue instanceof RegExp ? "object" : isSymbol(propType, propValue) ? "symbol" : propType;
      }
      function getPreciseType(propValue) {
        if (typeof propValue > "u" || propValue === null)
          return "" + propValue;
        var propType = getPropType(propValue);
        if (propType === "object") {
          if (propValue instanceof Date)
            return "date";
          if (propValue instanceof RegExp)
            return "regexp";
        }
        return propType;
      }
      function getPostfixForTypeWarning(value) {
        var type = getPreciseType(value);
        switch (type) {
          case "array":
          case "object":
            return "an " + type;
          case "boolean":
          case "date":
          case "regexp":
            return "a " + type;
          default:
            return type;
        }
      }
      function getClassName(propValue) {
        return !propValue.constructor || !propValue.constructor.name ? ANONYMOUS : propValue.constructor.name;
      }
      return ReactPropTypes.checkPropTypes = checkPropTypes, ReactPropTypes.resetWarningCache = checkPropTypes.resetWarningCache, ReactPropTypes.PropTypes = ReactPropTypes, ReactPropTypes;
    };
  }
});

// node_modules/prop-types/index.js
var require_prop_types = __commonJS({
  "node_modules/prop-types/index.js"(exports, module) {
    ReactIs = require_react_is(), throwOnDirectAccess = !0, module.exports = require_factoryWithTypeCheckers()(ReactIs.isElement, throwOnDirectAccess);
    var ReactIs, throwOnDirectAccess;
  }
});

// node_modules/clsx/dist/clsx.m.js
function r(e) {
  var t, f, n = "";
  if (typeof e == "string" || typeof e == "number")
    n += e;
  else if (typeof e == "object")
    if (Array.isArray(e))
      for (t = 0; t < e.length; t++)
        e[t] && (f = r(e[t])) && (n && (n += " "), n += f);
    else
      for (t in e)
        e[t] && (n && (n += " "), n += t);
  return n;
}
function clsx() {
  for (var e, t, f = 0, n = ""; f < arguments.length; )
    (e = arguments[f++]) && (t = r(e)) && (n && (n += " "), n += t);
  return n;
}
var clsx_m_default, init_clsx_m = __esm({
  "node_modules/clsx/dist/clsx.m.js"() {
    clsx_m_default = clsx;
  }
});

// node_modules/@mui/utils/esm/chainPropTypes.js
function chainPropTypes(propType1, propType2) {
  return function(...args) {
    return propType1(...args) || propType2(...args);
  };
}
var init_chainPropTypes = __esm({
  "node_modules/@mui/utils/esm/chainPropTypes.js"() {
  }
});

// node_modules/@mui/utils/esm/deepmerge.js
function isPlainObject(item) {
  return item !== null && typeof item == "object" && item.constructor === Object;
}
function deepmerge(target, source, options = {
  clone: !0
}) {
  let output = options.clone ? _extends({}, target) : target;
  return isPlainObject(target) && isPlainObject(source) && Object.keys(source).forEach((key) => {
    key !== "__proto__" && (isPlainObject(source[key]) && key in target && isPlainObject(target[key]) ? output[key] = deepmerge(target[key], source[key], options) : output[key] = source[key]);
  }), output;
}
var init_deepmerge = __esm({
  "node_modules/@mui/utils/esm/deepmerge.js"() {
    init_extends();
  }
});

// node_modules/@mui/utils/esm/elementAcceptingRef.js
function isClassComponent(elementType) {
  let {
    prototype = {}
  } = elementType;
  return Boolean(prototype.isReactComponent);
}
function acceptingRef(props, propName, componentName, location, propFullName) {
  let element = props[propName], safePropName = propFullName || propName;
  if (element == null || typeof window > "u")
    return null;
  let warningHint, elementType = element.type;
  return typeof elementType == "function" && !isClassComponent(elementType) && (warningHint = "Did you accidentally use a plain function component for an element instead?"), warningHint !== void 0 ? new Error(`Invalid ${location} \`${safePropName}\` supplied to \`${componentName}\`. Expected an element that can hold a ref. ${warningHint} For more information see https://mui.com/r/caveat-with-refs-guide`) : null;
}
var import_prop_types, elementAcceptingRef, elementAcceptingRef_default, init_elementAcceptingRef = __esm({
  "node_modules/@mui/utils/esm/elementAcceptingRef.js"() {
    import_prop_types = __toESM(require_prop_types());
    init_chainPropTypes();
    elementAcceptingRef = chainPropTypes(import_prop_types.default.element, acceptingRef);
    elementAcceptingRef.isRequired = chainPropTypes(import_prop_types.default.element.isRequired, acceptingRef);
    elementAcceptingRef_default = elementAcceptingRef;
  }
});

// node_modules/@mui/utils/esm/elementTypeAcceptingRef.js
function isClassComponent2(elementType) {
  let {
    prototype = {}
  } = elementType;
  return Boolean(prototype.isReactComponent);
}
function elementTypeAcceptingRef(props, propName, componentName, location, propFullName) {
  let propValue = props[propName], safePropName = propFullName || propName;
  if (propValue == null || typeof window > "u")
    return null;
  let warningHint;
  return typeof propValue == "function" && !isClassComponent2(propValue) && (warningHint = "Did you accidentally provide a plain function component instead?"), warningHint !== void 0 ? new Error(`Invalid ${location} \`${safePropName}\` supplied to \`${componentName}\`. Expected an element type that can hold a ref. ${warningHint} For more information see https://mui.com/r/caveat-with-refs-guide`) : null;
}
var import_prop_types2, elementTypeAcceptingRef_default, init_elementTypeAcceptingRef = __esm({
  "node_modules/@mui/utils/esm/elementTypeAcceptingRef.js"() {
    import_prop_types2 = __toESM(require_prop_types());
    init_chainPropTypes();
    elementTypeAcceptingRef_default = chainPropTypes(import_prop_types2.default.elementType, elementTypeAcceptingRef);
  }
});

// node_modules/@mui/utils/esm/exactProp.js
function exactProp(propTypes) {
  return _extends({}, propTypes, {
    [specialProperty]: (props) => {
      let unsupportedProps = Object.keys(props).filter((prop) => !propTypes.hasOwnProperty(prop));
      return unsupportedProps.length > 0 ? new Error(`The following props are not supported: ${unsupportedProps.map((prop) => `\`${prop}\``).join(", ")}. Please remove them.`) : null;
    }
  });
}
var specialProperty, init_exactProp = __esm({
  "node_modules/@mui/utils/esm/exactProp.js"() {
    init_extends();
    specialProperty = "exact-prop: \u200B";
  }
});

// node_modules/react-is/cjs/react-is.development.js
var require_react_is_development2 = __commonJS({
  "node_modules/react-is/cjs/react-is.development.js"(exports) {
    "use strict";
    (function() {
      "use strict";
      var REACT_ELEMENT_TYPE = Symbol.for("react.element"), REACT_PORTAL_TYPE = Symbol.for("react.portal"), REACT_FRAGMENT_TYPE = Symbol.for("react.fragment"), REACT_STRICT_MODE_TYPE = Symbol.for("react.strict_mode"), REACT_PROFILER_TYPE = Symbol.for("react.profiler"), REACT_PROVIDER_TYPE = Symbol.for("react.provider"), REACT_CONTEXT_TYPE = Symbol.for("react.context"), REACT_SERVER_CONTEXT_TYPE = Symbol.for("react.server_context"), REACT_FORWARD_REF_TYPE = Symbol.for("react.forward_ref"), REACT_SUSPENSE_TYPE = Symbol.for("react.suspense"), REACT_SUSPENSE_LIST_TYPE = Symbol.for("react.suspense_list"), REACT_MEMO_TYPE = Symbol.for("react.memo"), REACT_LAZY_TYPE = Symbol.for("react.lazy"), REACT_OFFSCREEN_TYPE = Symbol.for("react.offscreen"), enableScopeAPI = !1, enableCacheElement = !1, enableTransitionTracing = !1, enableLegacyHidden = !1, enableDebugTracing = !1, REACT_MODULE_REFERENCE;
      REACT_MODULE_REFERENCE = Symbol.for("react.module.reference");
      function isValidElementType(type) {
        return !!(typeof type == "string" || typeof type == "function" || type === REACT_FRAGMENT_TYPE || type === REACT_PROFILER_TYPE || enableDebugTracing || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || enableLegacyHidden || type === REACT_OFFSCREEN_TYPE || enableScopeAPI || enableCacheElement || enableTransitionTracing || typeof type == "object" && type !== null && (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_PROVIDER_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE || type.$$typeof === REACT_MODULE_REFERENCE || type.getModuleId !== void 0));
      }
      function typeOf(object) {
        if (typeof object == "object" && object !== null) {
          var $$typeof = object.$$typeof;
          switch ($$typeof) {
            case REACT_ELEMENT_TYPE:
              var type = object.type;
              switch (type) {
                case REACT_FRAGMENT_TYPE:
                case REACT_PROFILER_TYPE:
                case REACT_STRICT_MODE_TYPE:
                case REACT_SUSPENSE_TYPE:
                case REACT_SUSPENSE_LIST_TYPE:
                  return type;
                default:
                  var $$typeofType = type && type.$$typeof;
                  switch ($$typeofType) {
                    case REACT_SERVER_CONTEXT_TYPE:
                    case REACT_CONTEXT_TYPE:
                    case REACT_FORWARD_REF_TYPE:
                    case REACT_LAZY_TYPE:
                    case REACT_MEMO_TYPE:
                    case REACT_PROVIDER_TYPE:
                      return $$typeofType;
                    default:
                      return $$typeof;
                  }
              }
            case REACT_PORTAL_TYPE:
              return $$typeof;
          }
        }
      }
      var ContextConsumer = REACT_CONTEXT_TYPE, ContextProvider = REACT_PROVIDER_TYPE, Element2 = REACT_ELEMENT_TYPE, ForwardRef2 = REACT_FORWARD_REF_TYPE, Fragment11 = REACT_FRAGMENT_TYPE, Lazy = REACT_LAZY_TYPE, Memo2 = REACT_MEMO_TYPE, Portal3 = REACT_PORTAL_TYPE, Profiler = REACT_PROFILER_TYPE, StrictMode = REACT_STRICT_MODE_TYPE, Suspense = REACT_SUSPENSE_TYPE, SuspenseList = REACT_SUSPENSE_LIST_TYPE, hasWarnedAboutDeprecatedIsAsyncMode = !1, hasWarnedAboutDeprecatedIsConcurrentMode = !1;
      function isAsyncMode(object) {
        return hasWarnedAboutDeprecatedIsAsyncMode || (hasWarnedAboutDeprecatedIsAsyncMode = !0, console.warn("The ReactIs.isAsyncMode() alias has been deprecated, and will be removed in React 18+.")), !1;
      }
      function isConcurrentMode(object) {
        return hasWarnedAboutDeprecatedIsConcurrentMode || (hasWarnedAboutDeprecatedIsConcurrentMode = !0, console.warn("The ReactIs.isConcurrentMode() alias has been deprecated, and will be removed in React 18+.")), !1;
      }
      function isContextConsumer(object) {
        return typeOf(object) === REACT_CONTEXT_TYPE;
      }
      function isContextProvider(object) {
        return typeOf(object) === REACT_PROVIDER_TYPE;
      }
      function isElement(object) {
        return typeof object == "object" && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;
      }
      function isForwardRef(object) {
        return typeOf(object) === REACT_FORWARD_REF_TYPE;
      }
      function isFragment4(object) {
        return typeOf(object) === REACT_FRAGMENT_TYPE;
      }
      function isLazy(object) {
        return typeOf(object) === REACT_LAZY_TYPE;
      }
      function isMemo(object) {
        return typeOf(object) === REACT_MEMO_TYPE;
      }
      function isPortal(object) {
        return typeOf(object) === REACT_PORTAL_TYPE;
      }
      function isProfiler(object) {
        return typeOf(object) === REACT_PROFILER_TYPE;
      }
      function isStrictMode(object) {
        return typeOf(object) === REACT_STRICT_MODE_TYPE;
      }
      function isSuspense(object) {
        return typeOf(object) === REACT_SUSPENSE_TYPE;
      }
      function isSuspenseList(object) {
        return typeOf(object) === REACT_SUSPENSE_LIST_TYPE;
      }
      exports.ContextConsumer = ContextConsumer, exports.ContextProvider = ContextProvider, exports.Element = Element2, exports.ForwardRef = ForwardRef2, exports.Fragment = Fragment11, exports.Lazy = Lazy, exports.Memo = Memo2, exports.Portal = Portal3, exports.Profiler = Profiler, exports.StrictMode = StrictMode, exports.Suspense = Suspense, exports.SuspenseList = SuspenseList, exports.isAsyncMode = isAsyncMode, exports.isConcurrentMode = isConcurrentMode, exports.isContextConsumer = isContextConsumer, exports.isContextProvider = isContextProvider, exports.isElement = isElement, exports.isForwardRef = isForwardRef, exports.isFragment = isFragment4, exports.isLazy = isLazy, exports.isMemo = isMemo, exports.isPortal = isPortal, exports.isProfiler = isProfiler, exports.isStrictMode = isStrictMode, exports.isSuspense = isSuspense, exports.isSuspenseList = isSuspenseList, exports.isValidElementType = isValidElementType, exports.typeOf = typeOf;
    })();
  }
});

// node_modules/react-is/index.js
var require_react_is2 = __commonJS({
  "node_modules/react-is/index.js"(exports, module) {
    "use strict";
    module.exports = require_react_is_development2();
  }
});

// node_modules/@mui/utils/esm/getDisplayName.js
function getFunctionName(fn) {
  let match = `${fn}`.match(fnNameMatchRegex);
  return match && match[1] || "";
}
function getFunctionComponentName(Component, fallback = "") {
  return Component.displayName || Component.name || getFunctionName(Component) || fallback;
}
function getWrappedName(outerType, innerType, wrapperName) {
  let functionName = getFunctionComponentName(innerType);
  return outerType.displayName || (functionName !== "" ? `${wrapperName}(${functionName})` : wrapperName);
}
function getDisplayName(Component) {
  if (Component != null) {
    if (typeof Component == "string")
      return Component;
    if (typeof Component == "function")
      return getFunctionComponentName(Component, "Component");
    if (typeof Component == "object")
      switch (Component.$$typeof) {
        case import_react_is.ForwardRef:
          return getWrappedName(Component, Component.render, "ForwardRef");
        case import_react_is.Memo:
          return getWrappedName(Component, Component.type, "memo");
        default:
          return;
      }
  }
}
var import_react_is, fnNameMatchRegex, init_getDisplayName = __esm({
  "node_modules/@mui/utils/esm/getDisplayName.js"() {
    import_react_is = __toESM(require_react_is2()), fnNameMatchRegex = /^\s*function(?:\s|\s*\/\*.*\*\/\s*)+([^(\s/]*)\s*/;
  }
});

// node_modules/@mui/utils/esm/HTMLElementType.js
function HTMLElementType(props, propName, componentName, location, propFullName) {
  let propValue = props[propName], safePropName = propFullName || propName;
  return propValue == null ? null : propValue && propValue.nodeType !== 1 ? new Error(`Invalid ${location} \`${safePropName}\` supplied to \`${componentName}\`. Expected an HTMLElement.`) : null;
}
var init_HTMLElementType = __esm({
  "node_modules/@mui/utils/esm/HTMLElementType.js"() {
  }
});

// node_modules/@mui/utils/esm/refType.js
var import_prop_types3, refType, refType_default, init_refType = __esm({
  "node_modules/@mui/utils/esm/refType.js"() {
    import_prop_types3 = __toESM(require_prop_types()), refType = import_prop_types3.default.oneOfType([import_prop_types3.default.func, import_prop_types3.default.object]), refType_default = refType;
  }
});

// node_modules/@mui/utils/esm/capitalize.js
function capitalize(string) {
  if (typeof string != "string")
    throw new Error("MUI: `capitalize(string)` expects a string argument.");
  return string.charAt(0).toUpperCase() + string.slice(1);
}
var init_capitalize = __esm({
  "node_modules/@mui/utils/esm/capitalize.js"() {
  }
});

// node_modules/@mui/utils/esm/createChainedFunction.js
function createChainedFunction(...funcs) {
  return funcs.reduce((acc, func) => func == null ? acc : function(...args) {
    acc.apply(this, args), func.apply(this, args);
  }, () => {
  });
}
var init_createChainedFunction = __esm({
  "node_modules/@mui/utils/esm/createChainedFunction.js"() {
  }
});

// node_modules/@mui/utils/esm/debounce.js
function debounce(func, wait = 166) {
  let timeout2;
  function debounced(...args) {
    let later = () => {
      func.apply(this, args);
    };
    clearTimeout(timeout2), timeout2 = setTimeout(later, wait);
  }
  return debounced.clear = () => {
    clearTimeout(timeout2);
  }, debounced;
}
var init_debounce = __esm({
  "node_modules/@mui/utils/esm/debounce.js"() {
  }
});

// node_modules/@mui/utils/esm/deprecatedPropType.js
function deprecatedPropType(validator2, reason) {
  return (props, propName, componentName, location, propFullName) => {
    let componentNameSafe = componentName || "<<anonymous>>", propFullNameSafe = propFullName || propName;
    return typeof props[propName] < "u" ? new Error(`The ${location} \`${propFullNameSafe}\` of \`${componentNameSafe}\` is deprecated. ${reason}`) : null;
  };
}
var init_deprecatedPropType = __esm({
  "node_modules/@mui/utils/esm/deprecatedPropType.js"() {
  }
});

// node_modules/@mui/utils/esm/isMuiElement.js
function isMuiElement(element, muiNames) {
  return /* @__PURE__ */ React5.isValidElement(element) && muiNames.indexOf(element.type.muiName) !== -1;
}
var React5, init_isMuiElement = __esm({
  "node_modules/@mui/utils/esm/isMuiElement.js"() {
    React5 = __toESM(require_react());
  }
});

// node_modules/@mui/utils/esm/ownerDocument.js
function ownerDocument(node) {
  return node && node.ownerDocument || document;
}
var init_ownerDocument = __esm({
  "node_modules/@mui/utils/esm/ownerDocument.js"() {
  }
});

// node_modules/@mui/utils/esm/ownerWindow.js
function ownerWindow(node) {
  return ownerDocument(node).defaultView || window;
}
var init_ownerWindow = __esm({
  "node_modules/@mui/utils/esm/ownerWindow.js"() {
    init_ownerDocument();
  }
});

// node_modules/@mui/utils/esm/requirePropFactory.js
function requirePropFactory(componentNameInError, Component) {
  let prevPropTypes = Component ? _extends({}, Component.propTypes) : null;
  return (requiredProp) => (props, propName, componentName, location, propFullName, ...args) => {
    let propFullNameSafe = propFullName || propName, defaultTypeChecker = prevPropTypes == null ? void 0 : prevPropTypes[propFullNameSafe];
    if (defaultTypeChecker) {
      let typeCheckerResult = defaultTypeChecker(props, propName, componentName, location, propFullName, ...args);
      if (typeCheckerResult)
        return typeCheckerResult;
    }
    return typeof props[propName] < "u" && !props[requiredProp] ? new Error(`The prop \`${propFullNameSafe}\` of \`${componentNameInError}\` can only be used together with the \`${requiredProp}\` prop.`) : null;
  };
}
var init_requirePropFactory = __esm({
  "node_modules/@mui/utils/esm/requirePropFactory.js"() {
    init_extends();
  }
});

// node_modules/@mui/utils/esm/setRef.js
function setRef(ref, value) {
  typeof ref == "function" ? ref(value) : ref && (ref.current = value);
}
var init_setRef = __esm({
  "node_modules/@mui/utils/esm/setRef.js"() {
  }
});

// node_modules/@mui/utils/esm/useEnhancedEffect.js
var React6, useEnhancedEffect, useEnhancedEffect_default, init_useEnhancedEffect = __esm({
  "node_modules/@mui/utils/esm/useEnhancedEffect.js"() {
    React6 = __toESM(require_react()), useEnhancedEffect = typeof window < "u" ? React6.useLayoutEffect : React6.useEffect, useEnhancedEffect_default = useEnhancedEffect;
  }
});

// node_modules/@mui/utils/esm/useId.js
function useGlobalId(idOverride) {
  let [defaultId, setDefaultId] = React7.useState(idOverride), id = idOverride || defaultId;
  return React7.useEffect(() => {
    defaultId == null && (globalId += 1, setDefaultId(`mui-${globalId}`));
  }, [defaultId]), id;
}
function useId2(idOverride) {
  if (maybeReactUseId !== void 0) {
    let reactId = maybeReactUseId();
    return idOverride ?? reactId;
  }
  return useGlobalId(idOverride);
}
var React7, globalId, maybeReactUseId, init_useId = __esm({
  "node_modules/@mui/utils/esm/useId.js"() {
    React7 = __toESM(require_react()), globalId = 0;
    maybeReactUseId = React7.useId;
  }
});

// node_modules/@mui/utils/esm/unsupportedProp.js
function unsupportedProp(props, propName, componentName, location, propFullName) {
  let propFullNameSafe = propFullName || propName;
  return typeof props[propName] < "u" ? new Error(`The prop \`${propFullNameSafe}\` is not supported. Please remove it.`) : null;
}
var init_unsupportedProp = __esm({
  "node_modules/@mui/utils/esm/unsupportedProp.js"() {
  }
});

// node_modules/@mui/utils/esm/useControlled.js
function useControlled({
  controlled,
  default: defaultProp,
  name,
  state = "value"
}) {
  let {
    current: isControlled
  } = React8.useRef(controlled !== void 0), [valueState, setValue] = React8.useState(defaultProp), value = isControlled ? controlled : valueState;
  {
    React8.useEffect(() => {
      isControlled !== (controlled !== void 0) && console.error([`MUI: A component is changing the ${isControlled ? "" : "un"}controlled ${state} state of ${name} to be ${isControlled ? "un" : ""}controlled.`, "Elements should not switch from uncontrolled to controlled (or vice versa).", `Decide between using a controlled or uncontrolled ${name} element for the lifetime of the component.`, "The nature of the state is determined during the first render. It's considered controlled if the value is not `undefined`.", "More info: https://fb.me/react-controlled-components"].join(`
`));
    }, [state, name, controlled]);
    let {
      current: defaultValue
    } = React8.useRef(defaultProp);
    React8.useEffect(() => {
      !isControlled && defaultValue !== defaultProp && console.error([`MUI: A component is changing the default ${state} state of an uncontrolled ${name} after being initialized. To suppress this warning opt to use a controlled ${name}.`].join(`
`));
    }, [JSON.stringify(defaultProp)]);
  }
  let setValueIfUncontrolled = React8.useCallback((newValue) => {
    isControlled || setValue(newValue);
  }, []);
  return [value, setValueIfUncontrolled];
}
var React8, init_useControlled = __esm({
  "node_modules/@mui/utils/esm/useControlled.js"() {
    React8 = __toESM(require_react());
  }
});

// node_modules/@mui/utils/esm/useEventCallback.js
function useEventCallback(fn) {
  let ref = React9.useRef(fn);
  return useEnhancedEffect_default(() => {
    ref.current = fn;
  }), React9.useCallback((...args) => (0, ref.current)(...args), []);
}
var React9, init_useEventCallback = __esm({
  "node_modules/@mui/utils/esm/useEventCallback.js"() {
    React9 = __toESM(require_react());
    init_useEnhancedEffect();
  }
});

// node_modules/@mui/utils/esm/useForkRef.js
function useForkRef(refA, refB) {
  return React10.useMemo(() => refA == null && refB == null ? null : (refValue) => {
    setRef(refA, refValue), setRef(refB, refValue);
  }, [refA, refB]);
}
var React10, init_useForkRef = __esm({
  "node_modules/@mui/utils/esm/useForkRef.js"() {
    React10 = __toESM(require_react());
    init_setRef();
  }
});

// node_modules/@mui/utils/esm/useIsFocusVisible.js
function focusTriggersKeyboardModality(node) {
  let {
    type,
    tagName
  } = node;
  return !!(tagName === "INPUT" && inputTypesWhitelist[type] && !node.readOnly || tagName === "TEXTAREA" && !node.readOnly || node.isContentEditable);
}
function handleKeyDown(event) {
  event.metaKey || event.altKey || event.ctrlKey || (hadKeyboardEvent = !0);
}
function handlePointerDown() {
  hadKeyboardEvent = !1;
}
function handleVisibilityChange() {
  this.visibilityState === "hidden" && hadFocusVisibleRecently && (hadKeyboardEvent = !0);
}
function prepare(doc) {
  doc.addEventListener("keydown", handleKeyDown, !0), doc.addEventListener("mousedown", handlePointerDown, !0), doc.addEventListener("pointerdown", handlePointerDown, !0), doc.addEventListener("touchstart", handlePointerDown, !0), doc.addEventListener("visibilitychange", handleVisibilityChange, !0);
}
function isFocusVisible(event) {
  let {
    target
  } = event;
  try {
    return target.matches(":focus-visible");
  } catch {
  }
  return hadKeyboardEvent || focusTriggersKeyboardModality(target);
}
function useIsFocusVisible() {
  let ref = React11.useCallback((node) => {
    node != null && prepare(node.ownerDocument);
  }, []), isFocusVisibleRef = React11.useRef(!1);
  function handleBlurVisible() {
    return isFocusVisibleRef.current ? (hadFocusVisibleRecently = !0, window.clearTimeout(hadFocusVisibleRecentlyTimeout), hadFocusVisibleRecentlyTimeout = window.setTimeout(() => {
      hadFocusVisibleRecently = !1;
    }, 100), isFocusVisibleRef.current = !1, !0) : !1;
  }
  function handleFocusVisible(event) {
    return isFocusVisible(event) ? (isFocusVisibleRef.current = !0, !0) : !1;
  }
  return {
    isFocusVisibleRef,
    onFocus: handleFocusVisible,
    onBlur: handleBlurVisible,
    ref
  };
}
var React11, hadKeyboardEvent, hadFocusVisibleRecently, hadFocusVisibleRecentlyTimeout, inputTypesWhitelist, init_useIsFocusVisible = __esm({
  "node_modules/@mui/utils/esm/useIsFocusVisible.js"() {
    React11 = __toESM(require_react()), hadKeyboardEvent = !0, hadFocusVisibleRecently = !1, inputTypesWhitelist = {
      text: !0,
      search: !0,
      url: !0,
      tel: !0,
      email: !0,
      password: !0,
      number: !0,
      date: !0,
      month: !0,
      week: !0,
      time: !0,
      datetime: !0,
      "datetime-local": !0
    };
  }
});

// node_modules/@mui/utils/esm/getScrollbarSize.js
function getScrollbarSize(doc) {
  let documentWidth = doc.documentElement.clientWidth;
  return Math.abs(window.innerWidth - documentWidth);
}
var init_getScrollbarSize = __esm({
  "node_modules/@mui/utils/esm/getScrollbarSize.js"() {
  }
});

// node_modules/@mui/utils/esm/integerPropType.js
function getTypeByValue(value) {
  let valueType = typeof value;
  switch (valueType) {
    case "number":
      return Number.isNaN(value) ? "NaN" : Number.isFinite(value) ? value !== Math.floor(value) ? "float" : "number" : "Infinity";
    case "object":
      return value === null ? "null" : value.constructor.name;
    default:
      return valueType;
  }
}
function ponyfillIsInteger(x) {
  return typeof x == "number" && isFinite(x) && Math.floor(x) === x;
}
function requiredInteger(props, propName, componentName, location) {
  let propValue = props[propName];
  if (propValue == null || !isInteger(propValue)) {
    let propType = getTypeByValue(propValue);
    return new RangeError(`Invalid ${location} \`${propName}\` of type \`${propType}\` supplied to \`${componentName}\`, expected \`integer\`.`);
  }
  return null;
}
function validator(props, propName, ...other) {
  return props[propName] === void 0 ? null : requiredInteger(props, propName, ...other);
}
function validatorNoop() {
  return null;
}
var isInteger, integerPropType_default, init_integerPropType = __esm({
  "node_modules/@mui/utils/esm/integerPropType.js"() {
    isInteger = Number.isInteger || ponyfillIsInteger;
    validator.isRequired = requiredInteger;
    validatorNoop.isRequired = validatorNoop;
    integerPropType_default = validator;
  }
});

// node_modules/@mui/utils/esm/resolveProps.js
function resolveProps(defaultProps2, props) {
  let output = _extends({}, props);
  return Object.keys(defaultProps2).forEach((propName) => {
    output[propName] === void 0 && (output[propName] = defaultProps2[propName]);
  }), output;
}
var init_resolveProps = __esm({
  "node_modules/@mui/utils/esm/resolveProps.js"() {
    init_extends();
  }
});

// node_modules/@mui/utils/esm/composeClasses/composeClasses.js
function composeClasses(slots, getUtilityClass, classes) {
  let output = {};
  return Object.keys(slots).forEach(
    (slot) => {
      output[slot] = slots[slot].reduce((acc, key) => (key && (acc.push(getUtilityClass(key)), classes && classes[key] && acc.push(classes[key])), acc), []).join(" ");
    }
  ), output;
}
var init_composeClasses = __esm({
  "node_modules/@mui/utils/esm/composeClasses/composeClasses.js"() {
  }
});

// node_modules/@mui/utils/esm/composeClasses/index.js
var init_composeClasses2 = __esm({
  "node_modules/@mui/utils/esm/composeClasses/index.js"() {
    init_composeClasses();
  }
});

// node_modules/@mui/utils/esm/ClassNameGenerator/ClassNameGenerator.js
var defaultGenerator, createClassNameGenerator, ClassNameGenerator, ClassNameGenerator_default, init_ClassNameGenerator = __esm({
  "node_modules/@mui/utils/esm/ClassNameGenerator/ClassNameGenerator.js"() {
    defaultGenerator = (componentName) => componentName, createClassNameGenerator = () => {
      let generate = defaultGenerator;
      return {
        configure(generator) {
          generate = generator;
        },
        generate(componentName) {
          return generate(componentName);
        },
        reset() {
          generate = defaultGenerator;
        }
      };
    }, ClassNameGenerator = createClassNameGenerator(), ClassNameGenerator_default = ClassNameGenerator;
  }
});

// node_modules/@mui/utils/esm/ClassNameGenerator/index.js
var init_ClassNameGenerator2 = __esm({
  "node_modules/@mui/utils/esm/ClassNameGenerator/index.js"() {
    init_ClassNameGenerator();
  }
});

// node_modules/@mui/utils/esm/generateUtilityClass/generateUtilityClass.js
function generateUtilityClass(componentName, slot, globalStatePrefix = "Mui") {
  let globalStateClass = globalStateClassesMapping[slot];
  return globalStateClass ? `${globalStatePrefix}-${globalStateClass}` : `${ClassNameGenerator_default.generate(componentName)}-${slot}`;
}
var globalStateClassesMapping, init_generateUtilityClass = __esm({
  "node_modules/@mui/utils/esm/generateUtilityClass/generateUtilityClass.js"() {
    init_ClassNameGenerator2();
    globalStateClassesMapping = {
      active: "active",
      checked: "checked",
      completed: "completed",
      disabled: "disabled",
      error: "error",
      expanded: "expanded",
      focused: "focused",
      focusVisible: "focusVisible",
      required: "required",
      selected: "selected"
    };
  }
});

// node_modules/@mui/utils/esm/generateUtilityClass/index.js
var init_generateUtilityClass2 = __esm({
  "node_modules/@mui/utils/esm/generateUtilityClass/index.js"() {
    init_generateUtilityClass();
    init_generateUtilityClass();
  }
});

// node_modules/@mui/utils/esm/generateUtilityClasses/generateUtilityClasses.js
function generateUtilityClasses(componentName, slots, globalStatePrefix = "Mui") {
  let result = {};
  return slots.forEach((slot) => {
    result[slot] = generateUtilityClass(componentName, slot, globalStatePrefix);
  }), result;
}
var init_generateUtilityClasses = __esm({
  "node_modules/@mui/utils/esm/generateUtilityClasses/generateUtilityClasses.js"() {
    init_generateUtilityClass2();
  }
});

// node_modules/@mui/utils/esm/generateUtilityClasses/index.js
var init_generateUtilityClasses2 = __esm({
  "node_modules/@mui/utils/esm/generateUtilityClasses/index.js"() {
    init_generateUtilityClasses();
  }
});

// node_modules/@mui/utils/esm/index.js
var init_esm2 = __esm({
  "node_modules/@mui/utils/esm/index.js"() {
    init_chainPropTypes();
    init_deepmerge();
    init_deepmerge();
    init_elementAcceptingRef();
    init_elementTypeAcceptingRef();
    init_exactProp();
    init_getDisplayName();
    init_HTMLElementType();
    init_refType();
    init_capitalize();
    init_createChainedFunction();
    init_debounce();
    init_deprecatedPropType();
    init_isMuiElement();
    init_ownerDocument();
    init_ownerWindow();
    init_requirePropFactory();
    init_setRef();
    init_useEnhancedEffect();
    init_useId();
    init_unsupportedProp();
    init_useControlled();
    init_useEventCallback();
    init_useForkRef();
    init_useIsFocusVisible();
    init_getScrollbarSize();
    init_integerPropType();
    init_resolveProps();
    init_composeClasses2();
    init_generateUtilityClass2();
    init_generateUtilityClass2();
    init_generateUtilityClasses2();
    init_ClassNameGenerator2();
  }
});

// node_modules/@mui/base/utils/isHostComponent.js
function isHostComponent(element) {
  return typeof element == "string";
}
var isHostComponent_default, init_isHostComponent = __esm({
  "node_modules/@mui/base/utils/isHostComponent.js"() {
    isHostComponent_default = isHostComponent;
  }
});

// node_modules/@mui/base/utils/appendOwnerState.js
function appendOwnerState(elementType, otherProps = {}, ownerState) {
  return isHostComponent_default(elementType) ? otherProps : _extends({}, otherProps, {
    ownerState: _extends({}, otherProps.ownerState, ownerState)
  });
}
var init_appendOwnerState = __esm({
  "node_modules/@mui/base/utils/appendOwnerState.js"() {
    init_extends();
    init_isHostComponent();
  }
});

// node_modules/@mui/base/utils/extractEventHandlers.js
function extractEventHandlers(object, excludeKeys = []) {
  if (object === void 0)
    return {};
  let result = {};
  return Object.keys(object).filter((prop) => prop.match(/^on[A-Z]/) && typeof object[prop] == "function" && !excludeKeys.includes(prop)).forEach((prop) => {
    result[prop] = object[prop];
  }), result;
}
var init_extractEventHandlers = __esm({
  "node_modules/@mui/base/utils/extractEventHandlers.js"() {
  }
});

// node_modules/@mui/base/utils/resolveComponentProps.js
function resolveComponentProps(componentProps, ownerState) {
  return typeof componentProps == "function" ? componentProps(ownerState) : componentProps;
}
var init_resolveComponentProps = __esm({
  "node_modules/@mui/base/utils/resolveComponentProps.js"() {
  }
});

// node_modules/@mui/base/utils/omitEventHandlers.js
function omitEventHandlers(object) {
  if (object === void 0)
    return {};
  let result = {};
  return Object.keys(object).filter((prop) => !(prop.match(/^on[A-Z]/) && typeof object[prop] == "function")).forEach((prop) => {
    result[prop] = object[prop];
  }), result;
}
var init_omitEventHandlers = __esm({
  "node_modules/@mui/base/utils/omitEventHandlers.js"() {
  }
});

// node_modules/@mui/base/utils/mergeSlotProps.js
function mergeSlotProps(parameters) {
  let {
    getSlotProps,
    additionalProps,
    externalSlotProps,
    externalForwardedProps,
    className
  } = parameters;
  if (!getSlotProps) {
    let joinedClasses2 = clsx_m_default(externalForwardedProps == null ? void 0 : externalForwardedProps.className, externalSlotProps == null ? void 0 : externalSlotProps.className, className, additionalProps == null ? void 0 : additionalProps.className), mergedStyle2 = _extends({}, additionalProps == null ? void 0 : additionalProps.style, externalForwardedProps == null ? void 0 : externalForwardedProps.style, externalSlotProps == null ? void 0 : externalSlotProps.style), props2 = _extends({}, additionalProps, externalForwardedProps, externalSlotProps);
    return joinedClasses2.length > 0 && (props2.className = joinedClasses2), Object.keys(mergedStyle2).length > 0 && (props2.style = mergedStyle2), {
      props: props2,
      internalRef: void 0
    };
  }
  let eventHandlers = extractEventHandlers(_extends({}, externalForwardedProps, externalSlotProps)), componentsPropsWithoutEventHandlers = omitEventHandlers(externalSlotProps), otherPropsWithoutEventHandlers = omitEventHandlers(externalForwardedProps), internalSlotProps = getSlotProps(eventHandlers), joinedClasses = clsx_m_default(internalSlotProps == null ? void 0 : internalSlotProps.className, additionalProps == null ? void 0 : additionalProps.className, className, externalForwardedProps == null ? void 0 : externalForwardedProps.className, externalSlotProps == null ? void 0 : externalSlotProps.className), mergedStyle = _extends({}, internalSlotProps == null ? void 0 : internalSlotProps.style, additionalProps == null ? void 0 : additionalProps.style, externalForwardedProps == null ? void 0 : externalForwardedProps.style, externalSlotProps == null ? void 0 : externalSlotProps.style), props = _extends({}, internalSlotProps, additionalProps, otherPropsWithoutEventHandlers, componentsPropsWithoutEventHandlers);
  return joinedClasses.length > 0 && (props.className = joinedClasses), Object.keys(mergedStyle).length > 0 && (props.style = mergedStyle), {
    props,
    internalRef: internalSlotProps.ref
  };
}
var init_mergeSlotProps = __esm({
  "node_modules/@mui/base/utils/mergeSlotProps.js"() {
    init_extends();
    init_clsx_m();
    init_extractEventHandlers();
    init_omitEventHandlers();
  }
});

// node_modules/@mui/base/utils/useSlotProps.js
function useSlotProps(parameters) {
  var _parameters$additiona;
  let {
    elementType,
    externalSlotProps,
    ownerState
  } = parameters, rest = _objectWithoutPropertiesLoose2(parameters, _excluded3), resolvedComponentsProps = resolveComponentProps(externalSlotProps, ownerState), {
    props: mergedProps,
    internalRef
  } = mergeSlotProps(_extends({}, rest, {
    externalSlotProps: resolvedComponentsProps
  })), ref = useForkRef(internalRef, useForkRef(resolvedComponentsProps == null ? void 0 : resolvedComponentsProps.ref, (_parameters$additiona = parameters.additionalProps) == null ? void 0 : _parameters$additiona.ref));
  return appendOwnerState(elementType, _extends({}, mergedProps, {
    ref
  }), ownerState);
}
var _excluded3, init_useSlotProps = __esm({
  "node_modules/@mui/base/utils/useSlotProps.js"() {
    init_extends();
    init_objectWithoutPropertiesLoose();
    init_esm2();
    init_appendOwnerState();
    init_mergeSlotProps();
    init_resolveComponentProps();
    _excluded3 = ["elementType", "externalSlotProps", "ownerState"];
  }
});

// node_modules/@mui/base/utils/types.js
var init_types = __esm({
  "node_modules/@mui/base/utils/types.js"() {
  }
});

// node_modules/@mui/base/utils/index.js
var init_utils2 = __esm({
  "node_modules/@mui/base/utils/index.js"() {
    init_isHostComponent();
    init_resolveComponentProps();
    init_useSlotProps();
    init_types();
  }
});

// node_modules/@mui/base/AutocompleteUnstyled/index.js
var init_AutocompleteUnstyled = __esm({
  "node_modules/@mui/base/AutocompleteUnstyled/index.js"() {
  }
});

// node_modules/@mui/base/composeClasses/index.js
var init_composeClasses3 = __esm({
  "node_modules/@mui/base/composeClasses/index.js"() {
    init_esm2();
  }
});

// node_modules/@mui/base/BadgeUnstyled/useBadge.js
var init_useBadge = __esm({
  "node_modules/@mui/base/BadgeUnstyled/useBadge.js"() {
  }
});

// node_modules/@mui/base/generateUtilityClasses/index.js
var init_generateUtilityClasses3 = __esm({
  "node_modules/@mui/base/generateUtilityClasses/index.js"() {
    init_esm2();
  }
});

// node_modules/@mui/base/generateUtilityClass/index.js
var init_generateUtilityClass3 = __esm({
  "node_modules/@mui/base/generateUtilityClass/index.js"() {
    init_esm2();
  }
});

// node_modules/@mui/base/BadgeUnstyled/badgeUnstyledClasses.js
var badgeUnstyledClasses, init_badgeUnstyledClasses = __esm({
  "node_modules/@mui/base/BadgeUnstyled/badgeUnstyledClasses.js"() {
    init_generateUtilityClasses3();
    badgeUnstyledClasses = generateUtilityClasses("BaseBadge", ["root", "badge", "invisible"]);
  }
});

// node_modules/react/cjs/react-jsx-runtime.development.js
var require_react_jsx_runtime_development = __commonJS({
  "node_modules/react/cjs/react-jsx-runtime.development.js"(exports) {
    "use strict";
    (function() {
      "use strict";
      var React90 = require_react(), _assign = require_object_assign(), REACT_ELEMENT_TYPE = 60103, REACT_PORTAL_TYPE = 60106;
      exports.Fragment = 60107;
      var REACT_STRICT_MODE_TYPE = 60108, REACT_PROFILER_TYPE = 60114, REACT_PROVIDER_TYPE = 60109, REACT_CONTEXT_TYPE = 60110, REACT_FORWARD_REF_TYPE = 60112, REACT_SUSPENSE_TYPE = 60113, REACT_SUSPENSE_LIST_TYPE = 60120, REACT_MEMO_TYPE = 60115, REACT_LAZY_TYPE = 60116, REACT_BLOCK_TYPE = 60121, REACT_SERVER_BLOCK_TYPE = 60122, REACT_FUNDAMENTAL_TYPE = 60117, REACT_SCOPE_TYPE = 60119, REACT_OPAQUE_ID_TYPE = 60128, REACT_DEBUG_TRACING_MODE_TYPE = 60129, REACT_OFFSCREEN_TYPE = 60130, REACT_LEGACY_HIDDEN_TYPE = 60131;
      if (typeof Symbol == "function" && Symbol.for) {
        var symbolFor = Symbol.for;
        REACT_ELEMENT_TYPE = symbolFor("react.element"), REACT_PORTAL_TYPE = symbolFor("react.portal"), exports.Fragment = symbolFor("react.fragment"), REACT_STRICT_MODE_TYPE = symbolFor("react.strict_mode"), REACT_PROFILER_TYPE = symbolFor("react.profiler"), REACT_PROVIDER_TYPE = symbolFor("react.provider"), REACT_CONTEXT_TYPE = symbolFor("react.context"), REACT_FORWARD_REF_TYPE = symbolFor("react.forward_ref"), REACT_SUSPENSE_TYPE = symbolFor("react.suspense"), REACT_SUSPENSE_LIST_TYPE = symbolFor("react.suspense_list"), REACT_MEMO_TYPE = symbolFor("react.memo"), REACT_LAZY_TYPE = symbolFor("react.lazy"), REACT_BLOCK_TYPE = symbolFor("react.block"), REACT_SERVER_BLOCK_TYPE = symbolFor("react.server.block"), REACT_FUNDAMENTAL_TYPE = symbolFor("react.fundamental"), REACT_SCOPE_TYPE = symbolFor("react.scope"), REACT_OPAQUE_ID_TYPE = symbolFor("react.opaque.id"), REACT_DEBUG_TRACING_MODE_TYPE = symbolFor("react.debug_trace_mode"), REACT_OFFSCREEN_TYPE = symbolFor("react.offscreen"), REACT_LEGACY_HIDDEN_TYPE = symbolFor("react.legacy_hidden");
      }
      var MAYBE_ITERATOR_SYMBOL = typeof Symbol == "function" && Symbol.iterator, FAUX_ITERATOR_SYMBOL = "@@iterator";
      function getIteratorFn(maybeIterable) {
        if (maybeIterable === null || typeof maybeIterable != "object")
          return null;
        var maybeIterator = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL];
        return typeof maybeIterator == "function" ? maybeIterator : null;
      }
      var ReactSharedInternals = React90.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
      function error(format2) {
        {
          for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++)
            args[_key2 - 1] = arguments[_key2];
          printWarning("error", format2, args);
        }
      }
      function printWarning(level, format2, args) {
        {
          var ReactDebugCurrentFrame2 = ReactSharedInternals.ReactDebugCurrentFrame, stack = ReactDebugCurrentFrame2.getStackAddendum();
          stack !== "" && (format2 += "%s", args = args.concat([stack]));
          var argsWithFormat = args.map(function(item) {
            return "" + item;
          });
          argsWithFormat.unshift("Warning: " + format2), Function.prototype.apply.call(console[level], console, argsWithFormat);
        }
      }
      var enableScopeAPI = !1;
      function isValidElementType(type) {
        return !!(typeof type == "string" || typeof type == "function" || type === exports.Fragment || type === REACT_PROFILER_TYPE || type === REACT_DEBUG_TRACING_MODE_TYPE || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || type === REACT_LEGACY_HIDDEN_TYPE || enableScopeAPI || typeof type == "object" && type !== null && (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_PROVIDER_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE || type.$$typeof === REACT_FUNDAMENTAL_TYPE || type.$$typeof === REACT_BLOCK_TYPE || type[0] === REACT_SERVER_BLOCK_TYPE));
      }
      function getWrappedName2(outerType, innerType, wrapperName) {
        var functionName = innerType.displayName || innerType.name || "";
        return outerType.displayName || (functionName !== "" ? wrapperName + "(" + functionName + ")" : wrapperName);
      }
      function getContextName(type) {
        return type.displayName || "Context";
      }
      function getComponentName(type) {
        if (type == null)
          return null;
        if (typeof type.tag == "number" && error("Received an unexpected object in getComponentName(). This is likely a bug in React. Please file an issue."), typeof type == "function")
          return type.displayName || type.name || null;
        if (typeof type == "string")
          return type;
        switch (type) {
          case exports.Fragment:
            return "Fragment";
          case REACT_PORTAL_TYPE:
            return "Portal";
          case REACT_PROFILER_TYPE:
            return "Profiler";
          case REACT_STRICT_MODE_TYPE:
            return "StrictMode";
          case REACT_SUSPENSE_TYPE:
            return "Suspense";
          case REACT_SUSPENSE_LIST_TYPE:
            return "SuspenseList";
        }
        if (typeof type == "object")
          switch (type.$$typeof) {
            case REACT_CONTEXT_TYPE:
              var context = type;
              return getContextName(context) + ".Consumer";
            case REACT_PROVIDER_TYPE:
              var provider = type;
              return getContextName(provider._context) + ".Provider";
            case REACT_FORWARD_REF_TYPE:
              return getWrappedName2(type, type.render, "ForwardRef");
            case REACT_MEMO_TYPE:
              return getComponentName(type.type);
            case REACT_BLOCK_TYPE:
              return getComponentName(type._render);
            case REACT_LAZY_TYPE: {
              var lazyComponent = type, payload = lazyComponent._payload, init2 = lazyComponent._init;
              try {
                return getComponentName(init2(payload));
              } catch {
                return null;
              }
            }
          }
        return null;
      }
      var disabledDepth = 0, prevLog, prevInfo, prevWarn, prevError, prevGroup, prevGroupCollapsed, prevGroupEnd;
      function disabledLog() {
      }
      disabledLog.__reactDisabledLog = !0;
      function disableLogs() {
        {
          if (disabledDepth === 0) {
            prevLog = console.log, prevInfo = console.info, prevWarn = console.warn, prevError = console.error, prevGroup = console.group, prevGroupCollapsed = console.groupCollapsed, prevGroupEnd = console.groupEnd;
            var props = {
              configurable: !0,
              enumerable: !0,
              value: disabledLog,
              writable: !0
            };
            Object.defineProperties(console, {
              info: props,
              log: props,
              warn: props,
              error: props,
              group: props,
              groupCollapsed: props,
              groupEnd: props
            });
          }
          disabledDepth++;
        }
      }
      function reenableLogs() {
        {
          if (disabledDepth--, disabledDepth === 0) {
            var props = {
              configurable: !0,
              enumerable: !0,
              writable: !0
            };
            Object.defineProperties(console, {
              log: _assign({}, props, {
                value: prevLog
              }),
              info: _assign({}, props, {
                value: prevInfo
              }),
              warn: _assign({}, props, {
                value: prevWarn
              }),
              error: _assign({}, props, {
                value: prevError
              }),
              group: _assign({}, props, {
                value: prevGroup
              }),
              groupCollapsed: _assign({}, props, {
                value: prevGroupCollapsed
              }),
              groupEnd: _assign({}, props, {
                value: prevGroupEnd
              })
            });
          }
          disabledDepth < 0 && error("disabledDepth fell below zero. This is a bug in React. Please file an issue.");
        }
      }
      var ReactCurrentDispatcher = ReactSharedInternals.ReactCurrentDispatcher, prefix;
      function describeBuiltInComponentFrame(name, source, ownerFn) {
        {
          if (prefix === void 0)
            try {
              throw Error();
            } catch (x) {
              var match = x.stack.trim().match(/\n( *(at )?)/);
              prefix = match && match[1] || "";
            }
          return `
` + prefix + name;
        }
      }
      var reentry = !1, componentFrameCache;
      {
        var PossiblyWeakMap = typeof WeakMap == "function" ? WeakMap : Map;
        componentFrameCache = new PossiblyWeakMap();
      }
      function describeNativeComponentFrame(fn, construct) {
        if (!fn || reentry)
          return "";
        {
          var frame = componentFrameCache.get(fn);
          if (frame !== void 0)
            return frame;
        }
        var control;
        reentry = !0;
        var previousPrepareStackTrace = Error.prepareStackTrace;
        Error.prepareStackTrace = void 0;
        var previousDispatcher;
        previousDispatcher = ReactCurrentDispatcher.current, ReactCurrentDispatcher.current = null, disableLogs();
        try {
          if (construct) {
            var Fake = function() {
              throw Error();
            };
            if (Object.defineProperty(Fake.prototype, "props", {
              set: function() {
                throw Error();
              }
            }), typeof Reflect == "object" && Reflect.construct) {
              try {
                Reflect.construct(Fake, []);
              } catch (x) {
                control = x;
              }
              Reflect.construct(fn, [], Fake);
            } else {
              try {
                Fake.call();
              } catch (x) {
                control = x;
              }
              fn.call(Fake.prototype);
            }
          } else {
            try {
              throw Error();
            } catch (x) {
              control = x;
            }
            fn();
          }
        } catch (sample) {
          if (sample && control && typeof sample.stack == "string") {
            for (var sampleLines = sample.stack.split(`
`), controlLines = control.stack.split(`
`), s = sampleLines.length - 1, c = controlLines.length - 1; s >= 1 && c >= 0 && sampleLines[s] !== controlLines[c]; )
              c--;
            for (; s >= 1 && c >= 0; s--, c--)
              if (sampleLines[s] !== controlLines[c]) {
                if (s !== 1 || c !== 1)
                  do
                    if (s--, c--, c < 0 || sampleLines[s] !== controlLines[c]) {
                      var _frame = `
` + sampleLines[s].replace(" at new ", " at ");
                      return typeof fn == "function" && componentFrameCache.set(fn, _frame), _frame;
                    }
                  while (s >= 1 && c >= 0);
                break;
              }
          }
        } finally {
          reentry = !1, ReactCurrentDispatcher.current = previousDispatcher, reenableLogs(), Error.prepareStackTrace = previousPrepareStackTrace;
        }
        var name = fn ? fn.displayName || fn.name : "", syntheticFrame = name ? describeBuiltInComponentFrame(name) : "";
        return typeof fn == "function" && componentFrameCache.set(fn, syntheticFrame), syntheticFrame;
      }
      function describeFunctionComponentFrame(fn, source, ownerFn) {
        return describeNativeComponentFrame(fn, !1);
      }
      function shouldConstruct(Component) {
        var prototype = Component.prototype;
        return !!(prototype && prototype.isReactComponent);
      }
      function describeUnknownElementTypeFrameInDEV(type, source, ownerFn) {
        if (type == null)
          return "";
        if (typeof type == "function")
          return describeNativeComponentFrame(type, shouldConstruct(type));
        if (typeof type == "string")
          return describeBuiltInComponentFrame(type);
        switch (type) {
          case REACT_SUSPENSE_TYPE:
            return describeBuiltInComponentFrame("Suspense");
          case REACT_SUSPENSE_LIST_TYPE:
            return describeBuiltInComponentFrame("SuspenseList");
        }
        if (typeof type == "object")
          switch (type.$$typeof) {
            case REACT_FORWARD_REF_TYPE:
              return describeFunctionComponentFrame(type.render);
            case REACT_MEMO_TYPE:
              return describeUnknownElementTypeFrameInDEV(type.type, source, ownerFn);
            case REACT_BLOCK_TYPE:
              return describeFunctionComponentFrame(type._render);
            case REACT_LAZY_TYPE: {
              var lazyComponent = type, payload = lazyComponent._payload, init2 = lazyComponent._init;
              try {
                return describeUnknownElementTypeFrameInDEV(init2(payload), source, ownerFn);
              } catch {
              }
            }
          }
        return "";
      }
      var loggedTypeFailures = {}, ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;
      function setCurrentlyValidatingElement(element) {
        if (element) {
          var owner = element._owner, stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);
          ReactDebugCurrentFrame.setExtraStackFrame(stack);
        } else
          ReactDebugCurrentFrame.setExtraStackFrame(null);
      }
      function checkPropTypes(typeSpecs, values3, location, componentName, element) {
        {
          var has = Function.call.bind(Object.prototype.hasOwnProperty);
          for (var typeSpecName in typeSpecs)
            if (has(typeSpecs, typeSpecName)) {
              var error$1 = void 0;
              try {
                if (typeof typeSpecs[typeSpecName] != "function") {
                  var err = Error((componentName || "React class") + ": " + location + " type `" + typeSpecName + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof typeSpecs[typeSpecName] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.");
                  throw err.name = "Invariant Violation", err;
                }
                error$1 = typeSpecs[typeSpecName](values3, typeSpecName, componentName, location, null, "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED");
              } catch (ex) {
                error$1 = ex;
              }
              error$1 && !(error$1 instanceof Error) && (setCurrentlyValidatingElement(element), error("%s: type specification of %s `%s` is invalid; the type checker function must return `null` or an `Error` but returned a %s. You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).", componentName || "React class", location, typeSpecName, typeof error$1), setCurrentlyValidatingElement(null)), error$1 instanceof Error && !(error$1.message in loggedTypeFailures) && (loggedTypeFailures[error$1.message] = !0, setCurrentlyValidatingElement(element), error("Failed %s type: %s", location, error$1.message), setCurrentlyValidatingElement(null));
            }
        }
      }
      var ReactCurrentOwner = ReactSharedInternals.ReactCurrentOwner, hasOwnProperty2 = Object.prototype.hasOwnProperty, RESERVED_PROPS = {
        key: !0,
        ref: !0,
        __self: !0,
        __source: !0
      }, specialPropKeyWarningShown, specialPropRefWarningShown, didWarnAboutStringRefs;
      didWarnAboutStringRefs = {};
      function hasValidRef(config2) {
        if (hasOwnProperty2.call(config2, "ref")) {
          var getter = Object.getOwnPropertyDescriptor(config2, "ref").get;
          if (getter && getter.isReactWarning)
            return !1;
        }
        return config2.ref !== void 0;
      }
      function hasValidKey(config2) {
        if (hasOwnProperty2.call(config2, "key")) {
          var getter = Object.getOwnPropertyDescriptor(config2, "key").get;
          if (getter && getter.isReactWarning)
            return !1;
        }
        return config2.key !== void 0;
      }
      function warnIfStringRefCannotBeAutoConverted(config2, self2) {
        if (typeof config2.ref == "string" && ReactCurrentOwner.current && self2 && ReactCurrentOwner.current.stateNode !== self2) {
          var componentName = getComponentName(ReactCurrentOwner.current.type);
          didWarnAboutStringRefs[componentName] || (error('Component "%s" contains the string ref "%s". Support for string refs will be removed in a future major release. This case cannot be automatically converted to an arrow function. We ask you to manually fix this case by using useRef() or createRef() instead. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-string-ref', getComponentName(ReactCurrentOwner.current.type), config2.ref), didWarnAboutStringRefs[componentName] = !0);
        }
      }
      function defineKeyPropWarningGetter(props, displayName) {
        {
          var warnAboutAccessingKey = function() {
            specialPropKeyWarningShown || (specialPropKeyWarningShown = !0, error("%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", displayName));
          };
          warnAboutAccessingKey.isReactWarning = !0, Object.defineProperty(props, "key", {
            get: warnAboutAccessingKey,
            configurable: !0
          });
        }
      }
      function defineRefPropWarningGetter(props, displayName) {
        {
          var warnAboutAccessingRef = function() {
            specialPropRefWarningShown || (specialPropRefWarningShown = !0, error("%s: `ref` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", displayName));
          };
          warnAboutAccessingRef.isReactWarning = !0, Object.defineProperty(props, "ref", {
            get: warnAboutAccessingRef,
            configurable: !0
          });
        }
      }
      var ReactElement = function(type, key, ref, self2, source, owner, props) {
        var element = {
          $$typeof: REACT_ELEMENT_TYPE,
          type,
          key,
          ref,
          props,
          _owner: owner
        };
        return element._store = {}, Object.defineProperty(element._store, "validated", {
          configurable: !1,
          enumerable: !1,
          writable: !0,
          value: !1
        }), Object.defineProperty(element, "_self", {
          configurable: !1,
          enumerable: !1,
          writable: !1,
          value: self2
        }), Object.defineProperty(element, "_source", {
          configurable: !1,
          enumerable: !1,
          writable: !1,
          value: source
        }), Object.freeze && (Object.freeze(element.props), Object.freeze(element)), element;
      };
      function jsxDEV7(type, config2, maybeKey, source, self2) {
        {
          var propName, props = {}, key = null, ref = null;
          maybeKey !== void 0 && (key = "" + maybeKey), hasValidKey(config2) && (key = "" + config2.key), hasValidRef(config2) && (ref = config2.ref, warnIfStringRefCannotBeAutoConverted(config2, self2));
          for (propName in config2)
            hasOwnProperty2.call(config2, propName) && !RESERVED_PROPS.hasOwnProperty(propName) && (props[propName] = config2[propName]);
          if (type && type.defaultProps) {
            var defaultProps2 = type.defaultProps;
            for (propName in defaultProps2)
              props[propName] === void 0 && (props[propName] = defaultProps2[propName]);
          }
          if (key || ref) {
            var displayName = typeof type == "function" ? type.displayName || type.name || "Unknown" : type;
            key && defineKeyPropWarningGetter(props, displayName), ref && defineRefPropWarningGetter(props, displayName);
          }
          return ReactElement(type, key, ref, self2, source, ReactCurrentOwner.current, props);
        }
      }
      var ReactCurrentOwner$1 = ReactSharedInternals.ReactCurrentOwner, ReactDebugCurrentFrame$1 = ReactSharedInternals.ReactDebugCurrentFrame;
      function setCurrentlyValidatingElement$1(element) {
        if (element) {
          var owner = element._owner, stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);
          ReactDebugCurrentFrame$1.setExtraStackFrame(stack);
        } else
          ReactDebugCurrentFrame$1.setExtraStackFrame(null);
      }
      var propTypesMisspellWarningShown;
      propTypesMisspellWarningShown = !1;
      function isValidElement9(object) {
        return typeof object == "object" && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;
      }
      function getDeclarationErrorAddendum() {
        {
          if (ReactCurrentOwner$1.current) {
            var name = getComponentName(ReactCurrentOwner$1.current.type);
            if (name)
              return `

Check the render method of \`` + name + "`.";
          }
          return "";
        }
      }
      function getSourceInfoErrorAddendum(source) {
        {
          if (source !== void 0) {
            var fileName = source.fileName.replace(/^.*[\\\/]/, ""), lineNumber = source.lineNumber;
            return `

Check your code at ` + fileName + ":" + lineNumber + ".";
          }
          return "";
        }
      }
      var ownerHasKeyUseWarning = {};
      function getCurrentComponentErrorInfo(parentType) {
        {
          var info = getDeclarationErrorAddendum();
          if (!info) {
            var parentName = typeof parentType == "string" ? parentType : parentType.displayName || parentType.name;
            parentName && (info = `

Check the top-level render call using <` + parentName + ">.");
          }
          return info;
        }
      }
      function validateExplicitKey(element, parentType) {
        {
          if (!element._store || element._store.validated || element.key != null)
            return;
          element._store.validated = !0;
          var currentComponentErrorInfo = getCurrentComponentErrorInfo(parentType);
          if (ownerHasKeyUseWarning[currentComponentErrorInfo])
            return;
          ownerHasKeyUseWarning[currentComponentErrorInfo] = !0;
          var childOwner = "";
          element && element._owner && element._owner !== ReactCurrentOwner$1.current && (childOwner = " It was passed a child from " + getComponentName(element._owner.type) + "."), setCurrentlyValidatingElement$1(element), error('Each child in a list should have a unique "key" prop.%s%s See https://reactjs.org/link/warning-keys for more information.', currentComponentErrorInfo, childOwner), setCurrentlyValidatingElement$1(null);
        }
      }
      function validateChildKeys(node, parentType) {
        {
          if (typeof node != "object")
            return;
          if (Array.isArray(node))
            for (var i = 0; i < node.length; i++) {
              var child = node[i];
              isValidElement9(child) && validateExplicitKey(child, parentType);
            }
          else if (isValidElement9(node))
            node._store && (node._store.validated = !0);
          else if (node) {
            var iteratorFn = getIteratorFn(node);
            if (typeof iteratorFn == "function" && iteratorFn !== node.entries)
              for (var iterator = iteratorFn.call(node), step; !(step = iterator.next()).done; )
                isValidElement9(step.value) && validateExplicitKey(step.value, parentType);
          }
        }
      }
      function validatePropTypes(element) {
        {
          var type = element.type;
          if (type == null || typeof type == "string")
            return;
          var propTypes;
          if (typeof type == "function")
            propTypes = type.propTypes;
          else if (typeof type == "object" && (type.$$typeof === REACT_FORWARD_REF_TYPE || type.$$typeof === REACT_MEMO_TYPE))
            propTypes = type.propTypes;
          else
            return;
          if (propTypes) {
            var name = getComponentName(type);
            checkPropTypes(propTypes, element.props, "prop", name, element);
          } else if (type.PropTypes !== void 0 && !propTypesMisspellWarningShown) {
            propTypesMisspellWarningShown = !0;
            var _name = getComponentName(type);
            error("Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?", _name || "Unknown");
          }
          typeof type.getDefaultProps == "function" && !type.getDefaultProps.isReactClassApproved && error("getDefaultProps is only used on classic React.createClass definitions. Use a static property named `defaultProps` instead.");
        }
      }
      function validateFragmentProps(fragment) {
        {
          for (var keys2 = Object.keys(fragment.props), i = 0; i < keys2.length; i++) {
            var key = keys2[i];
            if (key !== "children" && key !== "key") {
              setCurrentlyValidatingElement$1(fragment), error("Invalid prop `%s` supplied to `React.Fragment`. React.Fragment can only have `key` and `children` props.", key), setCurrentlyValidatingElement$1(null);
              break;
            }
          }
          fragment.ref !== null && (setCurrentlyValidatingElement$1(fragment), error("Invalid attribute `ref` supplied to `React.Fragment`."), setCurrentlyValidatingElement$1(null));
        }
      }
      function jsxWithValidation(type, props, key, isStaticChildren, source, self2) {
        {
          var validType = isValidElementType(type);
          if (!validType) {
            var info = "";
            (type === void 0 || typeof type == "object" && type !== null && Object.keys(type).length === 0) && (info += " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.");
            var sourceInfo = getSourceInfoErrorAddendum(source);
            sourceInfo ? info += sourceInfo : info += getDeclarationErrorAddendum();
            var typeString;
            type === null ? typeString = "null" : Array.isArray(type) ? typeString = "array" : type !== void 0 && type.$$typeof === REACT_ELEMENT_TYPE ? (typeString = "<" + (getComponentName(type.type) || "Unknown") + " />", info = " Did you accidentally export a JSX literal instead of a component?") : typeString = typeof type, error("React.jsx: type is invalid -- expected a string (for built-in components) or a class/function (for composite components) but got: %s.%s", typeString, info);
          }
          var element = jsxDEV7(type, props, key, source, self2);
          if (element == null)
            return element;
          if (validType) {
            var children = props.children;
            if (children !== void 0)
              if (isStaticChildren)
                if (Array.isArray(children)) {
                  for (var i = 0; i < children.length; i++)
                    validateChildKeys(children[i], type);
                  Object.freeze && Object.freeze(children);
                } else
                  error("React.jsx: Static children should always be an array. You are likely explicitly calling React.jsxs or React.jsxDEV. Use the Babel transform instead.");
              else
                validateChildKeys(children, type);
          }
          return type === exports.Fragment ? validateFragmentProps(element) : validatePropTypes(element), element;
        }
      }
      function jsxWithValidationStatic(type, props, key) {
        return jsxWithValidation(type, props, key, !0);
      }
      function jsxWithValidationDynamic(type, props, key) {
        return jsxWithValidation(type, props, key, !1);
      }
      var jsx = jsxWithValidationDynamic, jsxs = jsxWithValidationStatic;
      exports.jsx = jsx, exports.jsxs = jsxs;
    })();
  }
});

// node_modules/react/jsx-runtime.js
var require_jsx_runtime = __commonJS({
  "node_modules/react/jsx-runtime.js"(exports, module) {
    "use strict";
    module.exports = require_react_jsx_runtime_development();
  }
});

// node_modules/@mui/base/BadgeUnstyled/BadgeUnstyled.types.js
var init_BadgeUnstyled_types = __esm({
  "node_modules/@mui/base/BadgeUnstyled/BadgeUnstyled.types.js"() {
  }
});

// node_modules/@mui/base/BadgeUnstyled/index.js
var init_BadgeUnstyled = __esm({
  "node_modules/@mui/base/BadgeUnstyled/index.js"() {
    init_useBadge();
    init_BadgeUnstyled_types();
    init_badgeUnstyledClasses();
  }
});

// node_modules/@mui/base/ButtonUnstyled/ButtonUnstyled.types.js
var init_ButtonUnstyled_types = __esm({
  "node_modules/@mui/base/ButtonUnstyled/ButtonUnstyled.types.js"() {
  }
});

// node_modules/@mui/base/ButtonUnstyled/useButton.types.js
var init_useButton_types = __esm({
  "node_modules/@mui/base/ButtonUnstyled/useButton.types.js"() {
  }
});

// node_modules/@mui/base/ButtonUnstyled/index.js
var init_ButtonUnstyled = __esm({
  "node_modules/@mui/base/ButtonUnstyled/index.js"() {
    init_ButtonUnstyled_types();
    init_useButton_types();
  }
});

// node_modules/@mui/base/FormControlUnstyled/formControlUnstyledClasses.js
var formControlUnstyledClasses, init_formControlUnstyledClasses = __esm({
  "node_modules/@mui/base/FormControlUnstyled/formControlUnstyledClasses.js"() {
    init_generateUtilityClasses3();
    formControlUnstyledClasses = generateUtilityClasses("BaseFormControl", ["root", "disabled", "error", "filled", "focused", "required"]);
  }
});

// node_modules/@mui/base/FormControlUnstyled/index.js
var init_FormControlUnstyled = __esm({
  "node_modules/@mui/base/FormControlUnstyled/index.js"() {
    init_formControlUnstyledClasses();
  }
});

// node_modules/@mui/base/InputUnstyled/inputUnstyledClasses.js
var inputBaseClasses, init_inputUnstyledClasses = __esm({
  "node_modules/@mui/base/InputUnstyled/inputUnstyledClasses.js"() {
    init_generateUtilityClasses3();
    inputBaseClasses = generateUtilityClasses("MuiInput", ["root", "formControl", "focused", "disabled", "error", "multiline", "input", "inputMultiline", "inputTypeSearch", "adornedStart", "adornedEnd"]);
  }
});

// node_modules/@mui/base/InputUnstyled/InputUnstyled.types.js
var init_InputUnstyled_types = __esm({
  "node_modules/@mui/base/InputUnstyled/InputUnstyled.types.js"() {
  }
});

// node_modules/@mui/base/InputUnstyled/useInput.types.js
var init_useInput_types = __esm({
  "node_modules/@mui/base/InputUnstyled/useInput.types.js"() {
  }
});

// node_modules/@mui/base/InputUnstyled/index.js
var init_InputUnstyled = __esm({
  "node_modules/@mui/base/InputUnstyled/index.js"() {
    init_InputUnstyled_types();
    init_useInput_types();
    init_inputUnstyledClasses();
  }
});

// node_modules/@mui/base/ListboxUnstyled/useListbox.types.js
var ActionTypes, init_useListbox_types = __esm({
  "node_modules/@mui/base/ListboxUnstyled/useListbox.types.js"() {
    (function(ActionTypes2) {
      ActionTypes2.blur = "blur", ActionTypes2.focus = "focus", ActionTypes2.keyDown = "keyDown", ActionTypes2.optionClick = "optionClick", ActionTypes2.optionHover = "optionHover", ActionTypes2.optionsChange = "optionsChange", ActionTypes2.setValue = "setValue", ActionTypes2.setHighlight = "setHighlight", ActionTypes2.textNavigation = "textNagivation";
    })(ActionTypes || (ActionTypes = {}));
  }
});

// node_modules/@mui/base/ListboxUnstyled/index.js
var init_ListboxUnstyled = __esm({
  "node_modules/@mui/base/ListboxUnstyled/index.js"() {
    init_useListbox_types();
  }
});

// node_modules/@mui/base/MenuUnstyled/MenuUnstyledContext.js
var React12, MenuUnstyledContext, init_MenuUnstyledContext = __esm({
  "node_modules/@mui/base/MenuUnstyled/MenuUnstyledContext.js"() {
    React12 = __toESM(require_react()), MenuUnstyledContext = /* @__PURE__ */ React12.createContext(null);
    MenuUnstyledContext.displayName = "MenuUnstyledContext";
  }
});

// node_modules/@mui/base/MenuUnstyled/menuUnstyledClasses.js
var menuUnstyledClasses, init_menuUnstyledClasses = __esm({
  "node_modules/@mui/base/MenuUnstyled/menuUnstyledClasses.js"() {
    init_generateUtilityClasses3();
    menuUnstyledClasses = generateUtilityClasses("MuiMenuUnstyled", ["root", "listbox", "expanded"]);
  }
});

// node_modules/scheduler/cjs/scheduler.development.js
var require_scheduler_development = __commonJS({
  "node_modules/scheduler/cjs/scheduler.development.js"(exports) {
    "use strict";
    (function() {
      "use strict";
      var enableSchedulerDebugging = !1, enableProfiling = !1, requestHostCallback, requestHostTimeout, cancelHostTimeout, requestPaint, hasPerformanceNow = typeof performance == "object" && typeof performance.now == "function";
      if (hasPerformanceNow) {
        var localPerformance = performance;
        exports.unstable_now = function() {
          return localPerformance.now();
        };
      } else {
        var localDate = Date, initialTime = localDate.now();
        exports.unstable_now = function() {
          return localDate.now() - initialTime;
        };
      }
      if (typeof window > "u" || typeof MessageChannel != "function") {
        var _callback = null, _timeoutID = null, _flushCallback = function() {
          if (_callback !== null)
            try {
              var currentTime = exports.unstable_now(), hasRemainingTime = !0;
              _callback(hasRemainingTime, currentTime), _callback = null;
            } catch (e) {
              throw setTimeout(_flushCallback, 0), e;
            }
        };
        requestHostCallback = function(cb) {
          _callback !== null ? setTimeout(requestHostCallback, 0, cb) : (_callback = cb, setTimeout(_flushCallback, 0));
        }, requestHostTimeout = function(cb, ms) {
          _timeoutID = setTimeout(cb, ms);
        }, cancelHostTimeout = function() {
          clearTimeout(_timeoutID);
        }, exports.unstable_shouldYield = function() {
          return !1;
        }, requestPaint = exports.unstable_forceFrameRate = function() {
        };
      } else {
        var _setTimeout = window.setTimeout, _clearTimeout = window.clearTimeout;
        if (typeof console < "u") {
          var requestAnimationFrame = window.requestAnimationFrame, cancelAnimationFrame = window.cancelAnimationFrame;
          typeof requestAnimationFrame != "function" && console.error("This browser doesn't support requestAnimationFrame. Make sure that you load a polyfill in older browsers. https://reactjs.org/link/react-polyfills"), typeof cancelAnimationFrame != "function" && console.error("This browser doesn't support cancelAnimationFrame. Make sure that you load a polyfill in older browsers. https://reactjs.org/link/react-polyfills");
        }
        var isMessageLoopRunning = !1, scheduledHostCallback = null, taskTimeoutID = -1, yieldInterval = 5, deadline = 0;
        exports.unstable_shouldYield = function() {
          return exports.unstable_now() >= deadline;
        }, requestPaint = function() {
        }, exports.unstable_forceFrameRate = function(fps) {
          if (fps < 0 || fps > 125) {
            console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported");
            return;
          }
          fps > 0 ? yieldInterval = Math.floor(1e3 / fps) : yieldInterval = 5;
        };
        var performWorkUntilDeadline = function() {
          if (scheduledHostCallback !== null) {
            var currentTime = exports.unstable_now();
            deadline = currentTime + yieldInterval;
            var hasTimeRemaining = !0;
            try {
              var hasMoreWork = scheduledHostCallback(hasTimeRemaining, currentTime);
              hasMoreWork ? port.postMessage(null) : (isMessageLoopRunning = !1, scheduledHostCallback = null);
            } catch (error) {
              throw port.postMessage(null), error;
            }
          } else
            isMessageLoopRunning = !1;
        }, channel = new MessageChannel(), port = channel.port2;
        channel.port1.onmessage = performWorkUntilDeadline, requestHostCallback = function(callback) {
          scheduledHostCallback = callback, isMessageLoopRunning || (isMessageLoopRunning = !0, port.postMessage(null));
        }, requestHostTimeout = function(callback, ms) {
          taskTimeoutID = _setTimeout(function() {
            callback(exports.unstable_now());
          }, ms);
        }, cancelHostTimeout = function() {
          _clearTimeout(taskTimeoutID), taskTimeoutID = -1;
        };
      }
      function push(heap, node) {
        var index = heap.length;
        heap.push(node), siftUp(heap, node, index);
      }
      function peek(heap) {
        var first = heap[0];
        return first === void 0 ? null : first;
      }
      function pop(heap) {
        var first = heap[0];
        if (first !== void 0) {
          var last = heap.pop();
          return last !== first && (heap[0] = last, siftDown(heap, last, 0)), first;
        } else
          return null;
      }
      function siftUp(heap, node, i) {
        for (var index = i; ; ) {
          var parentIndex = index - 1 >>> 1, parent = heap[parentIndex];
          if (parent !== void 0 && compare3(parent, node) > 0)
            heap[parentIndex] = node, heap[index] = parent, index = parentIndex;
          else
            return;
        }
      }
      function siftDown(heap, node, i) {
        for (var index = i, length = heap.length; index < length; ) {
          var leftIndex = (index + 1) * 2 - 1, left2 = heap[leftIndex], rightIndex = leftIndex + 1, right2 = heap[rightIndex];
          if (left2 !== void 0 && compare3(left2, node) < 0)
            right2 !== void 0 && compare3(right2, left2) < 0 ? (heap[index] = right2, heap[rightIndex] = node, index = rightIndex) : (heap[index] = left2, heap[leftIndex] = node, index = leftIndex);
          else if (right2 !== void 0 && compare3(right2, node) < 0)
            heap[index] = right2, heap[rightIndex] = node, index = rightIndex;
          else
            return;
        }
      }
      function compare3(a, b) {
        var diff = a.sortIndex - b.sortIndex;
        return diff !== 0 ? diff : a.id - b.id;
      }
      var ImmediatePriority = 1, UserBlockingPriority = 2, NormalPriority = 3, LowPriority = 4, IdlePriority = 5;
      function markTaskErrored(task, ms) {
      }
      var maxSigned31BitInt = 1073741823, IMMEDIATE_PRIORITY_TIMEOUT = -1, USER_BLOCKING_PRIORITY_TIMEOUT = 250, NORMAL_PRIORITY_TIMEOUT = 5e3, LOW_PRIORITY_TIMEOUT = 1e4, IDLE_PRIORITY_TIMEOUT = maxSigned31BitInt, taskQueue = [], timerQueue = [], taskIdCounter = 1, currentTask = null, currentPriorityLevel = NormalPriority, isPerformingWork = !1, isHostCallbackScheduled = !1, isHostTimeoutScheduled = !1;
      function advanceTimers(currentTime) {
        for (var timer = peek(timerQueue); timer !== null; ) {
          if (timer.callback === null)
            pop(timerQueue);
          else if (timer.startTime <= currentTime)
            pop(timerQueue), timer.sortIndex = timer.expirationTime, push(taskQueue, timer);
          else
            return;
          timer = peek(timerQueue);
        }
      }
      function handleTimeout(currentTime) {
        if (isHostTimeoutScheduled = !1, advanceTimers(currentTime), !isHostCallbackScheduled)
          if (peek(taskQueue) !== null)
            isHostCallbackScheduled = !0, requestHostCallback(flushWork);
          else {
            var firstTimer = peek(timerQueue);
            firstTimer !== null && requestHostTimeout(handleTimeout, firstTimer.startTime - currentTime);
          }
      }
      function flushWork(hasTimeRemaining, initialTime2) {
        isHostCallbackScheduled = !1, isHostTimeoutScheduled && (isHostTimeoutScheduled = !1, cancelHostTimeout()), isPerformingWork = !0;
        var previousPriorityLevel = currentPriorityLevel;
        try {
          if (enableProfiling)
            try {
              return workLoop(hasTimeRemaining, initialTime2);
            } catch (error) {
              if (currentTask !== null) {
                var currentTime = exports.unstable_now();
                currentTask.isQueued = !1;
              }
              throw error;
            }
          else
            return workLoop(hasTimeRemaining, initialTime2);
        } finally {
          currentTask = null, currentPriorityLevel = previousPriorityLevel, isPerformingWork = !1;
        }
      }
      function workLoop(hasTimeRemaining, initialTime2) {
        var currentTime = initialTime2;
        for (advanceTimers(currentTime), currentTask = peek(taskQueue); currentTask !== null && !enableSchedulerDebugging && !(currentTask.expirationTime > currentTime && (!hasTimeRemaining || exports.unstable_shouldYield())); ) {
          var callback = currentTask.callback;
          if (typeof callback == "function") {
            currentTask.callback = null, currentPriorityLevel = currentTask.priorityLevel;
            var didUserCallbackTimeout = currentTask.expirationTime <= currentTime, continuationCallback = callback(didUserCallbackTimeout);
            currentTime = exports.unstable_now(), typeof continuationCallback == "function" ? currentTask.callback = continuationCallback : currentTask === peek(taskQueue) && pop(taskQueue), advanceTimers(currentTime);
          } else
            pop(taskQueue);
          currentTask = peek(taskQueue);
        }
        if (currentTask !== null)
          return !0;
        var firstTimer = peek(timerQueue);
        return firstTimer !== null && requestHostTimeout(handleTimeout, firstTimer.startTime - currentTime), !1;
      }
      function unstable_runWithPriority(priorityLevel, eventHandler) {
        switch (priorityLevel) {
          case ImmediatePriority:
          case UserBlockingPriority:
          case NormalPriority:
          case LowPriority:
          case IdlePriority:
            break;
          default:
            priorityLevel = NormalPriority;
        }
        var previousPriorityLevel = currentPriorityLevel;
        currentPriorityLevel = priorityLevel;
        try {
          return eventHandler();
        } finally {
          currentPriorityLevel = previousPriorityLevel;
        }
      }
      function unstable_next(eventHandler) {
        var priorityLevel;
        switch (currentPriorityLevel) {
          case ImmediatePriority:
          case UserBlockingPriority:
          case NormalPriority:
            priorityLevel = NormalPriority;
            break;
          default:
            priorityLevel = currentPriorityLevel;
            break;
        }
        var previousPriorityLevel = currentPriorityLevel;
        currentPriorityLevel = priorityLevel;
        try {
          return eventHandler();
        } finally {
          currentPriorityLevel = previousPriorityLevel;
        }
      }
      function unstable_wrapCallback(callback) {
        var parentPriorityLevel = currentPriorityLevel;
        return function() {
          var previousPriorityLevel = currentPriorityLevel;
          currentPriorityLevel = parentPriorityLevel;
          try {
            return callback.apply(this, arguments);
          } finally {
            currentPriorityLevel = previousPriorityLevel;
          }
        };
      }
      function unstable_scheduleCallback(priorityLevel, callback, options) {
        var currentTime = exports.unstable_now(), startTime2;
        if (typeof options == "object" && options !== null) {
          var delay = options.delay;
          typeof delay == "number" && delay > 0 ? startTime2 = currentTime + delay : startTime2 = currentTime;
        } else
          startTime2 = currentTime;
        var timeout2;
        switch (priorityLevel) {
          case ImmediatePriority:
            timeout2 = IMMEDIATE_PRIORITY_TIMEOUT;
            break;
          case UserBlockingPriority:
            timeout2 = USER_BLOCKING_PRIORITY_TIMEOUT;
            break;
          case IdlePriority:
            timeout2 = IDLE_PRIORITY_TIMEOUT;
            break;
          case LowPriority:
            timeout2 = LOW_PRIORITY_TIMEOUT;
            break;
          case NormalPriority:
          default:
            timeout2 = NORMAL_PRIORITY_TIMEOUT;
            break;
        }
        var expirationTime = startTime2 + timeout2, newTask = {
          id: taskIdCounter++,
          callback,
          priorityLevel,
          startTime: startTime2,
          expirationTime,
          sortIndex: -1
        };
        return startTime2 > currentTime ? (newTask.sortIndex = startTime2, push(timerQueue, newTask), peek(taskQueue) === null && newTask === peek(timerQueue) && (isHostTimeoutScheduled ? cancelHostTimeout() : isHostTimeoutScheduled = !0, requestHostTimeout(handleTimeout, startTime2 - currentTime))) : (newTask.sortIndex = expirationTime, push(taskQueue, newTask), !isHostCallbackScheduled && !isPerformingWork && (isHostCallbackScheduled = !0, requestHostCallback(flushWork))), newTask;
      }
      function unstable_pauseExecution() {
      }
      function unstable_continueExecution() {
        !isHostCallbackScheduled && !isPerformingWork && (isHostCallbackScheduled = !0, requestHostCallback(flushWork));
      }
      function unstable_getFirstCallbackNode() {
        return peek(taskQueue);
      }
      function unstable_cancelCallback(task) {
        task.callback = null;
      }
      function unstable_getCurrentPriorityLevel() {
        return currentPriorityLevel;
      }
      var unstable_requestPaint = requestPaint, unstable_Profiling = null;
      exports.unstable_IdlePriority = IdlePriority, exports.unstable_ImmediatePriority = ImmediatePriority, exports.unstable_LowPriority = LowPriority, exports.unstable_NormalPriority = NormalPriority, exports.unstable_Profiling = unstable_Profiling, exports.unstable_UserBlockingPriority = UserBlockingPriority, exports.unstable_cancelCallback = unstable_cancelCallback, exports.unstable_continueExecution = unstable_continueExecution, exports.unstable_getCurrentPriorityLevel = unstable_getCurrentPriorityLevel, exports.unstable_getFirstCallbackNode = unstable_getFirstCallbackNode, exports.unstable_next = unstable_next, exports.unstable_pauseExecution = unstable_pauseExecution, exports.unstable_requestPaint = unstable_requestPaint, exports.unstable_runWithPriority = unstable_runWithPriority, exports.unstable_scheduleCallback = unstable_scheduleCallback, exports.unstable_wrapCallback = unstable_wrapCallback;
    })();
  }
});

// node_modules/scheduler/index.js
var require_scheduler = __commonJS({
  "node_modules/scheduler/index.js"(exports, module) {
    "use strict";
    module.exports = require_scheduler_development();
  }
});

// node_modules/scheduler/cjs/scheduler-tracing.development.js
var require_scheduler_tracing_development = __commonJS({
  "node_modules/scheduler/cjs/scheduler-tracing.development.js"(exports) {
    "use strict";
    (function() {
      "use strict";
      var DEFAULT_THREAD_ID = 0, interactionIDCounter = 0, threadIDCounter = 0;
      exports.__interactionsRef = null, exports.__subscriberRef = null, exports.__interactionsRef = {
        current: /* @__PURE__ */ new Set()
      }, exports.__subscriberRef = {
        current: null
      };
      function unstable_clear(callback) {
        var prevInteractions = exports.__interactionsRef.current;
        exports.__interactionsRef.current = /* @__PURE__ */ new Set();
        try {
          return callback();
        } finally {
          exports.__interactionsRef.current = prevInteractions;
        }
      }
      function unstable_getCurrent() {
        return exports.__interactionsRef.current;
      }
      function unstable_getThreadID() {
        return ++threadIDCounter;
      }
      function unstable_trace(name, timestamp, callback) {
        var threadID = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : DEFAULT_THREAD_ID, interaction = {
          __count: 1,
          id: interactionIDCounter++,
          name,
          timestamp
        }, prevInteractions = exports.__interactionsRef.current, interactions = new Set(prevInteractions);
        interactions.add(interaction), exports.__interactionsRef.current = interactions;
        var subscriber = exports.__subscriberRef.current, returnValue;
        try {
          subscriber !== null && subscriber.onInteractionTraced(interaction);
        } finally {
          try {
            subscriber !== null && subscriber.onWorkStarted(interactions, threadID);
          } finally {
            try {
              returnValue = callback();
            } finally {
              exports.__interactionsRef.current = prevInteractions;
              try {
                subscriber !== null && subscriber.onWorkStopped(interactions, threadID);
              } finally {
                interaction.__count--, subscriber !== null && interaction.__count === 0 && subscriber.onInteractionScheduledWorkCompleted(interaction);
              }
            }
          }
        }
        return returnValue;
      }
      function unstable_wrap(callback) {
        var threadID = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : DEFAULT_THREAD_ID, wrappedInteractions = exports.__interactionsRef.current, subscriber = exports.__subscriberRef.current;
        subscriber !== null && subscriber.onWorkScheduled(wrappedInteractions, threadID), wrappedInteractions.forEach(function(interaction) {
          interaction.__count++;
        });
        var hasRun = !1;
        function wrapped() {
          var prevInteractions = exports.__interactionsRef.current;
          exports.__interactionsRef.current = wrappedInteractions, subscriber = exports.__subscriberRef.current;
          try {
            var returnValue;
            try {
              subscriber !== null && subscriber.onWorkStarted(wrappedInteractions, threadID);
            } finally {
              try {
                returnValue = callback.apply(void 0, arguments);
              } finally {
                exports.__interactionsRef.current = prevInteractions, subscriber !== null && subscriber.onWorkStopped(wrappedInteractions, threadID);
              }
            }
            return returnValue;
          } finally {
            hasRun || (hasRun = !0, wrappedInteractions.forEach(function(interaction) {
              interaction.__count--, subscriber !== null && interaction.__count === 0 && subscriber.onInteractionScheduledWorkCompleted(interaction);
            }));
          }
        }
        return wrapped.cancel = function() {
          subscriber = exports.__subscriberRef.current;
          try {
            subscriber !== null && subscriber.onWorkCanceled(wrappedInteractions, threadID);
          } finally {
            wrappedInteractions.forEach(function(interaction) {
              interaction.__count--, subscriber && interaction.__count === 0 && subscriber.onInteractionScheduledWorkCompleted(interaction);
            });
          }
        }, wrapped;
      }
      var subscribers = null;
      subscribers = /* @__PURE__ */ new Set();
      function unstable_subscribe(subscriber) {
        subscribers.add(subscriber), subscribers.size === 1 && (exports.__subscriberRef.current = {
          onInteractionScheduledWorkCompleted,
          onInteractionTraced,
          onWorkCanceled,
          onWorkScheduled,
          onWorkStarted,
          onWorkStopped
        });
      }
      function unstable_unsubscribe(subscriber) {
        subscribers.delete(subscriber), subscribers.size === 0 && (exports.__subscriberRef.current = null);
      }
      function onInteractionTraced(interaction) {
        var didCatchError = !1, caughtError = null;
        if (subscribers.forEach(function(subscriber) {
          try {
            subscriber.onInteractionTraced(interaction);
          } catch (error) {
            didCatchError || (didCatchError = !0, caughtError = error);
          }
        }), didCatchError)
          throw caughtError;
      }
      function onInteractionScheduledWorkCompleted(interaction) {
        var didCatchError = !1, caughtError = null;
        if (subscribers.forEach(function(subscriber) {
          try {
            subscriber.onInteractionScheduledWorkCompleted(interaction);
          } catch (error) {
            didCatchError || (didCatchError = !0, caughtError = error);
          }
        }), didCatchError)
          throw caughtError;
      }
      function onWorkScheduled(interactions, threadID) {
        var didCatchError = !1, caughtError = null;
        if (subscribers.forEach(function(subscriber) {
          try {
            subscriber.onWorkScheduled(interactions, threadID);
          } catch (error) {
            didCatchError || (didCatchError = !0, caughtError = error);
          }
        }), didCatchError)
          throw caughtError;
      }
      function onWorkStarted(interactions, threadID) {
        var didCatchError = !1, caughtError = null;
        if (subscribers.forEach(function(subscriber) {
          try {
            subscriber.onWorkStarted(interactions, threadID);
          } catch (error) {
            didCatchError || (didCatchError = !0, caughtError = error);
          }
        }), didCatchError)
          throw caughtError;
      }
      function onWorkStopped(interactions, threadID) {
        var didCatchError = !1, caughtError = null;
        if (subscribers.forEach(function(subscriber) {
          try {
            subscriber.onWorkStopped(interactions, threadID);
          } catch (error) {
            didCatchError || (didCatchError = !0, caughtError = error);
          }
        }), didCatchError)
          throw caughtError;
      }
      function onWorkCanceled(interactions, threadID) {
        var didCatchError = !1, caughtError = null;
        if (subscribers.forEach(function(subscriber) {
          try {
            subscriber.onWorkCanceled(interactions, threadID);
          } catch (error) {
            didCatchError || (didCatchError = !0, caughtError = error);
          }
        }), didCatchError)
          throw caughtError;
      }
      exports.unstable_clear = unstable_clear, exports.unstable_getCurrent = unstable_getCurrent, exports.unstable_getThreadID = unstable_getThreadID, exports.unstable_subscribe = unstable_subscribe, exports.unstable_trace = unstable_trace, exports.unstable_unsubscribe = unstable_unsubscribe, exports.unstable_wrap = unstable_wrap;
    })();
  }
});

// node_modules/scheduler/tracing.js
var require_tracing = __commonJS({
  "node_modules/scheduler/tracing.js"(exports, module) {
    "use strict";
    module.exports = require_scheduler_tracing_development();
  }
});

// node_modules/react-dom/cjs/react-dom.development.js
var require_react_dom_development = __commonJS({
  "node_modules/react-dom/cjs/react-dom.development.js"(exports) {
    "use strict";
    (function() {
      "use strict";
      var React90 = require_react(), _assign = require_object_assign(), Scheduler = require_scheduler(), tracing = require_tracing(), ReactSharedInternals = React90.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
      function warn(format2) {
        {
          for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++)
            args[_key - 1] = arguments[_key];
          printWarning("warn", format2, args);
        }
      }
      function error(format2) {
        {
          for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++)
            args[_key2 - 1] = arguments[_key2];
          printWarning("error", format2, args);
        }
      }
      function printWarning(level, format2, args) {
        {
          var ReactDebugCurrentFrame2 = ReactSharedInternals.ReactDebugCurrentFrame, stack = ReactDebugCurrentFrame2.getStackAddendum();
          stack !== "" && (format2 += "%s", args = args.concat([stack]));
          var argsWithFormat = args.map(function(item) {
            return "" + item;
          });
          argsWithFormat.unshift("Warning: " + format2), Function.prototype.apply.call(console[level], console, argsWithFormat);
        }
      }
      if (!React90)
        throw Error("ReactDOM was loaded before React. Make sure you load the React package before loading ReactDOM.");
      var FunctionComponent = 0, ClassComponent = 1, IndeterminateComponent = 2, HostRoot = 3, HostPortal = 4, HostComponent = 5, HostText = 6, Fragment11 = 7, Mode = 8, ContextConsumer = 9, ContextProvider = 10, ForwardRef2 = 11, Profiler = 12, SuspenseComponent = 13, MemoComponent = 14, SimpleMemoComponent = 15, LazyComponent = 16, IncompleteClassComponent = 17, DehydratedFragment = 18, SuspenseListComponent = 19, FundamentalComponent = 20, ScopeComponent = 21, Block = 22, OffscreenComponent = 23, LegacyHiddenComponent = 24, enableProfilerTimer = !0, enableFundamentalAPI = !1, enableNewReconciler = !1, warnAboutStringRefs = !1, allNativeEvents = /* @__PURE__ */ new Set(), registrationNameDependencies = {}, possibleRegistrationNames = {};
      function registerTwoPhaseEvent(registrationName, dependencies) {
        registerDirectEvent(registrationName, dependencies), registerDirectEvent(registrationName + "Capture", dependencies);
      }
      function registerDirectEvent(registrationName, dependencies) {
        registrationNameDependencies[registrationName] && error("EventRegistry: More than one plugin attempted to publish the same registration name, `%s`.", registrationName), registrationNameDependencies[registrationName] = dependencies;
        {
          var lowerCasedName = registrationName.toLowerCase();
          possibleRegistrationNames[lowerCasedName] = registrationName, registrationName === "onDoubleClick" && (possibleRegistrationNames.ondblclick = registrationName);
        }
        for (var i = 0; i < dependencies.length; i++)
          allNativeEvents.add(dependencies[i]);
      }
      var canUseDOM = typeof window < "u" && typeof window.document < "u" && typeof window.document.createElement < "u", RESERVED = 0, STRING = 1, BOOLEANISH_STRING = 2, BOOLEAN = 3, OVERLOADED_BOOLEAN = 4, NUMERIC = 5, POSITIVE_NUMERIC = 6, ATTRIBUTE_NAME_START_CHAR = ":A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD", ATTRIBUTE_NAME_CHAR = ATTRIBUTE_NAME_START_CHAR + "\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040", ROOT_ATTRIBUTE_NAME = "data-reactroot", VALID_ATTRIBUTE_NAME_REGEX = new RegExp("^[" + ATTRIBUTE_NAME_START_CHAR + "][" + ATTRIBUTE_NAME_CHAR + "]*$"), hasOwnProperty2 = Object.prototype.hasOwnProperty, illegalAttributeNameCache = {}, validatedAttributeNameCache = {};
      function isAttributeNameSafe(attributeName) {
        return hasOwnProperty2.call(validatedAttributeNameCache, attributeName) ? !0 : hasOwnProperty2.call(illegalAttributeNameCache, attributeName) ? !1 : VALID_ATTRIBUTE_NAME_REGEX.test(attributeName) ? (validatedAttributeNameCache[attributeName] = !0, !0) : (illegalAttributeNameCache[attributeName] = !0, error("Invalid attribute name: `%s`", attributeName), !1);
      }
      function shouldIgnoreAttribute(name, propertyInfo, isCustomComponentTag) {
        return propertyInfo !== null ? propertyInfo.type === RESERVED : isCustomComponentTag ? !1 : name.length > 2 && (name[0] === "o" || name[0] === "O") && (name[1] === "n" || name[1] === "N");
      }
      function shouldRemoveAttributeWithWarning(name, value, propertyInfo, isCustomComponentTag) {
        if (propertyInfo !== null && propertyInfo.type === RESERVED)
          return !1;
        switch (typeof value) {
          case "function":
          case "symbol":
            return !0;
          case "boolean": {
            if (isCustomComponentTag)
              return !1;
            if (propertyInfo !== null)
              return !propertyInfo.acceptsBooleans;
            var prefix2 = name.toLowerCase().slice(0, 5);
            return prefix2 !== "data-" && prefix2 !== "aria-";
          }
          default:
            return !1;
        }
      }
      function shouldRemoveAttribute(name, value, propertyInfo, isCustomComponentTag) {
        if (value === null || typeof value > "u" || shouldRemoveAttributeWithWarning(name, value, propertyInfo, isCustomComponentTag))
          return !0;
        if (isCustomComponentTag)
          return !1;
        if (propertyInfo !== null)
          switch (propertyInfo.type) {
            case BOOLEAN:
              return !value;
            case OVERLOADED_BOOLEAN:
              return value === !1;
            case NUMERIC:
              return isNaN(value);
            case POSITIVE_NUMERIC:
              return isNaN(value) || value < 1;
          }
        return !1;
      }
      function getPropertyInfo(name) {
        return properties2.hasOwnProperty(name) ? properties2[name] : null;
      }
      function PropertyInfoRecord(name, type, mustUseProperty, attributeName, attributeNamespace, sanitizeURL2, removeEmptyString) {
        this.acceptsBooleans = type === BOOLEANISH_STRING || type === BOOLEAN || type === OVERLOADED_BOOLEAN, this.attributeName = attributeName, this.attributeNamespace = attributeNamespace, this.mustUseProperty = mustUseProperty, this.propertyName = name, this.type = type, this.sanitizeURL = sanitizeURL2, this.removeEmptyString = removeEmptyString;
      }
      var properties2 = {}, reservedProps = [
        "children",
        "dangerouslySetInnerHTML",
        "defaultValue",
        "defaultChecked",
        "innerHTML",
        "suppressContentEditableWarning",
        "suppressHydrationWarning",
        "style"
      ];
      reservedProps.forEach(function(name) {
        properties2[name] = new PropertyInfoRecord(
          name,
          RESERVED,
          !1,
          name,
          null,
          !1,
          !1
        );
      }), [["acceptCharset", "accept-charset"], ["className", "class"], ["htmlFor", "for"], ["httpEquiv", "http-equiv"]].forEach(function(_ref) {
        var name = _ref[0], attributeName = _ref[1];
        properties2[name] = new PropertyInfoRecord(
          name,
          STRING,
          !1,
          attributeName,
          null,
          !1,
          !1
        );
      }), ["contentEditable", "draggable", "spellCheck", "value"].forEach(function(name) {
        properties2[name] = new PropertyInfoRecord(
          name,
          BOOLEANISH_STRING,
          !1,
          name.toLowerCase(),
          null,
          !1,
          !1
        );
      }), ["autoReverse", "externalResourcesRequired", "focusable", "preserveAlpha"].forEach(function(name) {
        properties2[name] = new PropertyInfoRecord(
          name,
          BOOLEANISH_STRING,
          !1,
          name,
          null,
          !1,
          !1
        );
      }), [
        "allowFullScreen",
        "async",
        "autoFocus",
        "autoPlay",
        "controls",
        "default",
        "defer",
        "disabled",
        "disablePictureInPicture",
        "disableRemotePlayback",
        "formNoValidate",
        "hidden",
        "loop",
        "noModule",
        "noValidate",
        "open",
        "playsInline",
        "readOnly",
        "required",
        "reversed",
        "scoped",
        "seamless",
        "itemScope"
      ].forEach(function(name) {
        properties2[name] = new PropertyInfoRecord(
          name,
          BOOLEAN,
          !1,
          name.toLowerCase(),
          null,
          !1,
          !1
        );
      }), [
        "checked",
        "multiple",
        "muted",
        "selected"
      ].forEach(function(name) {
        properties2[name] = new PropertyInfoRecord(
          name,
          BOOLEAN,
          !0,
          name,
          null,
          !1,
          !1
        );
      }), [
        "capture",
        "download"
      ].forEach(function(name) {
        properties2[name] = new PropertyInfoRecord(
          name,
          OVERLOADED_BOOLEAN,
          !1,
          name,
          null,
          !1,
          !1
        );
      }), [
        "cols",
        "rows",
        "size",
        "span"
      ].forEach(function(name) {
        properties2[name] = new PropertyInfoRecord(
          name,
          POSITIVE_NUMERIC,
          !1,
          name,
          null,
          !1,
          !1
        );
      }), ["rowSpan", "start"].forEach(function(name) {
        properties2[name] = new PropertyInfoRecord(
          name,
          NUMERIC,
          !1,
          name.toLowerCase(),
          null,
          !1,
          !1
        );
      });
      var CAMELIZE = /[\-\:]([a-z])/g, capitalize2 = function(token) {
        return token[1].toUpperCase();
      };
      [
        "accent-height",
        "alignment-baseline",
        "arabic-form",
        "baseline-shift",
        "cap-height",
        "clip-path",
        "clip-rule",
        "color-interpolation",
        "color-interpolation-filters",
        "color-profile",
        "color-rendering",
        "dominant-baseline",
        "enable-background",
        "fill-opacity",
        "fill-rule",
        "flood-color",
        "flood-opacity",
        "font-family",
        "font-size",
        "font-size-adjust",
        "font-stretch",
        "font-style",
        "font-variant",
        "font-weight",
        "glyph-name",
        "glyph-orientation-horizontal",
        "glyph-orientation-vertical",
        "horiz-adv-x",
        "horiz-origin-x",
        "image-rendering",
        "letter-spacing",
        "lighting-color",
        "marker-end",
        "marker-mid",
        "marker-start",
        "overline-position",
        "overline-thickness",
        "paint-order",
        "panose-1",
        "pointer-events",
        "rendering-intent",
        "shape-rendering",
        "stop-color",
        "stop-opacity",
        "strikethrough-position",
        "strikethrough-thickness",
        "stroke-dasharray",
        "stroke-dashoffset",
        "stroke-linecap",
        "stroke-linejoin",
        "stroke-miterlimit",
        "stroke-opacity",
        "stroke-width",
        "text-anchor",
        "text-decoration",
        "text-rendering",
        "underline-position",
        "underline-thickness",
        "unicode-bidi",
        "unicode-range",
        "units-per-em",
        "v-alphabetic",
        "v-hanging",
        "v-ideographic",
        "v-mathematical",
        "vector-effect",
        "vert-adv-y",
        "vert-origin-x",
        "vert-origin-y",
        "word-spacing",
        "writing-mode",
        "xmlns:xlink",
        "x-height"
      ].forEach(function(attributeName) {
        var name = attributeName.replace(CAMELIZE, capitalize2);
        properties2[name] = new PropertyInfoRecord(
          name,
          STRING,
          !1,
          attributeName,
          null,
          !1,
          !1
        );
      }), [
        "xlink:actuate",
        "xlink:arcrole",
        "xlink:role",
        "xlink:show",
        "xlink:title",
        "xlink:type"
      ].forEach(function(attributeName) {
        var name = attributeName.replace(CAMELIZE, capitalize2);
        properties2[name] = new PropertyInfoRecord(
          name,
          STRING,
          !1,
          attributeName,
          "http://www.w3.org/1999/xlink",
          !1,
          !1
        );
      }), [
        "xml:base",
        "xml:lang",
        "xml:space"
      ].forEach(function(attributeName) {
        var name = attributeName.replace(CAMELIZE, capitalize2);
        properties2[name] = new PropertyInfoRecord(
          name,
          STRING,
          !1,
          attributeName,
          "http://www.w3.org/XML/1998/namespace",
          !1,
          !1
        );
      }), ["tabIndex", "crossOrigin"].forEach(function(attributeName) {
        properties2[attributeName] = new PropertyInfoRecord(
          attributeName,
          STRING,
          !1,
          attributeName.toLowerCase(),
          null,
          !1,
          !1
        );
      });
      var xlinkHref = "xlinkHref";
      properties2[xlinkHref] = new PropertyInfoRecord(
        "xlinkHref",
        STRING,
        !1,
        "xlink:href",
        "http://www.w3.org/1999/xlink",
        !0,
        !1
      ), ["src", "href", "action", "formAction"].forEach(function(attributeName) {
        properties2[attributeName] = new PropertyInfoRecord(
          attributeName,
          STRING,
          !1,
          attributeName.toLowerCase(),
          null,
          !0,
          !0
        );
      });
      var isJavaScriptProtocol = /^[\u0000-\u001F ]*j[\r\n\t]*a[\r\n\t]*v[\r\n\t]*a[\r\n\t]*s[\r\n\t]*c[\r\n\t]*r[\r\n\t]*i[\r\n\t]*p[\r\n\t]*t[\r\n\t]*\:/i, didWarn = !1;
      function sanitizeURL(url) {
        !didWarn && isJavaScriptProtocol.test(url) && (didWarn = !0, error("A future version of React will block javascript: URLs as a security precaution. Use event handlers instead if you can. If you need to generate unsafe HTML try using dangerouslySetInnerHTML instead. React was passed %s.", JSON.stringify(url)));
      }
      function getValueForProperty(node, name, expected, propertyInfo) {
        if (propertyInfo.mustUseProperty) {
          var propertyName = propertyInfo.propertyName;
          return node[propertyName];
        } else {
          propertyInfo.sanitizeURL && sanitizeURL("" + expected);
          var attributeName = propertyInfo.attributeName, stringValue = null;
          if (propertyInfo.type === OVERLOADED_BOOLEAN) {
            if (node.hasAttribute(attributeName)) {
              var value = node.getAttribute(attributeName);
              return value === "" ? !0 : shouldRemoveAttribute(name, expected, propertyInfo, !1) ? value : value === "" + expected ? expected : value;
            }
          } else if (node.hasAttribute(attributeName)) {
            if (shouldRemoveAttribute(name, expected, propertyInfo, !1))
              return node.getAttribute(attributeName);
            if (propertyInfo.type === BOOLEAN)
              return expected;
            stringValue = node.getAttribute(attributeName);
          }
          return shouldRemoveAttribute(name, expected, propertyInfo, !1) ? stringValue === null ? expected : stringValue : stringValue === "" + expected ? expected : stringValue;
        }
      }
      function getValueForAttribute(node, name, expected) {
        {
          if (!isAttributeNameSafe(name))
            return;
          if (isOpaqueHydratingObject(expected))
            return expected;
          if (!node.hasAttribute(name))
            return expected === void 0 ? void 0 : null;
          var value = node.getAttribute(name);
          return value === "" + expected ? expected : value;
        }
      }
      function setValueForProperty(node, name, value, isCustomComponentTag) {
        var propertyInfo = getPropertyInfo(name);
        if (!shouldIgnoreAttribute(name, propertyInfo, isCustomComponentTag)) {
          if (shouldRemoveAttribute(name, value, propertyInfo, isCustomComponentTag) && (value = null), isCustomComponentTag || propertyInfo === null) {
            if (isAttributeNameSafe(name)) {
              var _attributeName = name;
              value === null ? node.removeAttribute(_attributeName) : node.setAttribute(_attributeName, "" + value);
            }
            return;
          }
          var mustUseProperty = propertyInfo.mustUseProperty;
          if (mustUseProperty) {
            var propertyName = propertyInfo.propertyName;
            if (value === null) {
              var type = propertyInfo.type;
              node[propertyName] = type === BOOLEAN ? !1 : "";
            } else
              node[propertyName] = value;
            return;
          }
          var attributeName = propertyInfo.attributeName, attributeNamespace = propertyInfo.attributeNamespace;
          if (value === null)
            node.removeAttribute(attributeName);
          else {
            var _type = propertyInfo.type, attributeValue;
            _type === BOOLEAN || _type === OVERLOADED_BOOLEAN && value === !0 ? attributeValue = "" : (attributeValue = "" + value, propertyInfo.sanitizeURL && sanitizeURL(attributeValue.toString())), attributeNamespace ? node.setAttributeNS(attributeNamespace, attributeName, attributeValue) : node.setAttribute(attributeName, attributeValue);
          }
        }
      }
      var REACT_ELEMENT_TYPE = 60103, REACT_PORTAL_TYPE = 60106, REACT_FRAGMENT_TYPE = 60107, REACT_STRICT_MODE_TYPE = 60108, REACT_PROFILER_TYPE = 60114, REACT_PROVIDER_TYPE = 60109, REACT_CONTEXT_TYPE = 60110, REACT_FORWARD_REF_TYPE = 60112, REACT_SUSPENSE_TYPE = 60113, REACT_SUSPENSE_LIST_TYPE = 60120, REACT_MEMO_TYPE = 60115, REACT_LAZY_TYPE = 60116, REACT_BLOCK_TYPE = 60121, REACT_SERVER_BLOCK_TYPE = 60122, REACT_FUNDAMENTAL_TYPE = 60117, REACT_SCOPE_TYPE = 60119, REACT_OPAQUE_ID_TYPE = 60128, REACT_DEBUG_TRACING_MODE_TYPE = 60129, REACT_OFFSCREEN_TYPE = 60130, REACT_LEGACY_HIDDEN_TYPE = 60131;
      if (typeof Symbol == "function" && Symbol.for) {
        var symbolFor = Symbol.for;
        REACT_ELEMENT_TYPE = symbolFor("react.element"), REACT_PORTAL_TYPE = symbolFor("react.portal"), REACT_FRAGMENT_TYPE = symbolFor("react.fragment"), REACT_STRICT_MODE_TYPE = symbolFor("react.strict_mode"), REACT_PROFILER_TYPE = symbolFor("react.profiler"), REACT_PROVIDER_TYPE = symbolFor("react.provider"), REACT_CONTEXT_TYPE = symbolFor("react.context"), REACT_FORWARD_REF_TYPE = symbolFor("react.forward_ref"), REACT_SUSPENSE_TYPE = symbolFor("react.suspense"), REACT_SUSPENSE_LIST_TYPE = symbolFor("react.suspense_list"), REACT_MEMO_TYPE = symbolFor("react.memo"), REACT_LAZY_TYPE = symbolFor("react.lazy"), REACT_BLOCK_TYPE = symbolFor("react.block"), REACT_SERVER_BLOCK_TYPE = symbolFor("react.server.block"), REACT_FUNDAMENTAL_TYPE = symbolFor("react.fundamental"), REACT_SCOPE_TYPE = symbolFor("react.scope"), REACT_OPAQUE_ID_TYPE = symbolFor("react.opaque.id"), REACT_DEBUG_TRACING_MODE_TYPE = symbolFor("react.debug_trace_mode"), REACT_OFFSCREEN_TYPE = symbolFor("react.offscreen"), REACT_LEGACY_HIDDEN_TYPE = symbolFor("react.legacy_hidden");
      }
      var MAYBE_ITERATOR_SYMBOL = typeof Symbol == "function" && Symbol.iterator, FAUX_ITERATOR_SYMBOL = "@@iterator";
      function getIteratorFn(maybeIterable) {
        if (maybeIterable === null || typeof maybeIterable != "object")
          return null;
        var maybeIterator = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL];
        return typeof maybeIterator == "function" ? maybeIterator : null;
      }
      var disabledDepth = 0, prevLog, prevInfo, prevWarn, prevError, prevGroup, prevGroupCollapsed, prevGroupEnd;
      function disabledLog() {
      }
      disabledLog.__reactDisabledLog = !0;
      function disableLogs() {
        {
          if (disabledDepth === 0) {
            prevLog = console.log, prevInfo = console.info, prevWarn = console.warn, prevError = console.error, prevGroup = console.group, prevGroupCollapsed = console.groupCollapsed, prevGroupEnd = console.groupEnd;
            var props = {
              configurable: !0,
              enumerable: !0,
              value: disabledLog,
              writable: !0
            };
            Object.defineProperties(console, {
              info: props,
              log: props,
              warn: props,
              error: props,
              group: props,
              groupCollapsed: props,
              groupEnd: props
            });
          }
          disabledDepth++;
        }
      }
      function reenableLogs() {
        {
          if (disabledDepth--, disabledDepth === 0) {
            var props = {
              configurable: !0,
              enumerable: !0,
              writable: !0
            };
            Object.defineProperties(console, {
              log: _assign({}, props, {
                value: prevLog
              }),
              info: _assign({}, props, {
                value: prevInfo
              }),
              warn: _assign({}, props, {
                value: prevWarn
              }),
              error: _assign({}, props, {
                value: prevError
              }),
              group: _assign({}, props, {
                value: prevGroup
              }),
              groupCollapsed: _assign({}, props, {
                value: prevGroupCollapsed
              }),
              groupEnd: _assign({}, props, {
                value: prevGroupEnd
              })
            });
          }
          disabledDepth < 0 && error("disabledDepth fell below zero. This is a bug in React. Please file an issue.");
        }
      }
      var ReactCurrentDispatcher = ReactSharedInternals.ReactCurrentDispatcher, prefix;
      function describeBuiltInComponentFrame(name, source, ownerFn) {
        {
          if (prefix === void 0)
            try {
              throw Error();
            } catch (x) {
              var match = x.stack.trim().match(/\n( *(at )?)/);
              prefix = match && match[1] || "";
            }
          return `
` + prefix + name;
        }
      }
      var reentry = !1, componentFrameCache;
      {
        var PossiblyWeakMap = typeof WeakMap == "function" ? WeakMap : Map;
        componentFrameCache = new PossiblyWeakMap();
      }
      function describeNativeComponentFrame(fn, construct) {
        if (!fn || reentry)
          return "";
        {
          var frame = componentFrameCache.get(fn);
          if (frame !== void 0)
            return frame;
        }
        var control;
        reentry = !0;
        var previousPrepareStackTrace = Error.prepareStackTrace;
        Error.prepareStackTrace = void 0;
        var previousDispatcher;
        previousDispatcher = ReactCurrentDispatcher.current, ReactCurrentDispatcher.current = null, disableLogs();
        try {
          if (construct) {
            var Fake = function() {
              throw Error();
            };
            if (Object.defineProperty(Fake.prototype, "props", {
              set: function() {
                throw Error();
              }
            }), typeof Reflect == "object" && Reflect.construct) {
              try {
                Reflect.construct(Fake, []);
              } catch (x) {
                control = x;
              }
              Reflect.construct(fn, [], Fake);
            } else {
              try {
                Fake.call();
              } catch (x) {
                control = x;
              }
              fn.call(Fake.prototype);
            }
          } else {
            try {
              throw Error();
            } catch (x) {
              control = x;
            }
            fn();
          }
        } catch (sample) {
          if (sample && control && typeof sample.stack == "string") {
            for (var sampleLines = sample.stack.split(`
`), controlLines = control.stack.split(`
`), s = sampleLines.length - 1, c = controlLines.length - 1; s >= 1 && c >= 0 && sampleLines[s] !== controlLines[c]; )
              c--;
            for (; s >= 1 && c >= 0; s--, c--)
              if (sampleLines[s] !== controlLines[c]) {
                if (s !== 1 || c !== 1)
                  do
                    if (s--, c--, c < 0 || sampleLines[s] !== controlLines[c]) {
                      var _frame = `
` + sampleLines[s].replace(" at new ", " at ");
                      return typeof fn == "function" && componentFrameCache.set(fn, _frame), _frame;
                    }
                  while (s >= 1 && c >= 0);
                break;
              }
          }
        } finally {
          reentry = !1, ReactCurrentDispatcher.current = previousDispatcher, reenableLogs(), Error.prepareStackTrace = previousPrepareStackTrace;
        }
        var name = fn ? fn.displayName || fn.name : "", syntheticFrame = name ? describeBuiltInComponentFrame(name) : "";
        return typeof fn == "function" && componentFrameCache.set(fn, syntheticFrame), syntheticFrame;
      }
      function describeClassComponentFrame(ctor, source, ownerFn) {
        return describeNativeComponentFrame(ctor, !0);
      }
      function describeFunctionComponentFrame(fn, source, ownerFn) {
        return describeNativeComponentFrame(fn, !1);
      }
      function shouldConstruct(Component) {
        var prototype = Component.prototype;
        return !!(prototype && prototype.isReactComponent);
      }
      function describeUnknownElementTypeFrameInDEV(type, source, ownerFn) {
        if (type == null)
          return "";
        if (typeof type == "function")
          return describeNativeComponentFrame(type, shouldConstruct(type));
        if (typeof type == "string")
          return describeBuiltInComponentFrame(type);
        switch (type) {
          case REACT_SUSPENSE_TYPE:
            return describeBuiltInComponentFrame("Suspense");
          case REACT_SUSPENSE_LIST_TYPE:
            return describeBuiltInComponentFrame("SuspenseList");
        }
        if (typeof type == "object")
          switch (type.$$typeof) {
            case REACT_FORWARD_REF_TYPE:
              return describeFunctionComponentFrame(type.render);
            case REACT_MEMO_TYPE:
              return describeUnknownElementTypeFrameInDEV(type.type, source, ownerFn);
            case REACT_BLOCK_TYPE:
              return describeFunctionComponentFrame(type._render);
            case REACT_LAZY_TYPE: {
              var lazyComponent = type, payload = lazyComponent._payload, init2 = lazyComponent._init;
              try {
                return describeUnknownElementTypeFrameInDEV(init2(payload), source, ownerFn);
              } catch {
              }
            }
          }
        return "";
      }
      function describeFiber(fiber) {
        var owner = fiber._debugOwner ? fiber._debugOwner.type : null, source = fiber._debugSource;
        switch (fiber.tag) {
          case HostComponent:
            return describeBuiltInComponentFrame(fiber.type);
          case LazyComponent:
            return describeBuiltInComponentFrame("Lazy");
          case SuspenseComponent:
            return describeBuiltInComponentFrame("Suspense");
          case SuspenseListComponent:
            return describeBuiltInComponentFrame("SuspenseList");
          case FunctionComponent:
          case IndeterminateComponent:
          case SimpleMemoComponent:
            return describeFunctionComponentFrame(fiber.type);
          case ForwardRef2:
            return describeFunctionComponentFrame(fiber.type.render);
          case Block:
            return describeFunctionComponentFrame(fiber.type._render);
          case ClassComponent:
            return describeClassComponentFrame(fiber.type);
          default:
            return "";
        }
      }
      function getStackByFiberInDevAndProd(workInProgress2) {
        try {
          var info = "", node = workInProgress2;
          do
            info += describeFiber(node), node = node.return;
          while (node);
          return info;
        } catch (x) {
          return `
Error generating stack: ` + x.message + `
` + x.stack;
        }
      }
      function getWrappedName2(outerType, innerType, wrapperName) {
        var functionName = innerType.displayName || innerType.name || "";
        return outerType.displayName || (functionName !== "" ? wrapperName + "(" + functionName + ")" : wrapperName);
      }
      function getContextName(type) {
        return type.displayName || "Context";
      }
      function getComponentName(type) {
        if (type == null)
          return null;
        if (typeof type.tag == "number" && error("Received an unexpected object in getComponentName(). This is likely a bug in React. Please file an issue."), typeof type == "function")
          return type.displayName || type.name || null;
        if (typeof type == "string")
          return type;
        switch (type) {
          case REACT_FRAGMENT_TYPE:
            return "Fragment";
          case REACT_PORTAL_TYPE:
            return "Portal";
          case REACT_PROFILER_TYPE:
            return "Profiler";
          case REACT_STRICT_MODE_TYPE:
            return "StrictMode";
          case REACT_SUSPENSE_TYPE:
            return "Suspense";
          case REACT_SUSPENSE_LIST_TYPE:
            return "SuspenseList";
        }
        if (typeof type == "object")
          switch (type.$$typeof) {
            case REACT_CONTEXT_TYPE:
              var context = type;
              return getContextName(context) + ".Consumer";
            case REACT_PROVIDER_TYPE:
              var provider = type;
              return getContextName(provider._context) + ".Provider";
            case REACT_FORWARD_REF_TYPE:
              return getWrappedName2(type, type.render, "ForwardRef");
            case REACT_MEMO_TYPE:
              return getComponentName(type.type);
            case REACT_BLOCK_TYPE:
              return getComponentName(type._render);
            case REACT_LAZY_TYPE: {
              var lazyComponent = type, payload = lazyComponent._payload, init2 = lazyComponent._init;
              try {
                return getComponentName(init2(payload));
              } catch {
                return null;
              }
            }
          }
        return null;
      }
      var ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame, current = null, isRendering = !1;
      function getCurrentFiberOwnerNameInDevOrNull() {
        {
          if (current === null)
            return null;
          var owner = current._debugOwner;
          if (owner !== null && typeof owner < "u")
            return getComponentName(owner.type);
        }
        return null;
      }
      function getCurrentFiberStackInDev() {
        return current === null ? "" : getStackByFiberInDevAndProd(current);
      }
      function resetCurrentFiber() {
        ReactDebugCurrentFrame.getCurrentStack = null, current = null, isRendering = !1;
      }
      function setCurrentFiber(fiber) {
        ReactDebugCurrentFrame.getCurrentStack = getCurrentFiberStackInDev, current = fiber, isRendering = !1;
      }
      function setIsRendering(rendering) {
        isRendering = rendering;
      }
      function getIsRendering() {
        return isRendering;
      }
      function toString3(value) {
        return "" + value;
      }
      function getToStringValue(value) {
        switch (typeof value) {
          case "boolean":
          case "number":
          case "object":
          case "string":
          case "undefined":
            return value;
          default:
            return "";
        }
      }
      var hasReadOnlyValue = {
        button: !0,
        checkbox: !0,
        image: !0,
        hidden: !0,
        radio: !0,
        reset: !0,
        submit: !0
      };
      function checkControlledValueProps(tagName, props) {
        hasReadOnlyValue[props.type] || props.onChange || props.onInput || props.readOnly || props.disabled || props.value == null || error("You provided a `value` prop to a form field without an `onChange` handler. This will render a read-only field. If the field should be mutable use `defaultValue`. Otherwise, set either `onChange` or `readOnly`."), props.onChange || props.readOnly || props.disabled || props.checked == null || error("You provided a `checked` prop to a form field without an `onChange` handler. This will render a read-only field. If the field should be mutable use `defaultChecked`. Otherwise, set either `onChange` or `readOnly`.");
      }
      function isCheckable(elem) {
        var type = elem.type, nodeName = elem.nodeName;
        return nodeName && nodeName.toLowerCase() === "input" && (type === "checkbox" || type === "radio");
      }
      function getTracker(node) {
        return node._valueTracker;
      }
      function detachTracker(node) {
        node._valueTracker = null;
      }
      function getValueFromNode(node) {
        var value = "";
        return node && (isCheckable(node) ? value = node.checked ? "true" : "false" : value = node.value), value;
      }
      function trackValueOnNode(node) {
        var valueField = isCheckable(node) ? "checked" : "value", descriptor = Object.getOwnPropertyDescriptor(node.constructor.prototype, valueField), currentValue = "" + node[valueField];
        if (!(node.hasOwnProperty(valueField) || typeof descriptor > "u" || typeof descriptor.get != "function" || typeof descriptor.set != "function")) {
          var get2 = descriptor.get, set2 = descriptor.set;
          Object.defineProperty(node, valueField, {
            configurable: !0,
            get: function() {
              return get2.call(this);
            },
            set: function(value) {
              currentValue = "" + value, set2.call(this, value);
            }
          }), Object.defineProperty(node, valueField, {
            enumerable: descriptor.enumerable
          });
          var tracker = {
            getValue: function() {
              return currentValue;
            },
            setValue: function(value) {
              currentValue = "" + value;
            },
            stopTracking: function() {
              detachTracker(node), delete node[valueField];
            }
          };
          return tracker;
        }
      }
      function track(node) {
        getTracker(node) || (node._valueTracker = trackValueOnNode(node));
      }
      function updateValueIfChanged(node) {
        if (!node)
          return !1;
        var tracker = getTracker(node);
        if (!tracker)
          return !0;
        var lastValue = tracker.getValue(), nextValue = getValueFromNode(node);
        return nextValue !== lastValue ? (tracker.setValue(nextValue), !0) : !1;
      }
      function getActiveElement(doc) {
        if (doc = doc || (typeof document < "u" ? document : void 0), typeof doc > "u")
          return null;
        try {
          return doc.activeElement || doc.body;
        } catch {
          return doc.body;
        }
      }
      var didWarnValueDefaultValue = !1, didWarnCheckedDefaultChecked = !1, didWarnControlledToUncontrolled = !1, didWarnUncontrolledToControlled = !1;
      function isControlled(props) {
        var usesChecked = props.type === "checkbox" || props.type === "radio";
        return usesChecked ? props.checked != null : props.value != null;
      }
      function getHostProps(element, props) {
        var node = element, checked2 = props.checked, hostProps = _assign({}, props, {
          defaultChecked: void 0,
          defaultValue: void 0,
          value: void 0,
          checked: checked2 ?? node._wrapperState.initialChecked
        });
        return hostProps;
      }
      function initWrapperState(element, props) {
        checkControlledValueProps("input", props), props.checked !== void 0 && props.defaultChecked !== void 0 && !didWarnCheckedDefaultChecked && (error("%s contains an input of type %s with both checked and defaultChecked props. Input elements must be either controlled or uncontrolled (specify either the checked prop, or the defaultChecked prop, but not both). Decide between using a controlled or uncontrolled input element and remove one of these props. More info: https://reactjs.org/link/controlled-components", getCurrentFiberOwnerNameInDevOrNull() || "A component", props.type), didWarnCheckedDefaultChecked = !0), props.value !== void 0 && props.defaultValue !== void 0 && !didWarnValueDefaultValue && (error("%s contains an input of type %s with both value and defaultValue props. Input elements must be either controlled or uncontrolled (specify either the value prop, or the defaultValue prop, but not both). Decide between using a controlled or uncontrolled input element and remove one of these props. More info: https://reactjs.org/link/controlled-components", getCurrentFiberOwnerNameInDevOrNull() || "A component", props.type), didWarnValueDefaultValue = !0);
        var node = element, defaultValue = props.defaultValue == null ? "" : props.defaultValue;
        node._wrapperState = {
          initialChecked: props.checked != null ? props.checked : props.defaultChecked,
          initialValue: getToStringValue(props.value != null ? props.value : defaultValue),
          controlled: isControlled(props)
        };
      }
      function updateChecked(element, props) {
        var node = element, checked2 = props.checked;
        checked2 != null && setValueForProperty(node, "checked", checked2, !1);
      }
      function updateWrapper(element, props) {
        var node = element;
        {
          var controlled = isControlled(props);
          !node._wrapperState.controlled && controlled && !didWarnUncontrolledToControlled && (error("A component is changing an uncontrolled input to be controlled. This is likely caused by the value changing from undefined to a defined value, which should not happen. Decide between using a controlled or uncontrolled input element for the lifetime of the component. More info: https://reactjs.org/link/controlled-components"), didWarnUncontrolledToControlled = !0), node._wrapperState.controlled && !controlled && !didWarnControlledToUncontrolled && (error("A component is changing a controlled input to be uncontrolled. This is likely caused by the value changing from a defined to undefined, which should not happen. Decide between using a controlled or uncontrolled input element for the lifetime of the component. More info: https://reactjs.org/link/controlled-components"), didWarnControlledToUncontrolled = !0);
        }
        updateChecked(element, props);
        var value = getToStringValue(props.value), type = props.type;
        if (value != null)
          type === "number" ? (value === 0 && node.value === "" || node.value != value) && (node.value = toString3(value)) : node.value !== toString3(value) && (node.value = toString3(value));
        else if (type === "submit" || type === "reset") {
          node.removeAttribute("value");
          return;
        }
        props.hasOwnProperty("value") ? setDefaultValue(node, props.type, value) : props.hasOwnProperty("defaultValue") && setDefaultValue(node, props.type, getToStringValue(props.defaultValue)), props.checked == null && props.defaultChecked != null && (node.defaultChecked = !!props.defaultChecked);
      }
      function postMountWrapper(element, props, isHydrating2) {
        var node = element;
        if (props.hasOwnProperty("value") || props.hasOwnProperty("defaultValue")) {
          var type = props.type, isButton = type === "submit" || type === "reset";
          if (isButton && (props.value === void 0 || props.value === null))
            return;
          var initialValue = toString3(node._wrapperState.initialValue);
          isHydrating2 || initialValue !== node.value && (node.value = initialValue), node.defaultValue = initialValue;
        }
        var name = node.name;
        name !== "" && (node.name = ""), node.defaultChecked = !node.defaultChecked, node.defaultChecked = !!node._wrapperState.initialChecked, name !== "" && (node.name = name);
      }
      function restoreControlledState(element, props) {
        var node = element;
        updateWrapper(node, props), updateNamedCousins(node, props);
      }
      function updateNamedCousins(rootNode, props) {
        var name = props.name;
        if (props.type === "radio" && name != null) {
          for (var queryRoot = rootNode; queryRoot.parentNode; )
            queryRoot = queryRoot.parentNode;
          for (var group = queryRoot.querySelectorAll("input[name=" + JSON.stringify("" + name) + '][type="radio"]'), i = 0; i < group.length; i++) {
            var otherNode = group[i];
            if (!(otherNode === rootNode || otherNode.form !== rootNode.form)) {
              var otherProps = getFiberCurrentPropsFromNode(otherNode);
              if (!otherProps)
                throw Error("ReactDOMInput: Mixing React and non-React radio inputs with the same `name` is not supported.");
              updateValueIfChanged(otherNode), updateWrapper(otherNode, otherProps);
            }
          }
        }
      }
      function setDefaultValue(node, type, value) {
        (type !== "number" || getActiveElement(node.ownerDocument) !== node) && (value == null ? node.defaultValue = toString3(node._wrapperState.initialValue) : node.defaultValue !== toString3(value) && (node.defaultValue = toString3(value)));
      }
      var didWarnSelectedSetOnOption = !1, didWarnInvalidChild = !1;
      function flattenChildren(children) {
        var content = "";
        return React90.Children.forEach(children, function(child) {
          child != null && (content += child);
        }), content;
      }
      function validateProps(element, props) {
        typeof props.children == "object" && props.children !== null && React90.Children.forEach(props.children, function(child) {
          child != null && (typeof child == "string" || typeof child == "number" || typeof child.type == "string" && (didWarnInvalidChild || (didWarnInvalidChild = !0, error("Only strings and numbers are supported as <option> children."))));
        }), props.selected != null && !didWarnSelectedSetOnOption && (error("Use the `defaultValue` or `value` props on <select> instead of setting `selected` on <option>."), didWarnSelectedSetOnOption = !0);
      }
      function postMountWrapper$1(element, props) {
        props.value != null && element.setAttribute("value", toString3(getToStringValue(props.value)));
      }
      function getHostProps$1(element, props) {
        var hostProps = _assign({
          children: void 0
        }, props), content = flattenChildren(props.children);
        return content && (hostProps.children = content), hostProps;
      }
      var didWarnValueDefaultValue$1;
      didWarnValueDefaultValue$1 = !1;
      function getDeclarationErrorAddendum() {
        var ownerName = getCurrentFiberOwnerNameInDevOrNull();
        return ownerName ? `

Check the render method of \`` + ownerName + "`." : "";
      }
      var valuePropNames = ["value", "defaultValue"];
      function checkSelectPropTypes(props) {
        {
          checkControlledValueProps("select", props);
          for (var i = 0; i < valuePropNames.length; i++) {
            var propName = valuePropNames[i];
            if (props[propName] != null) {
              var isArray4 = Array.isArray(props[propName]);
              props.multiple && !isArray4 ? error("The `%s` prop supplied to <select> must be an array if `multiple` is true.%s", propName, getDeclarationErrorAddendum()) : !props.multiple && isArray4 && error("The `%s` prop supplied to <select> must be a scalar value if `multiple` is false.%s", propName, getDeclarationErrorAddendum());
            }
          }
        }
      }
      function updateOptions(node, multiple, propValue, setDefaultSelected) {
        var options2 = node.options;
        if (multiple) {
          for (var selectedValues = propValue, selectedValue = {}, i = 0; i < selectedValues.length; i++)
            selectedValue["$" + selectedValues[i]] = !0;
          for (var _i = 0; _i < options2.length; _i++) {
            var selected = selectedValue.hasOwnProperty("$" + options2[_i].value);
            options2[_i].selected !== selected && (options2[_i].selected = selected), selected && setDefaultSelected && (options2[_i].defaultSelected = !0);
          }
        } else {
          for (var _selectedValue = toString3(getToStringValue(propValue)), defaultSelected = null, _i2 = 0; _i2 < options2.length; _i2++) {
            if (options2[_i2].value === _selectedValue) {
              options2[_i2].selected = !0, setDefaultSelected && (options2[_i2].defaultSelected = !0);
              return;
            }
            defaultSelected === null && !options2[_i2].disabled && (defaultSelected = options2[_i2]);
          }
          defaultSelected !== null && (defaultSelected.selected = !0);
        }
      }
      function getHostProps$2(element, props) {
        return _assign({}, props, {
          value: void 0
        });
      }
      function initWrapperState$1(element, props) {
        var node = element;
        checkSelectPropTypes(props), node._wrapperState = {
          wasMultiple: !!props.multiple
        }, props.value !== void 0 && props.defaultValue !== void 0 && !didWarnValueDefaultValue$1 && (error("Select elements must be either controlled or uncontrolled (specify either the value prop, or the defaultValue prop, but not both). Decide between using a controlled or uncontrolled select element and remove one of these props. More info: https://reactjs.org/link/controlled-components"), didWarnValueDefaultValue$1 = !0);
      }
      function postMountWrapper$2(element, props) {
        var node = element;
        node.multiple = !!props.multiple;
        var value = props.value;
        value != null ? updateOptions(node, !!props.multiple, value, !1) : props.defaultValue != null && updateOptions(node, !!props.multiple, props.defaultValue, !0);
      }
      function postUpdateWrapper(element, props) {
        var node = element, wasMultiple = node._wrapperState.wasMultiple;
        node._wrapperState.wasMultiple = !!props.multiple;
        var value = props.value;
        value != null ? updateOptions(node, !!props.multiple, value, !1) : wasMultiple !== !!props.multiple && (props.defaultValue != null ? updateOptions(node, !!props.multiple, props.defaultValue, !0) : updateOptions(node, !!props.multiple, props.multiple ? [] : "", !1));
      }
      function restoreControlledState$1(element, props) {
        var node = element, value = props.value;
        value != null && updateOptions(node, !!props.multiple, value, !1);
      }
      var didWarnValDefaultVal = !1;
      function getHostProps$3(element, props) {
        var node = element;
        if (props.dangerouslySetInnerHTML != null)
          throw Error("`dangerouslySetInnerHTML` does not make sense on <textarea>.");
        var hostProps = _assign({}, props, {
          value: void 0,
          defaultValue: void 0,
          children: toString3(node._wrapperState.initialValue)
        });
        return hostProps;
      }
      function initWrapperState$2(element, props) {
        var node = element;
        checkControlledValueProps("textarea", props), props.value !== void 0 && props.defaultValue !== void 0 && !didWarnValDefaultVal && (error("%s contains a textarea with both value and defaultValue props. Textarea elements must be either controlled or uncontrolled (specify either the value prop, or the defaultValue prop, but not both). Decide between using a controlled or uncontrolled textarea and remove one of these props. More info: https://reactjs.org/link/controlled-components", getCurrentFiberOwnerNameInDevOrNull() || "A component"), didWarnValDefaultVal = !0);
        var initialValue = props.value;
        if (initialValue == null) {
          var children = props.children, defaultValue = props.defaultValue;
          if (children != null) {
            error("Use the `defaultValue` or `value` props instead of setting children on <textarea>.");
            {
              if (defaultValue != null)
                throw Error("If you supply `defaultValue` on a <textarea>, do not pass children.");
              if (Array.isArray(children)) {
                if (!(children.length <= 1))
                  throw Error("<textarea> can only have at most one child.");
                children = children[0];
              }
              defaultValue = children;
            }
          }
          defaultValue == null && (defaultValue = ""), initialValue = defaultValue;
        }
        node._wrapperState = {
          initialValue: getToStringValue(initialValue)
        };
      }
      function updateWrapper$1(element, props) {
        var node = element, value = getToStringValue(props.value), defaultValue = getToStringValue(props.defaultValue);
        if (value != null) {
          var newValue = toString3(value);
          newValue !== node.value && (node.value = newValue), props.defaultValue == null && node.defaultValue !== newValue && (node.defaultValue = newValue);
        }
        defaultValue != null && (node.defaultValue = toString3(defaultValue));
      }
      function postMountWrapper$3(element, props) {
        var node = element, textContent = node.textContent;
        textContent === node._wrapperState.initialValue && textContent !== "" && textContent !== null && (node.value = textContent);
      }
      function restoreControlledState$2(element, props) {
        updateWrapper$1(element, props);
      }
      var HTML_NAMESPACE = "http://www.w3.org/1999/xhtml", MATH_NAMESPACE = "http://www.w3.org/1998/Math/MathML", SVG_NAMESPACE = "http://www.w3.org/2000/svg", Namespaces = {
        html: HTML_NAMESPACE,
        mathml: MATH_NAMESPACE,
        svg: SVG_NAMESPACE
      };
      function getIntrinsicNamespace(type) {
        switch (type) {
          case "svg":
            return SVG_NAMESPACE;
          case "math":
            return MATH_NAMESPACE;
          default:
            return HTML_NAMESPACE;
        }
      }
      function getChildNamespace(parentNamespace, type) {
        return parentNamespace == null || parentNamespace === HTML_NAMESPACE ? getIntrinsicNamespace(type) : parentNamespace === SVG_NAMESPACE && type === "foreignObject" ? HTML_NAMESPACE : parentNamespace;
      }
      var createMicrosoftUnsafeLocalFunction = function(func) {
        return typeof MSApp < "u" && MSApp.execUnsafeLocalFunction ? function(arg0, arg1, arg2, arg3) {
          MSApp.execUnsafeLocalFunction(function() {
            return func(arg0, arg1, arg2, arg3);
          });
        } : func;
      }, reusableSVGContainer, setInnerHTML = createMicrosoftUnsafeLocalFunction(function(node, html) {
        if (node.namespaceURI === Namespaces.svg && !("innerHTML" in node)) {
          reusableSVGContainer = reusableSVGContainer || document.createElement("div"), reusableSVGContainer.innerHTML = "<svg>" + html.valueOf().toString() + "</svg>";
          for (var svgNode = reusableSVGContainer.firstChild; node.firstChild; )
            node.removeChild(node.firstChild);
          for (; svgNode.firstChild; )
            node.appendChild(svgNode.firstChild);
          return;
        }
        node.innerHTML = html;
      }), ELEMENT_NODE = 1, TEXT_NODE = 3, COMMENT_NODE = 8, DOCUMENT_NODE = 9, DOCUMENT_FRAGMENT_NODE = 11, setTextContent = function(node, text) {
        if (text) {
          var firstChild = node.firstChild;
          if (firstChild && firstChild === node.lastChild && firstChild.nodeType === TEXT_NODE) {
            firstChild.nodeValue = text;
            return;
          }
        }
        node.textContent = text;
      }, shorthandToLonghand = {
        animation: ["animationDelay", "animationDirection", "animationDuration", "animationFillMode", "animationIterationCount", "animationName", "animationPlayState", "animationTimingFunction"],
        background: ["backgroundAttachment", "backgroundClip", "backgroundColor", "backgroundImage", "backgroundOrigin", "backgroundPositionX", "backgroundPositionY", "backgroundRepeat", "backgroundSize"],
        backgroundPosition: ["backgroundPositionX", "backgroundPositionY"],
        border: ["borderBottomColor", "borderBottomStyle", "borderBottomWidth", "borderImageOutset", "borderImageRepeat", "borderImageSlice", "borderImageSource", "borderImageWidth", "borderLeftColor", "borderLeftStyle", "borderLeftWidth", "borderRightColor", "borderRightStyle", "borderRightWidth", "borderTopColor", "borderTopStyle", "borderTopWidth"],
        borderBlockEnd: ["borderBlockEndColor", "borderBlockEndStyle", "borderBlockEndWidth"],
        borderBlockStart: ["borderBlockStartColor", "borderBlockStartStyle", "borderBlockStartWidth"],
        borderBottom: ["borderBottomColor", "borderBottomStyle", "borderBottomWidth"],
        borderColor: ["borderBottomColor", "borderLeftColor", "borderRightColor", "borderTopColor"],
        borderImage: ["borderImageOutset", "borderImageRepeat", "borderImageSlice", "borderImageSource", "borderImageWidth"],
        borderInlineEnd: ["borderInlineEndColor", "borderInlineEndStyle", "borderInlineEndWidth"],
        borderInlineStart: ["borderInlineStartColor", "borderInlineStartStyle", "borderInlineStartWidth"],
        borderLeft: ["borderLeftColor", "borderLeftStyle", "borderLeftWidth"],
        borderRadius: ["borderBottomLeftRadius", "borderBottomRightRadius", "borderTopLeftRadius", "borderTopRightRadius"],
        borderRight: ["borderRightColor", "borderRightStyle", "borderRightWidth"],
        borderStyle: ["borderBottomStyle", "borderLeftStyle", "borderRightStyle", "borderTopStyle"],
        borderTop: ["borderTopColor", "borderTopStyle", "borderTopWidth"],
        borderWidth: ["borderBottomWidth", "borderLeftWidth", "borderRightWidth", "borderTopWidth"],
        columnRule: ["columnRuleColor", "columnRuleStyle", "columnRuleWidth"],
        columns: ["columnCount", "columnWidth"],
        flex: ["flexBasis", "flexGrow", "flexShrink"],
        flexFlow: ["flexDirection", "flexWrap"],
        font: ["fontFamily", "fontFeatureSettings", "fontKerning", "fontLanguageOverride", "fontSize", "fontSizeAdjust", "fontStretch", "fontStyle", "fontVariant", "fontVariantAlternates", "fontVariantCaps", "fontVariantEastAsian", "fontVariantLigatures", "fontVariantNumeric", "fontVariantPosition", "fontWeight", "lineHeight"],
        fontVariant: ["fontVariantAlternates", "fontVariantCaps", "fontVariantEastAsian", "fontVariantLigatures", "fontVariantNumeric", "fontVariantPosition"],
        gap: ["columnGap", "rowGap"],
        grid: ["gridAutoColumns", "gridAutoFlow", "gridAutoRows", "gridTemplateAreas", "gridTemplateColumns", "gridTemplateRows"],
        gridArea: ["gridColumnEnd", "gridColumnStart", "gridRowEnd", "gridRowStart"],
        gridColumn: ["gridColumnEnd", "gridColumnStart"],
        gridColumnGap: ["columnGap"],
        gridGap: ["columnGap", "rowGap"],
        gridRow: ["gridRowEnd", "gridRowStart"],
        gridRowGap: ["rowGap"],
        gridTemplate: ["gridTemplateAreas", "gridTemplateColumns", "gridTemplateRows"],
        listStyle: ["listStyleImage", "listStylePosition", "listStyleType"],
        margin: ["marginBottom", "marginLeft", "marginRight", "marginTop"],
        marker: ["markerEnd", "markerMid", "markerStart"],
        mask: ["maskClip", "maskComposite", "maskImage", "maskMode", "maskOrigin", "maskPositionX", "maskPositionY", "maskRepeat", "maskSize"],
        maskPosition: ["maskPositionX", "maskPositionY"],
        outline: ["outlineColor", "outlineStyle", "outlineWidth"],
        overflow: ["overflowX", "overflowY"],
        padding: ["paddingBottom", "paddingLeft", "paddingRight", "paddingTop"],
        placeContent: ["alignContent", "justifyContent"],
        placeItems: ["alignItems", "justifyItems"],
        placeSelf: ["alignSelf", "justifySelf"],
        textDecoration: ["textDecorationColor", "textDecorationLine", "textDecorationStyle"],
        textEmphasis: ["textEmphasisColor", "textEmphasisStyle"],
        transition: ["transitionDelay", "transitionDuration", "transitionProperty", "transitionTimingFunction"],
        wordWrap: ["overflowWrap"]
      }, isUnitlessNumber = {
        animationIterationCount: !0,
        borderImageOutset: !0,
        borderImageSlice: !0,
        borderImageWidth: !0,
        boxFlex: !0,
        boxFlexGroup: !0,
        boxOrdinalGroup: !0,
        columnCount: !0,
        columns: !0,
        flex: !0,
        flexGrow: !0,
        flexPositive: !0,
        flexShrink: !0,
        flexNegative: !0,
        flexOrder: !0,
        gridArea: !0,
        gridRow: !0,
        gridRowEnd: !0,
        gridRowSpan: !0,
        gridRowStart: !0,
        gridColumn: !0,
        gridColumnEnd: !0,
        gridColumnSpan: !0,
        gridColumnStart: !0,
        fontWeight: !0,
        lineClamp: !0,
        lineHeight: !0,
        opacity: !0,
        order: !0,
        orphans: !0,
        tabSize: !0,
        widows: !0,
        zIndex: !0,
        zoom: !0,
        fillOpacity: !0,
        floodOpacity: !0,
        stopOpacity: !0,
        strokeDasharray: !0,
        strokeDashoffset: !0,
        strokeMiterlimit: !0,
        strokeOpacity: !0,
        strokeWidth: !0
      };
      function prefixKey(prefix2, key) {
        return prefix2 + key.charAt(0).toUpperCase() + key.substring(1);
      }
      var prefixes = ["Webkit", "ms", "Moz", "O"];
      Object.keys(isUnitlessNumber).forEach(function(prop) {
        prefixes.forEach(function(prefix2) {
          isUnitlessNumber[prefixKey(prefix2, prop)] = isUnitlessNumber[prop];
        });
      });
      function dangerousStyleValue(name, value, isCustomProperty) {
        var isEmpty6 = value == null || typeof value == "boolean" || value === "";
        return isEmpty6 ? "" : !isCustomProperty && typeof value == "number" && value !== 0 && !(isUnitlessNumber.hasOwnProperty(name) && isUnitlessNumber[name]) ? value + "px" : ("" + value).trim();
      }
      var uppercasePattern = /([A-Z])/g, msPattern = /^ms-/;
      function hyphenateStyleName(name) {
        return name.replace(uppercasePattern, "-$1").toLowerCase().replace(msPattern, "-ms-");
      }
      var warnValidStyle = function() {
      };
      {
        var badVendoredStyleNamePattern = /^(?:webkit|moz|o)[A-Z]/, msPattern$1 = /^-ms-/, hyphenPattern = /-(.)/g, badStyleValueWithSemicolonPattern = /;\s*$/, warnedStyleNames = {}, warnedStyleValues = {}, warnedForNaNValue = !1, warnedForInfinityValue = !1, camelize = function(string) {
          return string.replace(hyphenPattern, function(_2, character) {
            return character.toUpperCase();
          });
        }, warnHyphenatedStyleName = function(name) {
          warnedStyleNames.hasOwnProperty(name) && warnedStyleNames[name] || (warnedStyleNames[name] = !0, error(
            "Unsupported style property %s. Did you mean %s?",
            name,
            camelize(name.replace(msPattern$1, "ms-"))
          ));
        }, warnBadVendoredStyleName = function(name) {
          warnedStyleNames.hasOwnProperty(name) && warnedStyleNames[name] || (warnedStyleNames[name] = !0, error("Unsupported vendor-prefixed style property %s. Did you mean %s?", name, name.charAt(0).toUpperCase() + name.slice(1)));
        }, warnStyleValueWithSemicolon = function(name, value) {
          warnedStyleValues.hasOwnProperty(value) && warnedStyleValues[value] || (warnedStyleValues[value] = !0, error(`Style property values shouldn't contain a semicolon. Try "%s: %s" instead.`, name, value.replace(badStyleValueWithSemicolonPattern, "")));
        }, warnStyleValueIsNaN = function(name, value) {
          warnedForNaNValue || (warnedForNaNValue = !0, error("`NaN` is an invalid value for the `%s` css style property.", name));
        }, warnStyleValueIsInfinity = function(name, value) {
          warnedForInfinityValue || (warnedForInfinityValue = !0, error("`Infinity` is an invalid value for the `%s` css style property.", name));
        };
        warnValidStyle = function(name, value) {
          name.indexOf("-") > -1 ? warnHyphenatedStyleName(name) : badVendoredStyleNamePattern.test(name) ? warnBadVendoredStyleName(name) : badStyleValueWithSemicolonPattern.test(value) && warnStyleValueWithSemicolon(name, value), typeof value == "number" && (isNaN(value) ? warnStyleValueIsNaN(name, value) : isFinite(value) || warnStyleValueIsInfinity(name, value));
        };
      }
      var warnValidStyle$1 = warnValidStyle;
      function createDangerousStringForStyles(styles4) {
        {
          var serialized = "", delimiter = "";
          for (var styleName in styles4)
            if (!!styles4.hasOwnProperty(styleName)) {
              var styleValue = styles4[styleName];
              if (styleValue != null) {
                var isCustomProperty = styleName.indexOf("--") === 0;
                serialized += delimiter + (isCustomProperty ? styleName : hyphenateStyleName(styleName)) + ":", serialized += dangerousStyleValue(styleName, styleValue, isCustomProperty), delimiter = ";";
              }
            }
          return serialized || null;
        }
      }
      function setValueForStyles(node, styles4) {
        var style4 = node.style;
        for (var styleName in styles4)
          if (!!styles4.hasOwnProperty(styleName)) {
            var isCustomProperty = styleName.indexOf("--") === 0;
            isCustomProperty || warnValidStyle$1(styleName, styles4[styleName]);
            var styleValue = dangerousStyleValue(styleName, styles4[styleName], isCustomProperty);
            styleName === "float" && (styleName = "cssFloat"), isCustomProperty ? style4.setProperty(styleName, styleValue) : style4[styleName] = styleValue;
          }
      }
      function isValueEmpty(value) {
        return value == null || typeof value == "boolean" || value === "";
      }
      function expandShorthandMap(styles4) {
        var expanded = {};
        for (var key in styles4)
          for (var longhands = shorthandToLonghand[key] || [key], i = 0; i < longhands.length; i++)
            expanded[longhands[i]] = key;
        return expanded;
      }
      function validateShorthandPropertyCollisionInDev(styleUpdates, nextStyles) {
        {
          if (!nextStyles)
            return;
          var expandedUpdates = expandShorthandMap(styleUpdates), expandedStyles = expandShorthandMap(nextStyles), warnedAbout = {};
          for (var key in expandedUpdates) {
            var originalKey = expandedUpdates[key], correctOriginalKey = expandedStyles[key];
            if (correctOriginalKey && originalKey !== correctOriginalKey) {
              var warningKey = originalKey + "," + correctOriginalKey;
              if (warnedAbout[warningKey])
                continue;
              warnedAbout[warningKey] = !0, error("%s a style property during rerender (%s) when a conflicting property is set (%s) can lead to styling bugs. To avoid this, don't mix shorthand and non-shorthand properties for the same value; instead, replace the shorthand with separate values.", isValueEmpty(styleUpdates[originalKey]) ? "Removing" : "Updating", originalKey, correctOriginalKey);
            }
          }
        }
      }
      var omittedCloseTags = {
        area: !0,
        base: !0,
        br: !0,
        col: !0,
        embed: !0,
        hr: !0,
        img: !0,
        input: !0,
        keygen: !0,
        link: !0,
        meta: !0,
        param: !0,
        source: !0,
        track: !0,
        wbr: !0
      }, voidElementTags = _assign({
        menuitem: !0
      }, omittedCloseTags), HTML = "__html";
      function assertValidProps(tag, props) {
        if (!!props) {
          if (voidElementTags[tag] && !(props.children == null && props.dangerouslySetInnerHTML == null))
            throw Error(tag + " is a void element tag and must neither have `children` nor use `dangerouslySetInnerHTML`.");
          if (props.dangerouslySetInnerHTML != null) {
            if (props.children != null)
              throw Error("Can only set one of `children` or `props.dangerouslySetInnerHTML`.");
            if (!(typeof props.dangerouslySetInnerHTML == "object" && HTML in props.dangerouslySetInnerHTML))
              throw Error("`props.dangerouslySetInnerHTML` must be in the form `{__html: ...}`. Please visit https://reactjs.org/link/dangerously-set-inner-html for more information.");
          }
          if (!props.suppressContentEditableWarning && props.contentEditable && props.children != null && error("A component is `contentEditable` and contains `children` managed by React. It is now your responsibility to guarantee that none of those nodes are unexpectedly modified or duplicated. This is probably not intentional."), !(props.style == null || typeof props.style == "object"))
            throw Error("The `style` prop expects a mapping from style properties to values, not a string. For example, style={{marginRight: spacing + 'em'}} when using JSX.");
        }
      }
      function isCustomComponent(tagName, props) {
        if (tagName.indexOf("-") === -1)
          return typeof props.is == "string";
        switch (tagName) {
          case "annotation-xml":
          case "color-profile":
          case "font-face":
          case "font-face-src":
          case "font-face-uri":
          case "font-face-format":
          case "font-face-name":
          case "missing-glyph":
            return !1;
          default:
            return !0;
        }
      }
      var possibleStandardNames = {
        accept: "accept",
        acceptcharset: "acceptCharset",
        "accept-charset": "acceptCharset",
        accesskey: "accessKey",
        action: "action",
        allowfullscreen: "allowFullScreen",
        alt: "alt",
        as: "as",
        async: "async",
        autocapitalize: "autoCapitalize",
        autocomplete: "autoComplete",
        autocorrect: "autoCorrect",
        autofocus: "autoFocus",
        autoplay: "autoPlay",
        autosave: "autoSave",
        capture: "capture",
        cellpadding: "cellPadding",
        cellspacing: "cellSpacing",
        challenge: "challenge",
        charset: "charSet",
        checked: "checked",
        children: "children",
        cite: "cite",
        class: "className",
        classid: "classID",
        classname: "className",
        cols: "cols",
        colspan: "colSpan",
        content: "content",
        contenteditable: "contentEditable",
        contextmenu: "contextMenu",
        controls: "controls",
        controlslist: "controlsList",
        coords: "coords",
        crossorigin: "crossOrigin",
        dangerouslysetinnerhtml: "dangerouslySetInnerHTML",
        data: "data",
        datetime: "dateTime",
        default: "default",
        defaultchecked: "defaultChecked",
        defaultvalue: "defaultValue",
        defer: "defer",
        dir: "dir",
        disabled: "disabled",
        disablepictureinpicture: "disablePictureInPicture",
        disableremoteplayback: "disableRemotePlayback",
        download: "download",
        draggable: "draggable",
        enctype: "encType",
        enterkeyhint: "enterKeyHint",
        for: "htmlFor",
        form: "form",
        formmethod: "formMethod",
        formaction: "formAction",
        formenctype: "formEncType",
        formnovalidate: "formNoValidate",
        formtarget: "formTarget",
        frameborder: "frameBorder",
        headers: "headers",
        height: "height",
        hidden: "hidden",
        high: "high",
        href: "href",
        hreflang: "hrefLang",
        htmlfor: "htmlFor",
        httpequiv: "httpEquiv",
        "http-equiv": "httpEquiv",
        icon: "icon",
        id: "id",
        innerhtml: "innerHTML",
        inputmode: "inputMode",
        integrity: "integrity",
        is: "is",
        itemid: "itemID",
        itemprop: "itemProp",
        itemref: "itemRef",
        itemscope: "itemScope",
        itemtype: "itemType",
        keyparams: "keyParams",
        keytype: "keyType",
        kind: "kind",
        label: "label",
        lang: "lang",
        list: "list",
        loop: "loop",
        low: "low",
        manifest: "manifest",
        marginwidth: "marginWidth",
        marginheight: "marginHeight",
        max: "max",
        maxlength: "maxLength",
        media: "media",
        mediagroup: "mediaGroup",
        method: "method",
        min: "min",
        minlength: "minLength",
        multiple: "multiple",
        muted: "muted",
        name: "name",
        nomodule: "noModule",
        nonce: "nonce",
        novalidate: "noValidate",
        open: "open",
        optimum: "optimum",
        pattern: "pattern",
        placeholder: "placeholder",
        playsinline: "playsInline",
        poster: "poster",
        preload: "preload",
        profile: "profile",
        radiogroup: "radioGroup",
        readonly: "readOnly",
        referrerpolicy: "referrerPolicy",
        rel: "rel",
        required: "required",
        reversed: "reversed",
        role: "role",
        rows: "rows",
        rowspan: "rowSpan",
        sandbox: "sandbox",
        scope: "scope",
        scoped: "scoped",
        scrolling: "scrolling",
        seamless: "seamless",
        selected: "selected",
        shape: "shape",
        size: "size",
        sizes: "sizes",
        span: "span",
        spellcheck: "spellCheck",
        src: "src",
        srcdoc: "srcDoc",
        srclang: "srcLang",
        srcset: "srcSet",
        start: "start",
        step: "step",
        style: "style",
        summary: "summary",
        tabindex: "tabIndex",
        target: "target",
        title: "title",
        type: "type",
        usemap: "useMap",
        value: "value",
        width: "width",
        wmode: "wmode",
        wrap: "wrap",
        about: "about",
        accentheight: "accentHeight",
        "accent-height": "accentHeight",
        accumulate: "accumulate",
        additive: "additive",
        alignmentbaseline: "alignmentBaseline",
        "alignment-baseline": "alignmentBaseline",
        allowreorder: "allowReorder",
        alphabetic: "alphabetic",
        amplitude: "amplitude",
        arabicform: "arabicForm",
        "arabic-form": "arabicForm",
        ascent: "ascent",
        attributename: "attributeName",
        attributetype: "attributeType",
        autoreverse: "autoReverse",
        azimuth: "azimuth",
        basefrequency: "baseFrequency",
        baselineshift: "baselineShift",
        "baseline-shift": "baselineShift",
        baseprofile: "baseProfile",
        bbox: "bbox",
        begin: "begin",
        bias: "bias",
        by: "by",
        calcmode: "calcMode",
        capheight: "capHeight",
        "cap-height": "capHeight",
        clip: "clip",
        clippath: "clipPath",
        "clip-path": "clipPath",
        clippathunits: "clipPathUnits",
        cliprule: "clipRule",
        "clip-rule": "clipRule",
        color: "color",
        colorinterpolation: "colorInterpolation",
        "color-interpolation": "colorInterpolation",
        colorinterpolationfilters: "colorInterpolationFilters",
        "color-interpolation-filters": "colorInterpolationFilters",
        colorprofile: "colorProfile",
        "color-profile": "colorProfile",
        colorrendering: "colorRendering",
        "color-rendering": "colorRendering",
        contentscripttype: "contentScriptType",
        contentstyletype: "contentStyleType",
        cursor: "cursor",
        cx: "cx",
        cy: "cy",
        d: "d",
        datatype: "datatype",
        decelerate: "decelerate",
        descent: "descent",
        diffuseconstant: "diffuseConstant",
        direction: "direction",
        display: "display",
        divisor: "divisor",
        dominantbaseline: "dominantBaseline",
        "dominant-baseline": "dominantBaseline",
        dur: "dur",
        dx: "dx",
        dy: "dy",
        edgemode: "edgeMode",
        elevation: "elevation",
        enablebackground: "enableBackground",
        "enable-background": "enableBackground",
        end: "end",
        exponent: "exponent",
        externalresourcesrequired: "externalResourcesRequired",
        fill: "fill",
        fillopacity: "fillOpacity",
        "fill-opacity": "fillOpacity",
        fillrule: "fillRule",
        "fill-rule": "fillRule",
        filter: "filter",
        filterres: "filterRes",
        filterunits: "filterUnits",
        floodopacity: "floodOpacity",
        "flood-opacity": "floodOpacity",
        floodcolor: "floodColor",
        "flood-color": "floodColor",
        focusable: "focusable",
        fontfamily: "fontFamily",
        "font-family": "fontFamily",
        fontsize: "fontSize",
        "font-size": "fontSize",
        fontsizeadjust: "fontSizeAdjust",
        "font-size-adjust": "fontSizeAdjust",
        fontstretch: "fontStretch",
        "font-stretch": "fontStretch",
        fontstyle: "fontStyle",
        "font-style": "fontStyle",
        fontvariant: "fontVariant",
        "font-variant": "fontVariant",
        fontweight: "fontWeight",
        "font-weight": "fontWeight",
        format: "format",
        from: "from",
        fx: "fx",
        fy: "fy",
        g1: "g1",
        g2: "g2",
        glyphname: "glyphName",
        "glyph-name": "glyphName",
        glyphorientationhorizontal: "glyphOrientationHorizontal",
        "glyph-orientation-horizontal": "glyphOrientationHorizontal",
        glyphorientationvertical: "glyphOrientationVertical",
        "glyph-orientation-vertical": "glyphOrientationVertical",
        glyphref: "glyphRef",
        gradienttransform: "gradientTransform",
        gradientunits: "gradientUnits",
        hanging: "hanging",
        horizadvx: "horizAdvX",
        "horiz-adv-x": "horizAdvX",
        horizoriginx: "horizOriginX",
        "horiz-origin-x": "horizOriginX",
        ideographic: "ideographic",
        imagerendering: "imageRendering",
        "image-rendering": "imageRendering",
        in2: "in2",
        in: "in",
        inlist: "inlist",
        intercept: "intercept",
        k1: "k1",
        k2: "k2",
        k3: "k3",
        k4: "k4",
        k: "k",
        kernelmatrix: "kernelMatrix",
        kernelunitlength: "kernelUnitLength",
        kerning: "kerning",
        keypoints: "keyPoints",
        keysplines: "keySplines",
        keytimes: "keyTimes",
        lengthadjust: "lengthAdjust",
        letterspacing: "letterSpacing",
        "letter-spacing": "letterSpacing",
        lightingcolor: "lightingColor",
        "lighting-color": "lightingColor",
        limitingconeangle: "limitingConeAngle",
        local: "local",
        markerend: "markerEnd",
        "marker-end": "markerEnd",
        markerheight: "markerHeight",
        markermid: "markerMid",
        "marker-mid": "markerMid",
        markerstart: "markerStart",
        "marker-start": "markerStart",
        markerunits: "markerUnits",
        markerwidth: "markerWidth",
        mask: "mask",
        maskcontentunits: "maskContentUnits",
        maskunits: "maskUnits",
        mathematical: "mathematical",
        mode: "mode",
        numoctaves: "numOctaves",
        offset: "offset",
        opacity: "opacity",
        operator: "operator",
        order: "order",
        orient: "orient",
        orientation: "orientation",
        origin: "origin",
        overflow: "overflow",
        overlineposition: "overlinePosition",
        "overline-position": "overlinePosition",
        overlinethickness: "overlineThickness",
        "overline-thickness": "overlineThickness",
        paintorder: "paintOrder",
        "paint-order": "paintOrder",
        panose1: "panose1",
        "panose-1": "panose1",
        pathlength: "pathLength",
        patterncontentunits: "patternContentUnits",
        patterntransform: "patternTransform",
        patternunits: "patternUnits",
        pointerevents: "pointerEvents",
        "pointer-events": "pointerEvents",
        points: "points",
        pointsatx: "pointsAtX",
        pointsaty: "pointsAtY",
        pointsatz: "pointsAtZ",
        prefix: "prefix",
        preservealpha: "preserveAlpha",
        preserveaspectratio: "preserveAspectRatio",
        primitiveunits: "primitiveUnits",
        property: "property",
        r: "r",
        radius: "radius",
        refx: "refX",
        refy: "refY",
        renderingintent: "renderingIntent",
        "rendering-intent": "renderingIntent",
        repeatcount: "repeatCount",
        repeatdur: "repeatDur",
        requiredextensions: "requiredExtensions",
        requiredfeatures: "requiredFeatures",
        resource: "resource",
        restart: "restart",
        result: "result",
        results: "results",
        rotate: "rotate",
        rx: "rx",
        ry: "ry",
        scale: "scale",
        security: "security",
        seed: "seed",
        shaperendering: "shapeRendering",
        "shape-rendering": "shapeRendering",
        slope: "slope",
        spacing: "spacing",
        specularconstant: "specularConstant",
        specularexponent: "specularExponent",
        speed: "speed",
        spreadmethod: "spreadMethod",
        startoffset: "startOffset",
        stddeviation: "stdDeviation",
        stemh: "stemh",
        stemv: "stemv",
        stitchtiles: "stitchTiles",
        stopcolor: "stopColor",
        "stop-color": "stopColor",
        stopopacity: "stopOpacity",
        "stop-opacity": "stopOpacity",
        strikethroughposition: "strikethroughPosition",
        "strikethrough-position": "strikethroughPosition",
        strikethroughthickness: "strikethroughThickness",
        "strikethrough-thickness": "strikethroughThickness",
        string: "string",
        stroke: "stroke",
        strokedasharray: "strokeDasharray",
        "stroke-dasharray": "strokeDasharray",
        strokedashoffset: "strokeDashoffset",
        "stroke-dashoffset": "strokeDashoffset",
        strokelinecap: "strokeLinecap",
        "stroke-linecap": "strokeLinecap",
        strokelinejoin: "strokeLinejoin",
        "stroke-linejoin": "strokeLinejoin",
        strokemiterlimit: "strokeMiterlimit",
        "stroke-miterlimit": "strokeMiterlimit",
        strokewidth: "strokeWidth",
        "stroke-width": "strokeWidth",
        strokeopacity: "strokeOpacity",
        "stroke-opacity": "strokeOpacity",
        suppresscontenteditablewarning: "suppressContentEditableWarning",
        suppresshydrationwarning: "suppressHydrationWarning",
        surfacescale: "surfaceScale",
        systemlanguage: "systemLanguage",
        tablevalues: "tableValues",
        targetx: "targetX",
        targety: "targetY",
        textanchor: "textAnchor",
        "text-anchor": "textAnchor",
        textdecoration: "textDecoration",
        "text-decoration": "textDecoration",
        textlength: "textLength",
        textrendering: "textRendering",
        "text-rendering": "textRendering",
        to: "to",
        transform: "transform",
        typeof: "typeof",
        u1: "u1",
        u2: "u2",
        underlineposition: "underlinePosition",
        "underline-position": "underlinePosition",
        underlinethickness: "underlineThickness",
        "underline-thickness": "underlineThickness",
        unicode: "unicode",
        unicodebidi: "unicodeBidi",
        "unicode-bidi": "unicodeBidi",
        unicoderange: "unicodeRange",
        "unicode-range": "unicodeRange",
        unitsperem: "unitsPerEm",
        "units-per-em": "unitsPerEm",
        unselectable: "unselectable",
        valphabetic: "vAlphabetic",
        "v-alphabetic": "vAlphabetic",
        values: "values",
        vectoreffect: "vectorEffect",
        "vector-effect": "vectorEffect",
        version: "version",
        vertadvy: "vertAdvY",
        "vert-adv-y": "vertAdvY",
        vertoriginx: "vertOriginX",
        "vert-origin-x": "vertOriginX",
        vertoriginy: "vertOriginY",
        "vert-origin-y": "vertOriginY",
        vhanging: "vHanging",
        "v-hanging": "vHanging",
        videographic: "vIdeographic",
        "v-ideographic": "vIdeographic",
        viewbox: "viewBox",
        viewtarget: "viewTarget",
        visibility: "visibility",
        vmathematical: "vMathematical",
        "v-mathematical": "vMathematical",
        vocab: "vocab",
        widths: "widths",
        wordspacing: "wordSpacing",
        "word-spacing": "wordSpacing",
        writingmode: "writingMode",
        "writing-mode": "writingMode",
        x1: "x1",
        x2: "x2",
        x: "x",
        xchannelselector: "xChannelSelector",
        xheight: "xHeight",
        "x-height": "xHeight",
        xlinkactuate: "xlinkActuate",
        "xlink:actuate": "xlinkActuate",
        xlinkarcrole: "xlinkArcrole",
        "xlink:arcrole": "xlinkArcrole",
        xlinkhref: "xlinkHref",
        "xlink:href": "xlinkHref",
        xlinkrole: "xlinkRole",
        "xlink:role": "xlinkRole",
        xlinkshow: "xlinkShow",
        "xlink:show": "xlinkShow",
        xlinktitle: "xlinkTitle",
        "xlink:title": "xlinkTitle",
        xlinktype: "xlinkType",
        "xlink:type": "xlinkType",
        xmlbase: "xmlBase",
        "xml:base": "xmlBase",
        xmllang: "xmlLang",
        "xml:lang": "xmlLang",
        xmlns: "xmlns",
        "xml:space": "xmlSpace",
        xmlnsxlink: "xmlnsXlink",
        "xmlns:xlink": "xmlnsXlink",
        xmlspace: "xmlSpace",
        y1: "y1",
        y2: "y2",
        y: "y",
        ychannelselector: "yChannelSelector",
        z: "z",
        zoomandpan: "zoomAndPan"
      }, ariaProperties = {
        "aria-current": 0,
        "aria-details": 0,
        "aria-disabled": 0,
        "aria-hidden": 0,
        "aria-invalid": 0,
        "aria-keyshortcuts": 0,
        "aria-label": 0,
        "aria-roledescription": 0,
        "aria-autocomplete": 0,
        "aria-checked": 0,
        "aria-expanded": 0,
        "aria-haspopup": 0,
        "aria-level": 0,
        "aria-modal": 0,
        "aria-multiline": 0,
        "aria-multiselectable": 0,
        "aria-orientation": 0,
        "aria-placeholder": 0,
        "aria-pressed": 0,
        "aria-readonly": 0,
        "aria-required": 0,
        "aria-selected": 0,
        "aria-sort": 0,
        "aria-valuemax": 0,
        "aria-valuemin": 0,
        "aria-valuenow": 0,
        "aria-valuetext": 0,
        "aria-atomic": 0,
        "aria-busy": 0,
        "aria-live": 0,
        "aria-relevant": 0,
        "aria-dropeffect": 0,
        "aria-grabbed": 0,
        "aria-activedescendant": 0,
        "aria-colcount": 0,
        "aria-colindex": 0,
        "aria-colspan": 0,
        "aria-controls": 0,
        "aria-describedby": 0,
        "aria-errormessage": 0,
        "aria-flowto": 0,
        "aria-labelledby": 0,
        "aria-owns": 0,
        "aria-posinset": 0,
        "aria-rowcount": 0,
        "aria-rowindex": 0,
        "aria-rowspan": 0,
        "aria-setsize": 0
      }, warnedProperties = {}, rARIA = new RegExp("^(aria)-[" + ATTRIBUTE_NAME_CHAR + "]*$"), rARIACamel = new RegExp("^(aria)[A-Z][" + ATTRIBUTE_NAME_CHAR + "]*$"), hasOwnProperty$1 = Object.prototype.hasOwnProperty;
      function validateProperty(tagName, name) {
        {
          if (hasOwnProperty$1.call(warnedProperties, name) && warnedProperties[name])
            return !0;
          if (rARIACamel.test(name)) {
            var ariaName = "aria-" + name.slice(4).toLowerCase(), correctName = ariaProperties.hasOwnProperty(ariaName) ? ariaName : null;
            if (correctName == null)
              return error("Invalid ARIA attribute `%s`. ARIA attributes follow the pattern aria-* and must be lowercase.", name), warnedProperties[name] = !0, !0;
            if (name !== correctName)
              return error("Invalid ARIA attribute `%s`. Did you mean `%s`?", name, correctName), warnedProperties[name] = !0, !0;
          }
          if (rARIA.test(name)) {
            var lowerCasedName = name.toLowerCase(), standardName = ariaProperties.hasOwnProperty(lowerCasedName) ? lowerCasedName : null;
            if (standardName == null)
              return warnedProperties[name] = !0, !1;
            if (name !== standardName)
              return error("Unknown ARIA attribute `%s`. Did you mean `%s`?", name, standardName), warnedProperties[name] = !0, !0;
          }
        }
        return !0;
      }
      function warnInvalidARIAProps(type, props) {
        {
          var invalidProps = [];
          for (var key in props) {
            var isValid = validateProperty(type, key);
            isValid || invalidProps.push(key);
          }
          var unknownPropString = invalidProps.map(function(prop) {
            return "`" + prop + "`";
          }).join(", ");
          invalidProps.length === 1 ? error("Invalid aria prop %s on <%s> tag. For details, see https://reactjs.org/link/invalid-aria-props", unknownPropString, type) : invalidProps.length > 1 && error("Invalid aria props %s on <%s> tag. For details, see https://reactjs.org/link/invalid-aria-props", unknownPropString, type);
        }
      }
      function validateProperties(type, props) {
        isCustomComponent(type, props) || warnInvalidARIAProps(type, props);
      }
      var didWarnValueNull = !1;
      function validateProperties$1(type, props) {
        {
          if (type !== "input" && type !== "textarea" && type !== "select")
            return;
          props != null && props.value === null && !didWarnValueNull && (didWarnValueNull = !0, type === "select" && props.multiple ? error("`value` prop on `%s` should not be null. Consider using an empty array when `multiple` is set to `true` to clear the component or `undefined` for uncontrolled components.", type) : error("`value` prop on `%s` should not be null. Consider using an empty string to clear the component or `undefined` for uncontrolled components.", type));
        }
      }
      var validateProperty$1 = function() {
      };
      {
        var warnedProperties$1 = {}, _hasOwnProperty = Object.prototype.hasOwnProperty, EVENT_NAME_REGEX = /^on./, INVALID_EVENT_NAME_REGEX = /^on[^A-Z]/, rARIA$1 = new RegExp("^(aria)-[" + ATTRIBUTE_NAME_CHAR + "]*$"), rARIACamel$1 = new RegExp("^(aria)[A-Z][" + ATTRIBUTE_NAME_CHAR + "]*$");
        validateProperty$1 = function(tagName, name, value, eventRegistry) {
          if (_hasOwnProperty.call(warnedProperties$1, name) && warnedProperties$1[name])
            return !0;
          var lowerCasedName = name.toLowerCase();
          if (lowerCasedName === "onfocusin" || lowerCasedName === "onfocusout")
            return error("React uses onFocus and onBlur instead of onFocusIn and onFocusOut. All React events are normalized to bubble, so onFocusIn and onFocusOut are not needed/supported by React."), warnedProperties$1[name] = !0, !0;
          if (eventRegistry != null) {
            var registrationNameDependencies2 = eventRegistry.registrationNameDependencies, possibleRegistrationNames2 = eventRegistry.possibleRegistrationNames;
            if (registrationNameDependencies2.hasOwnProperty(name))
              return !0;
            var registrationName = possibleRegistrationNames2.hasOwnProperty(lowerCasedName) ? possibleRegistrationNames2[lowerCasedName] : null;
            if (registrationName != null)
              return error("Invalid event handler property `%s`. Did you mean `%s`?", name, registrationName), warnedProperties$1[name] = !0, !0;
            if (EVENT_NAME_REGEX.test(name))
              return error("Unknown event handler property `%s`. It will be ignored.", name), warnedProperties$1[name] = !0, !0;
          } else if (EVENT_NAME_REGEX.test(name))
            return INVALID_EVENT_NAME_REGEX.test(name) && error("Invalid event handler property `%s`. React events use the camelCase naming convention, for example `onClick`.", name), warnedProperties$1[name] = !0, !0;
          if (rARIA$1.test(name) || rARIACamel$1.test(name))
            return !0;
          if (lowerCasedName === "innerhtml")
            return error("Directly setting property `innerHTML` is not permitted. For more information, lookup documentation on `dangerouslySetInnerHTML`."), warnedProperties$1[name] = !0, !0;
          if (lowerCasedName === "aria")
            return error("The `aria` attribute is reserved for future use in React. Pass individual `aria-` attributes instead."), warnedProperties$1[name] = !0, !0;
          if (lowerCasedName === "is" && value !== null && value !== void 0 && typeof value != "string")
            return error("Received a `%s` for a string attribute `is`. If this is expected, cast the value to a string.", typeof value), warnedProperties$1[name] = !0, !0;
          if (typeof value == "number" && isNaN(value))
            return error("Received NaN for the `%s` attribute. If this is expected, cast the value to a string.", name), warnedProperties$1[name] = !0, !0;
          var propertyInfo = getPropertyInfo(name), isReserved = propertyInfo !== null && propertyInfo.type === RESERVED;
          if (possibleStandardNames.hasOwnProperty(lowerCasedName)) {
            var standardName = possibleStandardNames[lowerCasedName];
            if (standardName !== name)
              return error("Invalid DOM property `%s`. Did you mean `%s`?", name, standardName), warnedProperties$1[name] = !0, !0;
          } else if (!isReserved && name !== lowerCasedName)
            return error("React does not recognize the `%s` prop on a DOM element. If you intentionally want it to appear in the DOM as a custom attribute, spell it as lowercase `%s` instead. If you accidentally passed it from a parent component, remove it from the DOM element.", name, lowerCasedName), warnedProperties$1[name] = !0, !0;
          return typeof value == "boolean" && shouldRemoveAttributeWithWarning(name, value, propertyInfo, !1) ? (value ? error('Received `%s` for a non-boolean attribute `%s`.\n\nIf you want to write it to the DOM, pass a string instead: %s="%s" or %s={value.toString()}.', value, name, name, value, name) : error('Received `%s` for a non-boolean attribute `%s`.\n\nIf you want to write it to the DOM, pass a string instead: %s="%s" or %s={value.toString()}.\n\nIf you used to conditionally omit it with %s={condition && value}, pass %s={condition ? value : undefined} instead.', value, name, name, value, name, name, name), warnedProperties$1[name] = !0, !0) : isReserved ? !0 : shouldRemoveAttributeWithWarning(name, value, propertyInfo, !1) ? (warnedProperties$1[name] = !0, !1) : ((value === "false" || value === "true") && propertyInfo !== null && propertyInfo.type === BOOLEAN && (error("Received the string `%s` for the boolean attribute `%s`. %s Did you mean %s={%s}?", value, name, value === "false" ? "The browser will interpret it as a truthy value." : 'Although this works, it will not work as expected if you pass the string "false".', name, value), warnedProperties$1[name] = !0), !0);
        };
      }
      var warnUnknownProperties = function(type, props, eventRegistry) {
        {
          var unknownProps = [];
          for (var key in props) {
            var isValid = validateProperty$1(type, key, props[key], eventRegistry);
            isValid || unknownProps.push(key);
          }
          var unknownPropString = unknownProps.map(function(prop) {
            return "`" + prop + "`";
          }).join(", ");
          unknownProps.length === 1 ? error("Invalid value for prop %s on <%s> tag. Either remove it from the element, or pass a string or number value to keep it in the DOM. For details, see https://reactjs.org/link/attribute-behavior ", unknownPropString, type) : unknownProps.length > 1 && error("Invalid values for props %s on <%s> tag. Either remove them from the element, or pass a string or number value to keep them in the DOM. For details, see https://reactjs.org/link/attribute-behavior ", unknownPropString, type);
        }
      };
      function validateProperties$2(type, props, eventRegistry) {
        isCustomComponent(type, props) || warnUnknownProperties(type, props, eventRegistry);
      }
      var IS_EVENT_HANDLE_NON_MANAGED_NODE = 1, IS_NON_DELEGATED = 1 << 1, IS_CAPTURE_PHASE = 1 << 2, IS_REPLAYED = 1 << 4, SHOULD_NOT_PROCESS_POLYFILL_EVENT_PLUGINS = IS_EVENT_HANDLE_NON_MANAGED_NODE | IS_NON_DELEGATED | IS_CAPTURE_PHASE;
      function getEventTarget(nativeEvent) {
        var target = nativeEvent.target || nativeEvent.srcElement || window;
        return target.correspondingUseElement && (target = target.correspondingUseElement), target.nodeType === TEXT_NODE ? target.parentNode : target;
      }
      var restoreImpl = null, restoreTarget = null, restoreQueue = null;
      function restoreStateOfTarget(target) {
        var internalInstance = getInstanceFromNode(target);
        if (!!internalInstance) {
          if (typeof restoreImpl != "function")
            throw Error("setRestoreImplementation() needs to be called to handle a target for controlled events. This error is likely caused by a bug in React. Please file an issue.");
          var stateNode = internalInstance.stateNode;
          if (stateNode) {
            var _props = getFiberCurrentPropsFromNode(stateNode);
            restoreImpl(internalInstance.stateNode, internalInstance.type, _props);
          }
        }
      }
      function setRestoreImplementation(impl) {
        restoreImpl = impl;
      }
      function enqueueStateRestore(target) {
        restoreTarget ? restoreQueue ? restoreQueue.push(target) : restoreQueue = [target] : restoreTarget = target;
      }
      function needsStateRestore() {
        return restoreTarget !== null || restoreQueue !== null;
      }
      function restoreStateIfNeeded() {
        if (!!restoreTarget) {
          var target = restoreTarget, queuedTargets = restoreQueue;
          if (restoreTarget = null, restoreQueue = null, restoreStateOfTarget(target), queuedTargets)
            for (var i = 0; i < queuedTargets.length; i++)
              restoreStateOfTarget(queuedTargets[i]);
        }
      }
      var batchedUpdatesImpl = function(fn, bookkeeping) {
        return fn(bookkeeping);
      }, discreteUpdatesImpl = function(fn, a, b, c, d) {
        return fn(a, b, c, d);
      }, flushDiscreteUpdatesImpl = function() {
      }, batchedEventUpdatesImpl = batchedUpdatesImpl, isInsideEventHandler = !1, isBatchingEventUpdates = !1;
      function finishEventHandler() {
        var controlledComponentsHavePendingUpdates = needsStateRestore();
        controlledComponentsHavePendingUpdates && (flushDiscreteUpdatesImpl(), restoreStateIfNeeded());
      }
      function batchedUpdates(fn, bookkeeping) {
        if (isInsideEventHandler)
          return fn(bookkeeping);
        isInsideEventHandler = !0;
        try {
          return batchedUpdatesImpl(fn, bookkeeping);
        } finally {
          isInsideEventHandler = !1, finishEventHandler();
        }
      }
      function batchedEventUpdates(fn, a, b) {
        if (isBatchingEventUpdates)
          return fn(a, b);
        isBatchingEventUpdates = !0;
        try {
          return batchedEventUpdatesImpl(fn, a, b);
        } finally {
          isBatchingEventUpdates = !1, finishEventHandler();
        }
      }
      function discreteUpdates(fn, a, b, c, d) {
        var prevIsInsideEventHandler = isInsideEventHandler;
        isInsideEventHandler = !0;
        try {
          return discreteUpdatesImpl(fn, a, b, c, d);
        } finally {
          isInsideEventHandler = prevIsInsideEventHandler, isInsideEventHandler || finishEventHandler();
        }
      }
      function flushDiscreteUpdatesIfNeeded(timeStamp) {
        isInsideEventHandler || flushDiscreteUpdatesImpl();
      }
      function setBatchingImplementation(_batchedUpdatesImpl, _discreteUpdatesImpl, _flushDiscreteUpdatesImpl, _batchedEventUpdatesImpl) {
        batchedUpdatesImpl = _batchedUpdatesImpl, discreteUpdatesImpl = _discreteUpdatesImpl, flushDiscreteUpdatesImpl = _flushDiscreteUpdatesImpl, batchedEventUpdatesImpl = _batchedEventUpdatesImpl;
      }
      function isInteractive(tag) {
        return tag === "button" || tag === "input" || tag === "select" || tag === "textarea";
      }
      function shouldPreventMouseEvent(name, type, props) {
        switch (name) {
          case "onClick":
          case "onClickCapture":
          case "onDoubleClick":
          case "onDoubleClickCapture":
          case "onMouseDown":
          case "onMouseDownCapture":
          case "onMouseMove":
          case "onMouseMoveCapture":
          case "onMouseUp":
          case "onMouseUpCapture":
          case "onMouseEnter":
            return !!(props.disabled && isInteractive(type));
          default:
            return !1;
        }
      }
      function getListener(inst, registrationName) {
        var stateNode = inst.stateNode;
        if (stateNode === null)
          return null;
        var props = getFiberCurrentPropsFromNode(stateNode);
        if (props === null)
          return null;
        var listener = props[registrationName];
        if (shouldPreventMouseEvent(registrationName, inst.type, props))
          return null;
        if (!(!listener || typeof listener == "function"))
          throw Error("Expected `" + registrationName + "` listener to be a function, instead got a value of `" + typeof listener + "` type.");
        return listener;
      }
      var passiveBrowserEventsSupported = !1;
      if (canUseDOM)
        try {
          var options = {};
          Object.defineProperty(options, "passive", {
            get: function() {
              passiveBrowserEventsSupported = !0;
            }
          }), window.addEventListener("test", options, options), window.removeEventListener("test", options, options);
        } catch {
          passiveBrowserEventsSupported = !1;
        }
      function invokeGuardedCallbackProd(name, func, context, a, b, c, d, e, f) {
        var funcArgs = Array.prototype.slice.call(arguments, 3);
        try {
          func.apply(context, funcArgs);
        } catch (error2) {
          this.onError(error2);
        }
      }
      var invokeGuardedCallbackImpl = invokeGuardedCallbackProd;
      if (typeof window < "u" && typeof window.dispatchEvent == "function" && typeof document < "u" && typeof document.createEvent == "function") {
        var fakeNode = document.createElement("react");
        invokeGuardedCallbackImpl = function(name, func, context, a, b, c, d, e, f) {
          if (!(typeof document < "u"))
            throw Error("The `document` global was defined when React was initialized, but is not defined anymore. This can happen in a test environment if a component schedules an update from an asynchronous callback, but the test has already finished running. To solve this, you can either unmount the component at the end of your test (and ensure that any asynchronous operations get canceled in `componentWillUnmount`), or you can change the test itself to be asynchronous.");
          var evt = document.createEvent("Event"), didCall = !1, didError = !0, windowEvent = window.event, windowEventDescriptor = Object.getOwnPropertyDescriptor(window, "event");
          function restoreAfterDispatch() {
            fakeNode.removeEventListener(evtType, callCallback2, !1), typeof window.event < "u" && window.hasOwnProperty("event") && (window.event = windowEvent);
          }
          var funcArgs = Array.prototype.slice.call(arguments, 3);
          function callCallback2() {
            didCall = !0, restoreAfterDispatch(), func.apply(context, funcArgs), didError = !1;
          }
          var error2, didSetError = !1, isCrossOriginError = !1;
          function handleWindowError(event) {
            if (error2 = event.error, didSetError = !0, error2 === null && event.colno === 0 && event.lineno === 0 && (isCrossOriginError = !0), event.defaultPrevented && error2 != null && typeof error2 == "object")
              try {
                error2._suppressLogging = !0;
              } catch {
              }
          }
          var evtType = "react-" + (name || "invokeguardedcallback");
          if (window.addEventListener("error", handleWindowError), fakeNode.addEventListener(evtType, callCallback2, !1), evt.initEvent(evtType, !1, !1), fakeNode.dispatchEvent(evt), windowEventDescriptor && Object.defineProperty(window, "event", windowEventDescriptor), didCall && didError && (didSetError ? isCrossOriginError && (error2 = new Error("A cross-origin error was thrown. React doesn't have access to the actual error object in development. See https://reactjs.org/link/crossorigin-error for more information.")) : error2 = new Error(`An error was thrown inside one of your components, but React doesn't know what it was. This is likely due to browser flakiness. React does its best to preserve the "Pause on exceptions" behavior of the DevTools, which requires some DEV-mode only tricks. It's possible that these don't work in your browser. Try triggering the error in production mode, or switching to a modern browser. If you suspect that this is actually an issue with React, please file an issue.`), this.onError(error2)), window.removeEventListener("error", handleWindowError), !didCall)
            return restoreAfterDispatch(), invokeGuardedCallbackProd.apply(this, arguments);
        };
      }
      var invokeGuardedCallbackImpl$1 = invokeGuardedCallbackImpl, hasError = !1, caughtError = null, hasRethrowError = !1, rethrowError = null, reporter = {
        onError: function(error2) {
          hasError = !0, caughtError = error2;
        }
      };
      function invokeGuardedCallback(name, func, context, a, b, c, d, e, f) {
        hasError = !1, caughtError = null, invokeGuardedCallbackImpl$1.apply(reporter, arguments);
      }
      function invokeGuardedCallbackAndCatchFirstError(name, func, context, a, b, c, d, e, f) {
        if (invokeGuardedCallback.apply(this, arguments), hasError) {
          var error2 = clearCaughtError();
          hasRethrowError || (hasRethrowError = !0, rethrowError = error2);
        }
      }
      function rethrowCaughtError() {
        if (hasRethrowError) {
          var error2 = rethrowError;
          throw hasRethrowError = !1, rethrowError = null, error2;
        }
      }
      function hasCaughtError() {
        return hasError;
      }
      function clearCaughtError() {
        if (hasError) {
          var error2 = caughtError;
          return hasError = !1, caughtError = null, error2;
        } else
          throw Error("clearCaughtError was called but no error was captured. This error is likely caused by a bug in React. Please file an issue.");
      }
      function get(key) {
        return key._reactInternals;
      }
      function has(key) {
        return key._reactInternals !== void 0;
      }
      function set(key, value) {
        key._reactInternals = value;
      }
      var NoFlags = 0, PerformedWork = 1, Placement = 2, Update = 4, PlacementAndUpdate = 6, Deletion = 8, ContentReset = 16, Callback = 32, DidCapture = 64, Ref = 128, Snapshot = 256, Passive = 512, PassiveUnmountPendingDev = 8192, Hydrating = 1024, HydratingAndUpdate = 1028, LifecycleEffectMask = 932, HostEffectMask = 2047, Incomplete = 2048, ShouldCapture = 4096, ForceUpdateForLegacySuspense = 16384, ReactCurrentOwner = ReactSharedInternals.ReactCurrentOwner;
      function getNearestMountedFiber(fiber) {
        var node = fiber, nearestMounted = fiber;
        if (fiber.alternate)
          for (; node.return; )
            node = node.return;
        else {
          var nextNode = node;
          do
            node = nextNode, (node.flags & (Placement | Hydrating)) !== NoFlags && (nearestMounted = node.return), nextNode = node.return;
          while (nextNode);
        }
        return node.tag === HostRoot ? nearestMounted : null;
      }
      function getSuspenseInstanceFromFiber(fiber) {
        if (fiber.tag === SuspenseComponent) {
          var suspenseState = fiber.memoizedState;
          if (suspenseState === null) {
            var current2 = fiber.alternate;
            current2 !== null && (suspenseState = current2.memoizedState);
          }
          if (suspenseState !== null)
            return suspenseState.dehydrated;
        }
        return null;
      }
      function getContainerFromFiber(fiber) {
        return fiber.tag === HostRoot ? fiber.stateNode.containerInfo : null;
      }
      function isFiberMounted(fiber) {
        return getNearestMountedFiber(fiber) === fiber;
      }
      function isMounted(component) {
        {
          var owner = ReactCurrentOwner.current;
          if (owner !== null && owner.tag === ClassComponent) {
            var ownerFiber = owner, instance = ownerFiber.stateNode;
            instance._warnedAboutRefsInRender || error("%s is accessing isMounted inside its render() function. render() should be a pure function of props and state. It should never access something that requires stale data from the previous render, such as refs. Move this logic to componentDidMount and componentDidUpdate instead.", getComponentName(ownerFiber.type) || "A component"), instance._warnedAboutRefsInRender = !0;
          }
        }
        var fiber = get(component);
        return fiber ? getNearestMountedFiber(fiber) === fiber : !1;
      }
      function assertIsMounted(fiber) {
        if (getNearestMountedFiber(fiber) !== fiber)
          throw Error("Unable to find node on an unmounted component.");
      }
      function findCurrentFiberUsingSlowPath(fiber) {
        var alternate = fiber.alternate;
        if (!alternate) {
          var nearestMounted = getNearestMountedFiber(fiber);
          if (nearestMounted === null)
            throw Error("Unable to find node on an unmounted component.");
          return nearestMounted !== fiber ? null : fiber;
        }
        for (var a = fiber, b = alternate; ; ) {
          var parentA = a.return;
          if (parentA === null)
            break;
          var parentB = parentA.alternate;
          if (parentB === null) {
            var nextParent = parentA.return;
            if (nextParent !== null) {
              a = b = nextParent;
              continue;
            }
            break;
          }
          if (parentA.child === parentB.child) {
            for (var child = parentA.child; child; ) {
              if (child === a)
                return assertIsMounted(parentA), fiber;
              if (child === b)
                return assertIsMounted(parentA), alternate;
              child = child.sibling;
            }
            throw Error("Unable to find node on an unmounted component.");
          }
          if (a.return !== b.return)
            a = parentA, b = parentB;
          else {
            for (var didFindChild = !1, _child = parentA.child; _child; ) {
              if (_child === a) {
                didFindChild = !0, a = parentA, b = parentB;
                break;
              }
              if (_child === b) {
                didFindChild = !0, b = parentA, a = parentB;
                break;
              }
              _child = _child.sibling;
            }
            if (!didFindChild) {
              for (_child = parentB.child; _child; ) {
                if (_child === a) {
                  didFindChild = !0, a = parentB, b = parentA;
                  break;
                }
                if (_child === b) {
                  didFindChild = !0, b = parentB, a = parentA;
                  break;
                }
                _child = _child.sibling;
              }
              if (!didFindChild)
                throw Error("Child was not found in either parent set. This indicates a bug in React related to the return pointer. Please file an issue.");
            }
          }
          if (a.alternate !== b)
            throw Error("Return fibers should always be each others' alternates. This error is likely caused by a bug in React. Please file an issue.");
        }
        if (a.tag !== HostRoot)
          throw Error("Unable to find node on an unmounted component.");
        return a.stateNode.current === a ? fiber : alternate;
      }
      function findCurrentHostFiber(parent) {
        var currentParent = findCurrentFiberUsingSlowPath(parent);
        if (!currentParent)
          return null;
        for (var node = currentParent; ; ) {
          if (node.tag === HostComponent || node.tag === HostText)
            return node;
          if (node.child) {
            node.child.return = node, node = node.child;
            continue;
          }
          if (node === currentParent)
            return null;
          for (; !node.sibling; ) {
            if (!node.return || node.return === currentParent)
              return null;
            node = node.return;
          }
          node.sibling.return = node.return, node = node.sibling;
        }
        return null;
      }
      function findCurrentHostFiberWithNoPortals(parent) {
        var currentParent = findCurrentFiberUsingSlowPath(parent);
        if (!currentParent)
          return null;
        for (var node = currentParent; ; ) {
          if (node.tag === HostComponent || node.tag === HostText || enableFundamentalAPI)
            return node;
          if (node.child && node.tag !== HostPortal) {
            node.child.return = node, node = node.child;
            continue;
          }
          if (node === currentParent)
            return null;
          for (; !node.sibling; ) {
            if (!node.return || node.return === currentParent)
              return null;
            node = node.return;
          }
          node.sibling.return = node.return, node = node.sibling;
        }
        return null;
      }
      function doesFiberContain(parentFiber, childFiber) {
        for (var node = childFiber, parentFiberAlternate = parentFiber.alternate; node !== null; ) {
          if (node === parentFiber || node === parentFiberAlternate)
            return !0;
          node = node.return;
        }
        return !1;
      }
      var attemptUserBlockingHydration;
      function setAttemptUserBlockingHydration(fn) {
        attemptUserBlockingHydration = fn;
      }
      var attemptContinuousHydration;
      function setAttemptContinuousHydration(fn) {
        attemptContinuousHydration = fn;
      }
      var attemptHydrationAtCurrentPriority;
      function setAttemptHydrationAtCurrentPriority(fn) {
        attemptHydrationAtCurrentPriority = fn;
      }
      var attemptHydrationAtPriority;
      function setAttemptHydrationAtPriority(fn) {
        attemptHydrationAtPriority = fn;
      }
      var hasScheduledReplayAttempt = !1, queuedDiscreteEvents = [], queuedFocus = null, queuedDrag = null, queuedMouse = null, queuedPointers = /* @__PURE__ */ new Map(), queuedPointerCaptures = /* @__PURE__ */ new Map(), queuedExplicitHydrationTargets = [];
      function hasQueuedDiscreteEvents() {
        return queuedDiscreteEvents.length > 0;
      }
      var discreteReplayableEvents = [
        "mousedown",
        "mouseup",
        "touchcancel",
        "touchend",
        "touchstart",
        "auxclick",
        "dblclick",
        "pointercancel",
        "pointerdown",
        "pointerup",
        "dragend",
        "dragstart",
        "drop",
        "compositionend",
        "compositionstart",
        "keydown",
        "keypress",
        "keyup",
        "input",
        "textInput",
        "copy",
        "cut",
        "paste",
        "click",
        "change",
        "contextmenu",
        "reset",
        "submit"
      ];
      function isReplayableDiscreteEvent(eventType) {
        return discreteReplayableEvents.indexOf(eventType) > -1;
      }
      function createQueuedReplayableEvent(blockedOn, domEventName, eventSystemFlags, targetContainer, nativeEvent) {
        return {
          blockedOn,
          domEventName,
          eventSystemFlags: eventSystemFlags | IS_REPLAYED,
          nativeEvent,
          targetContainers: [targetContainer]
        };
      }
      function queueDiscreteEvent(blockedOn, domEventName, eventSystemFlags, targetContainer, nativeEvent) {
        var queuedEvent = createQueuedReplayableEvent(blockedOn, domEventName, eventSystemFlags, targetContainer, nativeEvent);
        queuedDiscreteEvents.push(queuedEvent);
      }
      function clearIfContinuousEvent(domEventName, nativeEvent) {
        switch (domEventName) {
          case "focusin":
          case "focusout":
            queuedFocus = null;
            break;
          case "dragenter":
          case "dragleave":
            queuedDrag = null;
            break;
          case "mouseover":
          case "mouseout":
            queuedMouse = null;
            break;
          case "pointerover":
          case "pointerout": {
            var pointerId = nativeEvent.pointerId;
            queuedPointers.delete(pointerId);
            break;
          }
          case "gotpointercapture":
          case "lostpointercapture": {
            var _pointerId = nativeEvent.pointerId;
            queuedPointerCaptures.delete(_pointerId);
            break;
          }
        }
      }
      function accumulateOrCreateContinuousQueuedReplayableEvent(existingQueuedEvent, blockedOn, domEventName, eventSystemFlags, targetContainer, nativeEvent) {
        if (existingQueuedEvent === null || existingQueuedEvent.nativeEvent !== nativeEvent) {
          var queuedEvent = createQueuedReplayableEvent(blockedOn, domEventName, eventSystemFlags, targetContainer, nativeEvent);
          if (blockedOn !== null) {
            var _fiber2 = getInstanceFromNode(blockedOn);
            _fiber2 !== null && attemptContinuousHydration(_fiber2);
          }
          return queuedEvent;
        }
        existingQueuedEvent.eventSystemFlags |= eventSystemFlags;
        var targetContainers = existingQueuedEvent.targetContainers;
        return targetContainer !== null && targetContainers.indexOf(targetContainer) === -1 && targetContainers.push(targetContainer), existingQueuedEvent;
      }
      function queueIfContinuousEvent(blockedOn, domEventName, eventSystemFlags, targetContainer, nativeEvent) {
        switch (domEventName) {
          case "focusin": {
            var focusEvent = nativeEvent;
            return queuedFocus = accumulateOrCreateContinuousQueuedReplayableEvent(queuedFocus, blockedOn, domEventName, eventSystemFlags, targetContainer, focusEvent), !0;
          }
          case "dragenter": {
            var dragEvent = nativeEvent;
            return queuedDrag = accumulateOrCreateContinuousQueuedReplayableEvent(queuedDrag, blockedOn, domEventName, eventSystemFlags, targetContainer, dragEvent), !0;
          }
          case "mouseover": {
            var mouseEvent = nativeEvent;
            return queuedMouse = accumulateOrCreateContinuousQueuedReplayableEvent(queuedMouse, blockedOn, domEventName, eventSystemFlags, targetContainer, mouseEvent), !0;
          }
          case "pointerover": {
            var pointerEvent = nativeEvent, pointerId = pointerEvent.pointerId;
            return queuedPointers.set(pointerId, accumulateOrCreateContinuousQueuedReplayableEvent(queuedPointers.get(pointerId) || null, blockedOn, domEventName, eventSystemFlags, targetContainer, pointerEvent)), !0;
          }
          case "gotpointercapture": {
            var _pointerEvent = nativeEvent, _pointerId2 = _pointerEvent.pointerId;
            return queuedPointerCaptures.set(_pointerId2, accumulateOrCreateContinuousQueuedReplayableEvent(queuedPointerCaptures.get(_pointerId2) || null, blockedOn, domEventName, eventSystemFlags, targetContainer, _pointerEvent)), !0;
          }
        }
        return !1;
      }
      function attemptExplicitHydrationTarget(queuedTarget) {
        var targetInst = getClosestInstanceFromNode(queuedTarget.target);
        if (targetInst !== null) {
          var nearestMounted = getNearestMountedFiber(targetInst);
          if (nearestMounted !== null) {
            var tag = nearestMounted.tag;
            if (tag === SuspenseComponent) {
              var instance = getSuspenseInstanceFromFiber(nearestMounted);
              if (instance !== null) {
                queuedTarget.blockedOn = instance, attemptHydrationAtPriority(queuedTarget.lanePriority, function() {
                  Scheduler.unstable_runWithPriority(queuedTarget.priority, function() {
                    attemptHydrationAtCurrentPriority(nearestMounted);
                  });
                });
                return;
              }
            } else if (tag === HostRoot) {
              var root2 = nearestMounted.stateNode;
              if (root2.hydrate) {
                queuedTarget.blockedOn = getContainerFromFiber(nearestMounted);
                return;
              }
            }
          }
        }
        queuedTarget.blockedOn = null;
      }
      function attemptReplayContinuousQueuedEvent(queuedEvent) {
        if (queuedEvent.blockedOn !== null)
          return !1;
        for (var targetContainers = queuedEvent.targetContainers; targetContainers.length > 0; ) {
          var targetContainer = targetContainers[0], nextBlockedOn = attemptToDispatchEvent(queuedEvent.domEventName, queuedEvent.eventSystemFlags, targetContainer, queuedEvent.nativeEvent);
          if (nextBlockedOn !== null) {
            var _fiber3 = getInstanceFromNode(nextBlockedOn);
            return _fiber3 !== null && attemptContinuousHydration(_fiber3), queuedEvent.blockedOn = nextBlockedOn, !1;
          }
          targetContainers.shift();
        }
        return !0;
      }
      function attemptReplayContinuousQueuedEventInMap(queuedEvent, key, map) {
        attemptReplayContinuousQueuedEvent(queuedEvent) && map.delete(key);
      }
      function replayUnblockedEvents() {
        for (hasScheduledReplayAttempt = !1; queuedDiscreteEvents.length > 0; ) {
          var nextDiscreteEvent = queuedDiscreteEvents[0];
          if (nextDiscreteEvent.blockedOn !== null) {
            var _fiber4 = getInstanceFromNode(nextDiscreteEvent.blockedOn);
            _fiber4 !== null && attemptUserBlockingHydration(_fiber4);
            break;
          }
          for (var targetContainers = nextDiscreteEvent.targetContainers; targetContainers.length > 0; ) {
            var targetContainer = targetContainers[0], nextBlockedOn = attemptToDispatchEvent(nextDiscreteEvent.domEventName, nextDiscreteEvent.eventSystemFlags, targetContainer, nextDiscreteEvent.nativeEvent);
            if (nextBlockedOn !== null) {
              nextDiscreteEvent.blockedOn = nextBlockedOn;
              break;
            }
            targetContainers.shift();
          }
          nextDiscreteEvent.blockedOn === null && queuedDiscreteEvents.shift();
        }
        queuedFocus !== null && attemptReplayContinuousQueuedEvent(queuedFocus) && (queuedFocus = null), queuedDrag !== null && attemptReplayContinuousQueuedEvent(queuedDrag) && (queuedDrag = null), queuedMouse !== null && attemptReplayContinuousQueuedEvent(queuedMouse) && (queuedMouse = null), queuedPointers.forEach(attemptReplayContinuousQueuedEventInMap), queuedPointerCaptures.forEach(attemptReplayContinuousQueuedEventInMap);
      }
      function scheduleCallbackIfUnblocked(queuedEvent, unblocked) {
        queuedEvent.blockedOn === unblocked && (queuedEvent.blockedOn = null, hasScheduledReplayAttempt || (hasScheduledReplayAttempt = !0, Scheduler.unstable_scheduleCallback(Scheduler.unstable_NormalPriority, replayUnblockedEvents)));
      }
      function retryIfBlockedOn(unblocked) {
        if (queuedDiscreteEvents.length > 0) {
          scheduleCallbackIfUnblocked(queuedDiscreteEvents[0], unblocked);
          for (var i = 1; i < queuedDiscreteEvents.length; i++) {
            var queuedEvent = queuedDiscreteEvents[i];
            queuedEvent.blockedOn === unblocked && (queuedEvent.blockedOn = null);
          }
        }
        queuedFocus !== null && scheduleCallbackIfUnblocked(queuedFocus, unblocked), queuedDrag !== null && scheduleCallbackIfUnblocked(queuedDrag, unblocked), queuedMouse !== null && scheduleCallbackIfUnblocked(queuedMouse, unblocked);
        var unblock = function(queuedEvent2) {
          return scheduleCallbackIfUnblocked(queuedEvent2, unblocked);
        };
        queuedPointers.forEach(unblock), queuedPointerCaptures.forEach(unblock);
        for (var _i = 0; _i < queuedExplicitHydrationTargets.length; _i++) {
          var queuedTarget = queuedExplicitHydrationTargets[_i];
          queuedTarget.blockedOn === unblocked && (queuedTarget.blockedOn = null);
        }
        for (; queuedExplicitHydrationTargets.length > 0; ) {
          var nextExplicitTarget = queuedExplicitHydrationTargets[0];
          if (nextExplicitTarget.blockedOn !== null)
            break;
          attemptExplicitHydrationTarget(nextExplicitTarget), nextExplicitTarget.blockedOn === null && queuedExplicitHydrationTargets.shift();
        }
      }
      var DiscreteEvent = 0, UserBlockingEvent = 1, ContinuousEvent = 2;
      function makePrefixMap(styleProp, eventName) {
        var prefixes2 = {};
        return prefixes2[styleProp.toLowerCase()] = eventName.toLowerCase(), prefixes2["Webkit" + styleProp] = "webkit" + eventName, prefixes2["Moz" + styleProp] = "moz" + eventName, prefixes2;
      }
      var vendorPrefixes = {
        animationend: makePrefixMap("Animation", "AnimationEnd"),
        animationiteration: makePrefixMap("Animation", "AnimationIteration"),
        animationstart: makePrefixMap("Animation", "AnimationStart"),
        transitionend: makePrefixMap("Transition", "TransitionEnd")
      }, prefixedEventNames = {}, style3 = {};
      canUseDOM && (style3 = document.createElement("div").style, "AnimationEvent" in window || (delete vendorPrefixes.animationend.animation, delete vendorPrefixes.animationiteration.animation, delete vendorPrefixes.animationstart.animation), "TransitionEvent" in window || delete vendorPrefixes.transitionend.transition);
      function getVendorPrefixedEventName(eventName) {
        if (prefixedEventNames[eventName])
          return prefixedEventNames[eventName];
        if (!vendorPrefixes[eventName])
          return eventName;
        var prefixMap = vendorPrefixes[eventName];
        for (var styleProp in prefixMap)
          if (prefixMap.hasOwnProperty(styleProp) && styleProp in style3)
            return prefixedEventNames[eventName] = prefixMap[styleProp];
        return eventName;
      }
      var ANIMATION_END = getVendorPrefixedEventName("animationend"), ANIMATION_ITERATION = getVendorPrefixedEventName("animationiteration"), ANIMATION_START = getVendorPrefixedEventName("animationstart"), TRANSITION_END = getVendorPrefixedEventName("transitionend"), topLevelEventsToReactNames = /* @__PURE__ */ new Map(), eventPriorities = /* @__PURE__ */ new Map(), discreteEventPairsForSimpleEventPlugin = [
        "cancel",
        "cancel",
        "click",
        "click",
        "close",
        "close",
        "contextmenu",
        "contextMenu",
        "copy",
        "copy",
        "cut",
        "cut",
        "auxclick",
        "auxClick",
        "dblclick",
        "doubleClick",
        "dragend",
        "dragEnd",
        "dragstart",
        "dragStart",
        "drop",
        "drop",
        "focusin",
        "focus",
        "focusout",
        "blur",
        "input",
        "input",
        "invalid",
        "invalid",
        "keydown",
        "keyDown",
        "keypress",
        "keyPress",
        "keyup",
        "keyUp",
        "mousedown",
        "mouseDown",
        "mouseup",
        "mouseUp",
        "paste",
        "paste",
        "pause",
        "pause",
        "play",
        "play",
        "pointercancel",
        "pointerCancel",
        "pointerdown",
        "pointerDown",
        "pointerup",
        "pointerUp",
        "ratechange",
        "rateChange",
        "reset",
        "reset",
        "seeked",
        "seeked",
        "submit",
        "submit",
        "touchcancel",
        "touchCancel",
        "touchend",
        "touchEnd",
        "touchstart",
        "touchStart",
        "volumechange",
        "volumeChange"
      ], otherDiscreteEvents = ["change", "selectionchange", "textInput", "compositionstart", "compositionend", "compositionupdate"], userBlockingPairsForSimpleEventPlugin = ["drag", "drag", "dragenter", "dragEnter", "dragexit", "dragExit", "dragleave", "dragLeave", "dragover", "dragOver", "mousemove", "mouseMove", "mouseout", "mouseOut", "mouseover", "mouseOver", "pointermove", "pointerMove", "pointerout", "pointerOut", "pointerover", "pointerOver", "scroll", "scroll", "toggle", "toggle", "touchmove", "touchMove", "wheel", "wheel"], continuousPairsForSimpleEventPlugin = ["abort", "abort", ANIMATION_END, "animationEnd", ANIMATION_ITERATION, "animationIteration", ANIMATION_START, "animationStart", "canplay", "canPlay", "canplaythrough", "canPlayThrough", "durationchange", "durationChange", "emptied", "emptied", "encrypted", "encrypted", "ended", "ended", "error", "error", "gotpointercapture", "gotPointerCapture", "load", "load", "loadeddata", "loadedData", "loadedmetadata", "loadedMetadata", "loadstart", "loadStart", "lostpointercapture", "lostPointerCapture", "playing", "playing", "progress", "progress", "seeking", "seeking", "stalled", "stalled", "suspend", "suspend", "timeupdate", "timeUpdate", TRANSITION_END, "transitionEnd", "waiting", "waiting"];
      function registerSimplePluginEventsAndSetTheirPriorities(eventTypes, priority) {
        for (var i = 0; i < eventTypes.length; i += 2) {
          var topEvent = eventTypes[i], event = eventTypes[i + 1], capitalizedEvent = event[0].toUpperCase() + event.slice(1), reactName = "on" + capitalizedEvent;
          eventPriorities.set(topEvent, priority), topLevelEventsToReactNames.set(topEvent, reactName), registerTwoPhaseEvent(reactName, [topEvent]);
        }
      }
      function setEventPriorities(eventTypes, priority) {
        for (var i = 0; i < eventTypes.length; i++)
          eventPriorities.set(eventTypes[i], priority);
      }
      function getEventPriorityForPluginSystem(domEventName) {
        var priority = eventPriorities.get(domEventName);
        return priority === void 0 ? ContinuousEvent : priority;
      }
      function registerSimpleEvents() {
        registerSimplePluginEventsAndSetTheirPriorities(discreteEventPairsForSimpleEventPlugin, DiscreteEvent), registerSimplePluginEventsAndSetTheirPriorities(userBlockingPairsForSimpleEventPlugin, UserBlockingEvent), registerSimplePluginEventsAndSetTheirPriorities(continuousPairsForSimpleEventPlugin, ContinuousEvent), setEventPriorities(otherDiscreteEvents, DiscreteEvent);
      }
      var Scheduler_now = Scheduler.unstable_now;
      if (!(tracing.__interactionsRef != null && tracing.__interactionsRef.current != null))
        throw Error("It is not supported to run the profiling version of a renderer (for example, `react-dom/profiling`) without also replacing the `scheduler/tracing` module with `scheduler/tracing-profiling`. Your bundler might have a setting for aliasing both modules. Learn more at https://reactjs.org/link/profiling");
      var ImmediatePriority = 99, UserBlockingPriority = 98, NormalPriority = 97, LowPriority = 96, IdlePriority = 95, NoPriority = 90, initialTimeMs = Scheduler_now(), SyncLanePriority = 15, SyncBatchedLanePriority = 14, InputDiscreteHydrationLanePriority = 13, InputDiscreteLanePriority = 12, InputContinuousHydrationLanePriority = 11, InputContinuousLanePriority = 10, DefaultHydrationLanePriority = 9, DefaultLanePriority = 8, TransitionHydrationPriority = 7, TransitionPriority = 6, RetryLanePriority = 5, SelectiveHydrationLanePriority = 4, IdleHydrationLanePriority = 3, IdleLanePriority = 2, OffscreenLanePriority = 1, NoLanePriority = 0, TotalLanes = 31, NoLanes = 0, NoLane = 0, SyncLane = 1, SyncBatchedLane = 2, InputDiscreteHydrationLane = 4, InputDiscreteLanes = 24, InputContinuousHydrationLane = 32, InputContinuousLanes = 192, DefaultHydrationLane = 256, DefaultLanes = 3584, TransitionHydrationLane = 4096, TransitionLanes = 4186112, RetryLanes = 62914560, SomeRetryLane = 33554432, SelectiveHydrationLane = 67108864, NonIdleLanes = 134217727, IdleHydrationLane = 134217728, IdleLanes = 805306368, OffscreenLane = 1073741824, NoTimestamp = -1;
      function setCurrentUpdateLanePriority(newLanePriority) {
      }
      var return_highestLanePriority = DefaultLanePriority;
      function getHighestPriorityLanes(lanes) {
        if ((SyncLane & lanes) !== NoLanes)
          return return_highestLanePriority = SyncLanePriority, SyncLane;
        if ((SyncBatchedLane & lanes) !== NoLanes)
          return return_highestLanePriority = SyncBatchedLanePriority, SyncBatchedLane;
        if ((InputDiscreteHydrationLane & lanes) !== NoLanes)
          return return_highestLanePriority = InputDiscreteHydrationLanePriority, InputDiscreteHydrationLane;
        var inputDiscreteLanes = InputDiscreteLanes & lanes;
        if (inputDiscreteLanes !== NoLanes)
          return return_highestLanePriority = InputDiscreteLanePriority, inputDiscreteLanes;
        if ((lanes & InputContinuousHydrationLane) !== NoLanes)
          return return_highestLanePriority = InputContinuousHydrationLanePriority, InputContinuousHydrationLane;
        var inputContinuousLanes = InputContinuousLanes & lanes;
        if (inputContinuousLanes !== NoLanes)
          return return_highestLanePriority = InputContinuousLanePriority, inputContinuousLanes;
        if ((lanes & DefaultHydrationLane) !== NoLanes)
          return return_highestLanePriority = DefaultHydrationLanePriority, DefaultHydrationLane;
        var defaultLanes = DefaultLanes & lanes;
        if (defaultLanes !== NoLanes)
          return return_highestLanePriority = DefaultLanePriority, defaultLanes;
        if ((lanes & TransitionHydrationLane) !== NoLanes)
          return return_highestLanePriority = TransitionHydrationPriority, TransitionHydrationLane;
        var transitionLanes = TransitionLanes & lanes;
        if (transitionLanes !== NoLanes)
          return return_highestLanePriority = TransitionPriority, transitionLanes;
        var retryLanes = RetryLanes & lanes;
        if (retryLanes !== NoLanes)
          return return_highestLanePriority = RetryLanePriority, retryLanes;
        if (lanes & SelectiveHydrationLane)
          return return_highestLanePriority = SelectiveHydrationLanePriority, SelectiveHydrationLane;
        if ((lanes & IdleHydrationLane) !== NoLanes)
          return return_highestLanePriority = IdleHydrationLanePriority, IdleHydrationLane;
        var idleLanes = IdleLanes & lanes;
        return idleLanes !== NoLanes ? (return_highestLanePriority = IdleLanePriority, idleLanes) : (OffscreenLane & lanes) !== NoLanes ? (return_highestLanePriority = OffscreenLanePriority, OffscreenLane) : (error("Should have found matching lanes. This is a bug in React."), return_highestLanePriority = DefaultLanePriority, lanes);
      }
      function schedulerPriorityToLanePriority(schedulerPriorityLevel) {
        switch (schedulerPriorityLevel) {
          case ImmediatePriority:
            return SyncLanePriority;
          case UserBlockingPriority:
            return InputContinuousLanePriority;
          case NormalPriority:
          case LowPriority:
            return DefaultLanePriority;
          case IdlePriority:
            return IdleLanePriority;
          default:
            return NoLanePriority;
        }
      }
      function lanePriorityToSchedulerPriority(lanePriority) {
        switch (lanePriority) {
          case SyncLanePriority:
          case SyncBatchedLanePriority:
            return ImmediatePriority;
          case InputDiscreteHydrationLanePriority:
          case InputDiscreteLanePriority:
          case InputContinuousHydrationLanePriority:
          case InputContinuousLanePriority:
            return UserBlockingPriority;
          case DefaultHydrationLanePriority:
          case DefaultLanePriority:
          case TransitionHydrationPriority:
          case TransitionPriority:
          case SelectiveHydrationLanePriority:
          case RetryLanePriority:
            return NormalPriority;
          case IdleHydrationLanePriority:
          case IdleLanePriority:
          case OffscreenLanePriority:
            return IdlePriority;
          case NoLanePriority:
            return NoPriority;
          default:
            throw Error("Invalid update priority: " + lanePriority + ". This is a bug in React.");
        }
      }
      function getNextLanes(root2, wipLanes) {
        var pendingLanes = root2.pendingLanes;
        if (pendingLanes === NoLanes)
          return return_highestLanePriority = NoLanePriority, NoLanes;
        var nextLanes = NoLanes, nextLanePriority = NoLanePriority, expiredLanes = root2.expiredLanes, suspendedLanes = root2.suspendedLanes, pingedLanes = root2.pingedLanes;
        if (expiredLanes !== NoLanes)
          nextLanes = expiredLanes, nextLanePriority = return_highestLanePriority = SyncLanePriority;
        else {
          var nonIdlePendingLanes = pendingLanes & NonIdleLanes;
          if (nonIdlePendingLanes !== NoLanes) {
            var nonIdleUnblockedLanes = nonIdlePendingLanes & ~suspendedLanes;
            if (nonIdleUnblockedLanes !== NoLanes)
              nextLanes = getHighestPriorityLanes(nonIdleUnblockedLanes), nextLanePriority = return_highestLanePriority;
            else {
              var nonIdlePingedLanes = nonIdlePendingLanes & pingedLanes;
              nonIdlePingedLanes !== NoLanes && (nextLanes = getHighestPriorityLanes(nonIdlePingedLanes), nextLanePriority = return_highestLanePriority);
            }
          } else {
            var unblockedLanes = pendingLanes & ~suspendedLanes;
            unblockedLanes !== NoLanes ? (nextLanes = getHighestPriorityLanes(unblockedLanes), nextLanePriority = return_highestLanePriority) : pingedLanes !== NoLanes && (nextLanes = getHighestPriorityLanes(pingedLanes), nextLanePriority = return_highestLanePriority);
          }
        }
        if (nextLanes === NoLanes)
          return NoLanes;
        if (nextLanes = pendingLanes & getEqualOrHigherPriorityLanes(nextLanes), wipLanes !== NoLanes && wipLanes !== nextLanes && (wipLanes & suspendedLanes) === NoLanes) {
          getHighestPriorityLanes(wipLanes);
          var wipLanePriority = return_highestLanePriority;
          if (nextLanePriority <= wipLanePriority)
            return wipLanes;
          return_highestLanePriority = nextLanePriority;
        }
        var entangledLanes = root2.entangledLanes;
        if (entangledLanes !== NoLanes)
          for (var entanglements = root2.entanglements, lanes = nextLanes & entangledLanes; lanes > 0; ) {
            var index2 = pickArbitraryLaneIndex(lanes), lane = 1 << index2;
            nextLanes |= entanglements[index2], lanes &= ~lane;
          }
        return nextLanes;
      }
      function getMostRecentEventTime(root2, lanes) {
        for (var eventTimes = root2.eventTimes, mostRecentEventTime = NoTimestamp; lanes > 0; ) {
          var index2 = pickArbitraryLaneIndex(lanes), lane = 1 << index2, eventTime = eventTimes[index2];
          eventTime > mostRecentEventTime && (mostRecentEventTime = eventTime), lanes &= ~lane;
        }
        return mostRecentEventTime;
      }
      function computeExpirationTime(lane, currentTime) {
        getHighestPriorityLanes(lane);
        var priority = return_highestLanePriority;
        return priority >= InputContinuousLanePriority ? currentTime + 250 : priority >= TransitionPriority ? currentTime + 5e3 : NoTimestamp;
      }
      function markStarvedLanesAsExpired(root2, currentTime) {
        for (var pendingLanes = root2.pendingLanes, suspendedLanes = root2.suspendedLanes, pingedLanes = root2.pingedLanes, expirationTimes = root2.expirationTimes, lanes = pendingLanes; lanes > 0; ) {
          var index2 = pickArbitraryLaneIndex(lanes), lane = 1 << index2, expirationTime = expirationTimes[index2];
          expirationTime === NoTimestamp ? ((lane & suspendedLanes) === NoLanes || (lane & pingedLanes) !== NoLanes) && (expirationTimes[index2] = computeExpirationTime(lane, currentTime)) : expirationTime <= currentTime && (root2.expiredLanes |= lane), lanes &= ~lane;
        }
      }
      function getLanesToRetrySynchronouslyOnError(root2) {
        var everythingButOffscreen = root2.pendingLanes & ~OffscreenLane;
        return everythingButOffscreen !== NoLanes ? everythingButOffscreen : everythingButOffscreen & OffscreenLane ? OffscreenLane : NoLanes;
      }
      function returnNextLanesPriority() {
        return return_highestLanePriority;
      }
      function includesNonIdleWork(lanes) {
        return (lanes & NonIdleLanes) !== NoLanes;
      }
      function includesOnlyRetries(lanes) {
        return (lanes & RetryLanes) === lanes;
      }
      function includesOnlyTransitions(lanes) {
        return (lanes & TransitionLanes) === lanes;
      }
      function findUpdateLane(lanePriority, wipLanes) {
        switch (lanePriority) {
          case NoLanePriority:
            break;
          case SyncLanePriority:
            return SyncLane;
          case SyncBatchedLanePriority:
            return SyncBatchedLane;
          case InputDiscreteLanePriority: {
            var _lane = pickArbitraryLane(InputDiscreteLanes & ~wipLanes);
            return _lane === NoLane ? findUpdateLane(InputContinuousLanePriority, wipLanes) : _lane;
          }
          case InputContinuousLanePriority: {
            var _lane2 = pickArbitraryLane(InputContinuousLanes & ~wipLanes);
            return _lane2 === NoLane ? findUpdateLane(DefaultLanePriority, wipLanes) : _lane2;
          }
          case DefaultLanePriority: {
            var _lane3 = pickArbitraryLane(DefaultLanes & ~wipLanes);
            return _lane3 === NoLane && (_lane3 = pickArbitraryLane(TransitionLanes & ~wipLanes), _lane3 === NoLane && (_lane3 = pickArbitraryLane(DefaultLanes))), _lane3;
          }
          case TransitionPriority:
          case RetryLanePriority:
            break;
          case IdleLanePriority:
            var lane = pickArbitraryLane(IdleLanes & ~wipLanes);
            return lane === NoLane && (lane = pickArbitraryLane(IdleLanes)), lane;
        }
        throw Error("Invalid update priority: " + lanePriority + ". This is a bug in React.");
      }
      function findTransitionLane(wipLanes, pendingLanes) {
        var lane = pickArbitraryLane(TransitionLanes & ~pendingLanes);
        return lane === NoLane && (lane = pickArbitraryLane(TransitionLanes & ~wipLanes), lane === NoLane && (lane = pickArbitraryLane(TransitionLanes))), lane;
      }
      function findRetryLane(wipLanes) {
        var lane = pickArbitraryLane(RetryLanes & ~wipLanes);
        return lane === NoLane && (lane = pickArbitraryLane(RetryLanes)), lane;
      }
      function getHighestPriorityLane(lanes) {
        return lanes & -lanes;
      }
      function getLowestPriorityLane(lanes) {
        var index2 = 31 - clz32(lanes);
        return index2 < 0 ? NoLanes : 1 << index2;
      }
      function getEqualOrHigherPriorityLanes(lanes) {
        return (getLowestPriorityLane(lanes) << 1) - 1;
      }
      function pickArbitraryLane(lanes) {
        return getHighestPriorityLane(lanes);
      }
      function pickArbitraryLaneIndex(lanes) {
        return 31 - clz32(lanes);
      }
      function laneToIndex(lane) {
        return pickArbitraryLaneIndex(lane);
      }
      function includesSomeLane(a, b) {
        return (a & b) !== NoLanes;
      }
      function isSubsetOfLanes(set2, subset) {
        return (set2 & subset) === subset;
      }
      function mergeLanes(a, b) {
        return a | b;
      }
      function removeLanes(set2, subset) {
        return set2 & ~subset;
      }
      function laneToLanes(lane) {
        return lane;
      }
      function higherPriorityLane(a, b) {
        return a !== NoLane && a < b ? a : b;
      }
      function createLaneMap(initial) {
        for (var laneMap = [], i = 0; i < TotalLanes; i++)
          laneMap.push(initial);
        return laneMap;
      }
      function markRootUpdated(root2, updateLane, eventTime) {
        root2.pendingLanes |= updateLane;
        var higherPriorityLanes = updateLane - 1;
        root2.suspendedLanes &= higherPriorityLanes, root2.pingedLanes &= higherPriorityLanes;
        var eventTimes = root2.eventTimes, index2 = laneToIndex(updateLane);
        eventTimes[index2] = eventTime;
      }
      function markRootSuspended(root2, suspendedLanes) {
        root2.suspendedLanes |= suspendedLanes, root2.pingedLanes &= ~suspendedLanes;
        for (var expirationTimes = root2.expirationTimes, lanes = suspendedLanes; lanes > 0; ) {
          var index2 = pickArbitraryLaneIndex(lanes), lane = 1 << index2;
          expirationTimes[index2] = NoTimestamp, lanes &= ~lane;
        }
      }
      function markRootPinged(root2, pingedLanes, eventTime) {
        root2.pingedLanes |= root2.suspendedLanes & pingedLanes;
      }
      function markDiscreteUpdatesExpired(root2) {
        root2.expiredLanes |= InputDiscreteLanes & root2.pendingLanes;
      }
      function hasDiscreteLanes(lanes) {
        return (lanes & InputDiscreteLanes) !== NoLanes;
      }
      function markRootMutableRead(root2, updateLane) {
        root2.mutableReadLanes |= updateLane & root2.pendingLanes;
      }
      function markRootFinished(root2, remainingLanes) {
        var noLongerPendingLanes = root2.pendingLanes & ~remainingLanes;
        root2.pendingLanes = remainingLanes, root2.suspendedLanes = 0, root2.pingedLanes = 0, root2.expiredLanes &= remainingLanes, root2.mutableReadLanes &= remainingLanes, root2.entangledLanes &= remainingLanes;
        for (var entanglements = root2.entanglements, eventTimes = root2.eventTimes, expirationTimes = root2.expirationTimes, lanes = noLongerPendingLanes; lanes > 0; ) {
          var index2 = pickArbitraryLaneIndex(lanes), lane = 1 << index2;
          entanglements[index2] = NoLanes, eventTimes[index2] = NoTimestamp, expirationTimes[index2] = NoTimestamp, lanes &= ~lane;
        }
      }
      function markRootEntangled(root2, entangledLanes) {
        root2.entangledLanes |= entangledLanes;
        for (var entanglements = root2.entanglements, lanes = entangledLanes; lanes > 0; ) {
          var index2 = pickArbitraryLaneIndex(lanes), lane = 1 << index2;
          entanglements[index2] |= entangledLanes, lanes &= ~lane;
        }
      }
      var clz32 = Math.clz32 ? Math.clz32 : clz32Fallback, log = Math.log, LN2 = Math.LN2;
      function clz32Fallback(lanes) {
        return lanes === 0 ? 32 : 31 - (log(lanes) / LN2 | 0) | 0;
      }
      var UserBlockingPriority$1 = Scheduler.unstable_UserBlockingPriority, runWithPriority = Scheduler.unstable_runWithPriority, _enabled = !0;
      function setEnabled(enabled) {
        _enabled = !!enabled;
      }
      function isEnabled() {
        return _enabled;
      }
      function createEventListenerWrapperWithPriority(targetContainer, domEventName, eventSystemFlags) {
        var eventPriority = getEventPriorityForPluginSystem(domEventName), listenerWrapper;
        switch (eventPriority) {
          case DiscreteEvent:
            listenerWrapper = dispatchDiscreteEvent;
            break;
          case UserBlockingEvent:
            listenerWrapper = dispatchUserBlockingUpdate;
            break;
          case ContinuousEvent:
          default:
            listenerWrapper = dispatchEvent;
            break;
        }
        return listenerWrapper.bind(null, domEventName, eventSystemFlags, targetContainer);
      }
      function dispatchDiscreteEvent(domEventName, eventSystemFlags, container, nativeEvent) {
        flushDiscreteUpdatesIfNeeded(nativeEvent.timeStamp), discreteUpdates(dispatchEvent, domEventName, eventSystemFlags, container, nativeEvent);
      }
      function dispatchUserBlockingUpdate(domEventName, eventSystemFlags, container, nativeEvent) {
        runWithPriority(UserBlockingPriority$1, dispatchEvent.bind(null, domEventName, eventSystemFlags, container, nativeEvent));
      }
      function dispatchEvent(domEventName, eventSystemFlags, targetContainer, nativeEvent) {
        if (!!_enabled) {
          var allowReplay = !0;
          if (allowReplay = (eventSystemFlags & IS_CAPTURE_PHASE) === 0, allowReplay && hasQueuedDiscreteEvents() && isReplayableDiscreteEvent(domEventName)) {
            queueDiscreteEvent(
              null,
              domEventName,
              eventSystemFlags,
              targetContainer,
              nativeEvent
            );
            return;
          }
          var blockedOn = attemptToDispatchEvent(domEventName, eventSystemFlags, targetContainer, nativeEvent);
          if (blockedOn === null) {
            allowReplay && clearIfContinuousEvent(domEventName, nativeEvent);
            return;
          }
          if (allowReplay) {
            if (isReplayableDiscreteEvent(domEventName)) {
              queueDiscreteEvent(blockedOn, domEventName, eventSystemFlags, targetContainer, nativeEvent);
              return;
            }
            if (queueIfContinuousEvent(blockedOn, domEventName, eventSystemFlags, targetContainer, nativeEvent))
              return;
            clearIfContinuousEvent(domEventName, nativeEvent);
          }
          dispatchEventForPluginEventSystem(domEventName, eventSystemFlags, nativeEvent, null, targetContainer);
        }
      }
      function attemptToDispatchEvent(domEventName, eventSystemFlags, targetContainer, nativeEvent) {
        var nativeEventTarget = getEventTarget(nativeEvent), targetInst = getClosestInstanceFromNode(nativeEventTarget);
        if (targetInst !== null) {
          var nearestMounted = getNearestMountedFiber(targetInst);
          if (nearestMounted === null)
            targetInst = null;
          else {
            var tag = nearestMounted.tag;
            if (tag === SuspenseComponent) {
              var instance = getSuspenseInstanceFromFiber(nearestMounted);
              if (instance !== null)
                return instance;
              targetInst = null;
            } else if (tag === HostRoot) {
              var root2 = nearestMounted.stateNode;
              if (root2.hydrate)
                return getContainerFromFiber(nearestMounted);
              targetInst = null;
            } else
              nearestMounted !== targetInst && (targetInst = null);
          }
        }
        return dispatchEventForPluginEventSystem(domEventName, eventSystemFlags, nativeEvent, targetInst, targetContainer), null;
      }
      function addEventBubbleListener(target, eventType, listener) {
        return target.addEventListener(eventType, listener, !1), listener;
      }
      function addEventCaptureListener(target, eventType, listener) {
        return target.addEventListener(eventType, listener, !0), listener;
      }
      function addEventCaptureListenerWithPassiveFlag(target, eventType, listener, passive) {
        return target.addEventListener(eventType, listener, {
          capture: !0,
          passive
        }), listener;
      }
      function addEventBubbleListenerWithPassiveFlag(target, eventType, listener, passive) {
        return target.addEventListener(eventType, listener, {
          passive
        }), listener;
      }
      var root = null, startText = null, fallbackText = null;
      function initialize(nativeEventTarget) {
        return root = nativeEventTarget, startText = getText(), !0;
      }
      function reset() {
        root = null, startText = null, fallbackText = null;
      }
      function getData() {
        if (fallbackText)
          return fallbackText;
        var start, startValue = startText, startLength = startValue.length, end, endValue = getText(), endLength = endValue.length;
        for (start = 0; start < startLength && startValue[start] === endValue[start]; start++)
          ;
        var minEnd = startLength - start;
        for (end = 1; end <= minEnd && startValue[startLength - end] === endValue[endLength - end]; end++)
          ;
        var sliceTail = end > 1 ? 1 - end : void 0;
        return fallbackText = endValue.slice(start, sliceTail), fallbackText;
      }
      function getText() {
        return "value" in root ? root.value : root.textContent;
      }
      function getEventCharCode(nativeEvent) {
        var charCode, keyCode = nativeEvent.keyCode;
        return "charCode" in nativeEvent ? (charCode = nativeEvent.charCode, charCode === 0 && keyCode === 13 && (charCode = 13)) : charCode = keyCode, charCode === 10 && (charCode = 13), charCode >= 32 || charCode === 13 ? charCode : 0;
      }
      function functionThatReturnsTrue() {
        return !0;
      }
      function functionThatReturnsFalse() {
        return !1;
      }
      function createSyntheticEvent(Interface) {
        function SyntheticBaseEvent(reactName, reactEventType, targetInst, nativeEvent, nativeEventTarget) {
          this._reactName = reactName, this._targetInst = targetInst, this.type = reactEventType, this.nativeEvent = nativeEvent, this.target = nativeEventTarget, this.currentTarget = null;
          for (var _propName in Interface)
            if (!!Interface.hasOwnProperty(_propName)) {
              var normalize = Interface[_propName];
              normalize ? this[_propName] = normalize(nativeEvent) : this[_propName] = nativeEvent[_propName];
            }
          var defaultPrevented = nativeEvent.defaultPrevented != null ? nativeEvent.defaultPrevented : nativeEvent.returnValue === !1;
          return defaultPrevented ? this.isDefaultPrevented = functionThatReturnsTrue : this.isDefaultPrevented = functionThatReturnsFalse, this.isPropagationStopped = functionThatReturnsFalse, this;
        }
        return _assign(SyntheticBaseEvent.prototype, {
          preventDefault: function() {
            this.defaultPrevented = !0;
            var event = this.nativeEvent;
            !event || (event.preventDefault ? event.preventDefault() : typeof event.returnValue != "unknown" && (event.returnValue = !1), this.isDefaultPrevented = functionThatReturnsTrue);
          },
          stopPropagation: function() {
            var event = this.nativeEvent;
            !event || (event.stopPropagation ? event.stopPropagation() : typeof event.cancelBubble != "unknown" && (event.cancelBubble = !0), this.isPropagationStopped = functionThatReturnsTrue);
          },
          persist: function() {
          },
          isPersistent: functionThatReturnsTrue
        }), SyntheticBaseEvent;
      }
      var EventInterface = {
        eventPhase: 0,
        bubbles: 0,
        cancelable: 0,
        timeStamp: function(event) {
          return event.timeStamp || Date.now();
        },
        defaultPrevented: 0,
        isTrusted: 0
      }, SyntheticEvent = createSyntheticEvent(EventInterface), UIEventInterface = _assign({}, EventInterface, {
        view: 0,
        detail: 0
      }), SyntheticUIEvent = createSyntheticEvent(UIEventInterface), lastMovementX, lastMovementY, lastMouseEvent;
      function updateMouseMovementPolyfillState(event) {
        event !== lastMouseEvent && (lastMouseEvent && event.type === "mousemove" ? (lastMovementX = event.screenX - lastMouseEvent.screenX, lastMovementY = event.screenY - lastMouseEvent.screenY) : (lastMovementX = 0, lastMovementY = 0), lastMouseEvent = event);
      }
      var MouseEventInterface = _assign({}, UIEventInterface, {
        screenX: 0,
        screenY: 0,
        clientX: 0,
        clientY: 0,
        pageX: 0,
        pageY: 0,
        ctrlKey: 0,
        shiftKey: 0,
        altKey: 0,
        metaKey: 0,
        getModifierState: getEventModifierState,
        button: 0,
        buttons: 0,
        relatedTarget: function(event) {
          return event.relatedTarget === void 0 ? event.fromElement === event.srcElement ? event.toElement : event.fromElement : event.relatedTarget;
        },
        movementX: function(event) {
          return "movementX" in event ? event.movementX : (updateMouseMovementPolyfillState(event), lastMovementX);
        },
        movementY: function(event) {
          return "movementY" in event ? event.movementY : lastMovementY;
        }
      }), SyntheticMouseEvent = createSyntheticEvent(MouseEventInterface), DragEventInterface = _assign({}, MouseEventInterface, {
        dataTransfer: 0
      }), SyntheticDragEvent = createSyntheticEvent(DragEventInterface), FocusEventInterface = _assign({}, UIEventInterface, {
        relatedTarget: 0
      }), SyntheticFocusEvent = createSyntheticEvent(FocusEventInterface), AnimationEventInterface = _assign({}, EventInterface, {
        animationName: 0,
        elapsedTime: 0,
        pseudoElement: 0
      }), SyntheticAnimationEvent = createSyntheticEvent(AnimationEventInterface), ClipboardEventInterface = _assign({}, EventInterface, {
        clipboardData: function(event) {
          return "clipboardData" in event ? event.clipboardData : window.clipboardData;
        }
      }), SyntheticClipboardEvent = createSyntheticEvent(ClipboardEventInterface), CompositionEventInterface = _assign({}, EventInterface, {
        data: 0
      }), SyntheticCompositionEvent = createSyntheticEvent(CompositionEventInterface), SyntheticInputEvent = SyntheticCompositionEvent, normalizeKey = {
        Esc: "Escape",
        Spacebar: " ",
        Left: "ArrowLeft",
        Up: "ArrowUp",
        Right: "ArrowRight",
        Down: "ArrowDown",
        Del: "Delete",
        Win: "OS",
        Menu: "ContextMenu",
        Apps: "ContextMenu",
        Scroll: "ScrollLock",
        MozPrintableKey: "Unidentified"
      }, translateToKey = {
        8: "Backspace",
        9: "Tab",
        12: "Clear",
        13: "Enter",
        16: "Shift",
        17: "Control",
        18: "Alt",
        19: "Pause",
        20: "CapsLock",
        27: "Escape",
        32: " ",
        33: "PageUp",
        34: "PageDown",
        35: "End",
        36: "Home",
        37: "ArrowLeft",
        38: "ArrowUp",
        39: "ArrowRight",
        40: "ArrowDown",
        45: "Insert",
        46: "Delete",
        112: "F1",
        113: "F2",
        114: "F3",
        115: "F4",
        116: "F5",
        117: "F6",
        118: "F7",
        119: "F8",
        120: "F9",
        121: "F10",
        122: "F11",
        123: "F12",
        144: "NumLock",
        145: "ScrollLock",
        224: "Meta"
      };
      function getEventKey(nativeEvent) {
        if (nativeEvent.key) {
          var key = normalizeKey[nativeEvent.key] || nativeEvent.key;
          if (key !== "Unidentified")
            return key;
        }
        if (nativeEvent.type === "keypress") {
          var charCode = getEventCharCode(nativeEvent);
          return charCode === 13 ? "Enter" : String.fromCharCode(charCode);
        }
        return nativeEvent.type === "keydown" || nativeEvent.type === "keyup" ? translateToKey[nativeEvent.keyCode] || "Unidentified" : "";
      }
      var modifierKeyToProp = {
        Alt: "altKey",
        Control: "ctrlKey",
        Meta: "metaKey",
        Shift: "shiftKey"
      };
      function modifierStateGetter(keyArg) {
        var syntheticEvent = this, nativeEvent = syntheticEvent.nativeEvent;
        if (nativeEvent.getModifierState)
          return nativeEvent.getModifierState(keyArg);
        var keyProp = modifierKeyToProp[keyArg];
        return keyProp ? !!nativeEvent[keyProp] : !1;
      }
      function getEventModifierState(nativeEvent) {
        return modifierStateGetter;
      }
      var KeyboardEventInterface = _assign({}, UIEventInterface, {
        key: getEventKey,
        code: 0,
        location: 0,
        ctrlKey: 0,
        shiftKey: 0,
        altKey: 0,
        metaKey: 0,
        repeat: 0,
        locale: 0,
        getModifierState: getEventModifierState,
        charCode: function(event) {
          return event.type === "keypress" ? getEventCharCode(event) : 0;
        },
        keyCode: function(event) {
          return event.type === "keydown" || event.type === "keyup" ? event.keyCode : 0;
        },
        which: function(event) {
          return event.type === "keypress" ? getEventCharCode(event) : event.type === "keydown" || event.type === "keyup" ? event.keyCode : 0;
        }
      }), SyntheticKeyboardEvent = createSyntheticEvent(KeyboardEventInterface), PointerEventInterface = _assign({}, MouseEventInterface, {
        pointerId: 0,
        width: 0,
        height: 0,
        pressure: 0,
        tangentialPressure: 0,
        tiltX: 0,
        tiltY: 0,
        twist: 0,
        pointerType: 0,
        isPrimary: 0
      }), SyntheticPointerEvent = createSyntheticEvent(PointerEventInterface), TouchEventInterface = _assign({}, UIEventInterface, {
        touches: 0,
        targetTouches: 0,
        changedTouches: 0,
        altKey: 0,
        metaKey: 0,
        ctrlKey: 0,
        shiftKey: 0,
        getModifierState: getEventModifierState
      }), SyntheticTouchEvent = createSyntheticEvent(TouchEventInterface), TransitionEventInterface = _assign({}, EventInterface, {
        propertyName: 0,
        elapsedTime: 0,
        pseudoElement: 0
      }), SyntheticTransitionEvent = createSyntheticEvent(TransitionEventInterface), WheelEventInterface = _assign({}, MouseEventInterface, {
        deltaX: function(event) {
          return "deltaX" in event ? event.deltaX : "wheelDeltaX" in event ? -event.wheelDeltaX : 0;
        },
        deltaY: function(event) {
          return "deltaY" in event ? event.deltaY : "wheelDeltaY" in event ? -event.wheelDeltaY : "wheelDelta" in event ? -event.wheelDelta : 0;
        },
        deltaZ: 0,
        deltaMode: 0
      }), SyntheticWheelEvent = createSyntheticEvent(WheelEventInterface), END_KEYCODES = [9, 13, 27, 32], START_KEYCODE = 229, canUseCompositionEvent = canUseDOM && "CompositionEvent" in window, documentMode = null;
      canUseDOM && "documentMode" in document && (documentMode = document.documentMode);
      var canUseTextInputEvent = canUseDOM && "TextEvent" in window && !documentMode, useFallbackCompositionData = canUseDOM && (!canUseCompositionEvent || documentMode && documentMode > 8 && documentMode <= 11), SPACEBAR_CODE = 32, SPACEBAR_CHAR = String.fromCharCode(SPACEBAR_CODE);
      function registerEvents() {
        registerTwoPhaseEvent("onBeforeInput", ["compositionend", "keypress", "textInput", "paste"]), registerTwoPhaseEvent("onCompositionEnd", ["compositionend", "focusout", "keydown", "keypress", "keyup", "mousedown"]), registerTwoPhaseEvent("onCompositionStart", ["compositionstart", "focusout", "keydown", "keypress", "keyup", "mousedown"]), registerTwoPhaseEvent("onCompositionUpdate", ["compositionupdate", "focusout", "keydown", "keypress", "keyup", "mousedown"]);
      }
      var hasSpaceKeypress = !1;
      function isKeypressCommand(nativeEvent) {
        return (nativeEvent.ctrlKey || nativeEvent.altKey || nativeEvent.metaKey) && !(nativeEvent.ctrlKey && nativeEvent.altKey);
      }
      function getCompositionEventType(domEventName) {
        switch (domEventName) {
          case "compositionstart":
            return "onCompositionStart";
          case "compositionend":
            return "onCompositionEnd";
          case "compositionupdate":
            return "onCompositionUpdate";
        }
      }
      function isFallbackCompositionStart(domEventName, nativeEvent) {
        return domEventName === "keydown" && nativeEvent.keyCode === START_KEYCODE;
      }
      function isFallbackCompositionEnd(domEventName, nativeEvent) {
        switch (domEventName) {
          case "keyup":
            return END_KEYCODES.indexOf(nativeEvent.keyCode) !== -1;
          case "keydown":
            return nativeEvent.keyCode !== START_KEYCODE;
          case "keypress":
          case "mousedown":
          case "focusout":
            return !0;
          default:
            return !1;
        }
      }
      function getDataFromCustomEvent(nativeEvent) {
        var detail = nativeEvent.detail;
        return typeof detail == "object" && "data" in detail ? detail.data : null;
      }
      function isUsingKoreanIME(nativeEvent) {
        return nativeEvent.locale === "ko";
      }
      var isComposing = !1;
      function extractCompositionEvent(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget) {
        var eventType, fallbackData;
        if (canUseCompositionEvent ? eventType = getCompositionEventType(domEventName) : isComposing ? isFallbackCompositionEnd(domEventName, nativeEvent) && (eventType = "onCompositionEnd") : isFallbackCompositionStart(domEventName, nativeEvent) && (eventType = "onCompositionStart"), !eventType)
          return null;
        useFallbackCompositionData && !isUsingKoreanIME(nativeEvent) && (!isComposing && eventType === "onCompositionStart" ? isComposing = initialize(nativeEventTarget) : eventType === "onCompositionEnd" && isComposing && (fallbackData = getData()));
        var listeners2 = accumulateTwoPhaseListeners(targetInst, eventType);
        if (listeners2.length > 0) {
          var event = new SyntheticCompositionEvent(eventType, domEventName, null, nativeEvent, nativeEventTarget);
          if (dispatchQueue.push({
            event,
            listeners: listeners2
          }), fallbackData)
            event.data = fallbackData;
          else {
            var customData = getDataFromCustomEvent(nativeEvent);
            customData !== null && (event.data = customData);
          }
        }
      }
      function getNativeBeforeInputChars(domEventName, nativeEvent) {
        switch (domEventName) {
          case "compositionend":
            return getDataFromCustomEvent(nativeEvent);
          case "keypress":
            var which = nativeEvent.which;
            return which !== SPACEBAR_CODE ? null : (hasSpaceKeypress = !0, SPACEBAR_CHAR);
          case "textInput":
            var chars = nativeEvent.data;
            return chars === SPACEBAR_CHAR && hasSpaceKeypress ? null : chars;
          default:
            return null;
        }
      }
      function getFallbackBeforeInputChars(domEventName, nativeEvent) {
        if (isComposing) {
          if (domEventName === "compositionend" || !canUseCompositionEvent && isFallbackCompositionEnd(domEventName, nativeEvent)) {
            var chars = getData();
            return reset(), isComposing = !1, chars;
          }
          return null;
        }
        switch (domEventName) {
          case "paste":
            return null;
          case "keypress":
            if (!isKeypressCommand(nativeEvent)) {
              if (nativeEvent.char && nativeEvent.char.length > 1)
                return nativeEvent.char;
              if (nativeEvent.which)
                return String.fromCharCode(nativeEvent.which);
            }
            return null;
          case "compositionend":
            return useFallbackCompositionData && !isUsingKoreanIME(nativeEvent) ? null : nativeEvent.data;
          default:
            return null;
        }
      }
      function extractBeforeInputEvent(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget) {
        var chars;
        if (canUseTextInputEvent ? chars = getNativeBeforeInputChars(domEventName, nativeEvent) : chars = getFallbackBeforeInputChars(domEventName, nativeEvent), !chars)
          return null;
        var listeners2 = accumulateTwoPhaseListeners(targetInst, "onBeforeInput");
        if (listeners2.length > 0) {
          var event = new SyntheticInputEvent("onBeforeInput", "beforeinput", null, nativeEvent, nativeEventTarget);
          dispatchQueue.push({
            event,
            listeners: listeners2
          }), event.data = chars;
        }
      }
      function extractEvents(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget, eventSystemFlags, targetContainer) {
        extractCompositionEvent(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget), extractBeforeInputEvent(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget);
      }
      var supportedInputTypes = {
        color: !0,
        date: !0,
        datetime: !0,
        "datetime-local": !0,
        email: !0,
        month: !0,
        number: !0,
        password: !0,
        range: !0,
        search: !0,
        tel: !0,
        text: !0,
        time: !0,
        url: !0,
        week: !0
      };
      function isTextInputElement(elem) {
        var nodeName = elem && elem.nodeName && elem.nodeName.toLowerCase();
        return nodeName === "input" ? !!supportedInputTypes[elem.type] : nodeName === "textarea";
      }
      function isEventSupported(eventNameSuffix) {
        if (!canUseDOM)
          return !1;
        var eventName = "on" + eventNameSuffix, isSupported = eventName in document;
        if (!isSupported) {
          var element = document.createElement("div");
          element.setAttribute(eventName, "return;"), isSupported = typeof element[eventName] == "function";
        }
        return isSupported;
      }
      function registerEvents$1() {
        registerTwoPhaseEvent("onChange", ["change", "click", "focusin", "focusout", "input", "keydown", "keyup", "selectionchange"]);
      }
      function createAndAccumulateChangeEvent(dispatchQueue, inst, nativeEvent, target) {
        enqueueStateRestore(target);
        var listeners2 = accumulateTwoPhaseListeners(inst, "onChange");
        if (listeners2.length > 0) {
          var event = new SyntheticEvent("onChange", "change", null, nativeEvent, target);
          dispatchQueue.push({
            event,
            listeners: listeners2
          });
        }
      }
      var activeElement = null, activeElementInst = null;
      function shouldUseChangeEvent(elem) {
        var nodeName = elem.nodeName && elem.nodeName.toLowerCase();
        return nodeName === "select" || nodeName === "input" && elem.type === "file";
      }
      function manualDispatchChangeEvent(nativeEvent) {
        var dispatchQueue = [];
        createAndAccumulateChangeEvent(dispatchQueue, activeElementInst, nativeEvent, getEventTarget(nativeEvent)), batchedUpdates(runEventInBatch, dispatchQueue);
      }
      function runEventInBatch(dispatchQueue) {
        processDispatchQueue(dispatchQueue, 0);
      }
      function getInstIfValueChanged(targetInst) {
        var targetNode = getNodeFromInstance(targetInst);
        if (updateValueIfChanged(targetNode))
          return targetInst;
      }
      function getTargetInstForChangeEvent(domEventName, targetInst) {
        if (domEventName === "change")
          return targetInst;
      }
      var isInputEventSupported = !1;
      canUseDOM && (isInputEventSupported = isEventSupported("input") && (!document.documentMode || document.documentMode > 9));
      function startWatchingForValueChange(target, targetInst) {
        activeElement = target, activeElementInst = targetInst, activeElement.attachEvent("onpropertychange", handlePropertyChange);
      }
      function stopWatchingForValueChange() {
        !activeElement || (activeElement.detachEvent("onpropertychange", handlePropertyChange), activeElement = null, activeElementInst = null);
      }
      function handlePropertyChange(nativeEvent) {
        nativeEvent.propertyName === "value" && getInstIfValueChanged(activeElementInst) && manualDispatchChangeEvent(nativeEvent);
      }
      function handleEventsForInputEventPolyfill(domEventName, target, targetInst) {
        domEventName === "focusin" ? (stopWatchingForValueChange(), startWatchingForValueChange(target, targetInst)) : domEventName === "focusout" && stopWatchingForValueChange();
      }
      function getTargetInstForInputEventPolyfill(domEventName, targetInst) {
        if (domEventName === "selectionchange" || domEventName === "keyup" || domEventName === "keydown")
          return getInstIfValueChanged(activeElementInst);
      }
      function shouldUseClickEvent(elem) {
        var nodeName = elem.nodeName;
        return nodeName && nodeName.toLowerCase() === "input" && (elem.type === "checkbox" || elem.type === "radio");
      }
      function getTargetInstForClickEvent(domEventName, targetInst) {
        if (domEventName === "click")
          return getInstIfValueChanged(targetInst);
      }
      function getTargetInstForInputOrChangeEvent(domEventName, targetInst) {
        if (domEventName === "input" || domEventName === "change")
          return getInstIfValueChanged(targetInst);
      }
      function handleControlledInputBlur(node) {
        var state = node._wrapperState;
        !state || !state.controlled || node.type !== "number" || setDefaultValue(node, "number", node.value);
      }
      function extractEvents$1(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget, eventSystemFlags, targetContainer) {
        var targetNode = targetInst ? getNodeFromInstance(targetInst) : window, getTargetInstFunc, handleEventFunc;
        if (shouldUseChangeEvent(targetNode) ? getTargetInstFunc = getTargetInstForChangeEvent : isTextInputElement(targetNode) ? isInputEventSupported ? getTargetInstFunc = getTargetInstForInputOrChangeEvent : (getTargetInstFunc = getTargetInstForInputEventPolyfill, handleEventFunc = handleEventsForInputEventPolyfill) : shouldUseClickEvent(targetNode) && (getTargetInstFunc = getTargetInstForClickEvent), getTargetInstFunc) {
          var inst = getTargetInstFunc(domEventName, targetInst);
          if (inst) {
            createAndAccumulateChangeEvent(dispatchQueue, inst, nativeEvent, nativeEventTarget);
            return;
          }
        }
        handleEventFunc && handleEventFunc(domEventName, targetNode, targetInst), domEventName === "focusout" && handleControlledInputBlur(targetNode);
      }
      function registerEvents$2() {
        registerDirectEvent("onMouseEnter", ["mouseout", "mouseover"]), registerDirectEvent("onMouseLeave", ["mouseout", "mouseover"]), registerDirectEvent("onPointerEnter", ["pointerout", "pointerover"]), registerDirectEvent("onPointerLeave", ["pointerout", "pointerover"]);
      }
      function extractEvents$2(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget, eventSystemFlags, targetContainer) {
        var isOverEvent = domEventName === "mouseover" || domEventName === "pointerover", isOutEvent = domEventName === "mouseout" || domEventName === "pointerout";
        if (isOverEvent && (eventSystemFlags & IS_REPLAYED) === 0) {
          var related = nativeEvent.relatedTarget || nativeEvent.fromElement;
          if (related && (getClosestInstanceFromNode(related) || isContainerMarkedAsRoot(related)))
            return;
        }
        if (!(!isOutEvent && !isOverEvent)) {
          var win;
          if (nativeEventTarget.window === nativeEventTarget)
            win = nativeEventTarget;
          else {
            var doc = nativeEventTarget.ownerDocument;
            doc ? win = doc.defaultView || doc.parentWindow : win = window;
          }
          var from2, to;
          if (isOutEvent) {
            var _related = nativeEvent.relatedTarget || nativeEvent.toElement;
            if (from2 = targetInst, to = _related ? getClosestInstanceFromNode(_related) : null, to !== null) {
              var nearestMounted = getNearestMountedFiber(to);
              (to !== nearestMounted || to.tag !== HostComponent && to.tag !== HostText) && (to = null);
            }
          } else
            from2 = null, to = targetInst;
          if (from2 !== to) {
            var SyntheticEventCtor = SyntheticMouseEvent, leaveEventType = "onMouseLeave", enterEventType = "onMouseEnter", eventTypePrefix = "mouse";
            (domEventName === "pointerout" || domEventName === "pointerover") && (SyntheticEventCtor = SyntheticPointerEvent, leaveEventType = "onPointerLeave", enterEventType = "onPointerEnter", eventTypePrefix = "pointer");
            var fromNode = from2 == null ? win : getNodeFromInstance(from2), toNode = to == null ? win : getNodeFromInstance(to), leave = new SyntheticEventCtor(leaveEventType, eventTypePrefix + "leave", from2, nativeEvent, nativeEventTarget);
            leave.target = fromNode, leave.relatedTarget = toNode;
            var enter = null, nativeTargetInst = getClosestInstanceFromNode(nativeEventTarget);
            if (nativeTargetInst === targetInst) {
              var enterEvent = new SyntheticEventCtor(enterEventType, eventTypePrefix + "enter", to, nativeEvent, nativeEventTarget);
              enterEvent.target = toNode, enterEvent.relatedTarget = fromNode, enter = enterEvent;
            }
            accumulateEnterLeaveTwoPhaseListeners(dispatchQueue, leave, enter, from2, to);
          }
        }
      }
      function is(x, y) {
        return x === y && (x !== 0 || 1 / x === 1 / y) || x !== x && y !== y;
      }
      var objectIs = typeof Object.is == "function" ? Object.is : is, hasOwnProperty$2 = Object.prototype.hasOwnProperty;
      function shallowEqual(objA, objB) {
        if (objectIs(objA, objB))
          return !0;
        if (typeof objA != "object" || objA === null || typeof objB != "object" || objB === null)
          return !1;
        var keysA = Object.keys(objA), keysB = Object.keys(objB);
        if (keysA.length !== keysB.length)
          return !1;
        for (var i = 0; i < keysA.length; i++)
          if (!hasOwnProperty$2.call(objB, keysA[i]) || !objectIs(objA[keysA[i]], objB[keysA[i]]))
            return !1;
        return !0;
      }
      function getLeafNode(node) {
        for (; node && node.firstChild; )
          node = node.firstChild;
        return node;
      }
      function getSiblingNode(node) {
        for (; node; ) {
          if (node.nextSibling)
            return node.nextSibling;
          node = node.parentNode;
        }
      }
      function getNodeForCharacterOffset(root2, offset) {
        for (var node = getLeafNode(root2), nodeStart = 0, nodeEnd = 0; node; ) {
          if (node.nodeType === TEXT_NODE) {
            if (nodeEnd = nodeStart + node.textContent.length, nodeStart <= offset && nodeEnd >= offset)
              return {
                node,
                offset: offset - nodeStart
              };
            nodeStart = nodeEnd;
          }
          node = getLeafNode(getSiblingNode(node));
        }
      }
      function getOffsets(outerNode) {
        var ownerDocument2 = outerNode.ownerDocument, win = ownerDocument2 && ownerDocument2.defaultView || window, selection = win.getSelection && win.getSelection();
        if (!selection || selection.rangeCount === 0)
          return null;
        var anchorNode = selection.anchorNode, anchorOffset = selection.anchorOffset, focusNode = selection.focusNode, focusOffset = selection.focusOffset;
        try {
          anchorNode.nodeType, focusNode.nodeType;
        } catch {
          return null;
        }
        return getModernOffsetsFromPoints(outerNode, anchorNode, anchorOffset, focusNode, focusOffset);
      }
      function getModernOffsetsFromPoints(outerNode, anchorNode, anchorOffset, focusNode, focusOffset) {
        var length = 0, start = -1, end = -1, indexWithinAnchor = 0, indexWithinFocus = 0, node = outerNode, parentNode = null;
        outer:
          for (; ; ) {
            for (var next = null; node === anchorNode && (anchorOffset === 0 || node.nodeType === TEXT_NODE) && (start = length + anchorOffset), node === focusNode && (focusOffset === 0 || node.nodeType === TEXT_NODE) && (end = length + focusOffset), node.nodeType === TEXT_NODE && (length += node.nodeValue.length), (next = node.firstChild) !== null; )
              parentNode = node, node = next;
            for (; ; ) {
              if (node === outerNode)
                break outer;
              if (parentNode === anchorNode && ++indexWithinAnchor === anchorOffset && (start = length), parentNode === focusNode && ++indexWithinFocus === focusOffset && (end = length), (next = node.nextSibling) !== null)
                break;
              node = parentNode, parentNode = node.parentNode;
            }
            node = next;
          }
        return start === -1 || end === -1 ? null : {
          start,
          end
        };
      }
      function setOffsets(node, offsets) {
        var doc = node.ownerDocument || document, win = doc && doc.defaultView || window;
        if (!!win.getSelection) {
          var selection = win.getSelection(), length = node.textContent.length, start = Math.min(offsets.start, length), end = offsets.end === void 0 ? start : Math.min(offsets.end, length);
          if (!selection.extend && start > end) {
            var temp = end;
            end = start, start = temp;
          }
          var startMarker = getNodeForCharacterOffset(node, start), endMarker = getNodeForCharacterOffset(node, end);
          if (startMarker && endMarker) {
            if (selection.rangeCount === 1 && selection.anchorNode === startMarker.node && selection.anchorOffset === startMarker.offset && selection.focusNode === endMarker.node && selection.focusOffset === endMarker.offset)
              return;
            var range = doc.createRange();
            range.setStart(startMarker.node, startMarker.offset), selection.removeAllRanges(), start > end ? (selection.addRange(range), selection.extend(endMarker.node, endMarker.offset)) : (range.setEnd(endMarker.node, endMarker.offset), selection.addRange(range));
          }
        }
      }
      function isTextNode(node) {
        return node && node.nodeType === TEXT_NODE;
      }
      function containsNode(outerNode, innerNode) {
        return !outerNode || !innerNode ? !1 : outerNode === innerNode ? !0 : isTextNode(outerNode) ? !1 : isTextNode(innerNode) ? containsNode(outerNode, innerNode.parentNode) : "contains" in outerNode ? outerNode.contains(innerNode) : outerNode.compareDocumentPosition ? !!(outerNode.compareDocumentPosition(innerNode) & 16) : !1;
      }
      function isInDocument(node) {
        return node && node.ownerDocument && containsNode(node.ownerDocument.documentElement, node);
      }
      function isSameOriginFrame(iframe) {
        try {
          return typeof iframe.contentWindow.location.href == "string";
        } catch {
          return !1;
        }
      }
      function getActiveElementDeep() {
        for (var win = window, element = getActiveElement(); element instanceof win.HTMLIFrameElement; ) {
          if (isSameOriginFrame(element))
            win = element.contentWindow;
          else
            return element;
          element = getActiveElement(win.document);
        }
        return element;
      }
      function hasSelectionCapabilities(elem) {
        var nodeName = elem && elem.nodeName && elem.nodeName.toLowerCase();
        return nodeName && (nodeName === "input" && (elem.type === "text" || elem.type === "search" || elem.type === "tel" || elem.type === "url" || elem.type === "password") || nodeName === "textarea" || elem.contentEditable === "true");
      }
      function getSelectionInformation() {
        var focusedElem = getActiveElementDeep();
        return {
          focusedElem,
          selectionRange: hasSelectionCapabilities(focusedElem) ? getSelection2(focusedElem) : null
        };
      }
      function restoreSelection(priorSelectionInformation) {
        var curFocusedElem = getActiveElementDeep(), priorFocusedElem = priorSelectionInformation.focusedElem, priorSelectionRange = priorSelectionInformation.selectionRange;
        if (curFocusedElem !== priorFocusedElem && isInDocument(priorFocusedElem)) {
          priorSelectionRange !== null && hasSelectionCapabilities(priorFocusedElem) && setSelection(priorFocusedElem, priorSelectionRange);
          for (var ancestors = [], ancestor = priorFocusedElem; ancestor = ancestor.parentNode; )
            ancestor.nodeType === ELEMENT_NODE && ancestors.push({
              element: ancestor,
              left: ancestor.scrollLeft,
              top: ancestor.scrollTop
            });
          typeof priorFocusedElem.focus == "function" && priorFocusedElem.focus();
          for (var i = 0; i < ancestors.length; i++) {
            var info = ancestors[i];
            info.element.scrollLeft = info.left, info.element.scrollTop = info.top;
          }
        }
      }
      function getSelection2(input) {
        var selection;
        return "selectionStart" in input ? selection = {
          start: input.selectionStart,
          end: input.selectionEnd
        } : selection = getOffsets(input), selection || {
          start: 0,
          end: 0
        };
      }
      function setSelection(input, offsets) {
        var start = offsets.start, end = offsets.end;
        end === void 0 && (end = start), "selectionStart" in input ? (input.selectionStart = start, input.selectionEnd = Math.min(end, input.value.length)) : setOffsets(input, offsets);
      }
      var skipSelectionChangeEvent = canUseDOM && "documentMode" in document && document.documentMode <= 11;
      function registerEvents$3() {
        registerTwoPhaseEvent("onSelect", ["focusout", "contextmenu", "dragend", "focusin", "keydown", "keyup", "mousedown", "mouseup", "selectionchange"]);
      }
      var activeElement$1 = null, activeElementInst$1 = null, lastSelection = null, mouseDown = !1;
      function getSelection$1(node) {
        if ("selectionStart" in node && hasSelectionCapabilities(node))
          return {
            start: node.selectionStart,
            end: node.selectionEnd
          };
        var win = node.ownerDocument && node.ownerDocument.defaultView || window, selection = win.getSelection();
        return {
          anchorNode: selection.anchorNode,
          anchorOffset: selection.anchorOffset,
          focusNode: selection.focusNode,
          focusOffset: selection.focusOffset
        };
      }
      function getEventTargetDocument(eventTarget) {
        return eventTarget.window === eventTarget ? eventTarget.document : eventTarget.nodeType === DOCUMENT_NODE ? eventTarget : eventTarget.ownerDocument;
      }
      function constructSelectEvent(dispatchQueue, nativeEvent, nativeEventTarget) {
        var doc = getEventTargetDocument(nativeEventTarget);
        if (!(mouseDown || activeElement$1 == null || activeElement$1 !== getActiveElement(doc))) {
          var currentSelection = getSelection$1(activeElement$1);
          if (!lastSelection || !shallowEqual(lastSelection, currentSelection)) {
            lastSelection = currentSelection;
            var listeners2 = accumulateTwoPhaseListeners(activeElementInst$1, "onSelect");
            if (listeners2.length > 0) {
              var event = new SyntheticEvent("onSelect", "select", null, nativeEvent, nativeEventTarget);
              dispatchQueue.push({
                event,
                listeners: listeners2
              }), event.target = activeElement$1;
            }
          }
        }
      }
      function extractEvents$3(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget, eventSystemFlags, targetContainer) {
        var targetNode = targetInst ? getNodeFromInstance(targetInst) : window;
        switch (domEventName) {
          case "focusin":
            (isTextInputElement(targetNode) || targetNode.contentEditable === "true") && (activeElement$1 = targetNode, activeElementInst$1 = targetInst, lastSelection = null);
            break;
          case "focusout":
            activeElement$1 = null, activeElementInst$1 = null, lastSelection = null;
            break;
          case "mousedown":
            mouseDown = !0;
            break;
          case "contextmenu":
          case "mouseup":
          case "dragend":
            mouseDown = !1, constructSelectEvent(dispatchQueue, nativeEvent, nativeEventTarget);
            break;
          case "selectionchange":
            if (skipSelectionChangeEvent)
              break;
          case "keydown":
          case "keyup":
            constructSelectEvent(dispatchQueue, nativeEvent, nativeEventTarget);
        }
      }
      function extractEvents$4(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget, eventSystemFlags, targetContainer) {
        var reactName = topLevelEventsToReactNames.get(domEventName);
        if (reactName !== void 0) {
          var SyntheticEventCtor = SyntheticEvent, reactEventType = domEventName;
          switch (domEventName) {
            case "keypress":
              if (getEventCharCode(nativeEvent) === 0)
                return;
            case "keydown":
            case "keyup":
              SyntheticEventCtor = SyntheticKeyboardEvent;
              break;
            case "focusin":
              reactEventType = "focus", SyntheticEventCtor = SyntheticFocusEvent;
              break;
            case "focusout":
              reactEventType = "blur", SyntheticEventCtor = SyntheticFocusEvent;
              break;
            case "beforeblur":
            case "afterblur":
              SyntheticEventCtor = SyntheticFocusEvent;
              break;
            case "click":
              if (nativeEvent.button === 2)
                return;
            case "auxclick":
            case "dblclick":
            case "mousedown":
            case "mousemove":
            case "mouseup":
            case "mouseout":
            case "mouseover":
            case "contextmenu":
              SyntheticEventCtor = SyntheticMouseEvent;
              break;
            case "drag":
            case "dragend":
            case "dragenter":
            case "dragexit":
            case "dragleave":
            case "dragover":
            case "dragstart":
            case "drop":
              SyntheticEventCtor = SyntheticDragEvent;
              break;
            case "touchcancel":
            case "touchend":
            case "touchmove":
            case "touchstart":
              SyntheticEventCtor = SyntheticTouchEvent;
              break;
            case ANIMATION_END:
            case ANIMATION_ITERATION:
            case ANIMATION_START:
              SyntheticEventCtor = SyntheticAnimationEvent;
              break;
            case TRANSITION_END:
              SyntheticEventCtor = SyntheticTransitionEvent;
              break;
            case "scroll":
              SyntheticEventCtor = SyntheticUIEvent;
              break;
            case "wheel":
              SyntheticEventCtor = SyntheticWheelEvent;
              break;
            case "copy":
            case "cut":
            case "paste":
              SyntheticEventCtor = SyntheticClipboardEvent;
              break;
            case "gotpointercapture":
            case "lostpointercapture":
            case "pointercancel":
            case "pointerdown":
            case "pointermove":
            case "pointerout":
            case "pointerover":
            case "pointerup":
              SyntheticEventCtor = SyntheticPointerEvent;
              break;
          }
          var inCapturePhase = (eventSystemFlags & IS_CAPTURE_PHASE) !== 0;
          {
            var accumulateTargetOnly = !inCapturePhase && domEventName === "scroll", _listeners = accumulateSinglePhaseListeners(targetInst, reactName, nativeEvent.type, inCapturePhase, accumulateTargetOnly);
            if (_listeners.length > 0) {
              var _event = new SyntheticEventCtor(reactName, reactEventType, null, nativeEvent, nativeEventTarget);
              dispatchQueue.push({
                event: _event,
                listeners: _listeners
              });
            }
          }
        }
      }
      registerSimpleEvents(), registerEvents$2(), registerEvents$1(), registerEvents$3(), registerEvents();
      function extractEvents$5(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget, eventSystemFlags, targetContainer) {
        extractEvents$4(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget, eventSystemFlags);
        var shouldProcessPolyfillPlugins = (eventSystemFlags & SHOULD_NOT_PROCESS_POLYFILL_EVENT_PLUGINS) === 0;
        shouldProcessPolyfillPlugins && (extractEvents$2(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget, eventSystemFlags), extractEvents$1(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget), extractEvents$3(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget), extractEvents(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget));
      }
      var mediaEventTypes = ["abort", "canplay", "canplaythrough", "durationchange", "emptied", "encrypted", "ended", "error", "loadeddata", "loadedmetadata", "loadstart", "pause", "play", "playing", "progress", "ratechange", "seeked", "seeking", "stalled", "suspend", "timeupdate", "volumechange", "waiting"], nonDelegatedEvents = new Set(["cancel", "close", "invalid", "load", "scroll", "toggle"].concat(mediaEventTypes));
      function executeDispatch(event, listener, currentTarget) {
        var type = event.type || "unknown-event";
        event.currentTarget = currentTarget, invokeGuardedCallbackAndCatchFirstError(type, listener, void 0, event), event.currentTarget = null;
      }
      function processDispatchQueueItemsInOrder(event, dispatchListeners, inCapturePhase) {
        var previousInstance;
        if (inCapturePhase)
          for (var i = dispatchListeners.length - 1; i >= 0; i--) {
            var _dispatchListeners$i = dispatchListeners[i], instance = _dispatchListeners$i.instance, currentTarget = _dispatchListeners$i.currentTarget, listener = _dispatchListeners$i.listener;
            if (instance !== previousInstance && event.isPropagationStopped())
              return;
            executeDispatch(event, listener, currentTarget), previousInstance = instance;
          }
        else
          for (var _i = 0; _i < dispatchListeners.length; _i++) {
            var _dispatchListeners$_i = dispatchListeners[_i], _instance = _dispatchListeners$_i.instance, _currentTarget = _dispatchListeners$_i.currentTarget, _listener = _dispatchListeners$_i.listener;
            if (_instance !== previousInstance && event.isPropagationStopped())
              return;
            executeDispatch(event, _listener, _currentTarget), previousInstance = _instance;
          }
      }
      function processDispatchQueue(dispatchQueue, eventSystemFlags) {
        for (var inCapturePhase = (eventSystemFlags & IS_CAPTURE_PHASE) !== 0, i = 0; i < dispatchQueue.length; i++) {
          var _dispatchQueue$i = dispatchQueue[i], event = _dispatchQueue$i.event, listeners2 = _dispatchQueue$i.listeners;
          processDispatchQueueItemsInOrder(event, listeners2, inCapturePhase);
        }
        rethrowCaughtError();
      }
      function dispatchEventsForPlugins(domEventName, eventSystemFlags, nativeEvent, targetInst, targetContainer) {
        var nativeEventTarget = getEventTarget(nativeEvent), dispatchQueue = [];
        extractEvents$5(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget, eventSystemFlags), processDispatchQueue(dispatchQueue, eventSystemFlags);
      }
      function listenToNonDelegatedEvent(domEventName, targetElement) {
        var isCapturePhaseListener = !1, listenerSet = getEventListenerSet(targetElement), listenerSetKey = getListenerSetKey(domEventName, isCapturePhaseListener);
        listenerSet.has(listenerSetKey) || (addTrappedEventListener(targetElement, domEventName, IS_NON_DELEGATED, isCapturePhaseListener), listenerSet.add(listenerSetKey));
      }
      var listeningMarker = "_reactListening" + Math.random().toString(36).slice(2);
      function listenToAllSupportedEvents(rootContainerElement) {
        {
          if (rootContainerElement[listeningMarker])
            return;
          rootContainerElement[listeningMarker] = !0, allNativeEvents.forEach(function(domEventName) {
            nonDelegatedEvents.has(domEventName) || listenToNativeEvent(domEventName, !1, rootContainerElement, null), listenToNativeEvent(domEventName, !0, rootContainerElement, null);
          });
        }
      }
      function listenToNativeEvent(domEventName, isCapturePhaseListener, rootContainerElement, targetElement) {
        var eventSystemFlags = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : 0, target = rootContainerElement;
        if (domEventName === "selectionchange" && rootContainerElement.nodeType !== DOCUMENT_NODE && (target = rootContainerElement.ownerDocument), targetElement !== null && !isCapturePhaseListener && nonDelegatedEvents.has(domEventName)) {
          if (domEventName !== "scroll")
            return;
          eventSystemFlags |= IS_NON_DELEGATED, target = targetElement;
        }
        var listenerSet = getEventListenerSet(target), listenerSetKey = getListenerSetKey(domEventName, isCapturePhaseListener);
        listenerSet.has(listenerSetKey) || (isCapturePhaseListener && (eventSystemFlags |= IS_CAPTURE_PHASE), addTrappedEventListener(target, domEventName, eventSystemFlags, isCapturePhaseListener), listenerSet.add(listenerSetKey));
      }
      function addTrappedEventListener(targetContainer, domEventName, eventSystemFlags, isCapturePhaseListener, isDeferredListenerForLegacyFBSupport) {
        var listener = createEventListenerWrapperWithPriority(targetContainer, domEventName, eventSystemFlags), isPassiveListener = void 0;
        passiveBrowserEventsSupported && (domEventName === "touchstart" || domEventName === "touchmove" || domEventName === "wheel") && (isPassiveListener = !0), targetContainer = targetContainer;
        var unsubscribeListener;
        isCapturePhaseListener ? isPassiveListener !== void 0 ? unsubscribeListener = addEventCaptureListenerWithPassiveFlag(targetContainer, domEventName, listener, isPassiveListener) : unsubscribeListener = addEventCaptureListener(targetContainer, domEventName, listener) : isPassiveListener !== void 0 ? unsubscribeListener = addEventBubbleListenerWithPassiveFlag(targetContainer, domEventName, listener, isPassiveListener) : unsubscribeListener = addEventBubbleListener(targetContainer, domEventName, listener);
      }
      function isMatchingRootContainer(grandContainer, targetContainer) {
        return grandContainer === targetContainer || grandContainer.nodeType === COMMENT_NODE && grandContainer.parentNode === targetContainer;
      }
      function dispatchEventForPluginEventSystem(domEventName, eventSystemFlags, nativeEvent, targetInst, targetContainer) {
        var ancestorInst = targetInst;
        if ((eventSystemFlags & IS_EVENT_HANDLE_NON_MANAGED_NODE) === 0 && (eventSystemFlags & IS_NON_DELEGATED) === 0) {
          var targetContainerNode = targetContainer;
          if (targetInst !== null) {
            var node = targetInst;
            mainLoop:
              for (; ; ) {
                if (node === null)
                  return;
                var nodeTag = node.tag;
                if (nodeTag === HostRoot || nodeTag === HostPortal) {
                  var container = node.stateNode.containerInfo;
                  if (isMatchingRootContainer(container, targetContainerNode))
                    break;
                  if (nodeTag === HostPortal)
                    for (var grandNode = node.return; grandNode !== null; ) {
                      var grandTag = grandNode.tag;
                      if (grandTag === HostRoot || grandTag === HostPortal) {
                        var grandContainer = grandNode.stateNode.containerInfo;
                        if (isMatchingRootContainer(grandContainer, targetContainerNode))
                          return;
                      }
                      grandNode = grandNode.return;
                    }
                  for (; container !== null; ) {
                    var parentNode = getClosestInstanceFromNode(container);
                    if (parentNode === null)
                      return;
                    var parentTag = parentNode.tag;
                    if (parentTag === HostComponent || parentTag === HostText) {
                      node = ancestorInst = parentNode;
                      continue mainLoop;
                    }
                    container = container.parentNode;
                  }
                }
                node = node.return;
              }
          }
        }
        batchedEventUpdates(function() {
          return dispatchEventsForPlugins(domEventName, eventSystemFlags, nativeEvent, ancestorInst);
        });
      }
      function createDispatchListener(instance, listener, currentTarget) {
        return {
          instance,
          listener,
          currentTarget
        };
      }
      function accumulateSinglePhaseListeners(targetFiber, reactName, nativeEventType, inCapturePhase, accumulateTargetOnly) {
        for (var captureName = reactName !== null ? reactName + "Capture" : null, reactEventName = inCapturePhase ? captureName : reactName, listeners2 = [], instance = targetFiber, lastHostComponent = null; instance !== null; ) {
          var _instance2 = instance, stateNode = _instance2.stateNode, tag = _instance2.tag;
          if (tag === HostComponent && stateNode !== null && (lastHostComponent = stateNode, reactEventName !== null)) {
            var listener = getListener(instance, reactEventName);
            listener != null && listeners2.push(createDispatchListener(instance, listener, lastHostComponent));
          }
          if (accumulateTargetOnly)
            break;
          instance = instance.return;
        }
        return listeners2;
      }
      function accumulateTwoPhaseListeners(targetFiber, reactName) {
        for (var captureName = reactName + "Capture", listeners2 = [], instance = targetFiber; instance !== null; ) {
          var _instance3 = instance, stateNode = _instance3.stateNode, tag = _instance3.tag;
          if (tag === HostComponent && stateNode !== null) {
            var currentTarget = stateNode, captureListener = getListener(instance, captureName);
            captureListener != null && listeners2.unshift(createDispatchListener(instance, captureListener, currentTarget));
            var bubbleListener = getListener(instance, reactName);
            bubbleListener != null && listeners2.push(createDispatchListener(instance, bubbleListener, currentTarget));
          }
          instance = instance.return;
        }
        return listeners2;
      }
      function getParent(inst) {
        if (inst === null)
          return null;
        do
          inst = inst.return;
        while (inst && inst.tag !== HostComponent);
        return inst || null;
      }
      function getLowestCommonAncestor(instA, instB) {
        for (var nodeA = instA, nodeB = instB, depthA = 0, tempA = nodeA; tempA; tempA = getParent(tempA))
          depthA++;
        for (var depthB = 0, tempB = nodeB; tempB; tempB = getParent(tempB))
          depthB++;
        for (; depthA - depthB > 0; )
          nodeA = getParent(nodeA), depthA--;
        for (; depthB - depthA > 0; )
          nodeB = getParent(nodeB), depthB--;
        for (var depth = depthA; depth--; ) {
          if (nodeA === nodeB || nodeB !== null && nodeA === nodeB.alternate)
            return nodeA;
          nodeA = getParent(nodeA), nodeB = getParent(nodeB);
        }
        return null;
      }
      function accumulateEnterLeaveListenersForEvent(dispatchQueue, event, target, common2, inCapturePhase) {
        for (var registrationName = event._reactName, listeners2 = [], instance = target; instance !== null && instance !== common2; ) {
          var _instance4 = instance, alternate = _instance4.alternate, stateNode = _instance4.stateNode, tag = _instance4.tag;
          if (alternate !== null && alternate === common2)
            break;
          if (tag === HostComponent && stateNode !== null) {
            var currentTarget = stateNode;
            if (inCapturePhase) {
              var captureListener = getListener(instance, registrationName);
              captureListener != null && listeners2.unshift(createDispatchListener(instance, captureListener, currentTarget));
            } else if (!inCapturePhase) {
              var bubbleListener = getListener(instance, registrationName);
              bubbleListener != null && listeners2.push(createDispatchListener(instance, bubbleListener, currentTarget));
            }
          }
          instance = instance.return;
        }
        listeners2.length !== 0 && dispatchQueue.push({
          event,
          listeners: listeners2
        });
      }
      function accumulateEnterLeaveTwoPhaseListeners(dispatchQueue, leaveEvent, enterEvent, from2, to) {
        var common2 = from2 && to ? getLowestCommonAncestor(from2, to) : null;
        from2 !== null && accumulateEnterLeaveListenersForEvent(dispatchQueue, leaveEvent, from2, common2, !1), to !== null && enterEvent !== null && accumulateEnterLeaveListenersForEvent(dispatchQueue, enterEvent, to, common2, !0);
      }
      function getListenerSetKey(domEventName, capture) {
        return domEventName + "__" + (capture ? "capture" : "bubble");
      }
      var didWarnInvalidHydration = !1, DANGEROUSLY_SET_INNER_HTML = "dangerouslySetInnerHTML", SUPPRESS_CONTENT_EDITABLE_WARNING = "suppressContentEditableWarning", SUPPRESS_HYDRATION_WARNING = "suppressHydrationWarning", AUTOFOCUS = "autoFocus", CHILDREN = "children", STYLE = "style", HTML$1 = "__html", HTML_NAMESPACE$1 = Namespaces.html, warnedUnknownTags, suppressHydrationWarning, validatePropertiesInDevelopment, warnForTextDifference, warnForPropDifference, warnForExtraAttributes, warnForInvalidEventListener, canDiffStyleForHydrationWarning, normalizeMarkupForTextOrAttribute, normalizeHTML;
      {
        warnedUnknownTags = {
          dialog: !0,
          webview: !0
        }, validatePropertiesInDevelopment = function(type, props) {
          validateProperties(type, props), validateProperties$1(type, props), validateProperties$2(type, props, {
            registrationNameDependencies,
            possibleRegistrationNames
          });
        }, canDiffStyleForHydrationWarning = canUseDOM && !document.documentMode;
        var NORMALIZE_NEWLINES_REGEX = /\r\n?/g, NORMALIZE_NULL_AND_REPLACEMENT_REGEX = /\u0000|\uFFFD/g;
        normalizeMarkupForTextOrAttribute = function(markup) {
          var markupString = typeof markup == "string" ? markup : "" + markup;
          return markupString.replace(NORMALIZE_NEWLINES_REGEX, `
`).replace(NORMALIZE_NULL_AND_REPLACEMENT_REGEX, "");
        }, warnForTextDifference = function(serverText, clientText) {
          if (!didWarnInvalidHydration) {
            var normalizedClientText = normalizeMarkupForTextOrAttribute(clientText), normalizedServerText = normalizeMarkupForTextOrAttribute(serverText);
            normalizedServerText !== normalizedClientText && (didWarnInvalidHydration = !0, error('Text content did not match. Server: "%s" Client: "%s"', normalizedServerText, normalizedClientText));
          }
        }, warnForPropDifference = function(propName, serverValue, clientValue) {
          if (!didWarnInvalidHydration) {
            var normalizedClientValue = normalizeMarkupForTextOrAttribute(clientValue), normalizedServerValue = normalizeMarkupForTextOrAttribute(serverValue);
            normalizedServerValue !== normalizedClientValue && (didWarnInvalidHydration = !0, error("Prop `%s` did not match. Server: %s Client: %s", propName, JSON.stringify(normalizedServerValue), JSON.stringify(normalizedClientValue)));
          }
        }, warnForExtraAttributes = function(attributeNames) {
          if (!didWarnInvalidHydration) {
            didWarnInvalidHydration = !0;
            var names = [];
            attributeNames.forEach(function(name) {
              names.push(name);
            }), error("Extra attributes from the server: %s", names);
          }
        }, warnForInvalidEventListener = function(registrationName, listener) {
          listener === !1 ? error("Expected `%s` listener to be a function, instead got `false`.\n\nIf you used to conditionally omit it with %s={condition && value}, pass %s={condition ? value : undefined} instead.", registrationName, registrationName, registrationName) : error("Expected `%s` listener to be a function, instead got a value of `%s` type.", registrationName, typeof listener);
        }, normalizeHTML = function(parent, html) {
          var testElement = parent.namespaceURI === HTML_NAMESPACE$1 ? parent.ownerDocument.createElement(parent.tagName) : parent.ownerDocument.createElementNS(parent.namespaceURI, parent.tagName);
          return testElement.innerHTML = html, testElement.innerHTML;
        };
      }
      function getOwnerDocumentFromRootContainer(rootContainerElement) {
        return rootContainerElement.nodeType === DOCUMENT_NODE ? rootContainerElement : rootContainerElement.ownerDocument;
      }
      function noop3() {
      }
      function trapClickOnNonInteractiveElement(node) {
        node.onclick = noop3;
      }
      function setInitialDOMProperties(tag, domElement, rootContainerElement, nextProps, isCustomComponentTag) {
        for (var propKey in nextProps)
          if (!!nextProps.hasOwnProperty(propKey)) {
            var nextProp = nextProps[propKey];
            if (propKey === STYLE)
              nextProp && Object.freeze(nextProp), setValueForStyles(domElement, nextProp);
            else if (propKey === DANGEROUSLY_SET_INNER_HTML) {
              var nextHtml = nextProp ? nextProp[HTML$1] : void 0;
              nextHtml != null && setInnerHTML(domElement, nextHtml);
            } else if (propKey === CHILDREN)
              if (typeof nextProp == "string") {
                var canSetTextContent = tag !== "textarea" || nextProp !== "";
                canSetTextContent && setTextContent(domElement, nextProp);
              } else
                typeof nextProp == "number" && setTextContent(domElement, "" + nextProp);
            else
              propKey === SUPPRESS_CONTENT_EDITABLE_WARNING || propKey === SUPPRESS_HYDRATION_WARNING || propKey === AUTOFOCUS || (registrationNameDependencies.hasOwnProperty(propKey) ? nextProp != null && (typeof nextProp != "function" && warnForInvalidEventListener(propKey, nextProp), propKey === "onScroll" && listenToNonDelegatedEvent("scroll", domElement)) : nextProp != null && setValueForProperty(domElement, propKey, nextProp, isCustomComponentTag));
          }
      }
      function updateDOMProperties(domElement, updatePayload, wasCustomComponentTag, isCustomComponentTag) {
        for (var i = 0; i < updatePayload.length; i += 2) {
          var propKey = updatePayload[i], propValue = updatePayload[i + 1];
          propKey === STYLE ? setValueForStyles(domElement, propValue) : propKey === DANGEROUSLY_SET_INNER_HTML ? setInnerHTML(domElement, propValue) : propKey === CHILDREN ? setTextContent(domElement, propValue) : setValueForProperty(domElement, propKey, propValue, isCustomComponentTag);
        }
      }
      function createElement7(type, props, rootContainerElement, parentNamespace) {
        var isCustomComponentTag, ownerDocument2 = getOwnerDocumentFromRootContainer(rootContainerElement), domElement, namespaceURI = parentNamespace;
        if (namespaceURI === HTML_NAMESPACE$1 && (namespaceURI = getIntrinsicNamespace(type)), namespaceURI === HTML_NAMESPACE$1) {
          if (isCustomComponentTag = isCustomComponent(type, props), !isCustomComponentTag && type !== type.toLowerCase() && error("<%s /> is using incorrect casing. Use PascalCase for React components, or lowercase for HTML elements.", type), type === "script") {
            var div = ownerDocument2.createElement("div");
            div.innerHTML = "<script><\/script>";
            var firstChild = div.firstChild;
            domElement = div.removeChild(firstChild);
          } else if (typeof props.is == "string")
            domElement = ownerDocument2.createElement(type, {
              is: props.is
            });
          else if (domElement = ownerDocument2.createElement(type), type === "select") {
            var node = domElement;
            props.multiple ? node.multiple = !0 : props.size && (node.size = props.size);
          }
        } else
          domElement = ownerDocument2.createElementNS(namespaceURI, type);
        return namespaceURI === HTML_NAMESPACE$1 && !isCustomComponentTag && Object.prototype.toString.call(domElement) === "[object HTMLUnknownElement]" && !Object.prototype.hasOwnProperty.call(warnedUnknownTags, type) && (warnedUnknownTags[type] = !0, error("The tag <%s> is unrecognized in this browser. If you meant to render a React component, start its name with an uppercase letter.", type)), domElement;
      }
      function createTextNode(text, rootContainerElement) {
        return getOwnerDocumentFromRootContainer(rootContainerElement).createTextNode(text);
      }
      function setInitialProperties(domElement, tag, rawProps, rootContainerElement) {
        var isCustomComponentTag = isCustomComponent(tag, rawProps);
        validatePropertiesInDevelopment(tag, rawProps);
        var props;
        switch (tag) {
          case "dialog":
            listenToNonDelegatedEvent("cancel", domElement), listenToNonDelegatedEvent("close", domElement), props = rawProps;
            break;
          case "iframe":
          case "object":
          case "embed":
            listenToNonDelegatedEvent("load", domElement), props = rawProps;
            break;
          case "video":
          case "audio":
            for (var i = 0; i < mediaEventTypes.length; i++)
              listenToNonDelegatedEvent(mediaEventTypes[i], domElement);
            props = rawProps;
            break;
          case "source":
            listenToNonDelegatedEvent("error", domElement), props = rawProps;
            break;
          case "img":
          case "image":
          case "link":
            listenToNonDelegatedEvent("error", domElement), listenToNonDelegatedEvent("load", domElement), props = rawProps;
            break;
          case "details":
            listenToNonDelegatedEvent("toggle", domElement), props = rawProps;
            break;
          case "input":
            initWrapperState(domElement, rawProps), props = getHostProps(domElement, rawProps), listenToNonDelegatedEvent("invalid", domElement);
            break;
          case "option":
            validateProps(domElement, rawProps), props = getHostProps$1(domElement, rawProps);
            break;
          case "select":
            initWrapperState$1(domElement, rawProps), props = getHostProps$2(domElement, rawProps), listenToNonDelegatedEvent("invalid", domElement);
            break;
          case "textarea":
            initWrapperState$2(domElement, rawProps), props = getHostProps$3(domElement, rawProps), listenToNonDelegatedEvent("invalid", domElement);
            break;
          default:
            props = rawProps;
        }
        switch (assertValidProps(tag, props), setInitialDOMProperties(tag, domElement, rootContainerElement, props, isCustomComponentTag), tag) {
          case "input":
            track(domElement), postMountWrapper(domElement, rawProps, !1);
            break;
          case "textarea":
            track(domElement), postMountWrapper$3(domElement);
            break;
          case "option":
            postMountWrapper$1(domElement, rawProps);
            break;
          case "select":
            postMountWrapper$2(domElement, rawProps);
            break;
          default:
            typeof props.onClick == "function" && trapClickOnNonInteractiveElement(domElement);
            break;
        }
      }
      function diffProperties(domElement, tag, lastRawProps, nextRawProps, rootContainerElement) {
        validatePropertiesInDevelopment(tag, nextRawProps);
        var updatePayload = null, lastProps, nextProps;
        switch (tag) {
          case "input":
            lastProps = getHostProps(domElement, lastRawProps), nextProps = getHostProps(domElement, nextRawProps), updatePayload = [];
            break;
          case "option":
            lastProps = getHostProps$1(domElement, lastRawProps), nextProps = getHostProps$1(domElement, nextRawProps), updatePayload = [];
            break;
          case "select":
            lastProps = getHostProps$2(domElement, lastRawProps), nextProps = getHostProps$2(domElement, nextRawProps), updatePayload = [];
            break;
          case "textarea":
            lastProps = getHostProps$3(domElement, lastRawProps), nextProps = getHostProps$3(domElement, nextRawProps), updatePayload = [];
            break;
          default:
            lastProps = lastRawProps, nextProps = nextRawProps, typeof lastProps.onClick != "function" && typeof nextProps.onClick == "function" && trapClickOnNonInteractiveElement(domElement);
            break;
        }
        assertValidProps(tag, nextProps);
        var propKey, styleName, styleUpdates = null;
        for (propKey in lastProps)
          if (!(nextProps.hasOwnProperty(propKey) || !lastProps.hasOwnProperty(propKey) || lastProps[propKey] == null))
            if (propKey === STYLE) {
              var lastStyle = lastProps[propKey];
              for (styleName in lastStyle)
                lastStyle.hasOwnProperty(styleName) && (styleUpdates || (styleUpdates = {}), styleUpdates[styleName] = "");
            } else
              propKey === DANGEROUSLY_SET_INNER_HTML || propKey === CHILDREN || propKey === SUPPRESS_CONTENT_EDITABLE_WARNING || propKey === SUPPRESS_HYDRATION_WARNING || propKey === AUTOFOCUS || (registrationNameDependencies.hasOwnProperty(propKey) ? updatePayload || (updatePayload = []) : (updatePayload = updatePayload || []).push(propKey, null));
        for (propKey in nextProps) {
          var nextProp = nextProps[propKey], lastProp = lastProps != null ? lastProps[propKey] : void 0;
          if (!(!nextProps.hasOwnProperty(propKey) || nextProp === lastProp || nextProp == null && lastProp == null))
            if (propKey === STYLE)
              if (nextProp && Object.freeze(nextProp), lastProp) {
                for (styleName in lastProp)
                  lastProp.hasOwnProperty(styleName) && (!nextProp || !nextProp.hasOwnProperty(styleName)) && (styleUpdates || (styleUpdates = {}), styleUpdates[styleName] = "");
                for (styleName in nextProp)
                  nextProp.hasOwnProperty(styleName) && lastProp[styleName] !== nextProp[styleName] && (styleUpdates || (styleUpdates = {}), styleUpdates[styleName] = nextProp[styleName]);
              } else
                styleUpdates || (updatePayload || (updatePayload = []), updatePayload.push(propKey, styleUpdates)), styleUpdates = nextProp;
            else if (propKey === DANGEROUSLY_SET_INNER_HTML) {
              var nextHtml = nextProp ? nextProp[HTML$1] : void 0, lastHtml = lastProp ? lastProp[HTML$1] : void 0;
              nextHtml != null && lastHtml !== nextHtml && (updatePayload = updatePayload || []).push(propKey, nextHtml);
            } else
              propKey === CHILDREN ? (typeof nextProp == "string" || typeof nextProp == "number") && (updatePayload = updatePayload || []).push(propKey, "" + nextProp) : propKey === SUPPRESS_CONTENT_EDITABLE_WARNING || propKey === SUPPRESS_HYDRATION_WARNING || (registrationNameDependencies.hasOwnProperty(propKey) ? (nextProp != null && (typeof nextProp != "function" && warnForInvalidEventListener(propKey, nextProp), propKey === "onScroll" && listenToNonDelegatedEvent("scroll", domElement)), !updatePayload && lastProp !== nextProp && (updatePayload = [])) : typeof nextProp == "object" && nextProp !== null && nextProp.$$typeof === REACT_OPAQUE_ID_TYPE ? nextProp.toString() : (updatePayload = updatePayload || []).push(propKey, nextProp));
        }
        return styleUpdates && (validateShorthandPropertyCollisionInDev(styleUpdates, nextProps[STYLE]), (updatePayload = updatePayload || []).push(STYLE, styleUpdates)), updatePayload;
      }
      function updateProperties(domElement, updatePayload, tag, lastRawProps, nextRawProps) {
        tag === "input" && nextRawProps.type === "radio" && nextRawProps.name != null && updateChecked(domElement, nextRawProps);
        var wasCustomComponentTag = isCustomComponent(tag, lastRawProps), isCustomComponentTag = isCustomComponent(tag, nextRawProps);
        switch (updateDOMProperties(domElement, updatePayload, wasCustomComponentTag, isCustomComponentTag), tag) {
          case "input":
            updateWrapper(domElement, nextRawProps);
            break;
          case "textarea":
            updateWrapper$1(domElement, nextRawProps);
            break;
          case "select":
            postUpdateWrapper(domElement, nextRawProps);
            break;
        }
      }
      function getPossibleStandardName(propName) {
        {
          var lowerCasedName = propName.toLowerCase();
          return possibleStandardNames.hasOwnProperty(lowerCasedName) && possibleStandardNames[lowerCasedName] || null;
        }
      }
      function diffHydratedProperties(domElement, tag, rawProps, parentNamespace, rootContainerElement) {
        var isCustomComponentTag, extraAttributeNames;
        switch (suppressHydrationWarning = rawProps[SUPPRESS_HYDRATION_WARNING] === !0, isCustomComponentTag = isCustomComponent(tag, rawProps), validatePropertiesInDevelopment(tag, rawProps), tag) {
          case "dialog":
            listenToNonDelegatedEvent("cancel", domElement), listenToNonDelegatedEvent("close", domElement);
            break;
          case "iframe":
          case "object":
          case "embed":
            listenToNonDelegatedEvent("load", domElement);
            break;
          case "video":
          case "audio":
            for (var i = 0; i < mediaEventTypes.length; i++)
              listenToNonDelegatedEvent(mediaEventTypes[i], domElement);
            break;
          case "source":
            listenToNonDelegatedEvent("error", domElement);
            break;
          case "img":
          case "image":
          case "link":
            listenToNonDelegatedEvent("error", domElement), listenToNonDelegatedEvent("load", domElement);
            break;
          case "details":
            listenToNonDelegatedEvent("toggle", domElement);
            break;
          case "input":
            initWrapperState(domElement, rawProps), listenToNonDelegatedEvent("invalid", domElement);
            break;
          case "option":
            validateProps(domElement, rawProps);
            break;
          case "select":
            initWrapperState$1(domElement, rawProps), listenToNonDelegatedEvent("invalid", domElement);
            break;
          case "textarea":
            initWrapperState$2(domElement, rawProps), listenToNonDelegatedEvent("invalid", domElement);
            break;
        }
        assertValidProps(tag, rawProps);
        {
          extraAttributeNames = /* @__PURE__ */ new Set();
          for (var attributes = domElement.attributes, _i = 0; _i < attributes.length; _i++) {
            var name = attributes[_i].name.toLowerCase();
            switch (name) {
              case "data-reactroot":
                break;
              case "value":
                break;
              case "checked":
                break;
              case "selected":
                break;
              default:
                extraAttributeNames.add(attributes[_i].name);
            }
          }
        }
        var updatePayload = null;
        for (var propKey in rawProps)
          if (!!rawProps.hasOwnProperty(propKey)) {
            var nextProp = rawProps[propKey];
            if (propKey === CHILDREN)
              typeof nextProp == "string" ? domElement.textContent !== nextProp && (suppressHydrationWarning || warnForTextDifference(domElement.textContent, nextProp), updatePayload = [CHILDREN, nextProp]) : typeof nextProp == "number" && domElement.textContent !== "" + nextProp && (suppressHydrationWarning || warnForTextDifference(domElement.textContent, nextProp), updatePayload = [CHILDREN, "" + nextProp]);
            else if (registrationNameDependencies.hasOwnProperty(propKey))
              nextProp != null && (typeof nextProp != "function" && warnForInvalidEventListener(propKey, nextProp), propKey === "onScroll" && listenToNonDelegatedEvent("scroll", domElement));
            else if (typeof isCustomComponentTag == "boolean") {
              var serverValue = void 0, propertyInfo = getPropertyInfo(propKey);
              if (!suppressHydrationWarning) {
                if (!(propKey === SUPPRESS_CONTENT_EDITABLE_WARNING || propKey === SUPPRESS_HYDRATION_WARNING || propKey === "value" || propKey === "checked" || propKey === "selected")) {
                  if (propKey === DANGEROUSLY_SET_INNER_HTML) {
                    var serverHTML = domElement.innerHTML, nextHtml = nextProp ? nextProp[HTML$1] : void 0;
                    if (nextHtml != null) {
                      var expectedHTML = normalizeHTML(domElement, nextHtml);
                      expectedHTML !== serverHTML && warnForPropDifference(propKey, serverHTML, expectedHTML);
                    }
                  } else if (propKey === STYLE) {
                    if (extraAttributeNames.delete(propKey), canDiffStyleForHydrationWarning) {
                      var expectedStyle = createDangerousStringForStyles(nextProp);
                      serverValue = domElement.getAttribute("style"), expectedStyle !== serverValue && warnForPropDifference(propKey, serverValue, expectedStyle);
                    }
                  } else if (isCustomComponentTag)
                    extraAttributeNames.delete(propKey.toLowerCase()), serverValue = getValueForAttribute(domElement, propKey, nextProp), nextProp !== serverValue && warnForPropDifference(propKey, serverValue, nextProp);
                  else if (!shouldIgnoreAttribute(propKey, propertyInfo, isCustomComponentTag) && !shouldRemoveAttribute(propKey, nextProp, propertyInfo, isCustomComponentTag)) {
                    var isMismatchDueToBadCasing = !1;
                    if (propertyInfo !== null)
                      extraAttributeNames.delete(propertyInfo.attributeName), serverValue = getValueForProperty(domElement, propKey, nextProp, propertyInfo);
                    else {
                      var ownNamespace = parentNamespace;
                      if (ownNamespace === HTML_NAMESPACE$1 && (ownNamespace = getIntrinsicNamespace(tag)), ownNamespace === HTML_NAMESPACE$1)
                        extraAttributeNames.delete(propKey.toLowerCase());
                      else {
                        var standardName = getPossibleStandardName(propKey);
                        standardName !== null && standardName !== propKey && (isMismatchDueToBadCasing = !0, extraAttributeNames.delete(standardName)), extraAttributeNames.delete(propKey);
                      }
                      serverValue = getValueForAttribute(domElement, propKey, nextProp);
                    }
                    nextProp !== serverValue && !isMismatchDueToBadCasing && warnForPropDifference(propKey, serverValue, nextProp);
                  }
                }
              }
            }
          }
        switch (extraAttributeNames.size > 0 && !suppressHydrationWarning && warnForExtraAttributes(extraAttributeNames), tag) {
          case "input":
            track(domElement), postMountWrapper(domElement, rawProps, !0);
            break;
          case "textarea":
            track(domElement), postMountWrapper$3(domElement);
            break;
          case "select":
          case "option":
            break;
          default:
            typeof rawProps.onClick == "function" && trapClickOnNonInteractiveElement(domElement);
            break;
        }
        return updatePayload;
      }
      function diffHydratedText(textNode, text) {
        var isDifferent = textNode.nodeValue !== text;
        return isDifferent;
      }
      function warnForUnmatchedText(textNode, text) {
        warnForTextDifference(textNode.nodeValue, text);
      }
      function warnForDeletedHydratableElement(parentNode, child) {
        {
          if (didWarnInvalidHydration)
            return;
          didWarnInvalidHydration = !0, error("Did not expect server HTML to contain a <%s> in <%s>.", child.nodeName.toLowerCase(), parentNode.nodeName.toLowerCase());
        }
      }
      function warnForDeletedHydratableText(parentNode, child) {
        {
          if (didWarnInvalidHydration)
            return;
          didWarnInvalidHydration = !0, error('Did not expect server HTML to contain the text node "%s" in <%s>.', child.nodeValue, parentNode.nodeName.toLowerCase());
        }
      }
      function warnForInsertedHydratedElement(parentNode, tag, props) {
        {
          if (didWarnInvalidHydration)
            return;
          didWarnInvalidHydration = !0, error("Expected server HTML to contain a matching <%s> in <%s>.", tag, parentNode.nodeName.toLowerCase());
        }
      }
      function warnForInsertedHydratedText(parentNode, text) {
        {
          if (text === "" || didWarnInvalidHydration)
            return;
          didWarnInvalidHydration = !0, error('Expected server HTML to contain a matching text node for "%s" in <%s>.', text, parentNode.nodeName.toLowerCase());
        }
      }
      function restoreControlledState$3(domElement, tag, props) {
        switch (tag) {
          case "input":
            restoreControlledState(domElement, props);
            return;
          case "textarea":
            restoreControlledState$2(domElement, props);
            return;
          case "select":
            restoreControlledState$1(domElement, props);
            return;
        }
      }
      var validateDOMNesting = function() {
      }, updatedAncestorInfo = function() {
      };
      {
        var specialTags = ["address", "applet", "area", "article", "aside", "base", "basefont", "bgsound", "blockquote", "body", "br", "button", "caption", "center", "col", "colgroup", "dd", "details", "dir", "div", "dl", "dt", "embed", "fieldset", "figcaption", "figure", "footer", "form", "frame", "frameset", "h1", "h2", "h3", "h4", "h5", "h6", "head", "header", "hgroup", "hr", "html", "iframe", "img", "input", "isindex", "li", "link", "listing", "main", "marquee", "menu", "menuitem", "meta", "nav", "noembed", "noframes", "noscript", "object", "ol", "p", "param", "plaintext", "pre", "script", "section", "select", "source", "style", "summary", "table", "tbody", "td", "template", "textarea", "tfoot", "th", "thead", "title", "tr", "track", "ul", "wbr", "xmp"], inScopeTags = [
          "applet",
          "caption",
          "html",
          "table",
          "td",
          "th",
          "marquee",
          "object",
          "template",
          "foreignObject",
          "desc",
          "title"
        ], buttonScopeTags = inScopeTags.concat(["button"]), impliedEndTags = ["dd", "dt", "li", "option", "optgroup", "p", "rp", "rt"], emptyAncestorInfo = {
          current: null,
          formTag: null,
          aTagInScope: null,
          buttonTagInScope: null,
          nobrTagInScope: null,
          pTagInButtonScope: null,
          listItemTagAutoclosing: null,
          dlItemTagAutoclosing: null
        };
        updatedAncestorInfo = function(oldInfo, tag) {
          var ancestorInfo = _assign({}, oldInfo || emptyAncestorInfo), info = {
            tag
          };
          return inScopeTags.indexOf(tag) !== -1 && (ancestorInfo.aTagInScope = null, ancestorInfo.buttonTagInScope = null, ancestorInfo.nobrTagInScope = null), buttonScopeTags.indexOf(tag) !== -1 && (ancestorInfo.pTagInButtonScope = null), specialTags.indexOf(tag) !== -1 && tag !== "address" && tag !== "div" && tag !== "p" && (ancestorInfo.listItemTagAutoclosing = null, ancestorInfo.dlItemTagAutoclosing = null), ancestorInfo.current = info, tag === "form" && (ancestorInfo.formTag = info), tag === "a" && (ancestorInfo.aTagInScope = info), tag === "button" && (ancestorInfo.buttonTagInScope = info), tag === "nobr" && (ancestorInfo.nobrTagInScope = info), tag === "p" && (ancestorInfo.pTagInButtonScope = info), tag === "li" && (ancestorInfo.listItemTagAutoclosing = info), (tag === "dd" || tag === "dt") && (ancestorInfo.dlItemTagAutoclosing = info), ancestorInfo;
        };
        var isTagValidWithParent = function(tag, parentTag) {
          switch (parentTag) {
            case "select":
              return tag === "option" || tag === "optgroup" || tag === "#text";
            case "optgroup":
              return tag === "option" || tag === "#text";
            case "option":
              return tag === "#text";
            case "tr":
              return tag === "th" || tag === "td" || tag === "style" || tag === "script" || tag === "template";
            case "tbody":
            case "thead":
            case "tfoot":
              return tag === "tr" || tag === "style" || tag === "script" || tag === "template";
            case "colgroup":
              return tag === "col" || tag === "template";
            case "table":
              return tag === "caption" || tag === "colgroup" || tag === "tbody" || tag === "tfoot" || tag === "thead" || tag === "style" || tag === "script" || tag === "template";
            case "head":
              return tag === "base" || tag === "basefont" || tag === "bgsound" || tag === "link" || tag === "meta" || tag === "title" || tag === "noscript" || tag === "noframes" || tag === "style" || tag === "script" || tag === "template";
            case "html":
              return tag === "head" || tag === "body" || tag === "frameset";
            case "frameset":
              return tag === "frame";
            case "#document":
              return tag === "html";
          }
          switch (tag) {
            case "h1":
            case "h2":
            case "h3":
            case "h4":
            case "h5":
            case "h6":
              return parentTag !== "h1" && parentTag !== "h2" && parentTag !== "h3" && parentTag !== "h4" && parentTag !== "h5" && parentTag !== "h6";
            case "rp":
            case "rt":
              return impliedEndTags.indexOf(parentTag) === -1;
            case "body":
            case "caption":
            case "col":
            case "colgroup":
            case "frameset":
            case "frame":
            case "head":
            case "html":
            case "tbody":
            case "td":
            case "tfoot":
            case "th":
            case "thead":
            case "tr":
              return parentTag == null;
          }
          return !0;
        }, findInvalidAncestorForTag = function(tag, ancestorInfo) {
          switch (tag) {
            case "address":
            case "article":
            case "aside":
            case "blockquote":
            case "center":
            case "details":
            case "dialog":
            case "dir":
            case "div":
            case "dl":
            case "fieldset":
            case "figcaption":
            case "figure":
            case "footer":
            case "header":
            case "hgroup":
            case "main":
            case "menu":
            case "nav":
            case "ol":
            case "p":
            case "section":
            case "summary":
            case "ul":
            case "pre":
            case "listing":
            case "table":
            case "hr":
            case "xmp":
            case "h1":
            case "h2":
            case "h3":
            case "h4":
            case "h5":
            case "h6":
              return ancestorInfo.pTagInButtonScope;
            case "form":
              return ancestorInfo.formTag || ancestorInfo.pTagInButtonScope;
            case "li":
              return ancestorInfo.listItemTagAutoclosing;
            case "dd":
            case "dt":
              return ancestorInfo.dlItemTagAutoclosing;
            case "button":
              return ancestorInfo.buttonTagInScope;
            case "a":
              return ancestorInfo.aTagInScope;
            case "nobr":
              return ancestorInfo.nobrTagInScope;
          }
          return null;
        }, didWarn$1 = {};
        validateDOMNesting = function(childTag, childText, ancestorInfo) {
          ancestorInfo = ancestorInfo || emptyAncestorInfo;
          var parentInfo = ancestorInfo.current, parentTag = parentInfo && parentInfo.tag;
          childText != null && (childTag != null && error("validateDOMNesting: when childText is passed, childTag should be null"), childTag = "#text");
          var invalidParent = isTagValidWithParent(childTag, parentTag) ? null : parentInfo, invalidAncestor = invalidParent ? null : findInvalidAncestorForTag(childTag, ancestorInfo), invalidParentOrAncestor = invalidParent || invalidAncestor;
          if (!!invalidParentOrAncestor) {
            var ancestorTag = invalidParentOrAncestor.tag, warnKey = !!invalidParent + "|" + childTag + "|" + ancestorTag;
            if (!didWarn$1[warnKey]) {
              didWarn$1[warnKey] = !0;
              var tagDisplayName = childTag, whitespaceInfo = "";
              if (childTag === "#text" ? /\S/.test(childText) ? tagDisplayName = "Text nodes" : (tagDisplayName = "Whitespace text nodes", whitespaceInfo = " Make sure you don't have any extra whitespace between tags on each line of your source code.") : tagDisplayName = "<" + childTag + ">", invalidParent) {
                var info = "";
                ancestorTag === "table" && childTag === "tr" && (info += " Add a <tbody>, <thead> or <tfoot> to your code to match the DOM tree generated by the browser."), error("validateDOMNesting(...): %s cannot appear as a child of <%s>.%s%s", tagDisplayName, ancestorTag, whitespaceInfo, info);
              } else
                error("validateDOMNesting(...): %s cannot appear as a descendant of <%s>.", tagDisplayName, ancestorTag);
            }
          }
        };
      }
      var SUPPRESS_HYDRATION_WARNING$1;
      SUPPRESS_HYDRATION_WARNING$1 = "suppressHydrationWarning";
      var SUSPENSE_START_DATA = "$", SUSPENSE_END_DATA = "/$", SUSPENSE_PENDING_START_DATA = "$?", SUSPENSE_FALLBACK_START_DATA = "$!", STYLE$1 = "style", eventsEnabled = null, selectionInformation = null;
      function shouldAutoFocusHostComponent(type, props) {
        switch (type) {
          case "button":
          case "input":
          case "select":
          case "textarea":
            return !!props.autoFocus;
        }
        return !1;
      }
      function getRootHostContext(rootContainerInstance) {
        var type, namespace, nodeType = rootContainerInstance.nodeType;
        switch (nodeType) {
          case DOCUMENT_NODE:
          case DOCUMENT_FRAGMENT_NODE: {
            type = nodeType === DOCUMENT_NODE ? "#document" : "#fragment";
            var root2 = rootContainerInstance.documentElement;
            namespace = root2 ? root2.namespaceURI : getChildNamespace(null, "");
            break;
          }
          default: {
            var container = nodeType === COMMENT_NODE ? rootContainerInstance.parentNode : rootContainerInstance, ownNamespace = container.namespaceURI || null;
            type = container.tagName, namespace = getChildNamespace(ownNamespace, type);
            break;
          }
        }
        {
          var validatedTag = type.toLowerCase(), ancestorInfo = updatedAncestorInfo(null, validatedTag);
          return {
            namespace,
            ancestorInfo
          };
        }
      }
      function getChildHostContext(parentHostContext, type, rootContainerInstance) {
        {
          var parentHostContextDev = parentHostContext, namespace = getChildNamespace(parentHostContextDev.namespace, type), ancestorInfo = updatedAncestorInfo(parentHostContextDev.ancestorInfo, type);
          return {
            namespace,
            ancestorInfo
          };
        }
      }
      function getPublicInstance(instance) {
        return instance;
      }
      function prepareForCommit(containerInfo) {
        eventsEnabled = isEnabled(), selectionInformation = getSelectionInformation();
        var activeInstance = null;
        return setEnabled(!1), activeInstance;
      }
      function resetAfterCommit(containerInfo) {
        restoreSelection(selectionInformation), setEnabled(eventsEnabled), eventsEnabled = null, selectionInformation = null;
      }
      function createInstance(type, props, rootContainerInstance, hostContext, internalInstanceHandle) {
        var parentNamespace;
        {
          var hostContextDev = hostContext;
          if (validateDOMNesting(type, null, hostContextDev.ancestorInfo), typeof props.children == "string" || typeof props.children == "number") {
            var string = "" + props.children, ownAncestorInfo = updatedAncestorInfo(hostContextDev.ancestorInfo, type);
            validateDOMNesting(null, string, ownAncestorInfo);
          }
          parentNamespace = hostContextDev.namespace;
        }
        var domElement = createElement7(type, props, rootContainerInstance, parentNamespace);
        return precacheFiberNode(internalInstanceHandle, domElement), updateFiberProps(domElement, props), domElement;
      }
      function appendInitialChild(parentInstance, child) {
        parentInstance.appendChild(child);
      }
      function finalizeInitialChildren(domElement, type, props, rootContainerInstance, hostContext) {
        return setInitialProperties(domElement, type, props, rootContainerInstance), shouldAutoFocusHostComponent(type, props);
      }
      function prepareUpdate(domElement, type, oldProps, newProps, rootContainerInstance, hostContext) {
        {
          var hostContextDev = hostContext;
          if (typeof newProps.children != typeof oldProps.children && (typeof newProps.children == "string" || typeof newProps.children == "number")) {
            var string = "" + newProps.children, ownAncestorInfo = updatedAncestorInfo(hostContextDev.ancestorInfo, type);
            validateDOMNesting(null, string, ownAncestorInfo);
          }
        }
        return diffProperties(domElement, type, oldProps, newProps);
      }
      function shouldSetTextContent(type, props) {
        return type === "textarea" || type === "option" || type === "noscript" || typeof props.children == "string" || typeof props.children == "number" || typeof props.dangerouslySetInnerHTML == "object" && props.dangerouslySetInnerHTML !== null && props.dangerouslySetInnerHTML.__html != null;
      }
      function createTextInstance(text, rootContainerInstance, hostContext, internalInstanceHandle) {
        {
          var hostContextDev = hostContext;
          validateDOMNesting(null, text, hostContextDev.ancestorInfo);
        }
        var textNode = createTextNode(text, rootContainerInstance);
        return precacheFiberNode(internalInstanceHandle, textNode), textNode;
      }
      var scheduleTimeout = typeof setTimeout == "function" ? setTimeout : void 0, cancelTimeout = typeof clearTimeout == "function" ? clearTimeout : void 0, noTimeout = -1;
      function commitMount(domElement, type, newProps, internalInstanceHandle) {
        shouldAutoFocusHostComponent(type, newProps) && domElement.focus();
      }
      function commitUpdate(domElement, updatePayload, type, oldProps, newProps, internalInstanceHandle) {
        updateFiberProps(domElement, newProps), updateProperties(domElement, updatePayload, type, oldProps, newProps);
      }
      function resetTextContent(domElement) {
        setTextContent(domElement, "");
      }
      function commitTextUpdate(textInstance, oldText, newText) {
        textInstance.nodeValue = newText;
      }
      function appendChild(parentInstance, child) {
        parentInstance.appendChild(child);
      }
      function appendChildToContainer(container, child) {
        var parentNode;
        container.nodeType === COMMENT_NODE ? (parentNode = container.parentNode, parentNode.insertBefore(child, container)) : (parentNode = container, parentNode.appendChild(child));
        var reactRootContainer = container._reactRootContainer;
        reactRootContainer == null && parentNode.onclick === null && trapClickOnNonInteractiveElement(parentNode);
      }
      function insertBefore(parentInstance, child, beforeChild) {
        parentInstance.insertBefore(child, beforeChild);
      }
      function insertInContainerBefore(container, child, beforeChild) {
        container.nodeType === COMMENT_NODE ? container.parentNode.insertBefore(child, beforeChild) : container.insertBefore(child, beforeChild);
      }
      function removeChild(parentInstance, child) {
        parentInstance.removeChild(child);
      }
      function removeChildFromContainer(container, child) {
        container.nodeType === COMMENT_NODE ? container.parentNode.removeChild(child) : container.removeChild(child);
      }
      function hideInstance(instance) {
        instance = instance;
        var style4 = instance.style;
        typeof style4.setProperty == "function" ? style4.setProperty("display", "none", "important") : style4.display = "none";
      }
      function hideTextInstance(textInstance) {
        textInstance.nodeValue = "";
      }
      function unhideInstance(instance, props) {
        instance = instance;
        var styleProp = props[STYLE$1], display = styleProp != null && styleProp.hasOwnProperty("display") ? styleProp.display : null;
        instance.style.display = dangerousStyleValue("display", display);
      }
      function unhideTextInstance(textInstance, text) {
        textInstance.nodeValue = text;
      }
      function clearContainer(container) {
        if (container.nodeType === ELEMENT_NODE)
          container.textContent = "";
        else if (container.nodeType === DOCUMENT_NODE) {
          var body = container.body;
          body != null && (body.textContent = "");
        }
      }
      function canHydrateInstance(instance, type, props) {
        return instance.nodeType !== ELEMENT_NODE || type.toLowerCase() !== instance.nodeName.toLowerCase() ? null : instance;
      }
      function canHydrateTextInstance(instance, text) {
        return text === "" || instance.nodeType !== TEXT_NODE ? null : instance;
      }
      function isSuspenseInstancePending(instance) {
        return instance.data === SUSPENSE_PENDING_START_DATA;
      }
      function isSuspenseInstanceFallback(instance) {
        return instance.data === SUSPENSE_FALLBACK_START_DATA;
      }
      function getNextHydratable(node) {
        for (; node != null; node = node.nextSibling) {
          var nodeType = node.nodeType;
          if (nodeType === ELEMENT_NODE || nodeType === TEXT_NODE)
            break;
        }
        return node;
      }
      function getNextHydratableSibling(instance) {
        return getNextHydratable(instance.nextSibling);
      }
      function getFirstHydratableChild(parentInstance) {
        return getNextHydratable(parentInstance.firstChild);
      }
      function hydrateInstance(instance, type, props, rootContainerInstance, hostContext, internalInstanceHandle) {
        precacheFiberNode(internalInstanceHandle, instance), updateFiberProps(instance, props);
        var parentNamespace;
        {
          var hostContextDev = hostContext;
          parentNamespace = hostContextDev.namespace;
        }
        return diffHydratedProperties(instance, type, props, parentNamespace);
      }
      function hydrateTextInstance(textInstance, text, internalInstanceHandle) {
        return precacheFiberNode(internalInstanceHandle, textInstance), diffHydratedText(textInstance, text);
      }
      function getNextHydratableInstanceAfterSuspenseInstance(suspenseInstance) {
        for (var node = suspenseInstance.nextSibling, depth = 0; node; ) {
          if (node.nodeType === COMMENT_NODE) {
            var data = node.data;
            if (data === SUSPENSE_END_DATA) {
              if (depth === 0)
                return getNextHydratableSibling(node);
              depth--;
            } else
              (data === SUSPENSE_START_DATA || data === SUSPENSE_FALLBACK_START_DATA || data === SUSPENSE_PENDING_START_DATA) && depth++;
          }
          node = node.nextSibling;
        }
        return null;
      }
      function getParentSuspenseInstance(targetInstance) {
        for (var node = targetInstance.previousSibling, depth = 0; node; ) {
          if (node.nodeType === COMMENT_NODE) {
            var data = node.data;
            if (data === SUSPENSE_START_DATA || data === SUSPENSE_FALLBACK_START_DATA || data === SUSPENSE_PENDING_START_DATA) {
              if (depth === 0)
                return node;
              depth--;
            } else
              data === SUSPENSE_END_DATA && depth++;
          }
          node = node.previousSibling;
        }
        return null;
      }
      function commitHydratedContainer(container) {
        retryIfBlockedOn(container);
      }
      function commitHydratedSuspenseInstance(suspenseInstance) {
        retryIfBlockedOn(suspenseInstance);
      }
      function didNotMatchHydratedContainerTextInstance(parentContainer, textInstance, text) {
        warnForUnmatchedText(textInstance, text);
      }
      function didNotMatchHydratedTextInstance(parentType, parentProps, parentInstance, textInstance, text) {
        parentProps[SUPPRESS_HYDRATION_WARNING$1] !== !0 && warnForUnmatchedText(textInstance, text);
      }
      function didNotHydrateContainerInstance(parentContainer, instance) {
        instance.nodeType === ELEMENT_NODE ? warnForDeletedHydratableElement(parentContainer, instance) : instance.nodeType === COMMENT_NODE || warnForDeletedHydratableText(parentContainer, instance);
      }
      function didNotHydrateInstance(parentType, parentProps, parentInstance, instance) {
        parentProps[SUPPRESS_HYDRATION_WARNING$1] !== !0 && (instance.nodeType === ELEMENT_NODE ? warnForDeletedHydratableElement(parentInstance, instance) : instance.nodeType === COMMENT_NODE || warnForDeletedHydratableText(parentInstance, instance));
      }
      function didNotFindHydratableContainerInstance(parentContainer, type, props) {
        warnForInsertedHydratedElement(parentContainer, type);
      }
      function didNotFindHydratableContainerTextInstance(parentContainer, text) {
        warnForInsertedHydratedText(parentContainer, text);
      }
      function didNotFindHydratableInstance(parentType, parentProps, parentInstance, type, props) {
        parentProps[SUPPRESS_HYDRATION_WARNING$1] !== !0 && warnForInsertedHydratedElement(parentInstance, type);
      }
      function didNotFindHydratableTextInstance(parentType, parentProps, parentInstance, text) {
        parentProps[SUPPRESS_HYDRATION_WARNING$1] !== !0 && warnForInsertedHydratedText(parentInstance, text);
      }
      function didNotFindHydratableSuspenseInstance(parentType, parentProps, parentInstance) {
        parentProps[SUPPRESS_HYDRATION_WARNING$1];
      }
      var clientId = 0;
      function makeClientIdInDEV(warnOnAccessInDEV) {
        var id = "r:" + (clientId++).toString(36);
        return {
          toString: function() {
            return warnOnAccessInDEV(), id;
          },
          valueOf: function() {
            return warnOnAccessInDEV(), id;
          }
        };
      }
      function isOpaqueHydratingObject(value) {
        return value !== null && typeof value == "object" && value.$$typeof === REACT_OPAQUE_ID_TYPE;
      }
      function makeOpaqueHydratingObject(attemptToReadValue) {
        return {
          $$typeof: REACT_OPAQUE_ID_TYPE,
          toString: attemptToReadValue,
          valueOf: attemptToReadValue
        };
      }
      function preparePortalMount(portalInstance) {
        listenToAllSupportedEvents(portalInstance);
      }
      var randomKey = Math.random().toString(36).slice(2), internalInstanceKey = "__reactFiber$" + randomKey, internalPropsKey = "__reactProps$" + randomKey, internalContainerInstanceKey = "__reactContainer$" + randomKey, internalEventHandlersKey = "__reactEvents$" + randomKey;
      function precacheFiberNode(hostInst, node) {
        node[internalInstanceKey] = hostInst;
      }
      function markContainerAsRoot(hostRoot, node) {
        node[internalContainerInstanceKey] = hostRoot;
      }
      function unmarkContainerAsRoot(node) {
        node[internalContainerInstanceKey] = null;
      }
      function isContainerMarkedAsRoot(node) {
        return !!node[internalContainerInstanceKey];
      }
      function getClosestInstanceFromNode(targetNode) {
        var targetInst = targetNode[internalInstanceKey];
        if (targetInst)
          return targetInst;
        for (var parentNode = targetNode.parentNode; parentNode; ) {
          if (targetInst = parentNode[internalContainerInstanceKey] || parentNode[internalInstanceKey], targetInst) {
            var alternate = targetInst.alternate;
            if (targetInst.child !== null || alternate !== null && alternate.child !== null)
              for (var suspenseInstance = getParentSuspenseInstance(targetNode); suspenseInstance !== null; ) {
                var targetSuspenseInst = suspenseInstance[internalInstanceKey];
                if (targetSuspenseInst)
                  return targetSuspenseInst;
                suspenseInstance = getParentSuspenseInstance(suspenseInstance);
              }
            return targetInst;
          }
          targetNode = parentNode, parentNode = targetNode.parentNode;
        }
        return null;
      }
      function getInstanceFromNode(node) {
        var inst = node[internalInstanceKey] || node[internalContainerInstanceKey];
        return inst && (inst.tag === HostComponent || inst.tag === HostText || inst.tag === SuspenseComponent || inst.tag === HostRoot) ? inst : null;
      }
      function getNodeFromInstance(inst) {
        if (inst.tag === HostComponent || inst.tag === HostText)
          return inst.stateNode;
        throw Error("getNodeFromInstance: Invalid argument.");
      }
      function getFiberCurrentPropsFromNode(node) {
        return node[internalPropsKey] || null;
      }
      function updateFiberProps(node, props) {
        node[internalPropsKey] = props;
      }
      function getEventListenerSet(node) {
        var elementListenerSet = node[internalEventHandlersKey];
        return elementListenerSet === void 0 && (elementListenerSet = node[internalEventHandlersKey] = /* @__PURE__ */ new Set()), elementListenerSet;
      }
      var loggedTypeFailures = {}, ReactDebugCurrentFrame$1 = ReactSharedInternals.ReactDebugCurrentFrame;
      function setCurrentlyValidatingElement(element) {
        if (element) {
          var owner = element._owner, stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);
          ReactDebugCurrentFrame$1.setExtraStackFrame(stack);
        } else
          ReactDebugCurrentFrame$1.setExtraStackFrame(null);
      }
      function checkPropTypes(typeSpecs, values3, location, componentName, element) {
        {
          var has2 = Function.call.bind(Object.prototype.hasOwnProperty);
          for (var typeSpecName in typeSpecs)
            if (has2(typeSpecs, typeSpecName)) {
              var error$1 = void 0;
              try {
                if (typeof typeSpecs[typeSpecName] != "function") {
                  var err = Error((componentName || "React class") + ": " + location + " type `" + typeSpecName + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof typeSpecs[typeSpecName] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.");
                  throw err.name = "Invariant Violation", err;
                }
                error$1 = typeSpecs[typeSpecName](values3, typeSpecName, componentName, location, null, "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED");
              } catch (ex) {
                error$1 = ex;
              }
              error$1 && !(error$1 instanceof Error) && (setCurrentlyValidatingElement(element), error("%s: type specification of %s `%s` is invalid; the type checker function must return `null` or an `Error` but returned a %s. You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).", componentName || "React class", location, typeSpecName, typeof error$1), setCurrentlyValidatingElement(null)), error$1 instanceof Error && !(error$1.message in loggedTypeFailures) && (loggedTypeFailures[error$1.message] = !0, setCurrentlyValidatingElement(element), error("Failed %s type: %s", location, error$1.message), setCurrentlyValidatingElement(null));
            }
        }
      }
      var valueStack = [], fiberStack;
      fiberStack = [];
      var index = -1;
      function createCursor(defaultValue) {
        return {
          current: defaultValue
        };
      }
      function pop(cursor, fiber) {
        if (index < 0) {
          error("Unexpected pop.");
          return;
        }
        fiber !== fiberStack[index] && error("Unexpected Fiber popped."), cursor.current = valueStack[index], valueStack[index] = null, fiberStack[index] = null, index--;
      }
      function push(cursor, value, fiber) {
        index++, valueStack[index] = cursor.current, fiberStack[index] = fiber, cursor.current = value;
      }
      var warnedAboutMissingGetChildContext;
      warnedAboutMissingGetChildContext = {};
      var emptyContextObject = {};
      Object.freeze(emptyContextObject);
      var contextStackCursor = createCursor(emptyContextObject), didPerformWorkStackCursor = createCursor(!1), previousContext = emptyContextObject;
      function getUnmaskedContext(workInProgress2, Component, didPushOwnContextIfProvider) {
        return didPushOwnContextIfProvider && isContextProvider(Component) ? previousContext : contextStackCursor.current;
      }
      function cacheContext(workInProgress2, unmaskedContext, maskedContext) {
        {
          var instance = workInProgress2.stateNode;
          instance.__reactInternalMemoizedUnmaskedChildContext = unmaskedContext, instance.__reactInternalMemoizedMaskedChildContext = maskedContext;
        }
      }
      function getMaskedContext(workInProgress2, unmaskedContext) {
        {
          var type = workInProgress2.type, contextTypes = type.contextTypes;
          if (!contextTypes)
            return emptyContextObject;
          var instance = workInProgress2.stateNode;
          if (instance && instance.__reactInternalMemoizedUnmaskedChildContext === unmaskedContext)
            return instance.__reactInternalMemoizedMaskedChildContext;
          var context = {};
          for (var key in contextTypes)
            context[key] = unmaskedContext[key];
          {
            var name = getComponentName(type) || "Unknown";
            checkPropTypes(contextTypes, context, "context", name);
          }
          return instance && cacheContext(workInProgress2, unmaskedContext, context), context;
        }
      }
      function hasContextChanged() {
        return didPerformWorkStackCursor.current;
      }
      function isContextProvider(type) {
        {
          var childContextTypes = type.childContextTypes;
          return childContextTypes != null;
        }
      }
      function popContext(fiber) {
        pop(didPerformWorkStackCursor, fiber), pop(contextStackCursor, fiber);
      }
      function popTopLevelContextObject(fiber) {
        pop(didPerformWorkStackCursor, fiber), pop(contextStackCursor, fiber);
      }
      function pushTopLevelContextObject(fiber, context, didChange) {
        {
          if (contextStackCursor.current !== emptyContextObject)
            throw Error("Unexpected context found on stack. This error is likely caused by a bug in React. Please file an issue.");
          push(contextStackCursor, context, fiber), push(didPerformWorkStackCursor, didChange, fiber);
        }
      }
      function processChildContext(fiber, type, parentContext) {
        {
          var instance = fiber.stateNode, childContextTypes = type.childContextTypes;
          if (typeof instance.getChildContext != "function") {
            {
              var componentName = getComponentName(type) || "Unknown";
              warnedAboutMissingGetChildContext[componentName] || (warnedAboutMissingGetChildContext[componentName] = !0, error("%s.childContextTypes is specified but there is no getChildContext() method on the instance. You can either define getChildContext() on %s or remove childContextTypes from it.", componentName, componentName));
            }
            return parentContext;
          }
          var childContext = instance.getChildContext();
          for (var contextKey in childContext)
            if (!(contextKey in childContextTypes))
              throw Error((getComponentName(type) || "Unknown") + '.getChildContext(): key "' + contextKey + '" is not defined in childContextTypes.');
          {
            var name = getComponentName(type) || "Unknown";
            checkPropTypes(childContextTypes, childContext, "child context", name);
          }
          return _assign({}, parentContext, childContext);
        }
      }
      function pushContextProvider(workInProgress2) {
        {
          var instance = workInProgress2.stateNode, memoizedMergedChildContext = instance && instance.__reactInternalMemoizedMergedChildContext || emptyContextObject;
          return previousContext = contextStackCursor.current, push(contextStackCursor, memoizedMergedChildContext, workInProgress2), push(didPerformWorkStackCursor, didPerformWorkStackCursor.current, workInProgress2), !0;
        }
      }
      function invalidateContextProvider(workInProgress2, type, didChange) {
        {
          var instance = workInProgress2.stateNode;
          if (!instance)
            throw Error("Expected to have an instance by this point. This error is likely caused by a bug in React. Please file an issue.");
          if (didChange) {
            var mergedContext = processChildContext(workInProgress2, type, previousContext);
            instance.__reactInternalMemoizedMergedChildContext = mergedContext, pop(didPerformWorkStackCursor, workInProgress2), pop(contextStackCursor, workInProgress2), push(contextStackCursor, mergedContext, workInProgress2), push(didPerformWorkStackCursor, didChange, workInProgress2);
          } else
            pop(didPerformWorkStackCursor, workInProgress2), push(didPerformWorkStackCursor, didChange, workInProgress2);
        }
      }
      function findCurrentUnmaskedContext(fiber) {
        {
          if (!(isFiberMounted(fiber) && fiber.tag === ClassComponent))
            throw Error("Expected subtree parent to be a mounted class component. This error is likely caused by a bug in React. Please file an issue.");
          var node = fiber;
          do {
            switch (node.tag) {
              case HostRoot:
                return node.stateNode.context;
              case ClassComponent: {
                var Component = node.type;
                if (isContextProvider(Component))
                  return node.stateNode.__reactInternalMemoizedMergedChildContext;
                break;
              }
            }
            node = node.return;
          } while (node !== null);
          throw Error("Found unexpected detached subtree parent. This error is likely caused by a bug in React. Please file an issue.");
        }
      }
      var LegacyRoot = 0, BlockingRoot = 1, ConcurrentRoot = 2, rendererID = null, injectedHook = null, hasLoggedError = !1, isDevToolsPresent = typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u";
      function injectInternals(internals) {
        if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ > "u")
          return !1;
        var hook = __REACT_DEVTOOLS_GLOBAL_HOOK__;
        if (hook.isDisabled)
          return !0;
        if (!hook.supportsFiber)
          return error("The installed version of React DevTools is too old and will not work with the current version of React. Please update React DevTools. https://reactjs.org/link/react-devtools"), !0;
        try {
          rendererID = hook.inject(internals), injectedHook = hook;
        } catch (err) {
          error("React instrumentation encountered an error: %s.", err);
        }
        return !0;
      }
      function onScheduleRoot(root2, children) {
        if (injectedHook && typeof injectedHook.onScheduleFiberRoot == "function")
          try {
            injectedHook.onScheduleFiberRoot(rendererID, root2, children);
          } catch (err) {
            hasLoggedError || (hasLoggedError = !0, error("React instrumentation encountered an error: %s", err));
          }
      }
      function onCommitRoot(root2, priorityLevel) {
        if (injectedHook && typeof injectedHook.onCommitFiberRoot == "function")
          try {
            var didError = (root2.current.flags & DidCapture) === DidCapture;
            enableProfilerTimer ? injectedHook.onCommitFiberRoot(rendererID, root2, priorityLevel, didError) : injectedHook.onCommitFiberRoot(rendererID, root2, void 0, didError);
          } catch (err) {
            hasLoggedError || (hasLoggedError = !0, error("React instrumentation encountered an error: %s", err));
          }
      }
      function onCommitUnmount(fiber) {
        if (injectedHook && typeof injectedHook.onCommitFiberUnmount == "function")
          try {
            injectedHook.onCommitFiberUnmount(rendererID, fiber);
          } catch (err) {
            hasLoggedError || (hasLoggedError = !0, error("React instrumentation encountered an error: %s", err));
          }
      }
      var Scheduler_runWithPriority = Scheduler.unstable_runWithPriority, Scheduler_scheduleCallback = Scheduler.unstable_scheduleCallback, Scheduler_cancelCallback = Scheduler.unstable_cancelCallback, Scheduler_shouldYield = Scheduler.unstable_shouldYield, Scheduler_requestPaint = Scheduler.unstable_requestPaint, Scheduler_now$1 = Scheduler.unstable_now, Scheduler_getCurrentPriorityLevel = Scheduler.unstable_getCurrentPriorityLevel, Scheduler_ImmediatePriority = Scheduler.unstable_ImmediatePriority, Scheduler_UserBlockingPriority = Scheduler.unstable_UserBlockingPriority, Scheduler_NormalPriority = Scheduler.unstable_NormalPriority, Scheduler_LowPriority = Scheduler.unstable_LowPriority, Scheduler_IdlePriority = Scheduler.unstable_IdlePriority;
      if (!(tracing.__interactionsRef != null && tracing.__interactionsRef.current != null))
        throw Error("It is not supported to run the profiling version of a renderer (for example, `react-dom/profiling`) without also replacing the `scheduler/tracing` module with `scheduler/tracing-profiling`. Your bundler might have a setting for aliasing both modules. Learn more at https://reactjs.org/link/profiling");
      var fakeCallbackNode = {}, ImmediatePriority$1 = 99, UserBlockingPriority$2 = 98, NormalPriority$1 = 97, LowPriority$1 = 96, IdlePriority$1 = 95, NoPriority$1 = 90, shouldYield = Scheduler_shouldYield, requestPaint = Scheduler_requestPaint !== void 0 ? Scheduler_requestPaint : function() {
      }, syncQueue = null, immediateQueueCallbackNode = null, isFlushingSyncQueue = !1, initialTimeMs$1 = Scheduler_now$1(), now = initialTimeMs$1 < 1e4 ? Scheduler_now$1 : function() {
        return Scheduler_now$1() - initialTimeMs$1;
      };
      function getCurrentPriorityLevel() {
        switch (Scheduler_getCurrentPriorityLevel()) {
          case Scheduler_ImmediatePriority:
            return ImmediatePriority$1;
          case Scheduler_UserBlockingPriority:
            return UserBlockingPriority$2;
          case Scheduler_NormalPriority:
            return NormalPriority$1;
          case Scheduler_LowPriority:
            return LowPriority$1;
          case Scheduler_IdlePriority:
            return IdlePriority$1;
          default:
            throw Error("Unknown priority level.");
        }
      }
      function reactPriorityToSchedulerPriority(reactPriorityLevel) {
        switch (reactPriorityLevel) {
          case ImmediatePriority$1:
            return Scheduler_ImmediatePriority;
          case UserBlockingPriority$2:
            return Scheduler_UserBlockingPriority;
          case NormalPriority$1:
            return Scheduler_NormalPriority;
          case LowPriority$1:
            return Scheduler_LowPriority;
          case IdlePriority$1:
            return Scheduler_IdlePriority;
          default:
            throw Error("Unknown priority level.");
        }
      }
      function runWithPriority$1(reactPriorityLevel, fn) {
        var priorityLevel = reactPriorityToSchedulerPriority(reactPriorityLevel);
        return Scheduler_runWithPriority(priorityLevel, fn);
      }
      function scheduleCallback(reactPriorityLevel, callback, options2) {
        var priorityLevel = reactPriorityToSchedulerPriority(reactPriorityLevel);
        return Scheduler_scheduleCallback(priorityLevel, callback, options2);
      }
      function scheduleSyncCallback(callback) {
        return syncQueue === null ? (syncQueue = [callback], immediateQueueCallbackNode = Scheduler_scheduleCallback(Scheduler_ImmediatePriority, flushSyncCallbackQueueImpl)) : syncQueue.push(callback), fakeCallbackNode;
      }
      function cancelCallback(callbackNode) {
        callbackNode !== fakeCallbackNode && Scheduler_cancelCallback(callbackNode);
      }
      function flushSyncCallbackQueue() {
        if (immediateQueueCallbackNode !== null) {
          var node = immediateQueueCallbackNode;
          immediateQueueCallbackNode = null, Scheduler_cancelCallback(node);
        }
        flushSyncCallbackQueueImpl();
      }
      function flushSyncCallbackQueueImpl() {
        if (!isFlushingSyncQueue && syncQueue !== null) {
          isFlushingSyncQueue = !0;
          var i = 0;
          try {
            var _isSync2 = !0, _queue = syncQueue;
            runWithPriority$1(ImmediatePriority$1, function() {
              for (; i < _queue.length; i++) {
                var callback = _queue[i];
                do
                  callback = callback(_isSync2);
                while (callback !== null);
              }
            }), syncQueue = null;
          } catch (error2) {
            throw syncQueue !== null && (syncQueue = syncQueue.slice(i + 1)), Scheduler_scheduleCallback(Scheduler_ImmediatePriority, flushSyncCallbackQueue), error2;
          } finally {
            isFlushingSyncQueue = !1;
          }
        }
      }
      var ReactVersion = "17.0.2", NoMode = 0, StrictMode = 1, BlockingMode = 2, ConcurrentMode = 4, ProfileMode = 8, DebugTracingMode = 16, ReactCurrentBatchConfig = ReactSharedInternals.ReactCurrentBatchConfig, NoTransition = 0;
      function requestCurrentTransition() {
        return ReactCurrentBatchConfig.transition;
      }
      var ReactStrictModeWarnings = {
        recordUnsafeLifecycleWarnings: function(fiber, instance) {
        },
        flushPendingUnsafeLifecycleWarnings: function() {
        },
        recordLegacyContextWarning: function(fiber, instance) {
        },
        flushLegacyContextWarning: function() {
        },
        discardPendingWarnings: function() {
        }
      };
      {
        var findStrictRoot = function(fiber) {
          for (var maybeStrictRoot = null, node = fiber; node !== null; )
            node.mode & StrictMode && (maybeStrictRoot = node), node = node.return;
          return maybeStrictRoot;
        }, setToSortedString = function(set2) {
          var array = [];
          return set2.forEach(function(value) {
            array.push(value);
          }), array.sort().join(", ");
        }, pendingComponentWillMountWarnings = [], pendingUNSAFE_ComponentWillMountWarnings = [], pendingComponentWillReceivePropsWarnings = [], pendingUNSAFE_ComponentWillReceivePropsWarnings = [], pendingComponentWillUpdateWarnings = [], pendingUNSAFE_ComponentWillUpdateWarnings = [], didWarnAboutUnsafeLifecycles = /* @__PURE__ */ new Set();
        ReactStrictModeWarnings.recordUnsafeLifecycleWarnings = function(fiber, instance) {
          didWarnAboutUnsafeLifecycles.has(fiber.type) || (typeof instance.componentWillMount == "function" && instance.componentWillMount.__suppressDeprecationWarning !== !0 && pendingComponentWillMountWarnings.push(fiber), fiber.mode & StrictMode && typeof instance.UNSAFE_componentWillMount == "function" && pendingUNSAFE_ComponentWillMountWarnings.push(fiber), typeof instance.componentWillReceiveProps == "function" && instance.componentWillReceiveProps.__suppressDeprecationWarning !== !0 && pendingComponentWillReceivePropsWarnings.push(fiber), fiber.mode & StrictMode && typeof instance.UNSAFE_componentWillReceiveProps == "function" && pendingUNSAFE_ComponentWillReceivePropsWarnings.push(fiber), typeof instance.componentWillUpdate == "function" && instance.componentWillUpdate.__suppressDeprecationWarning !== !0 && pendingComponentWillUpdateWarnings.push(fiber), fiber.mode & StrictMode && typeof instance.UNSAFE_componentWillUpdate == "function" && pendingUNSAFE_ComponentWillUpdateWarnings.push(fiber));
        }, ReactStrictModeWarnings.flushPendingUnsafeLifecycleWarnings = function() {
          var componentWillMountUniqueNames = /* @__PURE__ */ new Set();
          pendingComponentWillMountWarnings.length > 0 && (pendingComponentWillMountWarnings.forEach(function(fiber) {
            componentWillMountUniqueNames.add(getComponentName(fiber.type) || "Component"), didWarnAboutUnsafeLifecycles.add(fiber.type);
          }), pendingComponentWillMountWarnings = []);
          var UNSAFE_componentWillMountUniqueNames = /* @__PURE__ */ new Set();
          pendingUNSAFE_ComponentWillMountWarnings.length > 0 && (pendingUNSAFE_ComponentWillMountWarnings.forEach(function(fiber) {
            UNSAFE_componentWillMountUniqueNames.add(getComponentName(fiber.type) || "Component"), didWarnAboutUnsafeLifecycles.add(fiber.type);
          }), pendingUNSAFE_ComponentWillMountWarnings = []);
          var componentWillReceivePropsUniqueNames = /* @__PURE__ */ new Set();
          pendingComponentWillReceivePropsWarnings.length > 0 && (pendingComponentWillReceivePropsWarnings.forEach(function(fiber) {
            componentWillReceivePropsUniqueNames.add(getComponentName(fiber.type) || "Component"), didWarnAboutUnsafeLifecycles.add(fiber.type);
          }), pendingComponentWillReceivePropsWarnings = []);
          var UNSAFE_componentWillReceivePropsUniqueNames = /* @__PURE__ */ new Set();
          pendingUNSAFE_ComponentWillReceivePropsWarnings.length > 0 && (pendingUNSAFE_ComponentWillReceivePropsWarnings.forEach(function(fiber) {
            UNSAFE_componentWillReceivePropsUniqueNames.add(getComponentName(fiber.type) || "Component"), didWarnAboutUnsafeLifecycles.add(fiber.type);
          }), pendingUNSAFE_ComponentWillReceivePropsWarnings = []);
          var componentWillUpdateUniqueNames = /* @__PURE__ */ new Set();
          pendingComponentWillUpdateWarnings.length > 0 && (pendingComponentWillUpdateWarnings.forEach(function(fiber) {
            componentWillUpdateUniqueNames.add(getComponentName(fiber.type) || "Component"), didWarnAboutUnsafeLifecycles.add(fiber.type);
          }), pendingComponentWillUpdateWarnings = []);
          var UNSAFE_componentWillUpdateUniqueNames = /* @__PURE__ */ new Set();
          if (pendingUNSAFE_ComponentWillUpdateWarnings.length > 0 && (pendingUNSAFE_ComponentWillUpdateWarnings.forEach(function(fiber) {
            UNSAFE_componentWillUpdateUniqueNames.add(getComponentName(fiber.type) || "Component"), didWarnAboutUnsafeLifecycles.add(fiber.type);
          }), pendingUNSAFE_ComponentWillUpdateWarnings = []), UNSAFE_componentWillMountUniqueNames.size > 0) {
            var sortedNames = setToSortedString(UNSAFE_componentWillMountUniqueNames);
            error(`Using UNSAFE_componentWillMount in strict mode is not recommended and may indicate bugs in your code. See https://reactjs.org/link/unsafe-component-lifecycles for details.

* Move code with side effects to componentDidMount, and set initial state in the constructor.

Please update the following components: %s`, sortedNames);
          }
          if (UNSAFE_componentWillReceivePropsUniqueNames.size > 0) {
            var _sortedNames = setToSortedString(UNSAFE_componentWillReceivePropsUniqueNames);
            error(`Using UNSAFE_componentWillReceiveProps in strict mode is not recommended and may indicate bugs in your code. See https://reactjs.org/link/unsafe-component-lifecycles for details.

* Move data fetching code or side effects to componentDidUpdate.
* If you're updating state whenever props change, refactor your code to use memoization techniques or move it to static getDerivedStateFromProps. Learn more at: https://reactjs.org/link/derived-state

Please update the following components: %s`, _sortedNames);
          }
          if (UNSAFE_componentWillUpdateUniqueNames.size > 0) {
            var _sortedNames2 = setToSortedString(UNSAFE_componentWillUpdateUniqueNames);
            error(`Using UNSAFE_componentWillUpdate in strict mode is not recommended and may indicate bugs in your code. See https://reactjs.org/link/unsafe-component-lifecycles for details.

* Move data fetching code or side effects to componentDidUpdate.

Please update the following components: %s`, _sortedNames2);
          }
          if (componentWillMountUniqueNames.size > 0) {
            var _sortedNames3 = setToSortedString(componentWillMountUniqueNames);
            warn(`componentWillMount has been renamed, and is not recommended for use. See https://reactjs.org/link/unsafe-component-lifecycles for details.

* Move code with side effects to componentDidMount, and set initial state in the constructor.
* Rename componentWillMount to UNSAFE_componentWillMount to suppress this warning in non-strict mode. In React 18.x, only the UNSAFE_ name will work. To rename all deprecated lifecycles to their new names, you can run \`npx react-codemod rename-unsafe-lifecycles\` in your project source folder.

Please update the following components: %s`, _sortedNames3);
          }
          if (componentWillReceivePropsUniqueNames.size > 0) {
            var _sortedNames4 = setToSortedString(componentWillReceivePropsUniqueNames);
            warn(`componentWillReceiveProps has been renamed, and is not recommended for use. See https://reactjs.org/link/unsafe-component-lifecycles for details.

* Move data fetching code or side effects to componentDidUpdate.
* If you're updating state whenever props change, refactor your code to use memoization techniques or move it to static getDerivedStateFromProps. Learn more at: https://reactjs.org/link/derived-state
* Rename componentWillReceiveProps to UNSAFE_componentWillReceiveProps to suppress this warning in non-strict mode. In React 18.x, only the UNSAFE_ name will work. To rename all deprecated lifecycles to their new names, you can run \`npx react-codemod rename-unsafe-lifecycles\` in your project source folder.

Please update the following components: %s`, _sortedNames4);
          }
          if (componentWillUpdateUniqueNames.size > 0) {
            var _sortedNames5 = setToSortedString(componentWillUpdateUniqueNames);
            warn(`componentWillUpdate has been renamed, and is not recommended for use. See https://reactjs.org/link/unsafe-component-lifecycles for details.

* Move data fetching code or side effects to componentDidUpdate.
* Rename componentWillUpdate to UNSAFE_componentWillUpdate to suppress this warning in non-strict mode. In React 18.x, only the UNSAFE_ name will work. To rename all deprecated lifecycles to their new names, you can run \`npx react-codemod rename-unsafe-lifecycles\` in your project source folder.

Please update the following components: %s`, _sortedNames5);
          }
        };
        var pendingLegacyContextWarning = /* @__PURE__ */ new Map(), didWarnAboutLegacyContext = /* @__PURE__ */ new Set();
        ReactStrictModeWarnings.recordLegacyContextWarning = function(fiber, instance) {
          var strictRoot = findStrictRoot(fiber);
          if (strictRoot === null) {
            error("Expected to find a StrictMode component in a strict mode tree. This error is likely caused by a bug in React. Please file an issue.");
            return;
          }
          if (!didWarnAboutLegacyContext.has(fiber.type)) {
            var warningsForRoot = pendingLegacyContextWarning.get(strictRoot);
            (fiber.type.contextTypes != null || fiber.type.childContextTypes != null || instance !== null && typeof instance.getChildContext == "function") && (warningsForRoot === void 0 && (warningsForRoot = [], pendingLegacyContextWarning.set(strictRoot, warningsForRoot)), warningsForRoot.push(fiber));
          }
        }, ReactStrictModeWarnings.flushLegacyContextWarning = function() {
          pendingLegacyContextWarning.forEach(function(fiberArray, strictRoot) {
            if (fiberArray.length !== 0) {
              var firstFiber = fiberArray[0], uniqueNames = /* @__PURE__ */ new Set();
              fiberArray.forEach(function(fiber) {
                uniqueNames.add(getComponentName(fiber.type) || "Component"), didWarnAboutLegacyContext.add(fiber.type);
              });
              var sortedNames = setToSortedString(uniqueNames);
              try {
                setCurrentFiber(firstFiber), error(`Legacy context API has been detected within a strict-mode tree.

The old API will be supported in all 16.x releases, but applications using it should migrate to the new version.

Please update the following components: %s

Learn more about this warning here: https://reactjs.org/link/legacy-context`, sortedNames);
              } finally {
                resetCurrentFiber();
              }
            }
          });
        }, ReactStrictModeWarnings.discardPendingWarnings = function() {
          pendingComponentWillMountWarnings = [], pendingUNSAFE_ComponentWillMountWarnings = [], pendingComponentWillReceivePropsWarnings = [], pendingUNSAFE_ComponentWillReceivePropsWarnings = [], pendingComponentWillUpdateWarnings = [], pendingUNSAFE_ComponentWillUpdateWarnings = [], pendingLegacyContextWarning = /* @__PURE__ */ new Map();
        };
      }
      function resolveDefaultProps(Component, baseProps) {
        if (Component && Component.defaultProps) {
          var props = _assign({}, baseProps), defaultProps2 = Component.defaultProps;
          for (var propName in defaultProps2)
            props[propName] === void 0 && (props[propName] = defaultProps2[propName]);
          return props;
        }
        return baseProps;
      }
      var MAX_SIGNED_31_BIT_INT = 1073741823, valueCursor = createCursor(null), rendererSigil;
      rendererSigil = {};
      var currentlyRenderingFiber = null, lastContextDependency = null, lastContextWithAllBitsObserved = null, isDisallowedContextReadInDEV = !1;
      function resetContextDependencies() {
        currentlyRenderingFiber = null, lastContextDependency = null, lastContextWithAllBitsObserved = null, isDisallowedContextReadInDEV = !1;
      }
      function enterDisallowedContextReadInDEV() {
        isDisallowedContextReadInDEV = !0;
      }
      function exitDisallowedContextReadInDEV() {
        isDisallowedContextReadInDEV = !1;
      }
      function pushProvider(providerFiber, nextValue) {
        var context = providerFiber.type._context;
        push(valueCursor, context._currentValue, providerFiber), context._currentValue = nextValue, context._currentRenderer !== void 0 && context._currentRenderer !== null && context._currentRenderer !== rendererSigil && error("Detected multiple renderers concurrently rendering the same context provider. This is currently unsupported."), context._currentRenderer = rendererSigil;
      }
      function popProvider(providerFiber) {
        var currentValue = valueCursor.current;
        pop(valueCursor, providerFiber);
        var context = providerFiber.type._context;
        context._currentValue = currentValue;
      }
      function calculateChangedBits(context, newValue, oldValue) {
        if (objectIs(oldValue, newValue))
          return 0;
        var changedBits = typeof context._calculateChangedBits == "function" ? context._calculateChangedBits(oldValue, newValue) : MAX_SIGNED_31_BIT_INT;
        return (changedBits & MAX_SIGNED_31_BIT_INT) !== changedBits && error("calculateChangedBits: Expected the return value to be a 31-bit integer. Instead received: %s", changedBits), changedBits | 0;
      }
      function scheduleWorkOnParentPath(parent, renderLanes2) {
        for (var node = parent; node !== null; ) {
          var alternate = node.alternate;
          if (!isSubsetOfLanes(node.childLanes, renderLanes2))
            node.childLanes = mergeLanes(node.childLanes, renderLanes2), alternate !== null && (alternate.childLanes = mergeLanes(alternate.childLanes, renderLanes2));
          else if (alternate !== null && !isSubsetOfLanes(alternate.childLanes, renderLanes2))
            alternate.childLanes = mergeLanes(alternate.childLanes, renderLanes2);
          else
            break;
          node = node.return;
        }
      }
      function propagateContextChange(workInProgress2, context, changedBits, renderLanes2) {
        var fiber = workInProgress2.child;
        for (fiber !== null && (fiber.return = workInProgress2); fiber !== null; ) {
          var nextFiber = void 0, list = fiber.dependencies;
          if (list !== null) {
            nextFiber = fiber.child;
            for (var dependency = list.firstContext; dependency !== null; ) {
              if (dependency.context === context && (dependency.observedBits & changedBits) !== 0) {
                if (fiber.tag === ClassComponent) {
                  var update = createUpdate(NoTimestamp, pickArbitraryLane(renderLanes2));
                  update.tag = ForceUpdate, enqueueUpdate(fiber, update);
                }
                fiber.lanes = mergeLanes(fiber.lanes, renderLanes2);
                var alternate = fiber.alternate;
                alternate !== null && (alternate.lanes = mergeLanes(alternate.lanes, renderLanes2)), scheduleWorkOnParentPath(fiber.return, renderLanes2), list.lanes = mergeLanes(list.lanes, renderLanes2);
                break;
              }
              dependency = dependency.next;
            }
          } else
            fiber.tag === ContextProvider ? nextFiber = fiber.type === workInProgress2.type ? null : fiber.child : nextFiber = fiber.child;
          if (nextFiber !== null)
            nextFiber.return = fiber;
          else
            for (nextFiber = fiber; nextFiber !== null; ) {
              if (nextFiber === workInProgress2) {
                nextFiber = null;
                break;
              }
              var sibling = nextFiber.sibling;
              if (sibling !== null) {
                sibling.return = nextFiber.return, nextFiber = sibling;
                break;
              }
              nextFiber = nextFiber.return;
            }
          fiber = nextFiber;
        }
      }
      function prepareToReadContext(workInProgress2, renderLanes2) {
        currentlyRenderingFiber = workInProgress2, lastContextDependency = null, lastContextWithAllBitsObserved = null;
        var dependencies = workInProgress2.dependencies;
        if (dependencies !== null) {
          var firstContext = dependencies.firstContext;
          firstContext !== null && (includesSomeLane(dependencies.lanes, renderLanes2) && markWorkInProgressReceivedUpdate(), dependencies.firstContext = null);
        }
      }
      function readContext(context, observedBits) {
        if (isDisallowedContextReadInDEV && error("Context can only be read while React is rendering. In classes, you can read it in the render method or getDerivedStateFromProps. In function components, you can read it directly in the function body, but not inside Hooks like useReducer() or useMemo()."), lastContextWithAllBitsObserved !== context) {
          if (!(observedBits === !1 || observedBits === 0)) {
            var resolvedObservedBits;
            typeof observedBits != "number" || observedBits === MAX_SIGNED_31_BIT_INT ? (lastContextWithAllBitsObserved = context, resolvedObservedBits = MAX_SIGNED_31_BIT_INT) : resolvedObservedBits = observedBits;
            var contextItem = {
              context,
              observedBits: resolvedObservedBits,
              next: null
            };
            if (lastContextDependency === null) {
              if (currentlyRenderingFiber === null)
                throw Error("Context can only be read while React is rendering. In classes, you can read it in the render method or getDerivedStateFromProps. In function components, you can read it directly in the function body, but not inside Hooks like useReducer() or useMemo().");
              lastContextDependency = contextItem, currentlyRenderingFiber.dependencies = {
                lanes: NoLanes,
                firstContext: contextItem,
                responders: null
              };
            } else
              lastContextDependency = lastContextDependency.next = contextItem;
          }
        }
        return context._currentValue;
      }
      var UpdateState = 0, ReplaceState = 1, ForceUpdate = 2, CaptureUpdate = 3, hasForceUpdate = !1, didWarnUpdateInsideUpdate, currentlyProcessingQueue;
      didWarnUpdateInsideUpdate = !1, currentlyProcessingQueue = null;
      function initializeUpdateQueue(fiber) {
        var queue2 = {
          baseState: fiber.memoizedState,
          firstBaseUpdate: null,
          lastBaseUpdate: null,
          shared: {
            pending: null
          },
          effects: null
        };
        fiber.updateQueue = queue2;
      }
      function cloneUpdateQueue(current2, workInProgress2) {
        var queue2 = workInProgress2.updateQueue, currentQueue2 = current2.updateQueue;
        if (queue2 === currentQueue2) {
          var clone = {
            baseState: currentQueue2.baseState,
            firstBaseUpdate: currentQueue2.firstBaseUpdate,
            lastBaseUpdate: currentQueue2.lastBaseUpdate,
            shared: currentQueue2.shared,
            effects: currentQueue2.effects
          };
          workInProgress2.updateQueue = clone;
        }
      }
      function createUpdate(eventTime, lane) {
        var update = {
          eventTime,
          lane,
          tag: UpdateState,
          payload: null,
          callback: null,
          next: null
        };
        return update;
      }
      function enqueueUpdate(fiber, update) {
        var updateQueue = fiber.updateQueue;
        if (updateQueue !== null) {
          var sharedQueue = updateQueue.shared, pending = sharedQueue.pending;
          pending === null ? update.next = update : (update.next = pending.next, pending.next = update), sharedQueue.pending = update, currentlyProcessingQueue === sharedQueue && !didWarnUpdateInsideUpdate && (error("An update (setState, replaceState, or forceUpdate) was scheduled from inside an update function. Update functions should be pure, with zero side-effects. Consider using componentDidUpdate or a callback."), didWarnUpdateInsideUpdate = !0);
        }
      }
      function enqueueCapturedUpdate(workInProgress2, capturedUpdate) {
        var queue2 = workInProgress2.updateQueue, current2 = workInProgress2.alternate;
        if (current2 !== null) {
          var currentQueue2 = current2.updateQueue;
          if (queue2 === currentQueue2) {
            var newFirst = null, newLast = null, firstBaseUpdate = queue2.firstBaseUpdate;
            if (firstBaseUpdate !== null) {
              var update = firstBaseUpdate;
              do {
                var clone = {
                  eventTime: update.eventTime,
                  lane: update.lane,
                  tag: update.tag,
                  payload: update.payload,
                  callback: update.callback,
                  next: null
                };
                newLast === null ? newFirst = newLast = clone : (newLast.next = clone, newLast = clone), update = update.next;
              } while (update !== null);
              newLast === null ? newFirst = newLast = capturedUpdate : (newLast.next = capturedUpdate, newLast = capturedUpdate);
            } else
              newFirst = newLast = capturedUpdate;
            queue2 = {
              baseState: currentQueue2.baseState,
              firstBaseUpdate: newFirst,
              lastBaseUpdate: newLast,
              shared: currentQueue2.shared,
              effects: currentQueue2.effects
            }, workInProgress2.updateQueue = queue2;
            return;
          }
        }
        var lastBaseUpdate = queue2.lastBaseUpdate;
        lastBaseUpdate === null ? queue2.firstBaseUpdate = capturedUpdate : lastBaseUpdate.next = capturedUpdate, queue2.lastBaseUpdate = capturedUpdate;
      }
      function getStateFromUpdate(workInProgress2, queue2, update, prevState, nextProps, instance) {
        switch (update.tag) {
          case ReplaceState: {
            var payload = update.payload;
            if (typeof payload == "function") {
              enterDisallowedContextReadInDEV();
              var nextState = payload.call(instance, prevState, nextProps);
              {
                if (workInProgress2.mode & StrictMode) {
                  disableLogs();
                  try {
                    payload.call(instance, prevState, nextProps);
                  } finally {
                    reenableLogs();
                  }
                }
                exitDisallowedContextReadInDEV();
              }
              return nextState;
            }
            return payload;
          }
          case CaptureUpdate:
            workInProgress2.flags = workInProgress2.flags & ~ShouldCapture | DidCapture;
          case UpdateState: {
            var _payload = update.payload, partialState;
            if (typeof _payload == "function") {
              enterDisallowedContextReadInDEV(), partialState = _payload.call(instance, prevState, nextProps);
              {
                if (workInProgress2.mode & StrictMode) {
                  disableLogs();
                  try {
                    _payload.call(instance, prevState, nextProps);
                  } finally {
                    reenableLogs();
                  }
                }
                exitDisallowedContextReadInDEV();
              }
            } else
              partialState = _payload;
            return partialState == null ? prevState : _assign({}, prevState, partialState);
          }
          case ForceUpdate:
            return hasForceUpdate = !0, prevState;
        }
        return prevState;
      }
      function processUpdateQueue(workInProgress2, props, instance, renderLanes2) {
        var queue2 = workInProgress2.updateQueue;
        hasForceUpdate = !1, currentlyProcessingQueue = queue2.shared;
        var firstBaseUpdate = queue2.firstBaseUpdate, lastBaseUpdate = queue2.lastBaseUpdate, pendingQueue = queue2.shared.pending;
        if (pendingQueue !== null) {
          queue2.shared.pending = null;
          var lastPendingUpdate = pendingQueue, firstPendingUpdate = lastPendingUpdate.next;
          lastPendingUpdate.next = null, lastBaseUpdate === null ? firstBaseUpdate = firstPendingUpdate : lastBaseUpdate.next = firstPendingUpdate, lastBaseUpdate = lastPendingUpdate;
          var current2 = workInProgress2.alternate;
          if (current2 !== null) {
            var currentQueue2 = current2.updateQueue, currentLastBaseUpdate = currentQueue2.lastBaseUpdate;
            currentLastBaseUpdate !== lastBaseUpdate && (currentLastBaseUpdate === null ? currentQueue2.firstBaseUpdate = firstPendingUpdate : currentLastBaseUpdate.next = firstPendingUpdate, currentQueue2.lastBaseUpdate = lastPendingUpdate);
          }
        }
        if (firstBaseUpdate !== null) {
          var newState = queue2.baseState, newLanes = NoLanes, newBaseState = null, newFirstBaseUpdate = null, newLastBaseUpdate = null, update = firstBaseUpdate;
          do {
            var updateLane = update.lane, updateEventTime = update.eventTime;
            if (isSubsetOfLanes(renderLanes2, updateLane)) {
              if (newLastBaseUpdate !== null) {
                var _clone = {
                  eventTime: updateEventTime,
                  lane: NoLane,
                  tag: update.tag,
                  payload: update.payload,
                  callback: update.callback,
                  next: null
                };
                newLastBaseUpdate = newLastBaseUpdate.next = _clone;
              }
              newState = getStateFromUpdate(workInProgress2, queue2, update, newState, props, instance);
              var callback = update.callback;
              if (callback !== null) {
                workInProgress2.flags |= Callback;
                var effects = queue2.effects;
                effects === null ? queue2.effects = [update] : effects.push(update);
              }
            } else {
              var clone = {
                eventTime: updateEventTime,
                lane: updateLane,
                tag: update.tag,
                payload: update.payload,
                callback: update.callback,
                next: null
              };
              newLastBaseUpdate === null ? (newFirstBaseUpdate = newLastBaseUpdate = clone, newBaseState = newState) : newLastBaseUpdate = newLastBaseUpdate.next = clone, newLanes = mergeLanes(newLanes, updateLane);
            }
            if (update = update.next, update === null) {
              if (pendingQueue = queue2.shared.pending, pendingQueue === null)
                break;
              var _lastPendingUpdate = pendingQueue, _firstPendingUpdate = _lastPendingUpdate.next;
              _lastPendingUpdate.next = null, update = _firstPendingUpdate, queue2.lastBaseUpdate = _lastPendingUpdate, queue2.shared.pending = null;
            }
          } while (!0);
          newLastBaseUpdate === null && (newBaseState = newState), queue2.baseState = newBaseState, queue2.firstBaseUpdate = newFirstBaseUpdate, queue2.lastBaseUpdate = newLastBaseUpdate, markSkippedUpdateLanes(newLanes), workInProgress2.lanes = newLanes, workInProgress2.memoizedState = newState;
        }
        currentlyProcessingQueue = null;
      }
      function callCallback(callback, context) {
        if (typeof callback != "function")
          throw Error("Invalid argument passed as callback. Expected a function. Instead received: " + callback);
        callback.call(context);
      }
      function resetHasForceUpdateBeforeProcessing() {
        hasForceUpdate = !1;
      }
      function checkHasForceUpdateAfterProcessing() {
        return hasForceUpdate;
      }
      function commitUpdateQueue(finishedWork, finishedQueue, instance) {
        var effects = finishedQueue.effects;
        if (finishedQueue.effects = null, effects !== null)
          for (var i = 0; i < effects.length; i++) {
            var effect = effects[i], callback = effect.callback;
            callback !== null && (effect.callback = null, callCallback(callback, instance));
          }
      }
      var fakeInternalInstance = {}, isArray3 = Array.isArray, emptyRefsObject = new React90.Component().refs, didWarnAboutStateAssignmentForComponent, didWarnAboutUninitializedState, didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate, didWarnAboutLegacyLifecyclesAndDerivedState, didWarnAboutUndefinedDerivedState, warnOnUndefinedDerivedState, warnOnInvalidCallback, didWarnAboutDirectlyAssigningPropsToState, didWarnAboutContextTypeAndContextTypes, didWarnAboutInvalidateContextType;
      {
        didWarnAboutStateAssignmentForComponent = /* @__PURE__ */ new Set(), didWarnAboutUninitializedState = /* @__PURE__ */ new Set(), didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate = /* @__PURE__ */ new Set(), didWarnAboutLegacyLifecyclesAndDerivedState = /* @__PURE__ */ new Set(), didWarnAboutDirectlyAssigningPropsToState = /* @__PURE__ */ new Set(), didWarnAboutUndefinedDerivedState = /* @__PURE__ */ new Set(), didWarnAboutContextTypeAndContextTypes = /* @__PURE__ */ new Set(), didWarnAboutInvalidateContextType = /* @__PURE__ */ new Set();
        var didWarnOnInvalidCallback = /* @__PURE__ */ new Set();
        warnOnInvalidCallback = function(callback, callerName) {
          if (!(callback === null || typeof callback == "function")) {
            var key = callerName + "_" + callback;
            didWarnOnInvalidCallback.has(key) || (didWarnOnInvalidCallback.add(key), error("%s(...): Expected the last optional `callback` argument to be a function. Instead received: %s.", callerName, callback));
          }
        }, warnOnUndefinedDerivedState = function(type, partialState) {
          if (partialState === void 0) {
            var componentName = getComponentName(type) || "Component";
            didWarnAboutUndefinedDerivedState.has(componentName) || (didWarnAboutUndefinedDerivedState.add(componentName), error("%s.getDerivedStateFromProps(): A valid state object (or null) must be returned. You have returned undefined.", componentName));
          }
        }, Object.defineProperty(fakeInternalInstance, "_processChildContext", {
          enumerable: !1,
          value: function() {
            throw Error("_processChildContext is not available in React 16+. This likely means you have multiple copies of React and are attempting to nest a React 15 tree inside a React 16 tree using unstable_renderSubtreeIntoContainer, which isn't supported. Try to make sure you have only one copy of React (and ideally, switch to ReactDOM.createPortal).");
          }
        }), Object.freeze(fakeInternalInstance);
      }
      function applyDerivedStateFromProps(workInProgress2, ctor, getDerivedStateFromProps, nextProps) {
        var prevState = workInProgress2.memoizedState;
        if (workInProgress2.mode & StrictMode) {
          disableLogs();
          try {
            getDerivedStateFromProps(nextProps, prevState);
          } finally {
            reenableLogs();
          }
        }
        var partialState = getDerivedStateFromProps(nextProps, prevState);
        warnOnUndefinedDerivedState(ctor, partialState);
        var memoizedState = partialState == null ? prevState : _assign({}, prevState, partialState);
        if (workInProgress2.memoizedState = memoizedState, workInProgress2.lanes === NoLanes) {
          var updateQueue = workInProgress2.updateQueue;
          updateQueue.baseState = memoizedState;
        }
      }
      var classComponentUpdater = {
        isMounted,
        enqueueSetState: function(inst, payload, callback) {
          var fiber = get(inst), eventTime = requestEventTime(), lane = requestUpdateLane(fiber), update = createUpdate(eventTime, lane);
          update.payload = payload, callback != null && (warnOnInvalidCallback(callback, "setState"), update.callback = callback), enqueueUpdate(fiber, update), scheduleUpdateOnFiber(fiber, lane, eventTime);
        },
        enqueueReplaceState: function(inst, payload, callback) {
          var fiber = get(inst), eventTime = requestEventTime(), lane = requestUpdateLane(fiber), update = createUpdate(eventTime, lane);
          update.tag = ReplaceState, update.payload = payload, callback != null && (warnOnInvalidCallback(callback, "replaceState"), update.callback = callback), enqueueUpdate(fiber, update), scheduleUpdateOnFiber(fiber, lane, eventTime);
        },
        enqueueForceUpdate: function(inst, callback) {
          var fiber = get(inst), eventTime = requestEventTime(), lane = requestUpdateLane(fiber), update = createUpdate(eventTime, lane);
          update.tag = ForceUpdate, callback != null && (warnOnInvalidCallback(callback, "forceUpdate"), update.callback = callback), enqueueUpdate(fiber, update), scheduleUpdateOnFiber(fiber, lane, eventTime);
        }
      };
      function checkShouldComponentUpdate(workInProgress2, ctor, oldProps, newProps, oldState, newState, nextContext) {
        var instance = workInProgress2.stateNode;
        if (typeof instance.shouldComponentUpdate == "function") {
          if (workInProgress2.mode & StrictMode) {
            disableLogs();
            try {
              instance.shouldComponentUpdate(newProps, newState, nextContext);
            } finally {
              reenableLogs();
            }
          }
          var shouldUpdate = instance.shouldComponentUpdate(newProps, newState, nextContext);
          return shouldUpdate === void 0 && error("%s.shouldComponentUpdate(): Returned undefined instead of a boolean value. Make sure to return true or false.", getComponentName(ctor) || "Component"), shouldUpdate;
        }
        return ctor.prototype && ctor.prototype.isPureReactComponent ? !shallowEqual(oldProps, newProps) || !shallowEqual(oldState, newState) : !0;
      }
      function checkClassInstance(workInProgress2, ctor, newProps) {
        var instance = workInProgress2.stateNode;
        {
          var name = getComponentName(ctor) || "Component", renderPresent = instance.render;
          renderPresent || (ctor.prototype && typeof ctor.prototype.render == "function" ? error("%s(...): No `render` method found on the returned component instance: did you accidentally return an object from the constructor?", name) : error("%s(...): No `render` method found on the returned component instance: you may have forgotten to define `render`.", name)), instance.getInitialState && !instance.getInitialState.isReactClassApproved && !instance.state && error("getInitialState was defined on %s, a plain JavaScript class. This is only supported for classes created using React.createClass. Did you mean to define a state property instead?", name), instance.getDefaultProps && !instance.getDefaultProps.isReactClassApproved && error("getDefaultProps was defined on %s, a plain JavaScript class. This is only supported for classes created using React.createClass. Use a static property to define defaultProps instead.", name), instance.propTypes && error("propTypes was defined as an instance property on %s. Use a static property to define propTypes instead.", name), instance.contextType && error("contextType was defined as an instance property on %s. Use a static property to define contextType instead.", name), instance.contextTypes && error("contextTypes was defined as an instance property on %s. Use a static property to define contextTypes instead.", name), ctor.contextType && ctor.contextTypes && !didWarnAboutContextTypeAndContextTypes.has(ctor) && (didWarnAboutContextTypeAndContextTypes.add(ctor), error("%s declares both contextTypes and contextType static properties. The legacy contextTypes property will be ignored.", name)), typeof instance.componentShouldUpdate == "function" && error("%s has a method called componentShouldUpdate(). Did you mean shouldComponentUpdate()? The name is phrased as a question because the function is expected to return a value.", name), ctor.prototype && ctor.prototype.isPureReactComponent && typeof instance.shouldComponentUpdate < "u" && error("%s has a method called shouldComponentUpdate(). shouldComponentUpdate should not be used when extending React.PureComponent. Please extend React.Component if shouldComponentUpdate is used.", getComponentName(ctor) || "A pure component"), typeof instance.componentDidUnmount == "function" && error("%s has a method called componentDidUnmount(). But there is no such lifecycle method. Did you mean componentWillUnmount()?", name), typeof instance.componentDidReceiveProps == "function" && error("%s has a method called componentDidReceiveProps(). But there is no such lifecycle method. If you meant to update the state in response to changing props, use componentWillReceiveProps(). If you meant to fetch data or run side-effects or mutations after React has updated the UI, use componentDidUpdate().", name), typeof instance.componentWillRecieveProps == "function" && error("%s has a method called componentWillRecieveProps(). Did you mean componentWillReceiveProps()?", name), typeof instance.UNSAFE_componentWillRecieveProps == "function" && error("%s has a method called UNSAFE_componentWillRecieveProps(). Did you mean UNSAFE_componentWillReceiveProps()?", name);
          var hasMutatedProps = instance.props !== newProps;
          instance.props !== void 0 && hasMutatedProps && error("%s(...): When calling super() in `%s`, make sure to pass up the same props that your component's constructor was passed.", name, name), instance.defaultProps && error("Setting defaultProps as an instance property on %s is not supported and will be ignored. Instead, define defaultProps as a static property on %s.", name, name), typeof instance.getSnapshotBeforeUpdate == "function" && typeof instance.componentDidUpdate != "function" && !didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate.has(ctor) && (didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate.add(ctor), error("%s: getSnapshotBeforeUpdate() should be used with componentDidUpdate(). This component defines getSnapshotBeforeUpdate() only.", getComponentName(ctor))), typeof instance.getDerivedStateFromProps == "function" && error("%s: getDerivedStateFromProps() is defined as an instance method and will be ignored. Instead, declare it as a static method.", name), typeof instance.getDerivedStateFromError == "function" && error("%s: getDerivedStateFromError() is defined as an instance method and will be ignored. Instead, declare it as a static method.", name), typeof ctor.getSnapshotBeforeUpdate == "function" && error("%s: getSnapshotBeforeUpdate() is defined as a static method and will be ignored. Instead, declare it as an instance method.", name);
          var _state = instance.state;
          _state && (typeof _state != "object" || isArray3(_state)) && error("%s.state: must be set to an object or null", name), typeof instance.getChildContext == "function" && typeof ctor.childContextTypes != "object" && error("%s.getChildContext(): childContextTypes must be defined in order to use getChildContext().", name);
        }
      }
      function adoptClassInstance(workInProgress2, instance) {
        instance.updater = classComponentUpdater, workInProgress2.stateNode = instance, set(instance, workInProgress2), instance._reactInternalInstance = fakeInternalInstance;
      }
      function constructClassInstance(workInProgress2, ctor, props) {
        var isLegacyContextConsumer = !1, unmaskedContext = emptyContextObject, context = emptyContextObject, contextType = ctor.contextType;
        if ("contextType" in ctor) {
          var isValid = contextType === null || contextType !== void 0 && contextType.$$typeof === REACT_CONTEXT_TYPE && contextType._context === void 0;
          if (!isValid && !didWarnAboutInvalidateContextType.has(ctor)) {
            didWarnAboutInvalidateContextType.add(ctor);
            var addendum = "";
            contextType === void 0 ? addendum = " However, it is set to undefined. This can be caused by a typo or by mixing up named and default imports. This can also happen due to a circular dependency, so try moving the createContext() call to a separate file." : typeof contextType != "object" ? addendum = " However, it is set to a " + typeof contextType + "." : contextType.$$typeof === REACT_PROVIDER_TYPE ? addendum = " Did you accidentally pass the Context.Provider instead?" : contextType._context !== void 0 ? addendum = " Did you accidentally pass the Context.Consumer instead?" : addendum = " However, it is set to an object with keys {" + Object.keys(contextType).join(", ") + "}.", error("%s defines an invalid contextType. contextType should point to the Context object returned by React.createContext().%s", getComponentName(ctor) || "Component", addendum);
          }
        }
        if (typeof contextType == "object" && contextType !== null)
          context = readContext(contextType);
        else {
          unmaskedContext = getUnmaskedContext(workInProgress2, ctor, !0);
          var contextTypes = ctor.contextTypes;
          isLegacyContextConsumer = contextTypes != null, context = isLegacyContextConsumer ? getMaskedContext(workInProgress2, unmaskedContext) : emptyContextObject;
        }
        if (workInProgress2.mode & StrictMode) {
          disableLogs();
          try {
            new ctor(props, context);
          } finally {
            reenableLogs();
          }
        }
        var instance = new ctor(props, context), state = workInProgress2.memoizedState = instance.state !== null && instance.state !== void 0 ? instance.state : null;
        adoptClassInstance(workInProgress2, instance);
        {
          if (typeof ctor.getDerivedStateFromProps == "function" && state === null) {
            var componentName = getComponentName(ctor) || "Component";
            didWarnAboutUninitializedState.has(componentName) || (didWarnAboutUninitializedState.add(componentName), error("`%s` uses `getDerivedStateFromProps` but its initial state is %s. This is not recommended. Instead, define the initial state by assigning an object to `this.state` in the constructor of `%s`. This ensures that `getDerivedStateFromProps` arguments have a consistent shape.", componentName, instance.state === null ? "null" : "undefined", componentName));
          }
          if (typeof ctor.getDerivedStateFromProps == "function" || typeof instance.getSnapshotBeforeUpdate == "function") {
            var foundWillMountName = null, foundWillReceivePropsName = null, foundWillUpdateName = null;
            if (typeof instance.componentWillMount == "function" && instance.componentWillMount.__suppressDeprecationWarning !== !0 ? foundWillMountName = "componentWillMount" : typeof instance.UNSAFE_componentWillMount == "function" && (foundWillMountName = "UNSAFE_componentWillMount"), typeof instance.componentWillReceiveProps == "function" && instance.componentWillReceiveProps.__suppressDeprecationWarning !== !0 ? foundWillReceivePropsName = "componentWillReceiveProps" : typeof instance.UNSAFE_componentWillReceiveProps == "function" && (foundWillReceivePropsName = "UNSAFE_componentWillReceiveProps"), typeof instance.componentWillUpdate == "function" && instance.componentWillUpdate.__suppressDeprecationWarning !== !0 ? foundWillUpdateName = "componentWillUpdate" : typeof instance.UNSAFE_componentWillUpdate == "function" && (foundWillUpdateName = "UNSAFE_componentWillUpdate"), foundWillMountName !== null || foundWillReceivePropsName !== null || foundWillUpdateName !== null) {
              var _componentName = getComponentName(ctor) || "Component", newApiName = typeof ctor.getDerivedStateFromProps == "function" ? "getDerivedStateFromProps()" : "getSnapshotBeforeUpdate()";
              didWarnAboutLegacyLifecyclesAndDerivedState.has(_componentName) || (didWarnAboutLegacyLifecyclesAndDerivedState.add(_componentName), error(`Unsafe legacy lifecycles will not be called for components using new component APIs.

%s uses %s but also contains the following legacy lifecycles:%s%s%s

The above lifecycles should be removed. Learn more about this warning here:
https://reactjs.org/link/unsafe-component-lifecycles`, _componentName, newApiName, foundWillMountName !== null ? `
  ` + foundWillMountName : "", foundWillReceivePropsName !== null ? `
  ` + foundWillReceivePropsName : "", foundWillUpdateName !== null ? `
  ` + foundWillUpdateName : ""));
            }
          }
        }
        return isLegacyContextConsumer && cacheContext(workInProgress2, unmaskedContext, context), instance;
      }
      function callComponentWillMount(workInProgress2, instance) {
        var oldState = instance.state;
        typeof instance.componentWillMount == "function" && instance.componentWillMount(), typeof instance.UNSAFE_componentWillMount == "function" && instance.UNSAFE_componentWillMount(), oldState !== instance.state && (error("%s.componentWillMount(): Assigning directly to this.state is deprecated (except inside a component's constructor). Use setState instead.", getComponentName(workInProgress2.type) || "Component"), classComponentUpdater.enqueueReplaceState(instance, instance.state, null));
      }
      function callComponentWillReceiveProps(workInProgress2, instance, newProps, nextContext) {
        var oldState = instance.state;
        if (typeof instance.componentWillReceiveProps == "function" && instance.componentWillReceiveProps(newProps, nextContext), typeof instance.UNSAFE_componentWillReceiveProps == "function" && instance.UNSAFE_componentWillReceiveProps(newProps, nextContext), instance.state !== oldState) {
          {
            var componentName = getComponentName(workInProgress2.type) || "Component";
            didWarnAboutStateAssignmentForComponent.has(componentName) || (didWarnAboutStateAssignmentForComponent.add(componentName), error("%s.componentWillReceiveProps(): Assigning directly to this.state is deprecated (except inside a component's constructor). Use setState instead.", componentName));
          }
          classComponentUpdater.enqueueReplaceState(instance, instance.state, null);
        }
      }
      function mountClassInstance(workInProgress2, ctor, newProps, renderLanes2) {
        checkClassInstance(workInProgress2, ctor, newProps);
        var instance = workInProgress2.stateNode;
        instance.props = newProps, instance.state = workInProgress2.memoizedState, instance.refs = emptyRefsObject, initializeUpdateQueue(workInProgress2);
        var contextType = ctor.contextType;
        if (typeof contextType == "object" && contextType !== null)
          instance.context = readContext(contextType);
        else {
          var unmaskedContext = getUnmaskedContext(workInProgress2, ctor, !0);
          instance.context = getMaskedContext(workInProgress2, unmaskedContext);
        }
        {
          if (instance.state === newProps) {
            var componentName = getComponentName(ctor) || "Component";
            didWarnAboutDirectlyAssigningPropsToState.has(componentName) || (didWarnAboutDirectlyAssigningPropsToState.add(componentName), error("%s: It is not recommended to assign props directly to state because updates to props won't be reflected in state. In most cases, it is better to use props directly.", componentName));
          }
          workInProgress2.mode & StrictMode && ReactStrictModeWarnings.recordLegacyContextWarning(workInProgress2, instance), ReactStrictModeWarnings.recordUnsafeLifecycleWarnings(workInProgress2, instance);
        }
        processUpdateQueue(workInProgress2, newProps, instance, renderLanes2), instance.state = workInProgress2.memoizedState;
        var getDerivedStateFromProps = ctor.getDerivedStateFromProps;
        typeof getDerivedStateFromProps == "function" && (applyDerivedStateFromProps(workInProgress2, ctor, getDerivedStateFromProps, newProps), instance.state = workInProgress2.memoizedState), typeof ctor.getDerivedStateFromProps != "function" && typeof instance.getSnapshotBeforeUpdate != "function" && (typeof instance.UNSAFE_componentWillMount == "function" || typeof instance.componentWillMount == "function") && (callComponentWillMount(workInProgress2, instance), processUpdateQueue(workInProgress2, newProps, instance, renderLanes2), instance.state = workInProgress2.memoizedState), typeof instance.componentDidMount == "function" && (workInProgress2.flags |= Update);
      }
      function resumeMountClassInstance(workInProgress2, ctor, newProps, renderLanes2) {
        var instance = workInProgress2.stateNode, oldProps = workInProgress2.memoizedProps;
        instance.props = oldProps;
        var oldContext = instance.context, contextType = ctor.contextType, nextContext = emptyContextObject;
        if (typeof contextType == "object" && contextType !== null)
          nextContext = readContext(contextType);
        else {
          var nextLegacyUnmaskedContext = getUnmaskedContext(workInProgress2, ctor, !0);
          nextContext = getMaskedContext(workInProgress2, nextLegacyUnmaskedContext);
        }
        var getDerivedStateFromProps = ctor.getDerivedStateFromProps, hasNewLifecycles = typeof getDerivedStateFromProps == "function" || typeof instance.getSnapshotBeforeUpdate == "function";
        !hasNewLifecycles && (typeof instance.UNSAFE_componentWillReceiveProps == "function" || typeof instance.componentWillReceiveProps == "function") && (oldProps !== newProps || oldContext !== nextContext) && callComponentWillReceiveProps(workInProgress2, instance, newProps, nextContext), resetHasForceUpdateBeforeProcessing();
        var oldState = workInProgress2.memoizedState, newState = instance.state = oldState;
        if (processUpdateQueue(workInProgress2, newProps, instance, renderLanes2), newState = workInProgress2.memoizedState, oldProps === newProps && oldState === newState && !hasContextChanged() && !checkHasForceUpdateAfterProcessing())
          return typeof instance.componentDidMount == "function" && (workInProgress2.flags |= Update), !1;
        typeof getDerivedStateFromProps == "function" && (applyDerivedStateFromProps(workInProgress2, ctor, getDerivedStateFromProps, newProps), newState = workInProgress2.memoizedState);
        var shouldUpdate = checkHasForceUpdateAfterProcessing() || checkShouldComponentUpdate(workInProgress2, ctor, oldProps, newProps, oldState, newState, nextContext);
        return shouldUpdate ? (!hasNewLifecycles && (typeof instance.UNSAFE_componentWillMount == "function" || typeof instance.componentWillMount == "function") && (typeof instance.componentWillMount == "function" && instance.componentWillMount(), typeof instance.UNSAFE_componentWillMount == "function" && instance.UNSAFE_componentWillMount()), typeof instance.componentDidMount == "function" && (workInProgress2.flags |= Update)) : (typeof instance.componentDidMount == "function" && (workInProgress2.flags |= Update), workInProgress2.memoizedProps = newProps, workInProgress2.memoizedState = newState), instance.props = newProps, instance.state = newState, instance.context = nextContext, shouldUpdate;
      }
      function updateClassInstance(current2, workInProgress2, ctor, newProps, renderLanes2) {
        var instance = workInProgress2.stateNode;
        cloneUpdateQueue(current2, workInProgress2);
        var unresolvedOldProps = workInProgress2.memoizedProps, oldProps = workInProgress2.type === workInProgress2.elementType ? unresolvedOldProps : resolveDefaultProps(workInProgress2.type, unresolvedOldProps);
        instance.props = oldProps;
        var unresolvedNewProps = workInProgress2.pendingProps, oldContext = instance.context, contextType = ctor.contextType, nextContext = emptyContextObject;
        if (typeof contextType == "object" && contextType !== null)
          nextContext = readContext(contextType);
        else {
          var nextUnmaskedContext = getUnmaskedContext(workInProgress2, ctor, !0);
          nextContext = getMaskedContext(workInProgress2, nextUnmaskedContext);
        }
        var getDerivedStateFromProps = ctor.getDerivedStateFromProps, hasNewLifecycles = typeof getDerivedStateFromProps == "function" || typeof instance.getSnapshotBeforeUpdate == "function";
        !hasNewLifecycles && (typeof instance.UNSAFE_componentWillReceiveProps == "function" || typeof instance.componentWillReceiveProps == "function") && (unresolvedOldProps !== unresolvedNewProps || oldContext !== nextContext) && callComponentWillReceiveProps(workInProgress2, instance, newProps, nextContext), resetHasForceUpdateBeforeProcessing();
        var oldState = workInProgress2.memoizedState, newState = instance.state = oldState;
        if (processUpdateQueue(workInProgress2, newProps, instance, renderLanes2), newState = workInProgress2.memoizedState, unresolvedOldProps === unresolvedNewProps && oldState === newState && !hasContextChanged() && !checkHasForceUpdateAfterProcessing())
          return typeof instance.componentDidUpdate == "function" && (unresolvedOldProps !== current2.memoizedProps || oldState !== current2.memoizedState) && (workInProgress2.flags |= Update), typeof instance.getSnapshotBeforeUpdate == "function" && (unresolvedOldProps !== current2.memoizedProps || oldState !== current2.memoizedState) && (workInProgress2.flags |= Snapshot), !1;
        typeof getDerivedStateFromProps == "function" && (applyDerivedStateFromProps(workInProgress2, ctor, getDerivedStateFromProps, newProps), newState = workInProgress2.memoizedState);
        var shouldUpdate = checkHasForceUpdateAfterProcessing() || checkShouldComponentUpdate(workInProgress2, ctor, oldProps, newProps, oldState, newState, nextContext);
        return shouldUpdate ? (!hasNewLifecycles && (typeof instance.UNSAFE_componentWillUpdate == "function" || typeof instance.componentWillUpdate == "function") && (typeof instance.componentWillUpdate == "function" && instance.componentWillUpdate(newProps, newState, nextContext), typeof instance.UNSAFE_componentWillUpdate == "function" && instance.UNSAFE_componentWillUpdate(newProps, newState, nextContext)), typeof instance.componentDidUpdate == "function" && (workInProgress2.flags |= Update), typeof instance.getSnapshotBeforeUpdate == "function" && (workInProgress2.flags |= Snapshot)) : (typeof instance.componentDidUpdate == "function" && (unresolvedOldProps !== current2.memoizedProps || oldState !== current2.memoizedState) && (workInProgress2.flags |= Update), typeof instance.getSnapshotBeforeUpdate == "function" && (unresolvedOldProps !== current2.memoizedProps || oldState !== current2.memoizedState) && (workInProgress2.flags |= Snapshot), workInProgress2.memoizedProps = newProps, workInProgress2.memoizedState = newState), instance.props = newProps, instance.state = newState, instance.context = nextContext, shouldUpdate;
      }
      var didWarnAboutMaps, didWarnAboutGenerators, didWarnAboutStringRefs, ownerHasKeyUseWarning, ownerHasFunctionTypeWarning, warnForMissingKey = function(child, returnFiber) {
      };
      didWarnAboutMaps = !1, didWarnAboutGenerators = !1, didWarnAboutStringRefs = {}, ownerHasKeyUseWarning = {}, ownerHasFunctionTypeWarning = {}, warnForMissingKey = function(child, returnFiber) {
        if (!(child === null || typeof child != "object") && !(!child._store || child._store.validated || child.key != null)) {
          if (typeof child._store != "object")
            throw Error("React Component in warnForMissingKey should have a _store. This error is likely caused by a bug in React. Please file an issue.");
          child._store.validated = !0;
          var componentName = getComponentName(returnFiber.type) || "Component";
          ownerHasKeyUseWarning[componentName] || (ownerHasKeyUseWarning[componentName] = !0, error('Each child in a list should have a unique "key" prop. See https://reactjs.org/link/warning-keys for more information.'));
        }
      };
      var isArray$1 = Array.isArray;
      function coerceRef(returnFiber, current2, element) {
        var mixedRef = element.ref;
        if (mixedRef !== null && typeof mixedRef != "function" && typeof mixedRef != "object") {
          if ((returnFiber.mode & StrictMode || warnAboutStringRefs) && !(element._owner && element._self && element._owner.stateNode !== element._self)) {
            var componentName = getComponentName(returnFiber.type) || "Component";
            didWarnAboutStringRefs[componentName] || (error('A string ref, "%s", has been found within a strict mode tree. String refs are a source of potential bugs and should be avoided. We recommend using useRef() or createRef() instead. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-string-ref', mixedRef), didWarnAboutStringRefs[componentName] = !0);
          }
          if (element._owner) {
            var owner = element._owner, inst;
            if (owner) {
              var ownerFiber = owner;
              if (ownerFiber.tag !== ClassComponent)
                throw Error("Function components cannot have string refs. We recommend using useRef() instead. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-string-ref");
              inst = ownerFiber.stateNode;
            }
            if (!inst)
              throw Error("Missing owner for string ref " + mixedRef + ". This error is likely caused by a bug in React. Please file an issue.");
            var stringRef = "" + mixedRef;
            if (current2 !== null && current2.ref !== null && typeof current2.ref == "function" && current2.ref._stringRef === stringRef)
              return current2.ref;
            var ref = function(value) {
              var refs = inst.refs;
              refs === emptyRefsObject && (refs = inst.refs = {}), value === null ? delete refs[stringRef] : refs[stringRef] = value;
            };
            return ref._stringRef = stringRef, ref;
          } else {
            if (typeof mixedRef != "string")
              throw Error("Expected ref to be a function, a string, an object returned by React.createRef(), or null.");
            if (!element._owner)
              throw Error("Element ref was specified as a string (" + mixedRef + `) but no owner was set. This could happen for one of the following reasons:
1. You may be adding a ref to a function component
2. You may be adding a ref to a component that was not created inside a component's render method
3. You have multiple copies of React loaded
See https://reactjs.org/link/refs-must-have-owner for more information.`);
          }
        }
        return mixedRef;
      }
      function throwOnInvalidObjectType(returnFiber, newChild) {
        if (returnFiber.type !== "textarea")
          throw Error("Objects are not valid as a React child (found: " + (Object.prototype.toString.call(newChild) === "[object Object]" ? "object with keys {" + Object.keys(newChild).join(", ") + "}" : newChild) + "). If you meant to render a collection of children, use an array instead.");
      }
      function warnOnFunctionType(returnFiber) {
        {
          var componentName = getComponentName(returnFiber.type) || "Component";
          if (ownerHasFunctionTypeWarning[componentName])
            return;
          ownerHasFunctionTypeWarning[componentName] = !0, error("Functions are not valid as a React child. This may happen if you return a Component instead of <Component /> from render. Or maybe you meant to call this function rather than return it.");
        }
      }
      function ChildReconciler(shouldTrackSideEffects) {
        function deleteChild(returnFiber, childToDelete) {
          if (!!shouldTrackSideEffects) {
            var last = returnFiber.lastEffect;
            last !== null ? (last.nextEffect = childToDelete, returnFiber.lastEffect = childToDelete) : returnFiber.firstEffect = returnFiber.lastEffect = childToDelete, childToDelete.nextEffect = null, childToDelete.flags = Deletion;
          }
        }
        function deleteRemainingChildren(returnFiber, currentFirstChild) {
          if (!shouldTrackSideEffects)
            return null;
          for (var childToDelete = currentFirstChild; childToDelete !== null; )
            deleteChild(returnFiber, childToDelete), childToDelete = childToDelete.sibling;
          return null;
        }
        function mapRemainingChildren(returnFiber, currentFirstChild) {
          for (var existingChildren = /* @__PURE__ */ new Map(), existingChild = currentFirstChild; existingChild !== null; )
            existingChild.key !== null ? existingChildren.set(existingChild.key, existingChild) : existingChildren.set(existingChild.index, existingChild), existingChild = existingChild.sibling;
          return existingChildren;
        }
        function useFiber(fiber, pendingProps) {
          var clone = createWorkInProgress(fiber, pendingProps);
          return clone.index = 0, clone.sibling = null, clone;
        }
        function placeChild(newFiber, lastPlacedIndex, newIndex) {
          if (newFiber.index = newIndex, !shouldTrackSideEffects)
            return lastPlacedIndex;
          var current2 = newFiber.alternate;
          if (current2 !== null) {
            var oldIndex = current2.index;
            return oldIndex < lastPlacedIndex ? (newFiber.flags = Placement, lastPlacedIndex) : oldIndex;
          } else
            return newFiber.flags = Placement, lastPlacedIndex;
        }
        function placeSingleChild(newFiber) {
          return shouldTrackSideEffects && newFiber.alternate === null && (newFiber.flags = Placement), newFiber;
        }
        function updateTextNode(returnFiber, current2, textContent, lanes) {
          if (current2 === null || current2.tag !== HostText) {
            var created = createFiberFromText(textContent, returnFiber.mode, lanes);
            return created.return = returnFiber, created;
          } else {
            var existing = useFiber(current2, textContent);
            return existing.return = returnFiber, existing;
          }
        }
        function updateElement(returnFiber, current2, element, lanes) {
          if (current2 !== null && (current2.elementType === element.type || isCompatibleFamilyForHotReloading(current2, element))) {
            var existing = useFiber(current2, element.props);
            return existing.ref = coerceRef(returnFiber, current2, element), existing.return = returnFiber, existing._debugSource = element._source, existing._debugOwner = element._owner, existing;
          }
          var created = createFiberFromElement(element, returnFiber.mode, lanes);
          return created.ref = coerceRef(returnFiber, current2, element), created.return = returnFiber, created;
        }
        function updatePortal(returnFiber, current2, portal, lanes) {
          if (current2 === null || current2.tag !== HostPortal || current2.stateNode.containerInfo !== portal.containerInfo || current2.stateNode.implementation !== portal.implementation) {
            var created = createFiberFromPortal(portal, returnFiber.mode, lanes);
            return created.return = returnFiber, created;
          } else {
            var existing = useFiber(current2, portal.children || []);
            return existing.return = returnFiber, existing;
          }
        }
        function updateFragment2(returnFiber, current2, fragment, lanes, key) {
          if (current2 === null || current2.tag !== Fragment11) {
            var created = createFiberFromFragment(fragment, returnFiber.mode, lanes, key);
            return created.return = returnFiber, created;
          } else {
            var existing = useFiber(current2, fragment);
            return existing.return = returnFiber, existing;
          }
        }
        function createChild(returnFiber, newChild, lanes) {
          if (typeof newChild == "string" || typeof newChild == "number") {
            var created = createFiberFromText("" + newChild, returnFiber.mode, lanes);
            return created.return = returnFiber, created;
          }
          if (typeof newChild == "object" && newChild !== null) {
            switch (newChild.$$typeof) {
              case REACT_ELEMENT_TYPE: {
                var _created = createFiberFromElement(newChild, returnFiber.mode, lanes);
                return _created.ref = coerceRef(returnFiber, null, newChild), _created.return = returnFiber, _created;
              }
              case REACT_PORTAL_TYPE: {
                var _created2 = createFiberFromPortal(newChild, returnFiber.mode, lanes);
                return _created2.return = returnFiber, _created2;
              }
            }
            if (isArray$1(newChild) || getIteratorFn(newChild)) {
              var _created3 = createFiberFromFragment(newChild, returnFiber.mode, lanes, null);
              return _created3.return = returnFiber, _created3;
            }
            throwOnInvalidObjectType(returnFiber, newChild);
          }
          return typeof newChild == "function" && warnOnFunctionType(returnFiber), null;
        }
        function updateSlot(returnFiber, oldFiber, newChild, lanes) {
          var key = oldFiber !== null ? oldFiber.key : null;
          if (typeof newChild == "string" || typeof newChild == "number")
            return key !== null ? null : updateTextNode(returnFiber, oldFiber, "" + newChild, lanes);
          if (typeof newChild == "object" && newChild !== null) {
            switch (newChild.$$typeof) {
              case REACT_ELEMENT_TYPE:
                return newChild.key === key ? newChild.type === REACT_FRAGMENT_TYPE ? updateFragment2(returnFiber, oldFiber, newChild.props.children, lanes, key) : updateElement(returnFiber, oldFiber, newChild, lanes) : null;
              case REACT_PORTAL_TYPE:
                return newChild.key === key ? updatePortal(returnFiber, oldFiber, newChild, lanes) : null;
            }
            if (isArray$1(newChild) || getIteratorFn(newChild))
              return key !== null ? null : updateFragment2(returnFiber, oldFiber, newChild, lanes, null);
            throwOnInvalidObjectType(returnFiber, newChild);
          }
          return typeof newChild == "function" && warnOnFunctionType(returnFiber), null;
        }
        function updateFromMap(existingChildren, returnFiber, newIdx, newChild, lanes) {
          if (typeof newChild == "string" || typeof newChild == "number") {
            var matchedFiber = existingChildren.get(newIdx) || null;
            return updateTextNode(returnFiber, matchedFiber, "" + newChild, lanes);
          }
          if (typeof newChild == "object" && newChild !== null) {
            switch (newChild.$$typeof) {
              case REACT_ELEMENT_TYPE: {
                var _matchedFiber = existingChildren.get(newChild.key === null ? newIdx : newChild.key) || null;
                return newChild.type === REACT_FRAGMENT_TYPE ? updateFragment2(returnFiber, _matchedFiber, newChild.props.children, lanes, newChild.key) : updateElement(returnFiber, _matchedFiber, newChild, lanes);
              }
              case REACT_PORTAL_TYPE: {
                var _matchedFiber2 = existingChildren.get(newChild.key === null ? newIdx : newChild.key) || null;
                return updatePortal(returnFiber, _matchedFiber2, newChild, lanes);
              }
            }
            if (isArray$1(newChild) || getIteratorFn(newChild)) {
              var _matchedFiber3 = existingChildren.get(newIdx) || null;
              return updateFragment2(returnFiber, _matchedFiber3, newChild, lanes, null);
            }
            throwOnInvalidObjectType(returnFiber, newChild);
          }
          return typeof newChild == "function" && warnOnFunctionType(returnFiber), null;
        }
        function warnOnInvalidKey(child, knownKeys, returnFiber) {
          {
            if (typeof child != "object" || child === null)
              return knownKeys;
            switch (child.$$typeof) {
              case REACT_ELEMENT_TYPE:
              case REACT_PORTAL_TYPE:
                warnForMissingKey(child, returnFiber);
                var key = child.key;
                if (typeof key != "string")
                  break;
                if (knownKeys === null) {
                  knownKeys = /* @__PURE__ */ new Set(), knownKeys.add(key);
                  break;
                }
                if (!knownKeys.has(key)) {
                  knownKeys.add(key);
                  break;
                }
                error("Encountered two children with the same key, `%s`. Keys should be unique so that components maintain their identity across updates. Non-unique keys may cause children to be duplicated and/or omitted \u2014 the behavior is unsupported and could change in a future version.", key);
                break;
            }
          }
          return knownKeys;
        }
        function reconcileChildrenArray(returnFiber, currentFirstChild, newChildren, lanes) {
          for (var knownKeys = null, i = 0; i < newChildren.length; i++) {
            var child = newChildren[i];
            knownKeys = warnOnInvalidKey(child, knownKeys, returnFiber);
          }
          for (var resultingFirstChild = null, previousNewFiber = null, oldFiber = currentFirstChild, lastPlacedIndex = 0, newIdx = 0, nextOldFiber = null; oldFiber !== null && newIdx < newChildren.length; newIdx++) {
            oldFiber.index > newIdx ? (nextOldFiber = oldFiber, oldFiber = null) : nextOldFiber = oldFiber.sibling;
            var newFiber = updateSlot(returnFiber, oldFiber, newChildren[newIdx], lanes);
            if (newFiber === null) {
              oldFiber === null && (oldFiber = nextOldFiber);
              break;
            }
            shouldTrackSideEffects && oldFiber && newFiber.alternate === null && deleteChild(returnFiber, oldFiber), lastPlacedIndex = placeChild(newFiber, lastPlacedIndex, newIdx), previousNewFiber === null ? resultingFirstChild = newFiber : previousNewFiber.sibling = newFiber, previousNewFiber = newFiber, oldFiber = nextOldFiber;
          }
          if (newIdx === newChildren.length)
            return deleteRemainingChildren(returnFiber, oldFiber), resultingFirstChild;
          if (oldFiber === null) {
            for (; newIdx < newChildren.length; newIdx++) {
              var _newFiber = createChild(returnFiber, newChildren[newIdx], lanes);
              _newFiber !== null && (lastPlacedIndex = placeChild(_newFiber, lastPlacedIndex, newIdx), previousNewFiber === null ? resultingFirstChild = _newFiber : previousNewFiber.sibling = _newFiber, previousNewFiber = _newFiber);
            }
            return resultingFirstChild;
          }
          for (var existingChildren = mapRemainingChildren(returnFiber, oldFiber); newIdx < newChildren.length; newIdx++) {
            var _newFiber2 = updateFromMap(existingChildren, returnFiber, newIdx, newChildren[newIdx], lanes);
            _newFiber2 !== null && (shouldTrackSideEffects && _newFiber2.alternate !== null && existingChildren.delete(_newFiber2.key === null ? newIdx : _newFiber2.key), lastPlacedIndex = placeChild(_newFiber2, lastPlacedIndex, newIdx), previousNewFiber === null ? resultingFirstChild = _newFiber2 : previousNewFiber.sibling = _newFiber2, previousNewFiber = _newFiber2);
          }
          return shouldTrackSideEffects && existingChildren.forEach(function(child2) {
            return deleteChild(returnFiber, child2);
          }), resultingFirstChild;
        }
        function reconcileChildrenIterator(returnFiber, currentFirstChild, newChildrenIterable, lanes) {
          var iteratorFn = getIteratorFn(newChildrenIterable);
          if (typeof iteratorFn != "function")
            throw Error("An object is not an iterable. This error is likely caused by a bug in React. Please file an issue.");
          {
            typeof Symbol == "function" && newChildrenIterable[Symbol.toStringTag] === "Generator" && (didWarnAboutGenerators || error("Using Generators as children is unsupported and will likely yield unexpected results because enumerating a generator mutates it. You may convert it to an array with `Array.from()` or the `[...spread]` operator before rendering. Keep in mind you might need to polyfill these features for older browsers."), didWarnAboutGenerators = !0), newChildrenIterable.entries === iteratorFn && (didWarnAboutMaps || error("Using Maps as children is not supported. Use an array of keyed ReactElements instead."), didWarnAboutMaps = !0);
            var _newChildren = iteratorFn.call(newChildrenIterable);
            if (_newChildren)
              for (var knownKeys = null, _step = _newChildren.next(); !_step.done; _step = _newChildren.next()) {
                var child = _step.value;
                knownKeys = warnOnInvalidKey(child, knownKeys, returnFiber);
              }
          }
          var newChildren = iteratorFn.call(newChildrenIterable);
          if (newChildren == null)
            throw Error("An iterable object provided no iterator.");
          for (var resultingFirstChild = null, previousNewFiber = null, oldFiber = currentFirstChild, lastPlacedIndex = 0, newIdx = 0, nextOldFiber = null, step = newChildren.next(); oldFiber !== null && !step.done; newIdx++, step = newChildren.next()) {
            oldFiber.index > newIdx ? (nextOldFiber = oldFiber, oldFiber = null) : nextOldFiber = oldFiber.sibling;
            var newFiber = updateSlot(returnFiber, oldFiber, step.value, lanes);
            if (newFiber === null) {
              oldFiber === null && (oldFiber = nextOldFiber);
              break;
            }
            shouldTrackSideEffects && oldFiber && newFiber.alternate === null && deleteChild(returnFiber, oldFiber), lastPlacedIndex = placeChild(newFiber, lastPlacedIndex, newIdx), previousNewFiber === null ? resultingFirstChild = newFiber : previousNewFiber.sibling = newFiber, previousNewFiber = newFiber, oldFiber = nextOldFiber;
          }
          if (step.done)
            return deleteRemainingChildren(returnFiber, oldFiber), resultingFirstChild;
          if (oldFiber === null) {
            for (; !step.done; newIdx++, step = newChildren.next()) {
              var _newFiber3 = createChild(returnFiber, step.value, lanes);
              _newFiber3 !== null && (lastPlacedIndex = placeChild(_newFiber3, lastPlacedIndex, newIdx), previousNewFiber === null ? resultingFirstChild = _newFiber3 : previousNewFiber.sibling = _newFiber3, previousNewFiber = _newFiber3);
            }
            return resultingFirstChild;
          }
          for (var existingChildren = mapRemainingChildren(returnFiber, oldFiber); !step.done; newIdx++, step = newChildren.next()) {
            var _newFiber4 = updateFromMap(existingChildren, returnFiber, newIdx, step.value, lanes);
            _newFiber4 !== null && (shouldTrackSideEffects && _newFiber4.alternate !== null && existingChildren.delete(_newFiber4.key === null ? newIdx : _newFiber4.key), lastPlacedIndex = placeChild(_newFiber4, lastPlacedIndex, newIdx), previousNewFiber === null ? resultingFirstChild = _newFiber4 : previousNewFiber.sibling = _newFiber4, previousNewFiber = _newFiber4);
          }
          return shouldTrackSideEffects && existingChildren.forEach(function(child2) {
            return deleteChild(returnFiber, child2);
          }), resultingFirstChild;
        }
        function reconcileSingleTextNode(returnFiber, currentFirstChild, textContent, lanes) {
          if (currentFirstChild !== null && currentFirstChild.tag === HostText) {
            deleteRemainingChildren(returnFiber, currentFirstChild.sibling);
            var existing = useFiber(currentFirstChild, textContent);
            return existing.return = returnFiber, existing;
          }
          deleteRemainingChildren(returnFiber, currentFirstChild);
          var created = createFiberFromText(textContent, returnFiber.mode, lanes);
          return created.return = returnFiber, created;
        }
        function reconcileSingleElement(returnFiber, currentFirstChild, element, lanes) {
          for (var key = element.key, child = currentFirstChild; child !== null; ) {
            if (child.key === key) {
              switch (child.tag) {
                case Fragment11: {
                  if (element.type === REACT_FRAGMENT_TYPE) {
                    deleteRemainingChildren(returnFiber, child.sibling);
                    var existing = useFiber(child, element.props.children);
                    return existing.return = returnFiber, existing._debugSource = element._source, existing._debugOwner = element._owner, existing;
                  }
                  break;
                }
                case Block:
                default: {
                  if (child.elementType === element.type || isCompatibleFamilyForHotReloading(child, element)) {
                    deleteRemainingChildren(returnFiber, child.sibling);
                    var _existing3 = useFiber(child, element.props);
                    return _existing3.ref = coerceRef(returnFiber, child, element), _existing3.return = returnFiber, _existing3._debugSource = element._source, _existing3._debugOwner = element._owner, _existing3;
                  }
                  break;
                }
              }
              deleteRemainingChildren(returnFiber, child);
              break;
            } else
              deleteChild(returnFiber, child);
            child = child.sibling;
          }
          if (element.type === REACT_FRAGMENT_TYPE) {
            var created = createFiberFromFragment(element.props.children, returnFiber.mode, lanes, element.key);
            return created.return = returnFiber, created;
          } else {
            var _created4 = createFiberFromElement(element, returnFiber.mode, lanes);
            return _created4.ref = coerceRef(returnFiber, currentFirstChild, element), _created4.return = returnFiber, _created4;
          }
        }
        function reconcileSinglePortal(returnFiber, currentFirstChild, portal, lanes) {
          for (var key = portal.key, child = currentFirstChild; child !== null; ) {
            if (child.key === key)
              if (child.tag === HostPortal && child.stateNode.containerInfo === portal.containerInfo && child.stateNode.implementation === portal.implementation) {
                deleteRemainingChildren(returnFiber, child.sibling);
                var existing = useFiber(child, portal.children || []);
                return existing.return = returnFiber, existing;
              } else {
                deleteRemainingChildren(returnFiber, child);
                break;
              }
            else
              deleteChild(returnFiber, child);
            child = child.sibling;
          }
          var created = createFiberFromPortal(portal, returnFiber.mode, lanes);
          return created.return = returnFiber, created;
        }
        function reconcileChildFibers2(returnFiber, currentFirstChild, newChild, lanes) {
          var isUnkeyedTopLevelFragment = typeof newChild == "object" && newChild !== null && newChild.type === REACT_FRAGMENT_TYPE && newChild.key === null;
          isUnkeyedTopLevelFragment && (newChild = newChild.props.children);
          var isObject2 = typeof newChild == "object" && newChild !== null;
          if (isObject2)
            switch (newChild.$$typeof) {
              case REACT_ELEMENT_TYPE:
                return placeSingleChild(reconcileSingleElement(returnFiber, currentFirstChild, newChild, lanes));
              case REACT_PORTAL_TYPE:
                return placeSingleChild(reconcileSinglePortal(returnFiber, currentFirstChild, newChild, lanes));
            }
          if (typeof newChild == "string" || typeof newChild == "number")
            return placeSingleChild(reconcileSingleTextNode(returnFiber, currentFirstChild, "" + newChild, lanes));
          if (isArray$1(newChild))
            return reconcileChildrenArray(returnFiber, currentFirstChild, newChild, lanes);
          if (getIteratorFn(newChild))
            return reconcileChildrenIterator(returnFiber, currentFirstChild, newChild, lanes);
          if (isObject2 && throwOnInvalidObjectType(returnFiber, newChild), typeof newChild == "function" && warnOnFunctionType(returnFiber), typeof newChild > "u" && !isUnkeyedTopLevelFragment)
            switch (returnFiber.tag) {
              case ClassComponent: {
                var instance = returnFiber.stateNode;
                if (instance.render._isMockFunction)
                  break;
              }
              case Block:
              case FunctionComponent:
              case ForwardRef2:
              case SimpleMemoComponent:
                throw Error((getComponentName(returnFiber.type) || "Component") + "(...): Nothing was returned from render. This usually means a return statement is missing. Or, to render nothing, return null.");
            }
          return deleteRemainingChildren(returnFiber, currentFirstChild);
        }
        return reconcileChildFibers2;
      }
      var reconcileChildFibers = ChildReconciler(!0), mountChildFibers = ChildReconciler(!1);
      function cloneChildFibers(current2, workInProgress2) {
        if (!(current2 === null || workInProgress2.child === current2.child))
          throw Error("Resuming work not yet implemented.");
        if (workInProgress2.child !== null) {
          var currentChild = workInProgress2.child, newChild = createWorkInProgress(currentChild, currentChild.pendingProps);
          for (workInProgress2.child = newChild, newChild.return = workInProgress2; currentChild.sibling !== null; )
            currentChild = currentChild.sibling, newChild = newChild.sibling = createWorkInProgress(currentChild, currentChild.pendingProps), newChild.return = workInProgress2;
          newChild.sibling = null;
        }
      }
      function resetChildFibers(workInProgress2, lanes) {
        for (var child = workInProgress2.child; child !== null; )
          resetWorkInProgress(child, lanes), child = child.sibling;
      }
      var NO_CONTEXT = {}, contextStackCursor$1 = createCursor(NO_CONTEXT), contextFiberStackCursor = createCursor(NO_CONTEXT), rootInstanceStackCursor = createCursor(NO_CONTEXT);
      function requiredContext(c) {
        if (c === NO_CONTEXT)
          throw Error("Expected host context to exist. This error is likely caused by a bug in React. Please file an issue.");
        return c;
      }
      function getRootHostContainer() {
        var rootInstance = requiredContext(rootInstanceStackCursor.current);
        return rootInstance;
      }
      function pushHostContainer(fiber, nextRootInstance) {
        push(rootInstanceStackCursor, nextRootInstance, fiber), push(contextFiberStackCursor, fiber, fiber), push(contextStackCursor$1, NO_CONTEXT, fiber);
        var nextRootContext = getRootHostContext(nextRootInstance);
        pop(contextStackCursor$1, fiber), push(contextStackCursor$1, nextRootContext, fiber);
      }
      function popHostContainer(fiber) {
        pop(contextStackCursor$1, fiber), pop(contextFiberStackCursor, fiber), pop(rootInstanceStackCursor, fiber);
      }
      function getHostContext() {
        var context = requiredContext(contextStackCursor$1.current);
        return context;
      }
      function pushHostContext(fiber) {
        var rootInstance = requiredContext(rootInstanceStackCursor.current), context = requiredContext(contextStackCursor$1.current), nextContext = getChildHostContext(context, fiber.type);
        context !== nextContext && (push(contextFiberStackCursor, fiber, fiber), push(contextStackCursor$1, nextContext, fiber));
      }
      function popHostContext(fiber) {
        contextFiberStackCursor.current === fiber && (pop(contextStackCursor$1, fiber), pop(contextFiberStackCursor, fiber));
      }
      var DefaultSuspenseContext = 0, SubtreeSuspenseContextMask = 1, InvisibleParentSuspenseContext = 1, ForceSuspenseFallback = 2, suspenseStackCursor = createCursor(DefaultSuspenseContext);
      function hasSuspenseContext(parentContext, flag) {
        return (parentContext & flag) !== 0;
      }
      function setDefaultShallowSuspenseContext(parentContext) {
        return parentContext & SubtreeSuspenseContextMask;
      }
      function setShallowSuspenseContext(parentContext, shallowContext) {
        return parentContext & SubtreeSuspenseContextMask | shallowContext;
      }
      function addSubtreeSuspenseContext(parentContext, subtreeContext) {
        return parentContext | subtreeContext;
      }
      function pushSuspenseContext(fiber, newContext) {
        push(suspenseStackCursor, newContext, fiber);
      }
      function popSuspenseContext(fiber) {
        pop(suspenseStackCursor, fiber);
      }
      function shouldCaptureSuspense(workInProgress2, hasInvisibleParent) {
        var nextState = workInProgress2.memoizedState;
        if (nextState !== null)
          return nextState.dehydrated !== null;
        var props = workInProgress2.memoizedProps;
        return props.fallback === void 0 ? !1 : props.unstable_avoidThisFallback !== !0 ? !0 : !hasInvisibleParent;
      }
      function findFirstSuspended(row) {
        for (var node = row; node !== null; ) {
          if (node.tag === SuspenseComponent) {
            var state = node.memoizedState;
            if (state !== null) {
              var dehydrated = state.dehydrated;
              if (dehydrated === null || isSuspenseInstancePending(dehydrated) || isSuspenseInstanceFallback(dehydrated))
                return node;
            }
          } else if (node.tag === SuspenseListComponent && node.memoizedProps.revealOrder !== void 0) {
            var didSuspend = (node.flags & DidCapture) !== NoFlags;
            if (didSuspend)
              return node;
          } else if (node.child !== null) {
            node.child.return = node, node = node.child;
            continue;
          }
          if (node === row)
            return null;
          for (; node.sibling === null; ) {
            if (node.return === null || node.return === row)
              return null;
            node = node.return;
          }
          node.sibling.return = node.return, node = node.sibling;
        }
        return null;
      }
      var NoFlags$1 = 0, HasEffect = 1, Layout = 2, Passive$1 = 4, hydrationParentFiber = null, nextHydratableInstance = null, isHydrating = !1;
      function enterHydrationState(fiber) {
        var parentInstance = fiber.stateNode.containerInfo;
        return nextHydratableInstance = getFirstHydratableChild(parentInstance), hydrationParentFiber = fiber, isHydrating = !0, !0;
      }
      function deleteHydratableInstance(returnFiber, instance) {
        switch (returnFiber.tag) {
          case HostRoot:
            didNotHydrateContainerInstance(returnFiber.stateNode.containerInfo, instance);
            break;
          case HostComponent:
            didNotHydrateInstance(returnFiber.type, returnFiber.memoizedProps, returnFiber.stateNode, instance);
            break;
        }
        var childToDelete = createFiberFromHostInstanceForDeletion();
        childToDelete.stateNode = instance, childToDelete.return = returnFiber, childToDelete.flags = Deletion, returnFiber.lastEffect !== null ? (returnFiber.lastEffect.nextEffect = childToDelete, returnFiber.lastEffect = childToDelete) : returnFiber.firstEffect = returnFiber.lastEffect = childToDelete;
      }
      function insertNonHydratedInstance(returnFiber, fiber) {
        switch (fiber.flags = fiber.flags & ~Hydrating | Placement, returnFiber.tag) {
          case HostRoot: {
            var parentContainer = returnFiber.stateNode.containerInfo;
            switch (fiber.tag) {
              case HostComponent:
                var type = fiber.type, props = fiber.pendingProps;
                didNotFindHydratableContainerInstance(parentContainer, type);
                break;
              case HostText:
                var text = fiber.pendingProps;
                didNotFindHydratableContainerTextInstance(parentContainer, text);
                break;
            }
            break;
          }
          case HostComponent: {
            var parentType = returnFiber.type, parentProps = returnFiber.memoizedProps, parentInstance = returnFiber.stateNode;
            switch (fiber.tag) {
              case HostComponent:
                var _type = fiber.type, _props = fiber.pendingProps;
                didNotFindHydratableInstance(parentType, parentProps, parentInstance, _type);
                break;
              case HostText:
                var _text = fiber.pendingProps;
                didNotFindHydratableTextInstance(parentType, parentProps, parentInstance, _text);
                break;
              case SuspenseComponent:
                didNotFindHydratableSuspenseInstance(parentType, parentProps);
                break;
            }
            break;
          }
          default:
            return;
        }
      }
      function tryHydrate(fiber, nextInstance) {
        switch (fiber.tag) {
          case HostComponent: {
            var type = fiber.type, props = fiber.pendingProps, instance = canHydrateInstance(nextInstance, type);
            return instance !== null ? (fiber.stateNode = instance, !0) : !1;
          }
          case HostText: {
            var text = fiber.pendingProps, textInstance = canHydrateTextInstance(nextInstance, text);
            return textInstance !== null ? (fiber.stateNode = textInstance, !0) : !1;
          }
          case SuspenseComponent:
            return !1;
          default:
            return !1;
        }
      }
      function tryToClaimNextHydratableInstance(fiber) {
        if (!!isHydrating) {
          var nextInstance = nextHydratableInstance;
          if (!nextInstance) {
            insertNonHydratedInstance(hydrationParentFiber, fiber), isHydrating = !1, hydrationParentFiber = fiber;
            return;
          }
          var firstAttemptedInstance = nextInstance;
          if (!tryHydrate(fiber, nextInstance)) {
            if (nextInstance = getNextHydratableSibling(firstAttemptedInstance), !nextInstance || !tryHydrate(fiber, nextInstance)) {
              insertNonHydratedInstance(hydrationParentFiber, fiber), isHydrating = !1, hydrationParentFiber = fiber;
              return;
            }
            deleteHydratableInstance(hydrationParentFiber, firstAttemptedInstance);
          }
          hydrationParentFiber = fiber, nextHydratableInstance = getFirstHydratableChild(nextInstance);
        }
      }
      function prepareToHydrateHostInstance(fiber, rootContainerInstance, hostContext) {
        var instance = fiber.stateNode, updatePayload = hydrateInstance(instance, fiber.type, fiber.memoizedProps, rootContainerInstance, hostContext, fiber);
        return fiber.updateQueue = updatePayload, updatePayload !== null;
      }
      function prepareToHydrateHostTextInstance(fiber) {
        var textInstance = fiber.stateNode, textContent = fiber.memoizedProps, shouldUpdate = hydrateTextInstance(textInstance, textContent, fiber);
        if (shouldUpdate) {
          var returnFiber = hydrationParentFiber;
          if (returnFiber !== null)
            switch (returnFiber.tag) {
              case HostRoot: {
                var parentContainer = returnFiber.stateNode.containerInfo;
                didNotMatchHydratedContainerTextInstance(parentContainer, textInstance, textContent);
                break;
              }
              case HostComponent: {
                var parentType = returnFiber.type, parentProps = returnFiber.memoizedProps, parentInstance = returnFiber.stateNode;
                didNotMatchHydratedTextInstance(parentType, parentProps, parentInstance, textInstance, textContent);
                break;
              }
            }
        }
        return shouldUpdate;
      }
      function skipPastDehydratedSuspenseInstance(fiber) {
        var suspenseState = fiber.memoizedState, suspenseInstance = suspenseState !== null ? suspenseState.dehydrated : null;
        if (!suspenseInstance)
          throw Error("Expected to have a hydrated suspense instance. This error is likely caused by a bug in React. Please file an issue.");
        return getNextHydratableInstanceAfterSuspenseInstance(suspenseInstance);
      }
      function popToNextHostParent(fiber) {
        for (var parent = fiber.return; parent !== null && parent.tag !== HostComponent && parent.tag !== HostRoot && parent.tag !== SuspenseComponent; )
          parent = parent.return;
        hydrationParentFiber = parent;
      }
      function popHydrationState(fiber) {
        if (fiber !== hydrationParentFiber)
          return !1;
        if (!isHydrating)
          return popToNextHostParent(fiber), isHydrating = !0, !1;
        var type = fiber.type;
        if (fiber.tag !== HostComponent || type !== "head" && type !== "body" && !shouldSetTextContent(type, fiber.memoizedProps))
          for (var nextInstance = nextHydratableInstance; nextInstance; )
            deleteHydratableInstance(fiber, nextInstance), nextInstance = getNextHydratableSibling(nextInstance);
        return popToNextHostParent(fiber), fiber.tag === SuspenseComponent ? nextHydratableInstance = skipPastDehydratedSuspenseInstance(fiber) : nextHydratableInstance = hydrationParentFiber ? getNextHydratableSibling(fiber.stateNode) : null, !0;
      }
      function resetHydrationState() {
        hydrationParentFiber = null, nextHydratableInstance = null, isHydrating = !1;
      }
      function getIsHydrating() {
        return isHydrating;
      }
      var workInProgressSources = [], rendererSigil$1;
      rendererSigil$1 = {};
      function markSourceAsDirty(mutableSource) {
        workInProgressSources.push(mutableSource);
      }
      function resetWorkInProgressVersions() {
        for (var i = 0; i < workInProgressSources.length; i++) {
          var mutableSource = workInProgressSources[i];
          mutableSource._workInProgressVersionPrimary = null;
        }
        workInProgressSources.length = 0;
      }
      function getWorkInProgressVersion(mutableSource) {
        return mutableSource._workInProgressVersionPrimary;
      }
      function setWorkInProgressVersion(mutableSource, version2) {
        mutableSource._workInProgressVersionPrimary = version2, workInProgressSources.push(mutableSource);
      }
      function warnAboutMultipleRenderersDEV(mutableSource) {
        mutableSource._currentPrimaryRenderer == null ? mutableSource._currentPrimaryRenderer = rendererSigil$1 : mutableSource._currentPrimaryRenderer !== rendererSigil$1 && error("Detected multiple renderers concurrently rendering the same mutable source. This is currently unsupported.");
      }
      var ReactCurrentDispatcher$1 = ReactSharedInternals.ReactCurrentDispatcher, ReactCurrentBatchConfig$1 = ReactSharedInternals.ReactCurrentBatchConfig, didWarnAboutMismatchedHooksForComponent, didWarnAboutUseOpaqueIdentifier;
      didWarnAboutUseOpaqueIdentifier = {}, didWarnAboutMismatchedHooksForComponent = /* @__PURE__ */ new Set();
      var renderLanes = NoLanes, currentlyRenderingFiber$1 = null, currentHook = null, workInProgressHook = null, didScheduleRenderPhaseUpdate = !1, didScheduleRenderPhaseUpdateDuringThisPass = !1, RE_RENDER_LIMIT = 25, currentHookNameInDev = null, hookTypesDev = null, hookTypesUpdateIndexDev = -1, ignorePreviousDependencies = !1;
      function mountHookTypesDev() {
        {
          var hookName = currentHookNameInDev;
          hookTypesDev === null ? hookTypesDev = [hookName] : hookTypesDev.push(hookName);
        }
      }
      function updateHookTypesDev() {
        {
          var hookName = currentHookNameInDev;
          hookTypesDev !== null && (hookTypesUpdateIndexDev++, hookTypesDev[hookTypesUpdateIndexDev] !== hookName && warnOnHookMismatchInDev(hookName));
        }
      }
      function checkDepsAreArrayDev(deps) {
        deps != null && !Array.isArray(deps) && error("%s received a final argument that is not an array (instead, received `%s`). When specified, the final argument must be an array.", currentHookNameInDev, typeof deps);
      }
      function warnOnHookMismatchInDev(currentHookName) {
        {
          var componentName = getComponentName(currentlyRenderingFiber$1.type);
          if (!didWarnAboutMismatchedHooksForComponent.has(componentName) && (didWarnAboutMismatchedHooksForComponent.add(componentName), hookTypesDev !== null)) {
            for (var table = "", secondColumnStart = 30, i = 0; i <= hookTypesUpdateIndexDev; i++) {
              for (var oldHookName = hookTypesDev[i], newHookName = i === hookTypesUpdateIndexDev ? currentHookName : oldHookName, row = i + 1 + ". " + oldHookName; row.length < secondColumnStart; )
                row += " ";
              row += newHookName + `
`, table += row;
            }
            error(`React has detected a change in the order of Hooks called by %s. This will lead to bugs and errors if not fixed. For more information, read the Rules of Hooks: https://reactjs.org/link/rules-of-hooks

   Previous render            Next render
   ------------------------------------------------------
%s   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
`, componentName, table);
          }
        }
      }
      function throwInvalidHookError() {
        throw Error(`Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for one of the following reasons:
1. You might have mismatching versions of React and the renderer (such as React DOM)
2. You might be breaking the Rules of Hooks
3. You might have more than one copy of React in the same app
See https://reactjs.org/link/invalid-hook-call for tips about how to debug and fix this problem.`);
      }
      function areHookInputsEqual(nextDeps, prevDeps) {
        if (ignorePreviousDependencies)
          return !1;
        if (prevDeps === null)
          return error("%s received a final argument during this render, but not during the previous render. Even though the final argument is optional, its type cannot change between renders.", currentHookNameInDev), !1;
        nextDeps.length !== prevDeps.length && error(`The final argument passed to %s changed size between renders. The order and size of this array must remain constant.

Previous: %s
Incoming: %s`, currentHookNameInDev, "[" + prevDeps.join(", ") + "]", "[" + nextDeps.join(", ") + "]");
        for (var i = 0; i < prevDeps.length && i < nextDeps.length; i++)
          if (!objectIs(nextDeps[i], prevDeps[i]))
            return !1;
        return !0;
      }
      function renderWithHooks(current2, workInProgress2, Component, props, secondArg, nextRenderLanes) {
        renderLanes = nextRenderLanes, currentlyRenderingFiber$1 = workInProgress2, hookTypesDev = current2 !== null ? current2._debugHookTypes : null, hookTypesUpdateIndexDev = -1, ignorePreviousDependencies = current2 !== null && current2.type !== workInProgress2.type, workInProgress2.memoizedState = null, workInProgress2.updateQueue = null, workInProgress2.lanes = NoLanes, current2 !== null && current2.memoizedState !== null ? ReactCurrentDispatcher$1.current = HooksDispatcherOnUpdateInDEV : hookTypesDev !== null ? ReactCurrentDispatcher$1.current = HooksDispatcherOnMountWithHookTypesInDEV : ReactCurrentDispatcher$1.current = HooksDispatcherOnMountInDEV;
        var children = Component(props, secondArg);
        if (didScheduleRenderPhaseUpdateDuringThisPass) {
          var numberOfReRenders = 0;
          do {
            if (didScheduleRenderPhaseUpdateDuringThisPass = !1, !(numberOfReRenders < RE_RENDER_LIMIT))
              throw Error("Too many re-renders. React limits the number of renders to prevent an infinite loop.");
            numberOfReRenders += 1, ignorePreviousDependencies = !1, currentHook = null, workInProgressHook = null, workInProgress2.updateQueue = null, hookTypesUpdateIndexDev = -1, ReactCurrentDispatcher$1.current = HooksDispatcherOnRerenderInDEV, children = Component(props, secondArg);
          } while (didScheduleRenderPhaseUpdateDuringThisPass);
        }
        ReactCurrentDispatcher$1.current = ContextOnlyDispatcher, workInProgress2._debugHookTypes = hookTypesDev;
        var didRenderTooFewHooks = currentHook !== null && currentHook.next !== null;
        if (renderLanes = NoLanes, currentlyRenderingFiber$1 = null, currentHook = null, workInProgressHook = null, currentHookNameInDev = null, hookTypesDev = null, hookTypesUpdateIndexDev = -1, didScheduleRenderPhaseUpdate = !1, didRenderTooFewHooks)
          throw Error("Rendered fewer hooks than expected. This may be caused by an accidental early return statement.");
        return children;
      }
      function bailoutHooks(current2, workInProgress2, lanes) {
        workInProgress2.updateQueue = current2.updateQueue, workInProgress2.flags &= ~(Passive | Update), current2.lanes = removeLanes(current2.lanes, lanes);
      }
      function resetHooksAfterThrow() {
        if (ReactCurrentDispatcher$1.current = ContextOnlyDispatcher, didScheduleRenderPhaseUpdate) {
          for (var hook = currentlyRenderingFiber$1.memoizedState; hook !== null; ) {
            var queue2 = hook.queue;
            queue2 !== null && (queue2.pending = null), hook = hook.next;
          }
          didScheduleRenderPhaseUpdate = !1;
        }
        renderLanes = NoLanes, currentlyRenderingFiber$1 = null, currentHook = null, workInProgressHook = null, hookTypesDev = null, hookTypesUpdateIndexDev = -1, currentHookNameInDev = null, isUpdatingOpaqueValueInRenderPhase = !1, didScheduleRenderPhaseUpdateDuringThisPass = !1;
      }
      function mountWorkInProgressHook() {
        var hook = {
          memoizedState: null,
          baseState: null,
          baseQueue: null,
          queue: null,
          next: null
        };
        return workInProgressHook === null ? currentlyRenderingFiber$1.memoizedState = workInProgressHook = hook : workInProgressHook = workInProgressHook.next = hook, workInProgressHook;
      }
      function updateWorkInProgressHook() {
        var nextCurrentHook;
        if (currentHook === null) {
          var current2 = currentlyRenderingFiber$1.alternate;
          current2 !== null ? nextCurrentHook = current2.memoizedState : nextCurrentHook = null;
        } else
          nextCurrentHook = currentHook.next;
        var nextWorkInProgressHook;
        if (workInProgressHook === null ? nextWorkInProgressHook = currentlyRenderingFiber$1.memoizedState : nextWorkInProgressHook = workInProgressHook.next, nextWorkInProgressHook !== null)
          workInProgressHook = nextWorkInProgressHook, nextWorkInProgressHook = workInProgressHook.next, currentHook = nextCurrentHook;
        else {
          if (nextCurrentHook === null)
            throw Error("Rendered more hooks than during the previous render.");
          currentHook = nextCurrentHook;
          var newHook = {
            memoizedState: currentHook.memoizedState,
            baseState: currentHook.baseState,
            baseQueue: currentHook.baseQueue,
            queue: currentHook.queue,
            next: null
          };
          workInProgressHook === null ? currentlyRenderingFiber$1.memoizedState = workInProgressHook = newHook : workInProgressHook = workInProgressHook.next = newHook;
        }
        return workInProgressHook;
      }
      function createFunctionComponentUpdateQueue() {
        return {
          lastEffect: null
        };
      }
      function basicStateReducer(state, action) {
        return typeof action == "function" ? action(state) : action;
      }
      function mountReducer(reducer, initialArg, init2) {
        var hook = mountWorkInProgressHook(), initialState;
        init2 !== void 0 ? initialState = init2(initialArg) : initialState = initialArg, hook.memoizedState = hook.baseState = initialState;
        var queue2 = hook.queue = {
          pending: null,
          dispatch: null,
          lastRenderedReducer: reducer,
          lastRenderedState: initialState
        }, dispatch = queue2.dispatch = dispatchAction.bind(null, currentlyRenderingFiber$1, queue2);
        return [hook.memoizedState, dispatch];
      }
      function updateReducer(reducer, initialArg, init2) {
        var hook = updateWorkInProgressHook(), queue2 = hook.queue;
        if (queue2 === null)
          throw Error("Should have a queue. This is likely a bug in React. Please file an issue.");
        queue2.lastRenderedReducer = reducer;
        var current2 = currentHook, baseQueue = current2.baseQueue, pendingQueue = queue2.pending;
        if (pendingQueue !== null) {
          if (baseQueue !== null) {
            var baseFirst = baseQueue.next, pendingFirst = pendingQueue.next;
            baseQueue.next = pendingFirst, pendingQueue.next = baseFirst;
          }
          current2.baseQueue !== baseQueue && error("Internal error: Expected work-in-progress queue to be a clone. This is a bug in React."), current2.baseQueue = baseQueue = pendingQueue, queue2.pending = null;
        }
        if (baseQueue !== null) {
          var first = baseQueue.next, newState = current2.baseState, newBaseState = null, newBaseQueueFirst = null, newBaseQueueLast = null, update = first;
          do {
            var updateLane = update.lane;
            if (isSubsetOfLanes(renderLanes, updateLane)) {
              if (newBaseQueueLast !== null) {
                var _clone = {
                  lane: NoLane,
                  action: update.action,
                  eagerReducer: update.eagerReducer,
                  eagerState: update.eagerState,
                  next: null
                };
                newBaseQueueLast = newBaseQueueLast.next = _clone;
              }
              if (update.eagerReducer === reducer)
                newState = update.eagerState;
              else {
                var action = update.action;
                newState = reducer(newState, action);
              }
            } else {
              var clone = {
                lane: updateLane,
                action: update.action,
                eagerReducer: update.eagerReducer,
                eagerState: update.eagerState,
                next: null
              };
              newBaseQueueLast === null ? (newBaseQueueFirst = newBaseQueueLast = clone, newBaseState = newState) : newBaseQueueLast = newBaseQueueLast.next = clone, currentlyRenderingFiber$1.lanes = mergeLanes(currentlyRenderingFiber$1.lanes, updateLane), markSkippedUpdateLanes(updateLane);
            }
            update = update.next;
          } while (update !== null && update !== first);
          newBaseQueueLast === null ? newBaseState = newState : newBaseQueueLast.next = newBaseQueueFirst, objectIs(newState, hook.memoizedState) || markWorkInProgressReceivedUpdate(), hook.memoizedState = newState, hook.baseState = newBaseState, hook.baseQueue = newBaseQueueLast, queue2.lastRenderedState = newState;
        }
        var dispatch = queue2.dispatch;
        return [hook.memoizedState, dispatch];
      }
      function rerenderReducer(reducer, initialArg, init2) {
        var hook = updateWorkInProgressHook(), queue2 = hook.queue;
        if (queue2 === null)
          throw Error("Should have a queue. This is likely a bug in React. Please file an issue.");
        queue2.lastRenderedReducer = reducer;
        var dispatch = queue2.dispatch, lastRenderPhaseUpdate = queue2.pending, newState = hook.memoizedState;
        if (lastRenderPhaseUpdate !== null) {
          queue2.pending = null;
          var firstRenderPhaseUpdate = lastRenderPhaseUpdate.next, update = firstRenderPhaseUpdate;
          do {
            var action = update.action;
            newState = reducer(newState, action), update = update.next;
          } while (update !== firstRenderPhaseUpdate);
          objectIs(newState, hook.memoizedState) || markWorkInProgressReceivedUpdate(), hook.memoizedState = newState, hook.baseQueue === null && (hook.baseState = newState), queue2.lastRenderedState = newState;
        }
        return [newState, dispatch];
      }
      function readFromUnsubcribedMutableSource(root2, source, getSnapshot) {
        warnAboutMultipleRenderersDEV(source);
        var getVersion = source._getVersion, version2 = getVersion(source._source), isSafeToReadFromSource = !1, currentRenderVersion = getWorkInProgressVersion(source);
        if (currentRenderVersion !== null ? isSafeToReadFromSource = currentRenderVersion === version2 : (isSafeToReadFromSource = isSubsetOfLanes(renderLanes, root2.mutableReadLanes), isSafeToReadFromSource && setWorkInProgressVersion(source, version2)), isSafeToReadFromSource) {
          var snapshot = getSnapshot(source._source);
          return typeof snapshot == "function" && error("Mutable source should not return a function as the snapshot value. Functions may close over mutable values and cause tearing."), snapshot;
        } else
          throw markSourceAsDirty(source), Error("Cannot read from mutable source during the current render without tearing. This is a bug in React. Please file an issue.");
      }
      function useMutableSource(hook, source, getSnapshot, subscribe) {
        var root2 = getWorkInProgressRoot();
        if (root2 === null)
          throw Error("Expected a work-in-progress root. This is a bug in React. Please file an issue.");
        var getVersion = source._getVersion, version2 = getVersion(source._source), dispatcher = ReactCurrentDispatcher$1.current, _dispatcher$useState = dispatcher.useState(function() {
          return readFromUnsubcribedMutableSource(root2, source, getSnapshot);
        }), currentSnapshot = _dispatcher$useState[0], setSnapshot = _dispatcher$useState[1], snapshot = currentSnapshot, stateHook = workInProgressHook, memoizedState = hook.memoizedState, refs = memoizedState.refs, prevGetSnapshot = refs.getSnapshot, prevSource = memoizedState.source, prevSubscribe = memoizedState.subscribe, fiber = currentlyRenderingFiber$1;
        if (hook.memoizedState = {
          refs,
          source,
          subscribe
        }, dispatcher.useEffect(function() {
          refs.getSnapshot = getSnapshot, refs.setSnapshot = setSnapshot;
          var maybeNewVersion = getVersion(source._source);
          if (!objectIs(version2, maybeNewVersion)) {
            var maybeNewSnapshot = getSnapshot(source._source);
            if (typeof maybeNewSnapshot == "function" && error("Mutable source should not return a function as the snapshot value. Functions may close over mutable values and cause tearing."), !objectIs(snapshot, maybeNewSnapshot)) {
              setSnapshot(maybeNewSnapshot);
              var lane = requestUpdateLane(fiber);
              markRootMutableRead(root2, lane);
            }
            markRootEntangled(root2, root2.mutableReadLanes);
          }
        }, [getSnapshot, source, subscribe]), dispatcher.useEffect(function() {
          var handleChange = function() {
            var latestGetSnapshot = refs.getSnapshot, latestSetSnapshot = refs.setSnapshot;
            try {
              latestSetSnapshot(latestGetSnapshot(source._source));
              var lane = requestUpdateLane(fiber);
              markRootMutableRead(root2, lane);
            } catch (error2) {
              latestSetSnapshot(function() {
                throw error2;
              });
            }
          }, unsubscribe = subscribe(source._source, handleChange);
          return typeof unsubscribe != "function" && error("Mutable source subscribe function must return an unsubscribe function."), unsubscribe;
        }, [source, subscribe]), !objectIs(prevGetSnapshot, getSnapshot) || !objectIs(prevSource, source) || !objectIs(prevSubscribe, subscribe)) {
          var newQueue = {
            pending: null,
            dispatch: null,
            lastRenderedReducer: basicStateReducer,
            lastRenderedState: snapshot
          };
          newQueue.dispatch = setSnapshot = dispatchAction.bind(null, currentlyRenderingFiber$1, newQueue), stateHook.queue = newQueue, stateHook.baseQueue = null, snapshot = readFromUnsubcribedMutableSource(root2, source, getSnapshot), stateHook.memoizedState = stateHook.baseState = snapshot;
        }
        return snapshot;
      }
      function mountMutableSource(source, getSnapshot, subscribe) {
        var hook = mountWorkInProgressHook();
        return hook.memoizedState = {
          refs: {
            getSnapshot,
            setSnapshot: null
          },
          source,
          subscribe
        }, useMutableSource(hook, source, getSnapshot, subscribe);
      }
      function updateMutableSource(source, getSnapshot, subscribe) {
        var hook = updateWorkInProgressHook();
        return useMutableSource(hook, source, getSnapshot, subscribe);
      }
      function mountState(initialState) {
        var hook = mountWorkInProgressHook();
        typeof initialState == "function" && (initialState = initialState()), hook.memoizedState = hook.baseState = initialState;
        var queue2 = hook.queue = {
          pending: null,
          dispatch: null,
          lastRenderedReducer: basicStateReducer,
          lastRenderedState: initialState
        }, dispatch = queue2.dispatch = dispatchAction.bind(null, currentlyRenderingFiber$1, queue2);
        return [hook.memoizedState, dispatch];
      }
      function updateState(initialState) {
        return updateReducer(basicStateReducer);
      }
      function rerenderState(initialState) {
        return rerenderReducer(basicStateReducer);
      }
      function pushEffect(tag, create, destroy, deps) {
        var effect = {
          tag,
          create,
          destroy,
          deps,
          next: null
        }, componentUpdateQueue = currentlyRenderingFiber$1.updateQueue;
        if (componentUpdateQueue === null)
          componentUpdateQueue = createFunctionComponentUpdateQueue(), currentlyRenderingFiber$1.updateQueue = componentUpdateQueue, componentUpdateQueue.lastEffect = effect.next = effect;
        else {
          var lastEffect = componentUpdateQueue.lastEffect;
          if (lastEffect === null)
            componentUpdateQueue.lastEffect = effect.next = effect;
          else {
            var firstEffect = lastEffect.next;
            lastEffect.next = effect, effect.next = firstEffect, componentUpdateQueue.lastEffect = effect;
          }
        }
        return effect;
      }
      function mountRef(initialValue) {
        var hook = mountWorkInProgressHook(), ref = {
          current: initialValue
        };
        return Object.seal(ref), hook.memoizedState = ref, ref;
      }
      function updateRef(initialValue) {
        var hook = updateWorkInProgressHook();
        return hook.memoizedState;
      }
      function mountEffectImpl(fiberFlags, hookFlags, create, deps) {
        var hook = mountWorkInProgressHook(), nextDeps = deps === void 0 ? null : deps;
        currentlyRenderingFiber$1.flags |= fiberFlags, hook.memoizedState = pushEffect(HasEffect | hookFlags, create, void 0, nextDeps);
      }
      function updateEffectImpl(fiberFlags, hookFlags, create, deps) {
        var hook = updateWorkInProgressHook(), nextDeps = deps === void 0 ? null : deps, destroy = void 0;
        if (currentHook !== null) {
          var prevEffect = currentHook.memoizedState;
          if (destroy = prevEffect.destroy, nextDeps !== null) {
            var prevDeps = prevEffect.deps;
            if (areHookInputsEqual(nextDeps, prevDeps)) {
              pushEffect(hookFlags, create, destroy, nextDeps);
              return;
            }
          }
        }
        currentlyRenderingFiber$1.flags |= fiberFlags, hook.memoizedState = pushEffect(HasEffect | hookFlags, create, destroy, nextDeps);
      }
      function mountEffect(create, deps) {
        return typeof jest < "u" && warnIfNotCurrentlyActingEffectsInDEV(currentlyRenderingFiber$1), mountEffectImpl(Update | Passive, Passive$1, create, deps);
      }
      function updateEffect(create, deps) {
        return typeof jest < "u" && warnIfNotCurrentlyActingEffectsInDEV(currentlyRenderingFiber$1), updateEffectImpl(Update | Passive, Passive$1, create, deps);
      }
      function mountLayoutEffect(create, deps) {
        return mountEffectImpl(Update, Layout, create, deps);
      }
      function updateLayoutEffect(create, deps) {
        return updateEffectImpl(Update, Layout, create, deps);
      }
      function imperativeHandleEffect(create, ref) {
        if (typeof ref == "function") {
          var refCallback = ref, _inst = create();
          return refCallback(_inst), function() {
            refCallback(null);
          };
        } else if (ref != null) {
          var refObject = ref;
          refObject.hasOwnProperty("current") || error("Expected useImperativeHandle() first argument to either be a ref callback or React.createRef() object. Instead received: %s.", "an object with keys {" + Object.keys(refObject).join(", ") + "}");
          var _inst2 = create();
          return refObject.current = _inst2, function() {
            refObject.current = null;
          };
        }
      }
      function mountImperativeHandle(ref, create, deps) {
        typeof create != "function" && error("Expected useImperativeHandle() second argument to be a function that creates a handle. Instead received: %s.", create !== null ? typeof create : "null");
        var effectDeps = deps != null ? deps.concat([ref]) : null;
        return mountEffectImpl(Update, Layout, imperativeHandleEffect.bind(null, create, ref), effectDeps);
      }
      function updateImperativeHandle(ref, create, deps) {
        typeof create != "function" && error("Expected useImperativeHandle() second argument to be a function that creates a handle. Instead received: %s.", create !== null ? typeof create : "null");
        var effectDeps = deps != null ? deps.concat([ref]) : null;
        return updateEffectImpl(Update, Layout, imperativeHandleEffect.bind(null, create, ref), effectDeps);
      }
      function mountDebugValue(value, formatterFn) {
      }
      var updateDebugValue = mountDebugValue;
      function mountCallback(callback, deps) {
        var hook = mountWorkInProgressHook(), nextDeps = deps === void 0 ? null : deps;
        return hook.memoizedState = [callback, nextDeps], callback;
      }
      function updateCallback(callback, deps) {
        var hook = updateWorkInProgressHook(), nextDeps = deps === void 0 ? null : deps, prevState = hook.memoizedState;
        if (prevState !== null && nextDeps !== null) {
          var prevDeps = prevState[1];
          if (areHookInputsEqual(nextDeps, prevDeps))
            return prevState[0];
        }
        return hook.memoizedState = [callback, nextDeps], callback;
      }
      function mountMemo(nextCreate, deps) {
        var hook = mountWorkInProgressHook(), nextDeps = deps === void 0 ? null : deps, nextValue = nextCreate();
        return hook.memoizedState = [nextValue, nextDeps], nextValue;
      }
      function updateMemo(nextCreate, deps) {
        var hook = updateWorkInProgressHook(), nextDeps = deps === void 0 ? null : deps, prevState = hook.memoizedState;
        if (prevState !== null && nextDeps !== null) {
          var prevDeps = prevState[1];
          if (areHookInputsEqual(nextDeps, prevDeps))
            return prevState[0];
        }
        var nextValue = nextCreate();
        return hook.memoizedState = [nextValue, nextDeps], nextValue;
      }
      function mountDeferredValue(value) {
        var _mountState = mountState(value), prevValue = _mountState[0], setValue = _mountState[1];
        return mountEffect(function() {
          var prevTransition = ReactCurrentBatchConfig$1.transition;
          ReactCurrentBatchConfig$1.transition = 1;
          try {
            setValue(value);
          } finally {
            ReactCurrentBatchConfig$1.transition = prevTransition;
          }
        }, [value]), prevValue;
      }
      function updateDeferredValue(value) {
        var _updateState = updateState(), prevValue = _updateState[0], setValue = _updateState[1];
        return updateEffect(function() {
          var prevTransition = ReactCurrentBatchConfig$1.transition;
          ReactCurrentBatchConfig$1.transition = 1;
          try {
            setValue(value);
          } finally {
            ReactCurrentBatchConfig$1.transition = prevTransition;
          }
        }, [value]), prevValue;
      }
      function rerenderDeferredValue(value) {
        var _rerenderState = rerenderState(), prevValue = _rerenderState[0], setValue = _rerenderState[1];
        return updateEffect(function() {
          var prevTransition = ReactCurrentBatchConfig$1.transition;
          ReactCurrentBatchConfig$1.transition = 1;
          try {
            setValue(value);
          } finally {
            ReactCurrentBatchConfig$1.transition = prevTransition;
          }
        }, [value]), prevValue;
      }
      function startTransition(setPending, callback) {
        var priorityLevel = getCurrentPriorityLevel();
        runWithPriority$1(priorityLevel < UserBlockingPriority$2 ? UserBlockingPriority$2 : priorityLevel, function() {
          setPending(!0);
        }), runWithPriority$1(priorityLevel > NormalPriority$1 ? NormalPriority$1 : priorityLevel, function() {
          var prevTransition = ReactCurrentBatchConfig$1.transition;
          ReactCurrentBatchConfig$1.transition = 1;
          try {
            setPending(!1), callback();
          } finally {
            ReactCurrentBatchConfig$1.transition = prevTransition;
          }
        });
      }
      function mountTransition() {
        var _mountState2 = mountState(!1), isPending = _mountState2[0], setPending = _mountState2[1], start = startTransition.bind(null, setPending);
        return mountRef(start), [start, isPending];
      }
      function updateTransition() {
        var _updateState2 = updateState(), isPending = _updateState2[0], startRef = updateRef(), start = startRef.current;
        return [start, isPending];
      }
      function rerenderTransition() {
        var _rerenderState2 = rerenderState(), isPending = _rerenderState2[0], startRef = updateRef(), start = startRef.current;
        return [start, isPending];
      }
      var isUpdatingOpaqueValueInRenderPhase = !1;
      function getIsUpdatingOpaqueValueInRenderPhaseInDEV() {
        return isUpdatingOpaqueValueInRenderPhase;
      }
      function warnOnOpaqueIdentifierAccessInDEV(fiber) {
        {
          var name = getComponentName(fiber.type) || "Unknown";
          getIsRendering() && !didWarnAboutUseOpaqueIdentifier[name] && (error("The object passed back from useOpaqueIdentifier is meant to be passed through to attributes only. Do not read the value directly."), didWarnAboutUseOpaqueIdentifier[name] = !0);
        }
      }
      function mountOpaqueIdentifier() {
        var makeId = makeClientIdInDEV.bind(null, warnOnOpaqueIdentifierAccessInDEV.bind(null, currentlyRenderingFiber$1));
        if (getIsHydrating()) {
          var didUpgrade = !1, fiber = currentlyRenderingFiber$1, readValue = function() {
            throw didUpgrade || (didUpgrade = !0, isUpdatingOpaqueValueInRenderPhase = !0, setId(makeId()), isUpdatingOpaqueValueInRenderPhase = !1, warnOnOpaqueIdentifierAccessInDEV(fiber)), Error("The object passed back from useOpaqueIdentifier is meant to be passed through to attributes only. Do not read the value directly.");
          }, id = makeOpaqueHydratingObject(readValue), setId = mountState(id)[1];
          return (currentlyRenderingFiber$1.mode & BlockingMode) === NoMode && (currentlyRenderingFiber$1.flags |= Update | Passive, pushEffect(HasEffect | Passive$1, function() {
            setId(makeId());
          }, void 0, null)), id;
        } else {
          var _id = makeId();
          return mountState(_id), _id;
        }
      }
      function updateOpaqueIdentifier() {
        var id = updateState()[0];
        return id;
      }
      function rerenderOpaqueIdentifier() {
        var id = rerenderState()[0];
        return id;
      }
      function dispatchAction(fiber, queue2, action) {
        typeof arguments[3] == "function" && error("State updates from the useState() and useReducer() Hooks don't support the second callback argument. To execute a side effect after rendering, declare it in the component body with useEffect().");
        var eventTime = requestEventTime(), lane = requestUpdateLane(fiber), update = {
          lane,
          action,
          eagerReducer: null,
          eagerState: null,
          next: null
        }, pending = queue2.pending;
        pending === null ? update.next = update : (update.next = pending.next, pending.next = update), queue2.pending = update;
        var alternate = fiber.alternate;
        if (fiber === currentlyRenderingFiber$1 || alternate !== null && alternate === currentlyRenderingFiber$1)
          didScheduleRenderPhaseUpdateDuringThisPass = didScheduleRenderPhaseUpdate = !0;
        else {
          if (fiber.lanes === NoLanes && (alternate === null || alternate.lanes === NoLanes)) {
            var lastRenderedReducer = queue2.lastRenderedReducer;
            if (lastRenderedReducer !== null) {
              var prevDispatcher;
              prevDispatcher = ReactCurrentDispatcher$1.current, ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnUpdateInDEV;
              try {
                var currentState = queue2.lastRenderedState, eagerState = lastRenderedReducer(currentState, action);
                if (update.eagerReducer = lastRenderedReducer, update.eagerState = eagerState, objectIs(eagerState, currentState))
                  return;
              } catch {
              } finally {
                ReactCurrentDispatcher$1.current = prevDispatcher;
              }
            }
          }
          typeof jest < "u" && (warnIfNotScopedWithMatchingAct(fiber), warnIfNotCurrentlyActingUpdatesInDev(fiber)), scheduleUpdateOnFiber(fiber, lane, eventTime);
        }
      }
      var ContextOnlyDispatcher = {
        readContext,
        useCallback: throwInvalidHookError,
        useContext: throwInvalidHookError,
        useEffect: throwInvalidHookError,
        useImperativeHandle: throwInvalidHookError,
        useLayoutEffect: throwInvalidHookError,
        useMemo: throwInvalidHookError,
        useReducer: throwInvalidHookError,
        useRef: throwInvalidHookError,
        useState: throwInvalidHookError,
        useDebugValue: throwInvalidHookError,
        useDeferredValue: throwInvalidHookError,
        useTransition: throwInvalidHookError,
        useMutableSource: throwInvalidHookError,
        useOpaqueIdentifier: throwInvalidHookError,
        unstable_isNewReconciler: enableNewReconciler
      }, HooksDispatcherOnMountInDEV = null, HooksDispatcherOnMountWithHookTypesInDEV = null, HooksDispatcherOnUpdateInDEV = null, HooksDispatcherOnRerenderInDEV = null, InvalidNestedHooksDispatcherOnMountInDEV = null, InvalidNestedHooksDispatcherOnUpdateInDEV = null, InvalidNestedHooksDispatcherOnRerenderInDEV = null;
      {
        var warnInvalidContextAccess = function() {
          error("Context can only be read while React is rendering. In classes, you can read it in the render method or getDerivedStateFromProps. In function components, you can read it directly in the function body, but not inside Hooks like useReducer() or useMemo().");
        }, warnInvalidHookAccess = function() {
          error("Do not call Hooks inside useEffect(...), useMemo(...), or other built-in Hooks. You can only call Hooks at the top level of your React function. For more information, see https://reactjs.org/link/rules-of-hooks");
        };
        HooksDispatcherOnMountInDEV = {
          readContext: function(context, observedBits) {
            return readContext(context, observedBits);
          },
          useCallback: function(callback, deps) {
            return currentHookNameInDev = "useCallback", mountHookTypesDev(), checkDepsAreArrayDev(deps), mountCallback(callback, deps);
          },
          useContext: function(context, observedBits) {
            return currentHookNameInDev = "useContext", mountHookTypesDev(), readContext(context, observedBits);
          },
          useEffect: function(create, deps) {
            return currentHookNameInDev = "useEffect", mountHookTypesDev(), checkDepsAreArrayDev(deps), mountEffect(create, deps);
          },
          useImperativeHandle: function(ref, create, deps) {
            return currentHookNameInDev = "useImperativeHandle", mountHookTypesDev(), checkDepsAreArrayDev(deps), mountImperativeHandle(ref, create, deps);
          },
          useLayoutEffect: function(create, deps) {
            return currentHookNameInDev = "useLayoutEffect", mountHookTypesDev(), checkDepsAreArrayDev(deps), mountLayoutEffect(create, deps);
          },
          useMemo: function(create, deps) {
            currentHookNameInDev = "useMemo", mountHookTypesDev(), checkDepsAreArrayDev(deps);
            var prevDispatcher = ReactCurrentDispatcher$1.current;
            ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnMountInDEV;
            try {
              return mountMemo(create, deps);
            } finally {
              ReactCurrentDispatcher$1.current = prevDispatcher;
            }
          },
          useReducer: function(reducer, initialArg, init2) {
            currentHookNameInDev = "useReducer", mountHookTypesDev();
            var prevDispatcher = ReactCurrentDispatcher$1.current;
            ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnMountInDEV;
            try {
              return mountReducer(reducer, initialArg, init2);
            } finally {
              ReactCurrentDispatcher$1.current = prevDispatcher;
            }
          },
          useRef: function(initialValue) {
            return currentHookNameInDev = "useRef", mountHookTypesDev(), mountRef(initialValue);
          },
          useState: function(initialState) {
            currentHookNameInDev = "useState", mountHookTypesDev();
            var prevDispatcher = ReactCurrentDispatcher$1.current;
            ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnMountInDEV;
            try {
              return mountState(initialState);
            } finally {
              ReactCurrentDispatcher$1.current = prevDispatcher;
            }
          },
          useDebugValue: function(value, formatterFn) {
            return currentHookNameInDev = "useDebugValue", mountHookTypesDev(), void 0;
          },
          useDeferredValue: function(value) {
            return currentHookNameInDev = "useDeferredValue", mountHookTypesDev(), mountDeferredValue(value);
          },
          useTransition: function() {
            return currentHookNameInDev = "useTransition", mountHookTypesDev(), mountTransition();
          },
          useMutableSource: function(source, getSnapshot, subscribe) {
            return currentHookNameInDev = "useMutableSource", mountHookTypesDev(), mountMutableSource(source, getSnapshot, subscribe);
          },
          useOpaqueIdentifier: function() {
            return currentHookNameInDev = "useOpaqueIdentifier", mountHookTypesDev(), mountOpaqueIdentifier();
          },
          unstable_isNewReconciler: enableNewReconciler
        }, HooksDispatcherOnMountWithHookTypesInDEV = {
          readContext: function(context, observedBits) {
            return readContext(context, observedBits);
          },
          useCallback: function(callback, deps) {
            return currentHookNameInDev = "useCallback", updateHookTypesDev(), mountCallback(callback, deps);
          },
          useContext: function(context, observedBits) {
            return currentHookNameInDev = "useContext", updateHookTypesDev(), readContext(context, observedBits);
          },
          useEffect: function(create, deps) {
            return currentHookNameInDev = "useEffect", updateHookTypesDev(), mountEffect(create, deps);
          },
          useImperativeHandle: function(ref, create, deps) {
            return currentHookNameInDev = "useImperativeHandle", updateHookTypesDev(), mountImperativeHandle(ref, create, deps);
          },
          useLayoutEffect: function(create, deps) {
            return currentHookNameInDev = "useLayoutEffect", updateHookTypesDev(), mountLayoutEffect(create, deps);
          },
          useMemo: function(create, deps) {
            currentHookNameInDev = "useMemo", updateHookTypesDev();
            var prevDispatcher = ReactCurrentDispatcher$1.current;
            ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnMountInDEV;
            try {
              return mountMemo(create, deps);
            } finally {
              ReactCurrentDispatcher$1.current = prevDispatcher;
            }
          },
          useReducer: function(reducer, initialArg, init2) {
            currentHookNameInDev = "useReducer", updateHookTypesDev();
            var prevDispatcher = ReactCurrentDispatcher$1.current;
            ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnMountInDEV;
            try {
              return mountReducer(reducer, initialArg, init2);
            } finally {
              ReactCurrentDispatcher$1.current = prevDispatcher;
            }
          },
          useRef: function(initialValue) {
            return currentHookNameInDev = "useRef", updateHookTypesDev(), mountRef(initialValue);
          },
          useState: function(initialState) {
            currentHookNameInDev = "useState", updateHookTypesDev();
            var prevDispatcher = ReactCurrentDispatcher$1.current;
            ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnMountInDEV;
            try {
              return mountState(initialState);
            } finally {
              ReactCurrentDispatcher$1.current = prevDispatcher;
            }
          },
          useDebugValue: function(value, formatterFn) {
            return currentHookNameInDev = "useDebugValue", updateHookTypesDev(), void 0;
          },
          useDeferredValue: function(value) {
            return currentHookNameInDev = "useDeferredValue", updateHookTypesDev(), mountDeferredValue(value);
          },
          useTransition: function() {
            return currentHookNameInDev = "useTransition", updateHookTypesDev(), mountTransition();
          },
          useMutableSource: function(source, getSnapshot, subscribe) {
            return currentHookNameInDev = "useMutableSource", updateHookTypesDev(), mountMutableSource(source, getSnapshot, subscribe);
          },
          useOpaqueIdentifier: function() {
            return currentHookNameInDev = "useOpaqueIdentifier", updateHookTypesDev(), mountOpaqueIdentifier();
          },
          unstable_isNewReconciler: enableNewReconciler
        }, HooksDispatcherOnUpdateInDEV = {
          readContext: function(context, observedBits) {
            return readContext(context, observedBits);
          },
          useCallback: function(callback, deps) {
            return currentHookNameInDev = "useCallback", updateHookTypesDev(), updateCallback(callback, deps);
          },
          useContext: function(context, observedBits) {
            return currentHookNameInDev = "useContext", updateHookTypesDev(), readContext(context, observedBits);
          },
          useEffect: function(create, deps) {
            return currentHookNameInDev = "useEffect", updateHookTypesDev(), updateEffect(create, deps);
          },
          useImperativeHandle: function(ref, create, deps) {
            return currentHookNameInDev = "useImperativeHandle", updateHookTypesDev(), updateImperativeHandle(ref, create, deps);
          },
          useLayoutEffect: function(create, deps) {
            return currentHookNameInDev = "useLayoutEffect", updateHookTypesDev(), updateLayoutEffect(create, deps);
          },
          useMemo: function(create, deps) {
            currentHookNameInDev = "useMemo", updateHookTypesDev();
            var prevDispatcher = ReactCurrentDispatcher$1.current;
            ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnUpdateInDEV;
            try {
              return updateMemo(create, deps);
            } finally {
              ReactCurrentDispatcher$1.current = prevDispatcher;
            }
          },
          useReducer: function(reducer, initialArg, init2) {
            currentHookNameInDev = "useReducer", updateHookTypesDev();
            var prevDispatcher = ReactCurrentDispatcher$1.current;
            ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnUpdateInDEV;
            try {
              return updateReducer(reducer, initialArg, init2);
            } finally {
              ReactCurrentDispatcher$1.current = prevDispatcher;
            }
          },
          useRef: function(initialValue) {
            return currentHookNameInDev = "useRef", updateHookTypesDev(), updateRef();
          },
          useState: function(initialState) {
            currentHookNameInDev = "useState", updateHookTypesDev();
            var prevDispatcher = ReactCurrentDispatcher$1.current;
            ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnUpdateInDEV;
            try {
              return updateState(initialState);
            } finally {
              ReactCurrentDispatcher$1.current = prevDispatcher;
            }
          },
          useDebugValue: function(value, formatterFn) {
            return currentHookNameInDev = "useDebugValue", updateHookTypesDev(), updateDebugValue();
          },
          useDeferredValue: function(value) {
            return currentHookNameInDev = "useDeferredValue", updateHookTypesDev(), updateDeferredValue(value);
          },
          useTransition: function() {
            return currentHookNameInDev = "useTransition", updateHookTypesDev(), updateTransition();
          },
          useMutableSource: function(source, getSnapshot, subscribe) {
            return currentHookNameInDev = "useMutableSource", updateHookTypesDev(), updateMutableSource(source, getSnapshot, subscribe);
          },
          useOpaqueIdentifier: function() {
            return currentHookNameInDev = "useOpaqueIdentifier", updateHookTypesDev(), updateOpaqueIdentifier();
          },
          unstable_isNewReconciler: enableNewReconciler
        }, HooksDispatcherOnRerenderInDEV = {
          readContext: function(context, observedBits) {
            return readContext(context, observedBits);
          },
          useCallback: function(callback, deps) {
            return currentHookNameInDev = "useCallback", updateHookTypesDev(), updateCallback(callback, deps);
          },
          useContext: function(context, observedBits) {
            return currentHookNameInDev = "useContext", updateHookTypesDev(), readContext(context, observedBits);
          },
          useEffect: function(create, deps) {
            return currentHookNameInDev = "useEffect", updateHookTypesDev(), updateEffect(create, deps);
          },
          useImperativeHandle: function(ref, create, deps) {
            return currentHookNameInDev = "useImperativeHandle", updateHookTypesDev(), updateImperativeHandle(ref, create, deps);
          },
          useLayoutEffect: function(create, deps) {
            return currentHookNameInDev = "useLayoutEffect", updateHookTypesDev(), updateLayoutEffect(create, deps);
          },
          useMemo: function(create, deps) {
            currentHookNameInDev = "useMemo", updateHookTypesDev();
            var prevDispatcher = ReactCurrentDispatcher$1.current;
            ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnRerenderInDEV;
            try {
              return updateMemo(create, deps);
            } finally {
              ReactCurrentDispatcher$1.current = prevDispatcher;
            }
          },
          useReducer: function(reducer, initialArg, init2) {
            currentHookNameInDev = "useReducer", updateHookTypesDev();
            var prevDispatcher = ReactCurrentDispatcher$1.current;
            ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnRerenderInDEV;
            try {
              return rerenderReducer(reducer, initialArg, init2);
            } finally {
              ReactCurrentDispatcher$1.current = prevDispatcher;
            }
          },
          useRef: function(initialValue) {
            return currentHookNameInDev = "useRef", updateHookTypesDev(), updateRef();
          },
          useState: function(initialState) {
            currentHookNameInDev = "useState", updateHookTypesDev();
            var prevDispatcher = ReactCurrentDispatcher$1.current;
            ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnRerenderInDEV;
            try {
              return rerenderState(initialState);
            } finally {
              ReactCurrentDispatcher$1.current = prevDispatcher;
            }
          },
          useDebugValue: function(value, formatterFn) {
            return currentHookNameInDev = "useDebugValue", updateHookTypesDev(), updateDebugValue();
          },
          useDeferredValue: function(value) {
            return currentHookNameInDev = "useDeferredValue", updateHookTypesDev(), rerenderDeferredValue(value);
          },
          useTransition: function() {
            return currentHookNameInDev = "useTransition", updateHookTypesDev(), rerenderTransition();
          },
          useMutableSource: function(source, getSnapshot, subscribe) {
            return currentHookNameInDev = "useMutableSource", updateHookTypesDev(), updateMutableSource(source, getSnapshot, subscribe);
          },
          useOpaqueIdentifier: function() {
            return currentHookNameInDev = "useOpaqueIdentifier", updateHookTypesDev(), rerenderOpaqueIdentifier();
          },
          unstable_isNewReconciler: enableNewReconciler
        }, InvalidNestedHooksDispatcherOnMountInDEV = {
          readContext: function(context, observedBits) {
            return warnInvalidContextAccess(), readContext(context, observedBits);
          },
          useCallback: function(callback, deps) {
            return currentHookNameInDev = "useCallback", warnInvalidHookAccess(), mountHookTypesDev(), mountCallback(callback, deps);
          },
          useContext: function(context, observedBits) {
            return currentHookNameInDev = "useContext", warnInvalidHookAccess(), mountHookTypesDev(), readContext(context, observedBits);
          },
          useEffect: function(create, deps) {
            return currentHookNameInDev = "useEffect", warnInvalidHookAccess(), mountHookTypesDev(), mountEffect(create, deps);
          },
          useImperativeHandle: function(ref, create, deps) {
            return currentHookNameInDev = "useImperativeHandle", warnInvalidHookAccess(), mountHookTypesDev(), mountImperativeHandle(ref, create, deps);
          },
          useLayoutEffect: function(create, deps) {
            return currentHookNameInDev = "useLayoutEffect", warnInvalidHookAccess(), mountHookTypesDev(), mountLayoutEffect(create, deps);
          },
          useMemo: function(create, deps) {
            currentHookNameInDev = "useMemo", warnInvalidHookAccess(), mountHookTypesDev();
            var prevDispatcher = ReactCurrentDispatcher$1.current;
            ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnMountInDEV;
            try {
              return mountMemo(create, deps);
            } finally {
              ReactCurrentDispatcher$1.current = prevDispatcher;
            }
          },
          useReducer: function(reducer, initialArg, init2) {
            currentHookNameInDev = "useReducer", warnInvalidHookAccess(), mountHookTypesDev();
            var prevDispatcher = ReactCurrentDispatcher$1.current;
            ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnMountInDEV;
            try {
              return mountReducer(reducer, initialArg, init2);
            } finally {
              ReactCurrentDispatcher$1.current = prevDispatcher;
            }
          },
          useRef: function(initialValue) {
            return currentHookNameInDev = "useRef", warnInvalidHookAccess(), mountHookTypesDev(), mountRef(initialValue);
          },
          useState: function(initialState) {
            currentHookNameInDev = "useState", warnInvalidHookAccess(), mountHookTypesDev();
            var prevDispatcher = ReactCurrentDispatcher$1.current;
            ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnMountInDEV;
            try {
              return mountState(initialState);
            } finally {
              ReactCurrentDispatcher$1.current = prevDispatcher;
            }
          },
          useDebugValue: function(value, formatterFn) {
            return currentHookNameInDev = "useDebugValue", warnInvalidHookAccess(), mountHookTypesDev(), void 0;
          },
          useDeferredValue: function(value) {
            return currentHookNameInDev = "useDeferredValue", warnInvalidHookAccess(), mountHookTypesDev(), mountDeferredValue(value);
          },
          useTransition: function() {
            return currentHookNameInDev = "useTransition", warnInvalidHookAccess(), mountHookTypesDev(), mountTransition();
          },
          useMutableSource: function(source, getSnapshot, subscribe) {
            return currentHookNameInDev = "useMutableSource", warnInvalidHookAccess(), mountHookTypesDev(), mountMutableSource(source, getSnapshot, subscribe);
          },
          useOpaqueIdentifier: function() {
            return currentHookNameInDev = "useOpaqueIdentifier", warnInvalidHookAccess(), mountHookTypesDev(), mountOpaqueIdentifier();
          },
          unstable_isNewReconciler: enableNewReconciler
        }, InvalidNestedHooksDispatcherOnUpdateInDEV = {
          readContext: function(context, observedBits) {
            return warnInvalidContextAccess(), readContext(context, observedBits);
          },
          useCallback: function(callback, deps) {
            return currentHookNameInDev = "useCallback", warnInvalidHookAccess(), updateHookTypesDev(), updateCallback(callback, deps);
          },
          useContext: function(context, observedBits) {
            return currentHookNameInDev = "useContext", warnInvalidHookAccess(), updateHookTypesDev(), readContext(context, observedBits);
          },
          useEffect: function(create, deps) {
            return currentHookNameInDev = "useEffect", warnInvalidHookAccess(), updateHookTypesDev(), updateEffect(create, deps);
          },
          useImperativeHandle: function(ref, create, deps) {
            return currentHookNameInDev = "useImperativeHandle", warnInvalidHookAccess(), updateHookTypesDev(), updateImperativeHandle(ref, create, deps);
          },
          useLayoutEffect: function(create, deps) {
            return currentHookNameInDev = "useLayoutEffect", warnInvalidHookAccess(), updateHookTypesDev(), updateLayoutEffect(create, deps);
          },
          useMemo: function(create, deps) {
            currentHookNameInDev = "useMemo", warnInvalidHookAccess(), updateHookTypesDev();
            var prevDispatcher = ReactCurrentDispatcher$1.current;
            ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnUpdateInDEV;
            try {
              return updateMemo(create, deps);
            } finally {
              ReactCurrentDispatcher$1.current = prevDispatcher;
            }
          },
          useReducer: function(reducer, initialArg, init2) {
            currentHookNameInDev = "useReducer", warnInvalidHookAccess(), updateHookTypesDev();
            var prevDispatcher = ReactCurrentDispatcher$1.current;
            ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnUpdateInDEV;
            try {
              return updateReducer(reducer, initialArg, init2);
            } finally {
              ReactCurrentDispatcher$1.current = prevDispatcher;
            }
          },
          useRef: function(initialValue) {
            return currentHookNameInDev = "useRef", warnInvalidHookAccess(), updateHookTypesDev(), updateRef();
          },
          useState: function(initialState) {
            currentHookNameInDev = "useState", warnInvalidHookAccess(), updateHookTypesDev();
            var prevDispatcher = ReactCurrentDispatcher$1.current;
            ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnUpdateInDEV;
            try {
              return updateState(initialState);
            } finally {
              ReactCurrentDispatcher$1.current = prevDispatcher;
            }
          },
          useDebugValue: function(value, formatterFn) {
            return currentHookNameInDev = "useDebugValue", warnInvalidHookAccess(), updateHookTypesDev(), updateDebugValue();
          },
          useDeferredValue: function(value) {
            return currentHookNameInDev = "useDeferredValue", warnInvalidHookAccess(), updateHookTypesDev(), updateDeferredValue(value);
          },
          useTransition: function() {
            return currentHookNameInDev = "useTransition", warnInvalidHookAccess(), updateHookTypesDev(), updateTransition();
          },
          useMutableSource: function(source, getSnapshot, subscribe) {
            return currentHookNameInDev = "useMutableSource", warnInvalidHookAccess(), updateHookTypesDev(), updateMutableSource(source, getSnapshot, subscribe);
          },
          useOpaqueIdentifier: function() {
            return currentHookNameInDev = "useOpaqueIdentifier", warnInvalidHookAccess(), updateHookTypesDev(), updateOpaqueIdentifier();
          },
          unstable_isNewReconciler: enableNewReconciler
        }, InvalidNestedHooksDispatcherOnRerenderInDEV = {
          readContext: function(context, observedBits) {
            return warnInvalidContextAccess(), readContext(context, observedBits);
          },
          useCallback: function(callback, deps) {
            return currentHookNameInDev = "useCallback", warnInvalidHookAccess(), updateHookTypesDev(), updateCallback(callback, deps);
          },
          useContext: function(context, observedBits) {
            return currentHookNameInDev = "useContext", warnInvalidHookAccess(), updateHookTypesDev(), readContext(context, observedBits);
          },
          useEffect: function(create, deps) {
            return currentHookNameInDev = "useEffect", warnInvalidHookAccess(), updateHookTypesDev(), updateEffect(create, deps);
          },
          useImperativeHandle: function(ref, create, deps) {
            return currentHookNameInDev = "useImperativeHandle", warnInvalidHookAccess(), updateHookTypesDev(), updateImperativeHandle(ref, create, deps);
          },
          useLayoutEffect: function(create, deps) {
            return currentHookNameInDev = "useLayoutEffect", warnInvalidHookAccess(), updateHookTypesDev(), updateLayoutEffect(create, deps);
          },
          useMemo: function(create, deps) {
            currentHookNameInDev = "useMemo", warnInvalidHookAccess(), updateHookTypesDev();
            var prevDispatcher = ReactCurrentDispatcher$1.current;
            ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnUpdateInDEV;
            try {
              return updateMemo(create, deps);
            } finally {
              ReactCurrentDispatcher$1.current = prevDispatcher;
            }
          },
          useReducer: function(reducer, initialArg, init2) {
            currentHookNameInDev = "useReducer", warnInvalidHookAccess(), updateHookTypesDev();
            var prevDispatcher = ReactCurrentDispatcher$1.current;
            ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnUpdateInDEV;
            try {
              return rerenderReducer(reducer, initialArg, init2);
            } finally {
              ReactCurrentDispatcher$1.current = prevDispatcher;
            }
          },
          useRef: function(initialValue) {
            return currentHookNameInDev = "useRef", warnInvalidHookAccess(), updateHookTypesDev(), updateRef();
          },
          useState: function(initialState) {
            currentHookNameInDev = "useState", warnInvalidHookAccess(), updateHookTypesDev();
            var prevDispatcher = ReactCurrentDispatcher$1.current;
            ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnUpdateInDEV;
            try {
              return rerenderState(initialState);
            } finally {
              ReactCurrentDispatcher$1.current = prevDispatcher;
            }
          },
          useDebugValue: function(value, formatterFn) {
            return currentHookNameInDev = "useDebugValue", warnInvalidHookAccess(), updateHookTypesDev(), updateDebugValue();
          },
          useDeferredValue: function(value) {
            return currentHookNameInDev = "useDeferredValue", warnInvalidHookAccess(), updateHookTypesDev(), rerenderDeferredValue(value);
          },
          useTransition: function() {
            return currentHookNameInDev = "useTransition", warnInvalidHookAccess(), updateHookTypesDev(), rerenderTransition();
          },
          useMutableSource: function(source, getSnapshot, subscribe) {
            return currentHookNameInDev = "useMutableSource", warnInvalidHookAccess(), updateHookTypesDev(), updateMutableSource(source, getSnapshot, subscribe);
          },
          useOpaqueIdentifier: function() {
            return currentHookNameInDev = "useOpaqueIdentifier", warnInvalidHookAccess(), updateHookTypesDev(), rerenderOpaqueIdentifier();
          },
          unstable_isNewReconciler: enableNewReconciler
        };
      }
      var now$1 = Scheduler.unstable_now, commitTime = 0, profilerStartTime = -1;
      function getCommitTime() {
        return commitTime;
      }
      function recordCommitTime() {
        commitTime = now$1();
      }
      function startProfilerTimer(fiber) {
        profilerStartTime = now$1(), fiber.actualStartTime < 0 && (fiber.actualStartTime = now$1());
      }
      function stopProfilerTimerIfRunning(fiber) {
        profilerStartTime = -1;
      }
      function stopProfilerTimerIfRunningAndRecordDelta(fiber, overrideBaseTime) {
        if (profilerStartTime >= 0) {
          var elapsedTime = now$1() - profilerStartTime;
          fiber.actualDuration += elapsedTime, overrideBaseTime && (fiber.selfBaseDuration = elapsedTime), profilerStartTime = -1;
        }
      }
      function transferActualDuration(fiber) {
        for (var child = fiber.child; child; )
          fiber.actualDuration += child.actualDuration, child = child.sibling;
      }
      var ReactCurrentOwner$1 = ReactSharedInternals.ReactCurrentOwner, didReceiveUpdate = !1, didWarnAboutBadClass, didWarnAboutModulePatternComponent, didWarnAboutContextTypeOnFunctionComponent, didWarnAboutGetDerivedStateOnFunctionComponent, didWarnAboutFunctionRefs, didWarnAboutReassigningProps, didWarnAboutRevealOrder, didWarnAboutTailOptions;
      didWarnAboutBadClass = {}, didWarnAboutModulePatternComponent = {}, didWarnAboutContextTypeOnFunctionComponent = {}, didWarnAboutGetDerivedStateOnFunctionComponent = {}, didWarnAboutFunctionRefs = {}, didWarnAboutReassigningProps = !1, didWarnAboutRevealOrder = {}, didWarnAboutTailOptions = {};
      function reconcileChildren(current2, workInProgress2, nextChildren, renderLanes2) {
        current2 === null ? workInProgress2.child = mountChildFibers(workInProgress2, null, nextChildren, renderLanes2) : workInProgress2.child = reconcileChildFibers(workInProgress2, current2.child, nextChildren, renderLanes2);
      }
      function forceUnmountCurrentAndReconcile(current2, workInProgress2, nextChildren, renderLanes2) {
        workInProgress2.child = reconcileChildFibers(workInProgress2, current2.child, null, renderLanes2), workInProgress2.child = reconcileChildFibers(workInProgress2, null, nextChildren, renderLanes2);
      }
      function updateForwardRef(current2, workInProgress2, Component, nextProps, renderLanes2) {
        if (workInProgress2.type !== workInProgress2.elementType) {
          var innerPropTypes = Component.propTypes;
          innerPropTypes && checkPropTypes(
            innerPropTypes,
            nextProps,
            "prop",
            getComponentName(Component)
          );
        }
        var render2 = Component.render, ref = workInProgress2.ref, nextChildren;
        prepareToReadContext(workInProgress2, renderLanes2);
        {
          if (ReactCurrentOwner$1.current = workInProgress2, setIsRendering(!0), nextChildren = renderWithHooks(current2, workInProgress2, render2, nextProps, ref, renderLanes2), workInProgress2.mode & StrictMode) {
            disableLogs();
            try {
              nextChildren = renderWithHooks(current2, workInProgress2, render2, nextProps, ref, renderLanes2);
            } finally {
              reenableLogs();
            }
          }
          setIsRendering(!1);
        }
        return current2 !== null && !didReceiveUpdate ? (bailoutHooks(current2, workInProgress2, renderLanes2), bailoutOnAlreadyFinishedWork(current2, workInProgress2, renderLanes2)) : (workInProgress2.flags |= PerformedWork, reconcileChildren(current2, workInProgress2, nextChildren, renderLanes2), workInProgress2.child);
      }
      function updateMemoComponent(current2, workInProgress2, Component, nextProps, updateLanes, renderLanes2) {
        if (current2 === null) {
          var type = Component.type;
          if (isSimpleFunctionComponent(type) && Component.compare === null && Component.defaultProps === void 0) {
            var resolvedType = type;
            return resolvedType = resolveFunctionForHotReloading(type), workInProgress2.tag = SimpleMemoComponent, workInProgress2.type = resolvedType, validateFunctionComponentInDev(workInProgress2, type), updateSimpleMemoComponent(current2, workInProgress2, resolvedType, nextProps, updateLanes, renderLanes2);
          }
          {
            var innerPropTypes = type.propTypes;
            innerPropTypes && checkPropTypes(
              innerPropTypes,
              nextProps,
              "prop",
              getComponentName(type)
            );
          }
          var child = createFiberFromTypeAndProps(Component.type, null, nextProps, workInProgress2, workInProgress2.mode, renderLanes2);
          return child.ref = workInProgress2.ref, child.return = workInProgress2, workInProgress2.child = child, child;
        }
        {
          var _type = Component.type, _innerPropTypes = _type.propTypes;
          _innerPropTypes && checkPropTypes(
            _innerPropTypes,
            nextProps,
            "prop",
            getComponentName(_type)
          );
        }
        var currentChild = current2.child;
        if (!includesSomeLane(updateLanes, renderLanes2)) {
          var prevProps = currentChild.memoizedProps, compare3 = Component.compare;
          if (compare3 = compare3 !== null ? compare3 : shallowEqual, compare3(prevProps, nextProps) && current2.ref === workInProgress2.ref)
            return bailoutOnAlreadyFinishedWork(current2, workInProgress2, renderLanes2);
        }
        workInProgress2.flags |= PerformedWork;
        var newChild = createWorkInProgress(currentChild, nextProps);
        return newChild.ref = workInProgress2.ref, newChild.return = workInProgress2, workInProgress2.child = newChild, newChild;
      }
      function updateSimpleMemoComponent(current2, workInProgress2, Component, nextProps, updateLanes, renderLanes2) {
        if (workInProgress2.type !== workInProgress2.elementType) {
          var outerMemoType = workInProgress2.elementType;
          if (outerMemoType.$$typeof === REACT_LAZY_TYPE) {
            var lazyComponent = outerMemoType, payload = lazyComponent._payload, init2 = lazyComponent._init;
            try {
              outerMemoType = init2(payload);
            } catch {
              outerMemoType = null;
            }
            var outerPropTypes = outerMemoType && outerMemoType.propTypes;
            outerPropTypes && checkPropTypes(
              outerPropTypes,
              nextProps,
              "prop",
              getComponentName(outerMemoType)
            );
          }
        }
        if (current2 !== null) {
          var prevProps = current2.memoizedProps;
          if (shallowEqual(prevProps, nextProps) && current2.ref === workInProgress2.ref && workInProgress2.type === current2.type)
            if (didReceiveUpdate = !1, includesSomeLane(renderLanes2, updateLanes))
              (current2.flags & ForceUpdateForLegacySuspense) !== NoFlags && (didReceiveUpdate = !0);
            else
              return workInProgress2.lanes = current2.lanes, bailoutOnAlreadyFinishedWork(current2, workInProgress2, renderLanes2);
        }
        return updateFunctionComponent(current2, workInProgress2, Component, nextProps, renderLanes2);
      }
      function updateOffscreenComponent(current2, workInProgress2, renderLanes2) {
        var nextProps = workInProgress2.pendingProps, nextChildren = nextProps.children, prevState = current2 !== null ? current2.memoizedState : null;
        if (nextProps.mode === "hidden" || nextProps.mode === "unstable-defer-without-hiding")
          if ((workInProgress2.mode & ConcurrentMode) === NoMode) {
            var nextState = {
              baseLanes: NoLanes
            };
            workInProgress2.memoizedState = nextState, pushRenderLanes(workInProgress2, renderLanes2);
          } else if (includesSomeLane(renderLanes2, OffscreenLane)) {
            var _nextState2 = {
              baseLanes: NoLanes
            };
            workInProgress2.memoizedState = _nextState2;
            var subtreeRenderLanes2 = prevState !== null ? prevState.baseLanes : renderLanes2;
            pushRenderLanes(workInProgress2, subtreeRenderLanes2);
          } else {
            var nextBaseLanes;
            if (prevState !== null) {
              var prevBaseLanes = prevState.baseLanes;
              nextBaseLanes = mergeLanes(prevBaseLanes, renderLanes2);
            } else
              nextBaseLanes = renderLanes2;
            markSpawnedWork(OffscreenLane), workInProgress2.lanes = workInProgress2.childLanes = OffscreenLane;
            var _nextState = {
              baseLanes: nextBaseLanes
            };
            return workInProgress2.memoizedState = _nextState, pushRenderLanes(workInProgress2, nextBaseLanes), null;
          }
        else {
          var _subtreeRenderLanes;
          prevState !== null ? (_subtreeRenderLanes = mergeLanes(prevState.baseLanes, renderLanes2), workInProgress2.memoizedState = null) : _subtreeRenderLanes = renderLanes2, pushRenderLanes(workInProgress2, _subtreeRenderLanes);
        }
        return reconcileChildren(current2, workInProgress2, nextChildren, renderLanes2), workInProgress2.child;
      }
      var updateLegacyHiddenComponent = updateOffscreenComponent;
      function updateFragment(current2, workInProgress2, renderLanes2) {
        var nextChildren = workInProgress2.pendingProps;
        return reconcileChildren(current2, workInProgress2, nextChildren, renderLanes2), workInProgress2.child;
      }
      function updateMode(current2, workInProgress2, renderLanes2) {
        var nextChildren = workInProgress2.pendingProps.children;
        return reconcileChildren(current2, workInProgress2, nextChildren, renderLanes2), workInProgress2.child;
      }
      function updateProfiler(current2, workInProgress2, renderLanes2) {
        {
          workInProgress2.flags |= Update;
          var stateNode = workInProgress2.stateNode;
          stateNode.effectDuration = 0, stateNode.passiveEffectDuration = 0;
        }
        var nextProps = workInProgress2.pendingProps, nextChildren = nextProps.children;
        return reconcileChildren(current2, workInProgress2, nextChildren, renderLanes2), workInProgress2.child;
      }
      function markRef(current2, workInProgress2) {
        var ref = workInProgress2.ref;
        (current2 === null && ref !== null || current2 !== null && current2.ref !== ref) && (workInProgress2.flags |= Ref);
      }
      function updateFunctionComponent(current2, workInProgress2, Component, nextProps, renderLanes2) {
        if (workInProgress2.type !== workInProgress2.elementType) {
          var innerPropTypes = Component.propTypes;
          innerPropTypes && checkPropTypes(
            innerPropTypes,
            nextProps,
            "prop",
            getComponentName(Component)
          );
        }
        var context;
        {
          var unmaskedContext = getUnmaskedContext(workInProgress2, Component, !0);
          context = getMaskedContext(workInProgress2, unmaskedContext);
        }
        var nextChildren;
        prepareToReadContext(workInProgress2, renderLanes2);
        {
          if (ReactCurrentOwner$1.current = workInProgress2, setIsRendering(!0), nextChildren = renderWithHooks(current2, workInProgress2, Component, nextProps, context, renderLanes2), workInProgress2.mode & StrictMode) {
            disableLogs();
            try {
              nextChildren = renderWithHooks(current2, workInProgress2, Component, nextProps, context, renderLanes2);
            } finally {
              reenableLogs();
            }
          }
          setIsRendering(!1);
        }
        return current2 !== null && !didReceiveUpdate ? (bailoutHooks(current2, workInProgress2, renderLanes2), bailoutOnAlreadyFinishedWork(current2, workInProgress2, renderLanes2)) : (workInProgress2.flags |= PerformedWork, reconcileChildren(current2, workInProgress2, nextChildren, renderLanes2), workInProgress2.child);
      }
      function updateClassComponent(current2, workInProgress2, Component, nextProps, renderLanes2) {
        if (workInProgress2.type !== workInProgress2.elementType) {
          var innerPropTypes = Component.propTypes;
          innerPropTypes && checkPropTypes(
            innerPropTypes,
            nextProps,
            "prop",
            getComponentName(Component)
          );
        }
        var hasContext;
        isContextProvider(Component) ? (hasContext = !0, pushContextProvider(workInProgress2)) : hasContext = !1, prepareToReadContext(workInProgress2, renderLanes2);
        var instance = workInProgress2.stateNode, shouldUpdate;
        instance === null ? (current2 !== null && (current2.alternate = null, workInProgress2.alternate = null, workInProgress2.flags |= Placement), constructClassInstance(workInProgress2, Component, nextProps), mountClassInstance(workInProgress2, Component, nextProps, renderLanes2), shouldUpdate = !0) : current2 === null ? shouldUpdate = resumeMountClassInstance(workInProgress2, Component, nextProps, renderLanes2) : shouldUpdate = updateClassInstance(current2, workInProgress2, Component, nextProps, renderLanes2);
        var nextUnitOfWork = finishClassComponent(current2, workInProgress2, Component, shouldUpdate, hasContext, renderLanes2);
        {
          var inst = workInProgress2.stateNode;
          shouldUpdate && inst.props !== nextProps && (didWarnAboutReassigningProps || error("It looks like %s is reassigning its own `this.props` while rendering. This is not supported and can lead to confusing bugs.", getComponentName(workInProgress2.type) || "a component"), didWarnAboutReassigningProps = !0);
        }
        return nextUnitOfWork;
      }
      function finishClassComponent(current2, workInProgress2, Component, shouldUpdate, hasContext, renderLanes2) {
        markRef(current2, workInProgress2);
        var didCaptureError = (workInProgress2.flags & DidCapture) !== NoFlags;
        if (!shouldUpdate && !didCaptureError)
          return hasContext && invalidateContextProvider(workInProgress2, Component, !1), bailoutOnAlreadyFinishedWork(current2, workInProgress2, renderLanes2);
        var instance = workInProgress2.stateNode;
        ReactCurrentOwner$1.current = workInProgress2;
        var nextChildren;
        if (didCaptureError && typeof Component.getDerivedStateFromError != "function")
          nextChildren = null, stopProfilerTimerIfRunning();
        else {
          if (setIsRendering(!0), nextChildren = instance.render(), workInProgress2.mode & StrictMode) {
            disableLogs();
            try {
              instance.render();
            } finally {
              reenableLogs();
            }
          }
          setIsRendering(!1);
        }
        return workInProgress2.flags |= PerformedWork, current2 !== null && didCaptureError ? forceUnmountCurrentAndReconcile(current2, workInProgress2, nextChildren, renderLanes2) : reconcileChildren(current2, workInProgress2, nextChildren, renderLanes2), workInProgress2.memoizedState = instance.state, hasContext && invalidateContextProvider(workInProgress2, Component, !0), workInProgress2.child;
      }
      function pushHostRootContext(workInProgress2) {
        var root2 = workInProgress2.stateNode;
        root2.pendingContext ? pushTopLevelContextObject(workInProgress2, root2.pendingContext, root2.pendingContext !== root2.context) : root2.context && pushTopLevelContextObject(workInProgress2, root2.context, !1), pushHostContainer(workInProgress2, root2.containerInfo);
      }
      function updateHostRoot(current2, workInProgress2, renderLanes2) {
        pushHostRootContext(workInProgress2);
        var updateQueue = workInProgress2.updateQueue;
        if (!(current2 !== null && updateQueue !== null))
          throw Error("If the root does not have an updateQueue, we should have already bailed out. This error is likely caused by a bug in React. Please file an issue.");
        var nextProps = workInProgress2.pendingProps, prevState = workInProgress2.memoizedState, prevChildren = prevState !== null ? prevState.element : null;
        cloneUpdateQueue(current2, workInProgress2), processUpdateQueue(workInProgress2, nextProps, null, renderLanes2);
        var nextState = workInProgress2.memoizedState, nextChildren = nextState.element;
        if (nextChildren === prevChildren)
          return resetHydrationState(), bailoutOnAlreadyFinishedWork(current2, workInProgress2, renderLanes2);
        var root2 = workInProgress2.stateNode;
        if (root2.hydrate && enterHydrationState(workInProgress2)) {
          {
            var mutableSourceEagerHydrationData = root2.mutableSourceEagerHydrationData;
            if (mutableSourceEagerHydrationData != null)
              for (var i = 0; i < mutableSourceEagerHydrationData.length; i += 2) {
                var mutableSource = mutableSourceEagerHydrationData[i], version2 = mutableSourceEagerHydrationData[i + 1];
                setWorkInProgressVersion(mutableSource, version2);
              }
          }
          var child = mountChildFibers(workInProgress2, null, nextChildren, renderLanes2);
          workInProgress2.child = child;
          for (var node = child; node; )
            node.flags = node.flags & ~Placement | Hydrating, node = node.sibling;
        } else
          reconcileChildren(current2, workInProgress2, nextChildren, renderLanes2), resetHydrationState();
        return workInProgress2.child;
      }
      function updateHostComponent(current2, workInProgress2, renderLanes2) {
        pushHostContext(workInProgress2), current2 === null && tryToClaimNextHydratableInstance(workInProgress2);
        var type = workInProgress2.type, nextProps = workInProgress2.pendingProps, prevProps = current2 !== null ? current2.memoizedProps : null, nextChildren = nextProps.children, isDirectTextChild = shouldSetTextContent(type, nextProps);
        return isDirectTextChild ? nextChildren = null : prevProps !== null && shouldSetTextContent(type, prevProps) && (workInProgress2.flags |= ContentReset), markRef(current2, workInProgress2), reconcileChildren(current2, workInProgress2, nextChildren, renderLanes2), workInProgress2.child;
      }
      function updateHostText(current2, workInProgress2) {
        return current2 === null && tryToClaimNextHydratableInstance(workInProgress2), null;
      }
      function mountLazyComponent(_current, workInProgress2, elementType, updateLanes, renderLanes2) {
        _current !== null && (_current.alternate = null, workInProgress2.alternate = null, workInProgress2.flags |= Placement);
        var props = workInProgress2.pendingProps, lazyComponent = elementType, payload = lazyComponent._payload, init2 = lazyComponent._init, Component = init2(payload);
        workInProgress2.type = Component;
        var resolvedTag = workInProgress2.tag = resolveLazyComponentTag(Component), resolvedProps = resolveDefaultProps(Component, props), child;
        switch (resolvedTag) {
          case FunctionComponent:
            return validateFunctionComponentInDev(workInProgress2, Component), workInProgress2.type = Component = resolveFunctionForHotReloading(Component), child = updateFunctionComponent(null, workInProgress2, Component, resolvedProps, renderLanes2), child;
          case ClassComponent:
            return workInProgress2.type = Component = resolveClassForHotReloading(Component), child = updateClassComponent(null, workInProgress2, Component, resolvedProps, renderLanes2), child;
          case ForwardRef2:
            return workInProgress2.type = Component = resolveForwardRefForHotReloading(Component), child = updateForwardRef(null, workInProgress2, Component, resolvedProps, renderLanes2), child;
          case MemoComponent: {
            if (workInProgress2.type !== workInProgress2.elementType) {
              var outerPropTypes = Component.propTypes;
              outerPropTypes && checkPropTypes(
                outerPropTypes,
                resolvedProps,
                "prop",
                getComponentName(Component)
              );
            }
            return child = updateMemoComponent(
              null,
              workInProgress2,
              Component,
              resolveDefaultProps(Component.type, resolvedProps),
              updateLanes,
              renderLanes2
            ), child;
          }
        }
        var hint = "";
        throw Component !== null && typeof Component == "object" && Component.$$typeof === REACT_LAZY_TYPE && (hint = " Did you wrap a component in React.lazy() more than once?"), Error("Element type is invalid. Received a promise that resolves to: " + Component + ". Lazy element type must resolve to a class or function." + hint);
      }
      function mountIncompleteClassComponent(_current, workInProgress2, Component, nextProps, renderLanes2) {
        _current !== null && (_current.alternate = null, workInProgress2.alternate = null, workInProgress2.flags |= Placement), workInProgress2.tag = ClassComponent;
        var hasContext;
        return isContextProvider(Component) ? (hasContext = !0, pushContextProvider(workInProgress2)) : hasContext = !1, prepareToReadContext(workInProgress2, renderLanes2), constructClassInstance(workInProgress2, Component, nextProps), mountClassInstance(workInProgress2, Component, nextProps, renderLanes2), finishClassComponent(null, workInProgress2, Component, !0, hasContext, renderLanes2);
      }
      function mountIndeterminateComponent(_current, workInProgress2, Component, renderLanes2) {
        _current !== null && (_current.alternate = null, workInProgress2.alternate = null, workInProgress2.flags |= Placement);
        var props = workInProgress2.pendingProps, context;
        {
          var unmaskedContext = getUnmaskedContext(workInProgress2, Component, !1);
          context = getMaskedContext(workInProgress2, unmaskedContext);
        }
        prepareToReadContext(workInProgress2, renderLanes2);
        var value;
        {
          if (Component.prototype && typeof Component.prototype.render == "function") {
            var componentName = getComponentName(Component) || "Unknown";
            didWarnAboutBadClass[componentName] || (error("The <%s /> component appears to have a render method, but doesn't extend React.Component. This is likely to cause errors. Change %s to extend React.Component instead.", componentName, componentName), didWarnAboutBadClass[componentName] = !0);
          }
          workInProgress2.mode & StrictMode && ReactStrictModeWarnings.recordLegacyContextWarning(workInProgress2, null), setIsRendering(!0), ReactCurrentOwner$1.current = workInProgress2, value = renderWithHooks(null, workInProgress2, Component, props, context, renderLanes2), setIsRendering(!1);
        }
        if (workInProgress2.flags |= PerformedWork, typeof value == "object" && value !== null && typeof value.render == "function" && value.$$typeof === void 0) {
          var _componentName = getComponentName(Component) || "Unknown";
          didWarnAboutModulePatternComponent[_componentName] || (error("The <%s /> component appears to be a function component that returns a class instance. Change %s to a class that extends React.Component instead. If you can't use a class try assigning the prototype on the function as a workaround. `%s.prototype = React.Component.prototype`. Don't use an arrow function since it cannot be called with `new` by React.", _componentName, _componentName, _componentName), didWarnAboutModulePatternComponent[_componentName] = !0);
        }
        if (typeof value == "object" && value !== null && typeof value.render == "function" && value.$$typeof === void 0) {
          {
            var _componentName2 = getComponentName(Component) || "Unknown";
            didWarnAboutModulePatternComponent[_componentName2] || (error("The <%s /> component appears to be a function component that returns a class instance. Change %s to a class that extends React.Component instead. If you can't use a class try assigning the prototype on the function as a workaround. `%s.prototype = React.Component.prototype`. Don't use an arrow function since it cannot be called with `new` by React.", _componentName2, _componentName2, _componentName2), didWarnAboutModulePatternComponent[_componentName2] = !0);
          }
          workInProgress2.tag = ClassComponent, workInProgress2.memoizedState = null, workInProgress2.updateQueue = null;
          var hasContext = !1;
          isContextProvider(Component) ? (hasContext = !0, pushContextProvider(workInProgress2)) : hasContext = !1, workInProgress2.memoizedState = value.state !== null && value.state !== void 0 ? value.state : null, initializeUpdateQueue(workInProgress2);
          var getDerivedStateFromProps = Component.getDerivedStateFromProps;
          return typeof getDerivedStateFromProps == "function" && applyDerivedStateFromProps(workInProgress2, Component, getDerivedStateFromProps, props), adoptClassInstance(workInProgress2, value), mountClassInstance(workInProgress2, Component, props, renderLanes2), finishClassComponent(null, workInProgress2, Component, !0, hasContext, renderLanes2);
        } else {
          if (workInProgress2.tag = FunctionComponent, workInProgress2.mode & StrictMode) {
            disableLogs();
            try {
              value = renderWithHooks(null, workInProgress2, Component, props, context, renderLanes2);
            } finally {
              reenableLogs();
            }
          }
          return reconcileChildren(null, workInProgress2, value, renderLanes2), validateFunctionComponentInDev(workInProgress2, Component), workInProgress2.child;
        }
      }
      function validateFunctionComponentInDev(workInProgress2, Component) {
        {
          if (Component && Component.childContextTypes && error("%s(...): childContextTypes cannot be defined on a function component.", Component.displayName || Component.name || "Component"), workInProgress2.ref !== null) {
            var info = "", ownerName = getCurrentFiberOwnerNameInDevOrNull();
            ownerName && (info += `

Check the render method of \`` + ownerName + "`.");
            var warningKey = ownerName || workInProgress2._debugID || "", debugSource = workInProgress2._debugSource;
            debugSource && (warningKey = debugSource.fileName + ":" + debugSource.lineNumber), didWarnAboutFunctionRefs[warningKey] || (didWarnAboutFunctionRefs[warningKey] = !0, error("Function components cannot be given refs. Attempts to access this ref will fail. Did you mean to use React.forwardRef()?%s", info));
          }
          if (typeof Component.getDerivedStateFromProps == "function") {
            var _componentName3 = getComponentName(Component) || "Unknown";
            didWarnAboutGetDerivedStateOnFunctionComponent[_componentName3] || (error("%s: Function components do not support getDerivedStateFromProps.", _componentName3), didWarnAboutGetDerivedStateOnFunctionComponent[_componentName3] = !0);
          }
          if (typeof Component.contextType == "object" && Component.contextType !== null) {
            var _componentName4 = getComponentName(Component) || "Unknown";
            didWarnAboutContextTypeOnFunctionComponent[_componentName4] || (error("%s: Function components do not support contextType.", _componentName4), didWarnAboutContextTypeOnFunctionComponent[_componentName4] = !0);
          }
        }
      }
      var SUSPENDED_MARKER = {
        dehydrated: null,
        retryLane: NoLane
      };
      function mountSuspenseOffscreenState(renderLanes2) {
        return {
          baseLanes: renderLanes2
        };
      }
      function updateSuspenseOffscreenState(prevOffscreenState, renderLanes2) {
        return {
          baseLanes: mergeLanes(prevOffscreenState.baseLanes, renderLanes2)
        };
      }
      function shouldRemainOnFallback(suspenseContext, current2, workInProgress2, renderLanes2) {
        if (current2 !== null) {
          var suspenseState = current2.memoizedState;
          if (suspenseState === null)
            return !1;
        }
        return hasSuspenseContext(suspenseContext, ForceSuspenseFallback);
      }
      function getRemainingWorkInPrimaryTree(current2, renderLanes2) {
        return removeLanes(current2.childLanes, renderLanes2);
      }
      function updateSuspenseComponent(current2, workInProgress2, renderLanes2) {
        var nextProps = workInProgress2.pendingProps;
        shouldSuspend(workInProgress2) && (workInProgress2.flags |= DidCapture);
        var suspenseContext = suspenseStackCursor.current, showFallback = !1, didSuspend = (workInProgress2.flags & DidCapture) !== NoFlags;
        if (didSuspend || shouldRemainOnFallback(suspenseContext, current2) ? (showFallback = !0, workInProgress2.flags &= ~DidCapture) : (current2 === null || current2.memoizedState !== null) && nextProps.fallback !== void 0 && nextProps.unstable_avoidThisFallback !== !0 && (suspenseContext = addSubtreeSuspenseContext(suspenseContext, InvisibleParentSuspenseContext)), suspenseContext = setDefaultShallowSuspenseContext(suspenseContext), pushSuspenseContext(workInProgress2, suspenseContext), current2 === null) {
          nextProps.fallback !== void 0 && tryToClaimNextHydratableInstance(workInProgress2);
          var nextPrimaryChildren = nextProps.children, nextFallbackChildren = nextProps.fallback;
          if (showFallback) {
            var fallbackFragment = mountSuspenseFallbackChildren(workInProgress2, nextPrimaryChildren, nextFallbackChildren, renderLanes2), primaryChildFragment = workInProgress2.child;
            return primaryChildFragment.memoizedState = mountSuspenseOffscreenState(renderLanes2), workInProgress2.memoizedState = SUSPENDED_MARKER, fallbackFragment;
          } else if (typeof nextProps.unstable_expectedLoadTime == "number") {
            var _fallbackFragment = mountSuspenseFallbackChildren(workInProgress2, nextPrimaryChildren, nextFallbackChildren, renderLanes2), _primaryChildFragment = workInProgress2.child;
            return _primaryChildFragment.memoizedState = mountSuspenseOffscreenState(renderLanes2), workInProgress2.memoizedState = SUSPENDED_MARKER, workInProgress2.lanes = SomeRetryLane, markSpawnedWork(SomeRetryLane), _fallbackFragment;
          } else
            return mountSuspensePrimaryChildren(workInProgress2, nextPrimaryChildren, renderLanes2);
        } else {
          var prevState = current2.memoizedState;
          if (prevState !== null)
            if (showFallback) {
              var _nextFallbackChildren2 = nextProps.fallback, _nextPrimaryChildren2 = nextProps.children, _fallbackChildFragment = updateSuspenseFallbackChildren(current2, workInProgress2, _nextPrimaryChildren2, _nextFallbackChildren2, renderLanes2), _primaryChildFragment3 = workInProgress2.child, prevOffscreenState = current2.child.memoizedState;
              return _primaryChildFragment3.memoizedState = prevOffscreenState === null ? mountSuspenseOffscreenState(renderLanes2) : updateSuspenseOffscreenState(prevOffscreenState, renderLanes2), _primaryChildFragment3.childLanes = getRemainingWorkInPrimaryTree(current2, renderLanes2), workInProgress2.memoizedState = SUSPENDED_MARKER, _fallbackChildFragment;
            } else {
              var _nextPrimaryChildren3 = nextProps.children, _primaryChildFragment4 = updateSuspensePrimaryChildren(current2, workInProgress2, _nextPrimaryChildren3, renderLanes2);
              return workInProgress2.memoizedState = null, _primaryChildFragment4;
            }
          else if (showFallback) {
            var _nextFallbackChildren3 = nextProps.fallback, _nextPrimaryChildren4 = nextProps.children, _fallbackChildFragment2 = updateSuspenseFallbackChildren(current2, workInProgress2, _nextPrimaryChildren4, _nextFallbackChildren3, renderLanes2), _primaryChildFragment5 = workInProgress2.child, _prevOffscreenState = current2.child.memoizedState;
            return _primaryChildFragment5.memoizedState = _prevOffscreenState === null ? mountSuspenseOffscreenState(renderLanes2) : updateSuspenseOffscreenState(_prevOffscreenState, renderLanes2), _primaryChildFragment5.childLanes = getRemainingWorkInPrimaryTree(current2, renderLanes2), workInProgress2.memoizedState = SUSPENDED_MARKER, _fallbackChildFragment2;
          } else {
            var _nextPrimaryChildren5 = nextProps.children, _primaryChildFragment6 = updateSuspensePrimaryChildren(current2, workInProgress2, _nextPrimaryChildren5, renderLanes2);
            return workInProgress2.memoizedState = null, _primaryChildFragment6;
          }
        }
      }
      function mountSuspensePrimaryChildren(workInProgress2, primaryChildren, renderLanes2) {
        var mode = workInProgress2.mode, primaryChildProps = {
          mode: "visible",
          children: primaryChildren
        }, primaryChildFragment = createFiberFromOffscreen(primaryChildProps, mode, renderLanes2, null);
        return primaryChildFragment.return = workInProgress2, workInProgress2.child = primaryChildFragment, primaryChildFragment;
      }
      function mountSuspenseFallbackChildren(workInProgress2, primaryChildren, fallbackChildren, renderLanes2) {
        var mode = workInProgress2.mode, progressedPrimaryFragment = workInProgress2.child, primaryChildProps = {
          mode: "hidden",
          children: primaryChildren
        }, primaryChildFragment, fallbackChildFragment;
        return (mode & BlockingMode) === NoMode && progressedPrimaryFragment !== null ? (primaryChildFragment = progressedPrimaryFragment, primaryChildFragment.childLanes = NoLanes, primaryChildFragment.pendingProps = primaryChildProps, workInProgress2.mode & ProfileMode && (primaryChildFragment.actualDuration = 0, primaryChildFragment.actualStartTime = -1, primaryChildFragment.selfBaseDuration = 0, primaryChildFragment.treeBaseDuration = 0), fallbackChildFragment = createFiberFromFragment(fallbackChildren, mode, renderLanes2, null)) : (primaryChildFragment = createFiberFromOffscreen(primaryChildProps, mode, NoLanes, null), fallbackChildFragment = createFiberFromFragment(fallbackChildren, mode, renderLanes2, null)), primaryChildFragment.return = workInProgress2, fallbackChildFragment.return = workInProgress2, primaryChildFragment.sibling = fallbackChildFragment, workInProgress2.child = primaryChildFragment, fallbackChildFragment;
      }
      function createWorkInProgressOffscreenFiber(current2, offscreenProps) {
        return createWorkInProgress(current2, offscreenProps);
      }
      function updateSuspensePrimaryChildren(current2, workInProgress2, primaryChildren, renderLanes2) {
        var currentPrimaryChildFragment = current2.child, currentFallbackChildFragment = currentPrimaryChildFragment.sibling, primaryChildFragment = createWorkInProgressOffscreenFiber(currentPrimaryChildFragment, {
          mode: "visible",
          children: primaryChildren
        });
        return (workInProgress2.mode & BlockingMode) === NoMode && (primaryChildFragment.lanes = renderLanes2), primaryChildFragment.return = workInProgress2, primaryChildFragment.sibling = null, currentFallbackChildFragment !== null && (currentFallbackChildFragment.nextEffect = null, currentFallbackChildFragment.flags = Deletion, workInProgress2.firstEffect = workInProgress2.lastEffect = currentFallbackChildFragment), workInProgress2.child = primaryChildFragment, primaryChildFragment;
      }
      function updateSuspenseFallbackChildren(current2, workInProgress2, primaryChildren, fallbackChildren, renderLanes2) {
        var mode = workInProgress2.mode, currentPrimaryChildFragment = current2.child, currentFallbackChildFragment = currentPrimaryChildFragment.sibling, primaryChildProps = {
          mode: "hidden",
          children: primaryChildren
        }, primaryChildFragment;
        if ((mode & BlockingMode) === NoMode && workInProgress2.child !== currentPrimaryChildFragment) {
          var progressedPrimaryFragment = workInProgress2.child;
          primaryChildFragment = progressedPrimaryFragment, primaryChildFragment.childLanes = NoLanes, primaryChildFragment.pendingProps = primaryChildProps, workInProgress2.mode & ProfileMode && (primaryChildFragment.actualDuration = 0, primaryChildFragment.actualStartTime = -1, primaryChildFragment.selfBaseDuration = currentPrimaryChildFragment.selfBaseDuration, primaryChildFragment.treeBaseDuration = currentPrimaryChildFragment.treeBaseDuration);
          var progressedLastEffect = primaryChildFragment.lastEffect;
          progressedLastEffect !== null ? (workInProgress2.firstEffect = primaryChildFragment.firstEffect, workInProgress2.lastEffect = progressedLastEffect, progressedLastEffect.nextEffect = null) : workInProgress2.firstEffect = workInProgress2.lastEffect = null;
        } else
          primaryChildFragment = createWorkInProgressOffscreenFiber(currentPrimaryChildFragment, primaryChildProps);
        var fallbackChildFragment;
        return currentFallbackChildFragment !== null ? fallbackChildFragment = createWorkInProgress(currentFallbackChildFragment, fallbackChildren) : (fallbackChildFragment = createFiberFromFragment(fallbackChildren, mode, renderLanes2, null), fallbackChildFragment.flags |= Placement), fallbackChildFragment.return = workInProgress2, primaryChildFragment.return = workInProgress2, primaryChildFragment.sibling = fallbackChildFragment, workInProgress2.child = primaryChildFragment, fallbackChildFragment;
      }
      function scheduleWorkOnFiber(fiber, renderLanes2) {
        fiber.lanes = mergeLanes(fiber.lanes, renderLanes2);
        var alternate = fiber.alternate;
        alternate !== null && (alternate.lanes = mergeLanes(alternate.lanes, renderLanes2)), scheduleWorkOnParentPath(fiber.return, renderLanes2);
      }
      function propagateSuspenseContextChange(workInProgress2, firstChild, renderLanes2) {
        for (var node = firstChild; node !== null; ) {
          if (node.tag === SuspenseComponent) {
            var state = node.memoizedState;
            state !== null && scheduleWorkOnFiber(node, renderLanes2);
          } else if (node.tag === SuspenseListComponent)
            scheduleWorkOnFiber(node, renderLanes2);
          else if (node.child !== null) {
            node.child.return = node, node = node.child;
            continue;
          }
          if (node === workInProgress2)
            return;
          for (; node.sibling === null; ) {
            if (node.return === null || node.return === workInProgress2)
              return;
            node = node.return;
          }
          node.sibling.return = node.return, node = node.sibling;
        }
      }
      function findLastContentRow(firstChild) {
        for (var row = firstChild, lastContentRow = null; row !== null; ) {
          var currentRow = row.alternate;
          currentRow !== null && findFirstSuspended(currentRow) === null && (lastContentRow = row), row = row.sibling;
        }
        return lastContentRow;
      }
      function validateRevealOrder(revealOrder) {
        if (revealOrder !== void 0 && revealOrder !== "forwards" && revealOrder !== "backwards" && revealOrder !== "together" && !didWarnAboutRevealOrder[revealOrder])
          if (didWarnAboutRevealOrder[revealOrder] = !0, typeof revealOrder == "string")
            switch (revealOrder.toLowerCase()) {
              case "together":
              case "forwards":
              case "backwards": {
                error('"%s" is not a valid value for revealOrder on <SuspenseList />. Use lowercase "%s" instead.', revealOrder, revealOrder.toLowerCase());
                break;
              }
              case "forward":
              case "backward": {
                error('"%s" is not a valid value for revealOrder on <SuspenseList />. React uses the -s suffix in the spelling. Use "%ss" instead.', revealOrder, revealOrder.toLowerCase());
                break;
              }
              default:
                error('"%s" is not a supported revealOrder on <SuspenseList />. Did you mean "together", "forwards" or "backwards"?', revealOrder);
                break;
            }
          else
            error('%s is not a supported value for revealOrder on <SuspenseList />. Did you mean "together", "forwards" or "backwards"?', revealOrder);
      }
      function validateTailOptions(tailMode, revealOrder) {
        tailMode !== void 0 && !didWarnAboutTailOptions[tailMode] && (tailMode !== "collapsed" && tailMode !== "hidden" ? (didWarnAboutTailOptions[tailMode] = !0, error('"%s" is not a supported value for tail on <SuspenseList />. Did you mean "collapsed" or "hidden"?', tailMode)) : revealOrder !== "forwards" && revealOrder !== "backwards" && (didWarnAboutTailOptions[tailMode] = !0, error('<SuspenseList tail="%s" /> is only valid if revealOrder is "forwards" or "backwards". Did you mean to specify revealOrder="forwards"?', tailMode)));
      }
      function validateSuspenseListNestedChild(childSlot, index2) {
        {
          var isArray4 = Array.isArray(childSlot), isIterable = !isArray4 && typeof getIteratorFn(childSlot) == "function";
          if (isArray4 || isIterable) {
            var type = isArray4 ? "array" : "iterable";
            return error("A nested %s was passed to row #%s in <SuspenseList />. Wrap it in an additional SuspenseList to configure its revealOrder: <SuspenseList revealOrder=...> ... <SuspenseList revealOrder=...>{%s}</SuspenseList> ... </SuspenseList>", type, index2, type), !1;
          }
        }
        return !0;
      }
      function validateSuspenseListChildren(children, revealOrder) {
        if ((revealOrder === "forwards" || revealOrder === "backwards") && children !== void 0 && children !== null && children !== !1)
          if (Array.isArray(children)) {
            for (var i = 0; i < children.length; i++)
              if (!validateSuspenseListNestedChild(children[i], i))
                return;
          } else {
            var iteratorFn = getIteratorFn(children);
            if (typeof iteratorFn == "function") {
              var childrenIterator = iteratorFn.call(children);
              if (childrenIterator)
                for (var step = childrenIterator.next(), _i = 0; !step.done; step = childrenIterator.next()) {
                  if (!validateSuspenseListNestedChild(step.value, _i))
                    return;
                  _i++;
                }
            } else
              error('A single row was passed to a <SuspenseList revealOrder="%s" />. This is not useful since it needs multiple rows. Did you mean to pass multiple children or an array?', revealOrder);
          }
      }
      function initSuspenseListRenderState(workInProgress2, isBackwards, tail, lastContentRow, tailMode, lastEffectBeforeRendering) {
        var renderState = workInProgress2.memoizedState;
        renderState === null ? workInProgress2.memoizedState = {
          isBackwards,
          rendering: null,
          renderingStartTime: 0,
          last: lastContentRow,
          tail,
          tailMode,
          lastEffect: lastEffectBeforeRendering
        } : (renderState.isBackwards = isBackwards, renderState.rendering = null, renderState.renderingStartTime = 0, renderState.last = lastContentRow, renderState.tail = tail, renderState.tailMode = tailMode, renderState.lastEffect = lastEffectBeforeRendering);
      }
      function updateSuspenseListComponent(current2, workInProgress2, renderLanes2) {
        var nextProps = workInProgress2.pendingProps, revealOrder = nextProps.revealOrder, tailMode = nextProps.tail, newChildren = nextProps.children;
        validateRevealOrder(revealOrder), validateTailOptions(tailMode, revealOrder), validateSuspenseListChildren(newChildren, revealOrder), reconcileChildren(current2, workInProgress2, newChildren, renderLanes2);
        var suspenseContext = suspenseStackCursor.current, shouldForceFallback = hasSuspenseContext(suspenseContext, ForceSuspenseFallback);
        if (shouldForceFallback)
          suspenseContext = setShallowSuspenseContext(suspenseContext, ForceSuspenseFallback), workInProgress2.flags |= DidCapture;
        else {
          var didSuspendBefore = current2 !== null && (current2.flags & DidCapture) !== NoFlags;
          didSuspendBefore && propagateSuspenseContextChange(workInProgress2, workInProgress2.child, renderLanes2), suspenseContext = setDefaultShallowSuspenseContext(suspenseContext);
        }
        if (pushSuspenseContext(workInProgress2, suspenseContext), (workInProgress2.mode & BlockingMode) === NoMode)
          workInProgress2.memoizedState = null;
        else
          switch (revealOrder) {
            case "forwards": {
              var lastContentRow = findLastContentRow(workInProgress2.child), tail;
              lastContentRow === null ? (tail = workInProgress2.child, workInProgress2.child = null) : (tail = lastContentRow.sibling, lastContentRow.sibling = null), initSuspenseListRenderState(
                workInProgress2,
                !1,
                tail,
                lastContentRow,
                tailMode,
                workInProgress2.lastEffect
              );
              break;
            }
            case "backwards": {
              var _tail = null, row = workInProgress2.child;
              for (workInProgress2.child = null; row !== null; ) {
                var currentRow = row.alternate;
                if (currentRow !== null && findFirstSuspended(currentRow) === null) {
                  workInProgress2.child = row;
                  break;
                }
                var nextRow = row.sibling;
                row.sibling = _tail, _tail = row, row = nextRow;
              }
              initSuspenseListRenderState(
                workInProgress2,
                !0,
                _tail,
                null,
                tailMode,
                workInProgress2.lastEffect
              );
              break;
            }
            case "together": {
              initSuspenseListRenderState(
                workInProgress2,
                !1,
                null,
                null,
                void 0,
                workInProgress2.lastEffect
              );
              break;
            }
            default:
              workInProgress2.memoizedState = null;
          }
        return workInProgress2.child;
      }
      function updatePortalComponent(current2, workInProgress2, renderLanes2) {
        pushHostContainer(workInProgress2, workInProgress2.stateNode.containerInfo);
        var nextChildren = workInProgress2.pendingProps;
        return current2 === null ? workInProgress2.child = reconcileChildFibers(workInProgress2, null, nextChildren, renderLanes2) : reconcileChildren(current2, workInProgress2, nextChildren, renderLanes2), workInProgress2.child;
      }
      var hasWarnedAboutUsingNoValuePropOnContextProvider = !1;
      function updateContextProvider(current2, workInProgress2, renderLanes2) {
        var providerType = workInProgress2.type, context = providerType._context, newProps = workInProgress2.pendingProps, oldProps = workInProgress2.memoizedProps, newValue = newProps.value;
        {
          "value" in newProps || hasWarnedAboutUsingNoValuePropOnContextProvider || (hasWarnedAboutUsingNoValuePropOnContextProvider = !0, error("The `value` prop is required for the `<Context.Provider>`. Did you misspell it or forget to pass it?"));
          var providerPropTypes = workInProgress2.type.propTypes;
          providerPropTypes && checkPropTypes(providerPropTypes, newProps, "prop", "Context.Provider");
        }
        if (pushProvider(workInProgress2, newValue), oldProps !== null) {
          var oldValue = oldProps.value, changedBits = calculateChangedBits(context, newValue, oldValue);
          if (changedBits === 0) {
            if (oldProps.children === newProps.children && !hasContextChanged())
              return bailoutOnAlreadyFinishedWork(current2, workInProgress2, renderLanes2);
          } else
            propagateContextChange(workInProgress2, context, changedBits, renderLanes2);
        }
        var newChildren = newProps.children;
        return reconcileChildren(current2, workInProgress2, newChildren, renderLanes2), workInProgress2.child;
      }
      var hasWarnedAboutUsingContextAsConsumer = !1;
      function updateContextConsumer(current2, workInProgress2, renderLanes2) {
        var context = workInProgress2.type;
        context._context === void 0 ? context !== context.Consumer && (hasWarnedAboutUsingContextAsConsumer || (hasWarnedAboutUsingContextAsConsumer = !0, error("Rendering <Context> directly is not supported and will be removed in a future major release. Did you mean to render <Context.Consumer> instead?"))) : context = context._context;
        var newProps = workInProgress2.pendingProps, render2 = newProps.children;
        typeof render2 != "function" && error("A context consumer was rendered with multiple children, or a child that isn't a function. A context consumer expects a single child that is a function. If you did pass a function, make sure there is no trailing or leading whitespace around it."), prepareToReadContext(workInProgress2, renderLanes2);
        var newValue = readContext(context, newProps.unstable_observedBits), newChildren;
        return ReactCurrentOwner$1.current = workInProgress2, setIsRendering(!0), newChildren = render2(newValue), setIsRendering(!1), workInProgress2.flags |= PerformedWork, reconcileChildren(current2, workInProgress2, newChildren, renderLanes2), workInProgress2.child;
      }
      function markWorkInProgressReceivedUpdate() {
        didReceiveUpdate = !0;
      }
      function bailoutOnAlreadyFinishedWork(current2, workInProgress2, renderLanes2) {
        return current2 !== null && (workInProgress2.dependencies = current2.dependencies), stopProfilerTimerIfRunning(), markSkippedUpdateLanes(workInProgress2.lanes), includesSomeLane(renderLanes2, workInProgress2.childLanes) ? (cloneChildFibers(current2, workInProgress2), workInProgress2.child) : null;
      }
      function remountFiber(current2, oldWorkInProgress, newWorkInProgress) {
        {
          var returnFiber = oldWorkInProgress.return;
          if (returnFiber === null)
            throw new Error("Cannot swap the root fiber.");
          if (current2.alternate = null, oldWorkInProgress.alternate = null, newWorkInProgress.index = oldWorkInProgress.index, newWorkInProgress.sibling = oldWorkInProgress.sibling, newWorkInProgress.return = oldWorkInProgress.return, newWorkInProgress.ref = oldWorkInProgress.ref, oldWorkInProgress === returnFiber.child)
            returnFiber.child = newWorkInProgress;
          else {
            var prevSibling = returnFiber.child;
            if (prevSibling === null)
              throw new Error("Expected parent to have a child.");
            for (; prevSibling.sibling !== oldWorkInProgress; )
              if (prevSibling = prevSibling.sibling, prevSibling === null)
                throw new Error("Expected to find the previous sibling.");
            prevSibling.sibling = newWorkInProgress;
          }
          var last = returnFiber.lastEffect;
          return last !== null ? (last.nextEffect = current2, returnFiber.lastEffect = current2) : returnFiber.firstEffect = returnFiber.lastEffect = current2, current2.nextEffect = null, current2.flags = Deletion, newWorkInProgress.flags |= Placement, newWorkInProgress;
        }
      }
      function beginWork(current2, workInProgress2, renderLanes2) {
        var updateLanes = workInProgress2.lanes;
        if (workInProgress2._debugNeedsRemount && current2 !== null)
          return remountFiber(current2, workInProgress2, createFiberFromTypeAndProps(workInProgress2.type, workInProgress2.key, workInProgress2.pendingProps, workInProgress2._debugOwner || null, workInProgress2.mode, workInProgress2.lanes));
        if (current2 !== null) {
          var oldProps = current2.memoizedProps, newProps = workInProgress2.pendingProps;
          if (oldProps !== newProps || hasContextChanged() || workInProgress2.type !== current2.type)
            didReceiveUpdate = !0;
          else if (includesSomeLane(renderLanes2, updateLanes))
            (current2.flags & ForceUpdateForLegacySuspense) !== NoFlags ? didReceiveUpdate = !0 : didReceiveUpdate = !1;
          else {
            switch (didReceiveUpdate = !1, workInProgress2.tag) {
              case HostRoot:
                pushHostRootContext(workInProgress2), resetHydrationState();
                break;
              case HostComponent:
                pushHostContext(workInProgress2);
                break;
              case ClassComponent: {
                var Component = workInProgress2.type;
                isContextProvider(Component) && pushContextProvider(workInProgress2);
                break;
              }
              case HostPortal:
                pushHostContainer(workInProgress2, workInProgress2.stateNode.containerInfo);
                break;
              case ContextProvider: {
                var newValue = workInProgress2.memoizedProps.value;
                pushProvider(workInProgress2, newValue);
                break;
              }
              case Profiler:
                {
                  var hasChildWork = includesSomeLane(renderLanes2, workInProgress2.childLanes);
                  hasChildWork && (workInProgress2.flags |= Update);
                  var stateNode = workInProgress2.stateNode;
                  stateNode.effectDuration = 0, stateNode.passiveEffectDuration = 0;
                }
                break;
              case SuspenseComponent: {
                var state = workInProgress2.memoizedState;
                if (state !== null) {
                  var primaryChildFragment = workInProgress2.child, primaryChildLanes = primaryChildFragment.childLanes;
                  if (includesSomeLane(renderLanes2, primaryChildLanes))
                    return updateSuspenseComponent(current2, workInProgress2, renderLanes2);
                  pushSuspenseContext(workInProgress2, setDefaultShallowSuspenseContext(suspenseStackCursor.current));
                  var child = bailoutOnAlreadyFinishedWork(current2, workInProgress2, renderLanes2);
                  return child !== null ? child.sibling : null;
                } else
                  pushSuspenseContext(workInProgress2, setDefaultShallowSuspenseContext(suspenseStackCursor.current));
                break;
              }
              case SuspenseListComponent: {
                var didSuspendBefore = (current2.flags & DidCapture) !== NoFlags, _hasChildWork = includesSomeLane(renderLanes2, workInProgress2.childLanes);
                if (didSuspendBefore) {
                  if (_hasChildWork)
                    return updateSuspenseListComponent(current2, workInProgress2, renderLanes2);
                  workInProgress2.flags |= DidCapture;
                }
                var renderState = workInProgress2.memoizedState;
                if (renderState !== null && (renderState.rendering = null, renderState.tail = null, renderState.lastEffect = null), pushSuspenseContext(workInProgress2, suspenseStackCursor.current), _hasChildWork)
                  break;
                return null;
              }
              case OffscreenComponent:
              case LegacyHiddenComponent:
                return workInProgress2.lanes = NoLanes, updateOffscreenComponent(current2, workInProgress2, renderLanes2);
            }
            return bailoutOnAlreadyFinishedWork(current2, workInProgress2, renderLanes2);
          }
        } else
          didReceiveUpdate = !1;
        switch (workInProgress2.lanes = NoLanes, workInProgress2.tag) {
          case IndeterminateComponent:
            return mountIndeterminateComponent(current2, workInProgress2, workInProgress2.type, renderLanes2);
          case LazyComponent: {
            var elementType = workInProgress2.elementType;
            return mountLazyComponent(current2, workInProgress2, elementType, updateLanes, renderLanes2);
          }
          case FunctionComponent: {
            var _Component = workInProgress2.type, unresolvedProps = workInProgress2.pendingProps, resolvedProps = workInProgress2.elementType === _Component ? unresolvedProps : resolveDefaultProps(_Component, unresolvedProps);
            return updateFunctionComponent(current2, workInProgress2, _Component, resolvedProps, renderLanes2);
          }
          case ClassComponent: {
            var _Component2 = workInProgress2.type, _unresolvedProps = workInProgress2.pendingProps, _resolvedProps = workInProgress2.elementType === _Component2 ? _unresolvedProps : resolveDefaultProps(_Component2, _unresolvedProps);
            return updateClassComponent(current2, workInProgress2, _Component2, _resolvedProps, renderLanes2);
          }
          case HostRoot:
            return updateHostRoot(current2, workInProgress2, renderLanes2);
          case HostComponent:
            return updateHostComponent(current2, workInProgress2, renderLanes2);
          case HostText:
            return updateHostText(current2, workInProgress2);
          case SuspenseComponent:
            return updateSuspenseComponent(current2, workInProgress2, renderLanes2);
          case HostPortal:
            return updatePortalComponent(current2, workInProgress2, renderLanes2);
          case ForwardRef2: {
            var type = workInProgress2.type, _unresolvedProps2 = workInProgress2.pendingProps, _resolvedProps2 = workInProgress2.elementType === type ? _unresolvedProps2 : resolveDefaultProps(type, _unresolvedProps2);
            return updateForwardRef(current2, workInProgress2, type, _resolvedProps2, renderLanes2);
          }
          case Fragment11:
            return updateFragment(current2, workInProgress2, renderLanes2);
          case Mode:
            return updateMode(current2, workInProgress2, renderLanes2);
          case Profiler:
            return updateProfiler(current2, workInProgress2, renderLanes2);
          case ContextProvider:
            return updateContextProvider(current2, workInProgress2, renderLanes2);
          case ContextConsumer:
            return updateContextConsumer(current2, workInProgress2, renderLanes2);
          case MemoComponent: {
            var _type2 = workInProgress2.type, _unresolvedProps3 = workInProgress2.pendingProps, _resolvedProps3 = resolveDefaultProps(_type2, _unresolvedProps3);
            if (workInProgress2.type !== workInProgress2.elementType) {
              var outerPropTypes = _type2.propTypes;
              outerPropTypes && checkPropTypes(
                outerPropTypes,
                _resolvedProps3,
                "prop",
                getComponentName(_type2)
              );
            }
            return _resolvedProps3 = resolveDefaultProps(_type2.type, _resolvedProps3), updateMemoComponent(current2, workInProgress2, _type2, _resolvedProps3, updateLanes, renderLanes2);
          }
          case SimpleMemoComponent:
            return updateSimpleMemoComponent(current2, workInProgress2, workInProgress2.type, workInProgress2.pendingProps, updateLanes, renderLanes2);
          case IncompleteClassComponent: {
            var _Component3 = workInProgress2.type, _unresolvedProps4 = workInProgress2.pendingProps, _resolvedProps4 = workInProgress2.elementType === _Component3 ? _unresolvedProps4 : resolveDefaultProps(_Component3, _unresolvedProps4);
            return mountIncompleteClassComponent(current2, workInProgress2, _Component3, _resolvedProps4, renderLanes2);
          }
          case SuspenseListComponent:
            return updateSuspenseListComponent(current2, workInProgress2, renderLanes2);
          case FundamentalComponent:
            break;
          case ScopeComponent:
            break;
          case Block:
            break;
          case OffscreenComponent:
            return updateOffscreenComponent(current2, workInProgress2, renderLanes2);
          case LegacyHiddenComponent:
            return updateLegacyHiddenComponent(current2, workInProgress2, renderLanes2);
        }
        throw Error("Unknown unit of work tag (" + workInProgress2.tag + "). This error is likely caused by a bug in React. Please file an issue.");
      }
      function markUpdate(workInProgress2) {
        workInProgress2.flags |= Update;
      }
      function markRef$1(workInProgress2) {
        workInProgress2.flags |= Ref;
      }
      var appendAllChildren, updateHostContainer, updateHostComponent$1, updateHostText$1;
      appendAllChildren = function(parent, workInProgress2, needsVisibilityToggle, isHidden) {
        for (var node = workInProgress2.child; node !== null; ) {
          if (node.tag === HostComponent || node.tag === HostText)
            appendInitialChild(parent, node.stateNode);
          else if (node.tag !== HostPortal) {
            if (node.child !== null) {
              node.child.return = node, node = node.child;
              continue;
            }
          }
          if (node === workInProgress2)
            return;
          for (; node.sibling === null; ) {
            if (node.return === null || node.return === workInProgress2)
              return;
            node = node.return;
          }
          node.sibling.return = node.return, node = node.sibling;
        }
      }, updateHostContainer = function(workInProgress2) {
      }, updateHostComponent$1 = function(current2, workInProgress2, type, newProps, rootContainerInstance) {
        var oldProps = current2.memoizedProps;
        if (oldProps !== newProps) {
          var instance = workInProgress2.stateNode, currentHostContext = getHostContext(), updatePayload = prepareUpdate(instance, type, oldProps, newProps, rootContainerInstance, currentHostContext);
          workInProgress2.updateQueue = updatePayload, updatePayload && markUpdate(workInProgress2);
        }
      }, updateHostText$1 = function(current2, workInProgress2, oldText, newText) {
        oldText !== newText && markUpdate(workInProgress2);
      };
      function cutOffTailIfNeeded(renderState, hasRenderedATailFallback) {
        if (!getIsHydrating())
          switch (renderState.tailMode) {
            case "hidden": {
              for (var tailNode = renderState.tail, lastTailNode = null; tailNode !== null; )
                tailNode.alternate !== null && (lastTailNode = tailNode), tailNode = tailNode.sibling;
              lastTailNode === null ? renderState.tail = null : lastTailNode.sibling = null;
              break;
            }
            case "collapsed": {
              for (var _tailNode = renderState.tail, _lastTailNode = null; _tailNode !== null; )
                _tailNode.alternate !== null && (_lastTailNode = _tailNode), _tailNode = _tailNode.sibling;
              _lastTailNode === null ? !hasRenderedATailFallback && renderState.tail !== null ? renderState.tail.sibling = null : renderState.tail = null : _lastTailNode.sibling = null;
              break;
            }
          }
      }
      function completeWork(current2, workInProgress2, renderLanes2) {
        var newProps = workInProgress2.pendingProps;
        switch (workInProgress2.tag) {
          case IndeterminateComponent:
          case LazyComponent:
          case SimpleMemoComponent:
          case FunctionComponent:
          case ForwardRef2:
          case Fragment11:
          case Mode:
          case Profiler:
          case ContextConsumer:
          case MemoComponent:
            return null;
          case ClassComponent: {
            var Component = workInProgress2.type;
            return isContextProvider(Component) && popContext(workInProgress2), null;
          }
          case HostRoot: {
            popHostContainer(workInProgress2), popTopLevelContextObject(workInProgress2), resetWorkInProgressVersions();
            var fiberRoot = workInProgress2.stateNode;
            if (fiberRoot.pendingContext && (fiberRoot.context = fiberRoot.pendingContext, fiberRoot.pendingContext = null), current2 === null || current2.child === null) {
              var wasHydrated = popHydrationState(workInProgress2);
              wasHydrated ? markUpdate(workInProgress2) : fiberRoot.hydrate || (workInProgress2.flags |= Snapshot);
            }
            return updateHostContainer(workInProgress2), null;
          }
          case HostComponent: {
            popHostContext(workInProgress2);
            var rootContainerInstance = getRootHostContainer(), type = workInProgress2.type;
            if (current2 !== null && workInProgress2.stateNode != null)
              updateHostComponent$1(current2, workInProgress2, type, newProps, rootContainerInstance), current2.ref !== workInProgress2.ref && markRef$1(workInProgress2);
            else {
              if (!newProps) {
                if (workInProgress2.stateNode === null)
                  throw Error("We must have new props for new mounts. This error is likely caused by a bug in React. Please file an issue.");
                return null;
              }
              var currentHostContext = getHostContext(), _wasHydrated = popHydrationState(workInProgress2);
              if (_wasHydrated)
                prepareToHydrateHostInstance(workInProgress2, rootContainerInstance, currentHostContext) && markUpdate(workInProgress2);
              else {
                var instance = createInstance(type, newProps, rootContainerInstance, currentHostContext, workInProgress2);
                appendAllChildren(instance, workInProgress2, !1, !1), workInProgress2.stateNode = instance, finalizeInitialChildren(instance, type, newProps, rootContainerInstance) && markUpdate(workInProgress2);
              }
              workInProgress2.ref !== null && markRef$1(workInProgress2);
            }
            return null;
          }
          case HostText: {
            var newText = newProps;
            if (current2 && workInProgress2.stateNode != null) {
              var oldText = current2.memoizedProps;
              updateHostText$1(current2, workInProgress2, oldText, newText);
            } else {
              if (typeof newText != "string" && workInProgress2.stateNode === null)
                throw Error("We must have new props for new mounts. This error is likely caused by a bug in React. Please file an issue.");
              var _rootContainerInstance = getRootHostContainer(), _currentHostContext = getHostContext(), _wasHydrated2 = popHydrationState(workInProgress2);
              _wasHydrated2 ? prepareToHydrateHostTextInstance(workInProgress2) && markUpdate(workInProgress2) : workInProgress2.stateNode = createTextInstance(newText, _rootContainerInstance, _currentHostContext, workInProgress2);
            }
            return null;
          }
          case SuspenseComponent: {
            popSuspenseContext(workInProgress2);
            var nextState = workInProgress2.memoizedState;
            if ((workInProgress2.flags & DidCapture) !== NoFlags)
              return workInProgress2.lanes = renderLanes2, (workInProgress2.mode & ProfileMode) !== NoMode && transferActualDuration(workInProgress2), workInProgress2;
            var nextDidTimeout = nextState !== null, prevDidTimeout = !1;
            if (current2 === null)
              workInProgress2.memoizedProps.fallback !== void 0 && popHydrationState(workInProgress2);
            else {
              var prevState = current2.memoizedState;
              prevDidTimeout = prevState !== null;
            }
            if (nextDidTimeout && !prevDidTimeout && (workInProgress2.mode & BlockingMode) !== NoMode) {
              var hasInvisibleChildContext = current2 === null && workInProgress2.memoizedProps.unstable_avoidThisFallback !== !0;
              hasInvisibleChildContext || hasSuspenseContext(suspenseStackCursor.current, InvisibleParentSuspenseContext) ? renderDidSuspend() : renderDidSuspendDelayIfPossible();
            }
            return (nextDidTimeout || prevDidTimeout) && (workInProgress2.flags |= Update), null;
          }
          case HostPortal:
            return popHostContainer(workInProgress2), updateHostContainer(workInProgress2), current2 === null && preparePortalMount(workInProgress2.stateNode.containerInfo), null;
          case ContextProvider:
            return popProvider(workInProgress2), null;
          case IncompleteClassComponent: {
            var _Component = workInProgress2.type;
            return isContextProvider(_Component) && popContext(workInProgress2), null;
          }
          case SuspenseListComponent: {
            popSuspenseContext(workInProgress2);
            var renderState = workInProgress2.memoizedState;
            if (renderState === null)
              return null;
            var didSuspendAlready = (workInProgress2.flags & DidCapture) !== NoFlags, renderedTail = renderState.rendering;
            if (renderedTail === null)
              if (didSuspendAlready)
                cutOffTailIfNeeded(renderState, !1);
              else {
                var cannotBeSuspended = renderHasNotSuspendedYet() && (current2 === null || (current2.flags & DidCapture) === NoFlags);
                if (!cannotBeSuspended)
                  for (var row = workInProgress2.child; row !== null; ) {
                    var suspended = findFirstSuspended(row);
                    if (suspended !== null) {
                      didSuspendAlready = !0, workInProgress2.flags |= DidCapture, cutOffTailIfNeeded(renderState, !1);
                      var newThennables = suspended.updateQueue;
                      return newThennables !== null && (workInProgress2.updateQueue = newThennables, workInProgress2.flags |= Update), renderState.lastEffect === null && (workInProgress2.firstEffect = null), workInProgress2.lastEffect = renderState.lastEffect, resetChildFibers(workInProgress2, renderLanes2), pushSuspenseContext(workInProgress2, setShallowSuspenseContext(suspenseStackCursor.current, ForceSuspenseFallback)), workInProgress2.child;
                    }
                    row = row.sibling;
                  }
                renderState.tail !== null && now() > getRenderTargetTime() && (workInProgress2.flags |= DidCapture, didSuspendAlready = !0, cutOffTailIfNeeded(renderState, !1), workInProgress2.lanes = SomeRetryLane, markSpawnedWork(SomeRetryLane));
              }
            else {
              if (!didSuspendAlready) {
                var _suspended = findFirstSuspended(renderedTail);
                if (_suspended !== null) {
                  workInProgress2.flags |= DidCapture, didSuspendAlready = !0;
                  var _newThennables = _suspended.updateQueue;
                  if (_newThennables !== null && (workInProgress2.updateQueue = _newThennables, workInProgress2.flags |= Update), cutOffTailIfNeeded(renderState, !0), renderState.tail === null && renderState.tailMode === "hidden" && !renderedTail.alternate && !getIsHydrating()) {
                    var lastEffect = workInProgress2.lastEffect = renderState.lastEffect;
                    return lastEffect !== null && (lastEffect.nextEffect = null), null;
                  }
                } else
                  now() * 2 - renderState.renderingStartTime > getRenderTargetTime() && renderLanes2 !== OffscreenLane && (workInProgress2.flags |= DidCapture, didSuspendAlready = !0, cutOffTailIfNeeded(renderState, !1), workInProgress2.lanes = SomeRetryLane, markSpawnedWork(SomeRetryLane));
              }
              if (renderState.isBackwards)
                renderedTail.sibling = workInProgress2.child, workInProgress2.child = renderedTail;
              else {
                var previousSibling = renderState.last;
                previousSibling !== null ? previousSibling.sibling = renderedTail : workInProgress2.child = renderedTail, renderState.last = renderedTail;
              }
            }
            if (renderState.tail !== null) {
              var next = renderState.tail;
              renderState.rendering = next, renderState.tail = next.sibling, renderState.lastEffect = workInProgress2.lastEffect, renderState.renderingStartTime = now(), next.sibling = null;
              var suspenseContext = suspenseStackCursor.current;
              return didSuspendAlready ? suspenseContext = setShallowSuspenseContext(suspenseContext, ForceSuspenseFallback) : suspenseContext = setDefaultShallowSuspenseContext(suspenseContext), pushSuspenseContext(workInProgress2, suspenseContext), next;
            }
            return null;
          }
          case FundamentalComponent:
            break;
          case ScopeComponent:
            break;
          case Block:
            break;
          case OffscreenComponent:
          case LegacyHiddenComponent: {
            if (popRenderLanes(workInProgress2), current2 !== null) {
              var _nextState = workInProgress2.memoizedState, _prevState = current2.memoizedState, prevIsHidden = _prevState !== null, nextIsHidden = _nextState !== null;
              prevIsHidden !== nextIsHidden && newProps.mode !== "unstable-defer-without-hiding" && (workInProgress2.flags |= Update);
            }
            return null;
          }
        }
        throw Error("Unknown unit of work tag (" + workInProgress2.tag + "). This error is likely caused by a bug in React. Please file an issue.");
      }
      function unwindWork(workInProgress2, renderLanes2) {
        switch (workInProgress2.tag) {
          case ClassComponent: {
            var Component = workInProgress2.type;
            isContextProvider(Component) && popContext(workInProgress2);
            var flags = workInProgress2.flags;
            return flags & ShouldCapture ? (workInProgress2.flags = flags & ~ShouldCapture | DidCapture, (workInProgress2.mode & ProfileMode) !== NoMode && transferActualDuration(workInProgress2), workInProgress2) : null;
          }
          case HostRoot: {
            popHostContainer(workInProgress2), popTopLevelContextObject(workInProgress2), resetWorkInProgressVersions();
            var _flags = workInProgress2.flags;
            if ((_flags & DidCapture) !== NoFlags)
              throw Error("The root failed to unmount after an error. This is likely a bug in React. Please file an issue.");
            return workInProgress2.flags = _flags & ~ShouldCapture | DidCapture, workInProgress2;
          }
          case HostComponent:
            return popHostContext(workInProgress2), null;
          case SuspenseComponent: {
            popSuspenseContext(workInProgress2);
            var _flags2 = workInProgress2.flags;
            return _flags2 & ShouldCapture ? (workInProgress2.flags = _flags2 & ~ShouldCapture | DidCapture, (workInProgress2.mode & ProfileMode) !== NoMode && transferActualDuration(workInProgress2), workInProgress2) : null;
          }
          case SuspenseListComponent:
            return popSuspenseContext(workInProgress2), null;
          case HostPortal:
            return popHostContainer(workInProgress2), null;
          case ContextProvider:
            return popProvider(workInProgress2), null;
          case OffscreenComponent:
          case LegacyHiddenComponent:
            return popRenderLanes(workInProgress2), null;
          default:
            return null;
        }
      }
      function unwindInterruptedWork(interruptedWork) {
        switch (interruptedWork.tag) {
          case ClassComponent: {
            var childContextTypes = interruptedWork.type.childContextTypes;
            childContextTypes != null && popContext(interruptedWork);
            break;
          }
          case HostRoot: {
            popHostContainer(interruptedWork), popTopLevelContextObject(interruptedWork), resetWorkInProgressVersions();
            break;
          }
          case HostComponent: {
            popHostContext(interruptedWork);
            break;
          }
          case HostPortal:
            popHostContainer(interruptedWork);
            break;
          case SuspenseComponent:
            popSuspenseContext(interruptedWork);
            break;
          case SuspenseListComponent:
            popSuspenseContext(interruptedWork);
            break;
          case ContextProvider:
            popProvider(interruptedWork);
            break;
          case OffscreenComponent:
          case LegacyHiddenComponent:
            popRenderLanes(interruptedWork);
            break;
        }
      }
      function createCapturedValue(value, source) {
        return {
          value,
          source,
          stack: getStackByFiberInDevAndProd(source)
        };
      }
      function showErrorDialog(boundary, errorInfo) {
        return !0;
      }
      function logCapturedError(boundary, errorInfo) {
        try {
          var logError = showErrorDialog(boundary, errorInfo);
          if (logError === !1)
            return;
          var error2 = errorInfo.value, source = errorInfo.source, stack = errorInfo.stack, componentStack = stack !== null ? stack : "";
          if (error2 != null && error2._suppressLogging) {
            if (boundary.tag === ClassComponent)
              return;
            console.error(error2);
          }
          var componentName = source ? getComponentName(source.type) : null, componentNameMessage = componentName ? "The above error occurred in the <" + componentName + "> component:" : "The above error occurred in one of your React components:", errorBoundaryMessage, errorBoundaryName = getComponentName(boundary.type);
          errorBoundaryName ? errorBoundaryMessage = "React will try to recreate this component tree from scratch " + ("using the error boundary you provided, " + errorBoundaryName + ".") : errorBoundaryMessage = `Consider adding an error boundary to your tree to customize error handling behavior.
Visit https://reactjs.org/link/error-boundaries to learn more about error boundaries.`;
          var combinedMessage = componentNameMessage + `
` + componentStack + `

` + ("" + errorBoundaryMessage);
          console.error(combinedMessage);
        } catch (e) {
          setTimeout(function() {
            throw e;
          });
        }
      }
      var PossiblyWeakMap$1 = typeof WeakMap == "function" ? WeakMap : Map;
      function createRootErrorUpdate(fiber, errorInfo, lane) {
        var update = createUpdate(NoTimestamp, lane);
        update.tag = CaptureUpdate, update.payload = {
          element: null
        };
        var error2 = errorInfo.value;
        return update.callback = function() {
          onUncaughtError(error2), logCapturedError(fiber, errorInfo);
        }, update;
      }
      function createClassErrorUpdate(fiber, errorInfo, lane) {
        var update = createUpdate(NoTimestamp, lane);
        update.tag = CaptureUpdate;
        var getDerivedStateFromError = fiber.type.getDerivedStateFromError;
        if (typeof getDerivedStateFromError == "function") {
          var error$1 = errorInfo.value;
          update.payload = function() {
            return logCapturedError(fiber, errorInfo), getDerivedStateFromError(error$1);
          };
        }
        var inst = fiber.stateNode;
        return inst !== null && typeof inst.componentDidCatch == "function" ? update.callback = function() {
          markFailedErrorBoundaryForHotReloading(fiber), typeof getDerivedStateFromError != "function" && (markLegacyErrorBoundaryAsFailed(this), logCapturedError(fiber, errorInfo));
          var error$12 = errorInfo.value, stack = errorInfo.stack;
          this.componentDidCatch(error$12, {
            componentStack: stack !== null ? stack : ""
          }), typeof getDerivedStateFromError != "function" && (includesSomeLane(fiber.lanes, SyncLane) || error("%s: Error boundaries should implement getDerivedStateFromError(). In that method, return a state update to display an error message or fallback UI.", getComponentName(fiber.type) || "Unknown"));
        } : update.callback = function() {
          markFailedErrorBoundaryForHotReloading(fiber);
        }, update;
      }
      function attachPingListener(root2, wakeable, lanes) {
        var pingCache = root2.pingCache, threadIDs;
        if (pingCache === null ? (pingCache = root2.pingCache = new PossiblyWeakMap$1(), threadIDs = /* @__PURE__ */ new Set(), pingCache.set(wakeable, threadIDs)) : (threadIDs = pingCache.get(wakeable), threadIDs === void 0 && (threadIDs = /* @__PURE__ */ new Set(), pingCache.set(wakeable, threadIDs))), !threadIDs.has(lanes)) {
          threadIDs.add(lanes);
          var ping = pingSuspendedRoot.bind(null, root2, wakeable, lanes);
          wakeable.then(ping, ping);
        }
      }
      function throwException(root2, returnFiber, sourceFiber, value, rootRenderLanes) {
        if (sourceFiber.flags |= Incomplete, sourceFiber.firstEffect = sourceFiber.lastEffect = null, value !== null && typeof value == "object" && typeof value.then == "function") {
          var wakeable = value;
          if ((sourceFiber.mode & BlockingMode) === NoMode) {
            var currentSource = sourceFiber.alternate;
            currentSource ? (sourceFiber.updateQueue = currentSource.updateQueue, sourceFiber.memoizedState = currentSource.memoizedState, sourceFiber.lanes = currentSource.lanes) : (sourceFiber.updateQueue = null, sourceFiber.memoizedState = null);
          }
          var hasInvisibleParentBoundary = hasSuspenseContext(suspenseStackCursor.current, InvisibleParentSuspenseContext), _workInProgress = returnFiber;
          do {
            if (_workInProgress.tag === SuspenseComponent && shouldCaptureSuspense(_workInProgress, hasInvisibleParentBoundary)) {
              var wakeables = _workInProgress.updateQueue;
              if (wakeables === null) {
                var updateQueue = /* @__PURE__ */ new Set();
                updateQueue.add(wakeable), _workInProgress.updateQueue = updateQueue;
              } else
                wakeables.add(wakeable);
              if ((_workInProgress.mode & BlockingMode) === NoMode) {
                if (_workInProgress.flags |= DidCapture, sourceFiber.flags |= ForceUpdateForLegacySuspense, sourceFiber.flags &= ~(LifecycleEffectMask | Incomplete), sourceFiber.tag === ClassComponent) {
                  var currentSourceFiber = sourceFiber.alternate;
                  if (currentSourceFiber === null)
                    sourceFiber.tag = IncompleteClassComponent;
                  else {
                    var update = createUpdate(NoTimestamp, SyncLane);
                    update.tag = ForceUpdate, enqueueUpdate(sourceFiber, update);
                  }
                }
                sourceFiber.lanes = mergeLanes(sourceFiber.lanes, SyncLane);
                return;
              }
              attachPingListener(root2, wakeable, rootRenderLanes), _workInProgress.flags |= ShouldCapture, _workInProgress.lanes = rootRenderLanes;
              return;
            }
            _workInProgress = _workInProgress.return;
          } while (_workInProgress !== null);
          value = new Error((getComponentName(sourceFiber.type) || "A React component") + ` suspended while rendering, but no fallback UI was specified.

Add a <Suspense fallback=...> component higher in the tree to provide a loading indicator or placeholder to display.`);
        }
        renderDidError(), value = createCapturedValue(value, sourceFiber);
        var workInProgress2 = returnFiber;
        do {
          switch (workInProgress2.tag) {
            case HostRoot: {
              var _errorInfo = value;
              workInProgress2.flags |= ShouldCapture;
              var lane = pickArbitraryLane(rootRenderLanes);
              workInProgress2.lanes = mergeLanes(workInProgress2.lanes, lane);
              var _update = createRootErrorUpdate(workInProgress2, _errorInfo, lane);
              enqueueCapturedUpdate(workInProgress2, _update);
              return;
            }
            case ClassComponent:
              var errorInfo = value, ctor = workInProgress2.type, instance = workInProgress2.stateNode;
              if ((workInProgress2.flags & DidCapture) === NoFlags && (typeof ctor.getDerivedStateFromError == "function" || instance !== null && typeof instance.componentDidCatch == "function" && !isAlreadyFailedLegacyErrorBoundary(instance))) {
                workInProgress2.flags |= ShouldCapture;
                var _lane = pickArbitraryLane(rootRenderLanes);
                workInProgress2.lanes = mergeLanes(workInProgress2.lanes, _lane);
                var _update2 = createClassErrorUpdate(workInProgress2, errorInfo, _lane);
                enqueueCapturedUpdate(workInProgress2, _update2);
                return;
              }
              break;
          }
          workInProgress2 = workInProgress2.return;
        } while (workInProgress2 !== null);
      }
      var didWarnAboutUndefinedSnapshotBeforeUpdate = null;
      didWarnAboutUndefinedSnapshotBeforeUpdate = /* @__PURE__ */ new Set();
      var PossiblyWeakSet = typeof WeakSet == "function" ? WeakSet : Set, callComponentWillUnmountWithTimer = function(current2, instance) {
        instance.props = current2.memoizedProps, instance.state = current2.memoizedState, instance.componentWillUnmount();
      };
      function safelyCallComponentWillUnmount(current2, instance) {
        if (invokeGuardedCallback(null, callComponentWillUnmountWithTimer, null, current2, instance), hasCaughtError()) {
          var unmountError = clearCaughtError();
          captureCommitPhaseError(current2, unmountError);
        }
      }
      function safelyDetachRef(current2) {
        var ref = current2.ref;
        if (ref !== null)
          if (typeof ref == "function") {
            if (invokeGuardedCallback(null, ref, null, null), hasCaughtError()) {
              var refError = clearCaughtError();
              captureCommitPhaseError(current2, refError);
            }
          } else
            ref.current = null;
      }
      function safelyCallDestroy(current2, destroy) {
        if (invokeGuardedCallback(null, destroy, null), hasCaughtError()) {
          var error2 = clearCaughtError();
          captureCommitPhaseError(current2, error2);
        }
      }
      function commitBeforeMutationLifeCycles(current2, finishedWork) {
        switch (finishedWork.tag) {
          case FunctionComponent:
          case ForwardRef2:
          case SimpleMemoComponent:
          case Block:
            return;
          case ClassComponent: {
            if (finishedWork.flags & Snapshot && current2 !== null) {
              var prevProps = current2.memoizedProps, prevState = current2.memoizedState, instance = finishedWork.stateNode;
              finishedWork.type === finishedWork.elementType && !didWarnAboutReassigningProps && (instance.props !== finishedWork.memoizedProps && error("Expected %s props to match memoized props before getSnapshotBeforeUpdate. This might either be because of a bug in React, or because a component reassigns its own `this.props`. Please file an issue.", getComponentName(finishedWork.type) || "instance"), instance.state !== finishedWork.memoizedState && error("Expected %s state to match memoized state before getSnapshotBeforeUpdate. This might either be because of a bug in React, or because a component reassigns its own `this.state`. Please file an issue.", getComponentName(finishedWork.type) || "instance"));
              var snapshot = instance.getSnapshotBeforeUpdate(finishedWork.elementType === finishedWork.type ? prevProps : resolveDefaultProps(finishedWork.type, prevProps), prevState);
              {
                var didWarnSet = didWarnAboutUndefinedSnapshotBeforeUpdate;
                snapshot === void 0 && !didWarnSet.has(finishedWork.type) && (didWarnSet.add(finishedWork.type), error("%s.getSnapshotBeforeUpdate(): A snapshot value (or null) must be returned. You have returned undefined.", getComponentName(finishedWork.type)));
              }
              instance.__reactInternalSnapshotBeforeUpdate = snapshot;
            }
            return;
          }
          case HostRoot: {
            if (finishedWork.flags & Snapshot) {
              var root2 = finishedWork.stateNode;
              clearContainer(root2.containerInfo);
            }
            return;
          }
          case HostComponent:
          case HostText:
          case HostPortal:
          case IncompleteClassComponent:
            return;
        }
        throw Error("This unit of work tag should not have side-effects. This error is likely caused by a bug in React. Please file an issue.");
      }
      function commitHookEffectListUnmount(tag, finishedWork) {
        var updateQueue = finishedWork.updateQueue, lastEffect = updateQueue !== null ? updateQueue.lastEffect : null;
        if (lastEffect !== null) {
          var firstEffect = lastEffect.next, effect = firstEffect;
          do {
            if ((effect.tag & tag) === tag) {
              var destroy = effect.destroy;
              effect.destroy = void 0, destroy !== void 0 && destroy();
            }
            effect = effect.next;
          } while (effect !== firstEffect);
        }
      }
      function commitHookEffectListMount(tag, finishedWork) {
        var updateQueue = finishedWork.updateQueue, lastEffect = updateQueue !== null ? updateQueue.lastEffect : null;
        if (lastEffect !== null) {
          var firstEffect = lastEffect.next, effect = firstEffect;
          do {
            if ((effect.tag & tag) === tag) {
              var create = effect.create;
              effect.destroy = create();
              {
                var destroy = effect.destroy;
                if (destroy !== void 0 && typeof destroy != "function") {
                  var addendum = void 0;
                  destroy === null ? addendum = " You returned null. If your effect does not require clean up, return undefined (or nothing)." : typeof destroy.then == "function" ? addendum = `

It looks like you wrote useEffect(async () => ...) or returned a Promise. Instead, write the async function inside your effect and call it immediately:

useEffect(() => {
  async function fetchData() {
    // You can await here
    const response = await MyAPI.getData(someId);
    // ...
  }
  fetchData();
}, [someId]); // Or [] if effect doesn't need props or state

Learn more about data fetching with Hooks: https://reactjs.org/link/hooks-data-fetching` : addendum = " You returned: " + destroy, error("An effect function must not return anything besides a function, which is used for clean-up.%s", addendum);
                }
              }
            }
            effect = effect.next;
          } while (effect !== firstEffect);
        }
      }
      function schedulePassiveEffects(finishedWork) {
        var updateQueue = finishedWork.updateQueue, lastEffect = updateQueue !== null ? updateQueue.lastEffect : null;
        if (lastEffect !== null) {
          var firstEffect = lastEffect.next, effect = firstEffect;
          do {
            var _effect = effect, next = _effect.next, tag = _effect.tag;
            (tag & Passive$1) !== NoFlags$1 && (tag & HasEffect) !== NoFlags$1 && (enqueuePendingPassiveHookEffectUnmount(finishedWork, effect), enqueuePendingPassiveHookEffectMount(finishedWork, effect)), effect = next;
          } while (effect !== firstEffect);
        }
      }
      function commitLifeCycles(finishedRoot, current2, finishedWork, committedLanes) {
        switch (finishedWork.tag) {
          case FunctionComponent:
          case ForwardRef2:
          case SimpleMemoComponent:
          case Block: {
            commitHookEffectListMount(Layout | HasEffect, finishedWork), schedulePassiveEffects(finishedWork);
            return;
          }
          case ClassComponent: {
            var instance = finishedWork.stateNode;
            if (finishedWork.flags & Update)
              if (current2 === null)
                finishedWork.type === finishedWork.elementType && !didWarnAboutReassigningProps && (instance.props !== finishedWork.memoizedProps && error("Expected %s props to match memoized props before componentDidMount. This might either be because of a bug in React, or because a component reassigns its own `this.props`. Please file an issue.", getComponentName(finishedWork.type) || "instance"), instance.state !== finishedWork.memoizedState && error("Expected %s state to match memoized state before componentDidMount. This might either be because of a bug in React, or because a component reassigns its own `this.state`. Please file an issue.", getComponentName(finishedWork.type) || "instance")), instance.componentDidMount();
              else {
                var prevProps = finishedWork.elementType === finishedWork.type ? current2.memoizedProps : resolveDefaultProps(finishedWork.type, current2.memoizedProps), prevState = current2.memoizedState;
                finishedWork.type === finishedWork.elementType && !didWarnAboutReassigningProps && (instance.props !== finishedWork.memoizedProps && error("Expected %s props to match memoized props before componentDidUpdate. This might either be because of a bug in React, or because a component reassigns its own `this.props`. Please file an issue.", getComponentName(finishedWork.type) || "instance"), instance.state !== finishedWork.memoizedState && error("Expected %s state to match memoized state before componentDidUpdate. This might either be because of a bug in React, or because a component reassigns its own `this.state`. Please file an issue.", getComponentName(finishedWork.type) || "instance")), instance.componentDidUpdate(prevProps, prevState, instance.__reactInternalSnapshotBeforeUpdate);
              }
            var updateQueue = finishedWork.updateQueue;
            updateQueue !== null && (finishedWork.type === finishedWork.elementType && !didWarnAboutReassigningProps && (instance.props !== finishedWork.memoizedProps && error("Expected %s props to match memoized props before processing the update queue. This might either be because of a bug in React, or because a component reassigns its own `this.props`. Please file an issue.", getComponentName(finishedWork.type) || "instance"), instance.state !== finishedWork.memoizedState && error("Expected %s state to match memoized state before processing the update queue. This might either be because of a bug in React, or because a component reassigns its own `this.state`. Please file an issue.", getComponentName(finishedWork.type) || "instance")), commitUpdateQueue(finishedWork, updateQueue, instance));
            return;
          }
          case HostRoot: {
            var _updateQueue = finishedWork.updateQueue;
            if (_updateQueue !== null) {
              var _instance = null;
              if (finishedWork.child !== null)
                switch (finishedWork.child.tag) {
                  case HostComponent:
                    _instance = finishedWork.child.stateNode;
                    break;
                  case ClassComponent:
                    _instance = finishedWork.child.stateNode;
                    break;
                }
              commitUpdateQueue(finishedWork, _updateQueue, _instance);
            }
            return;
          }
          case HostComponent: {
            var _instance2 = finishedWork.stateNode;
            if (current2 === null && finishedWork.flags & Update) {
              var type = finishedWork.type, props = finishedWork.memoizedProps;
              commitMount(_instance2, type, props);
            }
            return;
          }
          case HostText:
            return;
          case HostPortal:
            return;
          case Profiler: {
            {
              var _finishedWork$memoize2 = finishedWork.memoizedProps, onCommit = _finishedWork$memoize2.onCommit, onRender = _finishedWork$memoize2.onRender, effectDuration = finishedWork.stateNode.effectDuration, commitTime2 = getCommitTime();
              typeof onRender == "function" && onRender(finishedWork.memoizedProps.id, current2 === null ? "mount" : "update", finishedWork.actualDuration, finishedWork.treeBaseDuration, finishedWork.actualStartTime, commitTime2, finishedRoot.memoizedInteractions);
            }
            return;
          }
          case SuspenseComponent: {
            commitSuspenseHydrationCallbacks(finishedRoot, finishedWork);
            return;
          }
          case SuspenseListComponent:
          case IncompleteClassComponent:
          case FundamentalComponent:
          case ScopeComponent:
          case OffscreenComponent:
          case LegacyHiddenComponent:
            return;
        }
        throw Error("This unit of work tag should not have side-effects. This error is likely caused by a bug in React. Please file an issue.");
      }
      function hideOrUnhideAllChildren(finishedWork, isHidden) {
        for (var node = finishedWork; ; ) {
          if (node.tag === HostComponent) {
            var instance = node.stateNode;
            isHidden ? hideInstance(instance) : unhideInstance(node.stateNode, node.memoizedProps);
          } else if (node.tag === HostText) {
            var _instance3 = node.stateNode;
            isHidden ? hideTextInstance(_instance3) : unhideTextInstance(_instance3, node.memoizedProps);
          } else if (!((node.tag === OffscreenComponent || node.tag === LegacyHiddenComponent) && node.memoizedState !== null && node !== finishedWork)) {
            if (node.child !== null) {
              node.child.return = node, node = node.child;
              continue;
            }
          }
          if (node === finishedWork)
            return;
          for (; node.sibling === null; ) {
            if (node.return === null || node.return === finishedWork)
              return;
            node = node.return;
          }
          node.sibling.return = node.return, node = node.sibling;
        }
      }
      function commitAttachRef(finishedWork) {
        var ref = finishedWork.ref;
        if (ref !== null) {
          var instance = finishedWork.stateNode, instanceToUse;
          switch (finishedWork.tag) {
            case HostComponent:
              instanceToUse = instance;
              break;
            default:
              instanceToUse = instance;
          }
          typeof ref == "function" ? ref(instanceToUse) : (ref.hasOwnProperty("current") || error("Unexpected ref object provided for %s. Use either a ref-setter function or React.createRef().", getComponentName(finishedWork.type)), ref.current = instanceToUse);
        }
      }
      function commitDetachRef(current2) {
        var currentRef = current2.ref;
        currentRef !== null && (typeof currentRef == "function" ? currentRef(null) : currentRef.current = null);
      }
      function commitUnmount(finishedRoot, current2, renderPriorityLevel) {
        switch (onCommitUnmount(current2), current2.tag) {
          case FunctionComponent:
          case ForwardRef2:
          case MemoComponent:
          case SimpleMemoComponent:
          case Block: {
            var updateQueue = current2.updateQueue;
            if (updateQueue !== null) {
              var lastEffect = updateQueue.lastEffect;
              if (lastEffect !== null) {
                var firstEffect = lastEffect.next, effect = firstEffect;
                do {
                  var _effect2 = effect, destroy = _effect2.destroy, tag = _effect2.tag;
                  destroy !== void 0 && ((tag & Passive$1) !== NoFlags$1 ? enqueuePendingPassiveHookEffectUnmount(current2, effect) : safelyCallDestroy(current2, destroy)), effect = effect.next;
                } while (effect !== firstEffect);
              }
            }
            return;
          }
          case ClassComponent: {
            safelyDetachRef(current2);
            var instance = current2.stateNode;
            typeof instance.componentWillUnmount == "function" && safelyCallComponentWillUnmount(current2, instance);
            return;
          }
          case HostComponent: {
            safelyDetachRef(current2);
            return;
          }
          case HostPortal: {
            unmountHostComponents(finishedRoot, current2);
            return;
          }
          case FundamentalComponent:
            return;
          case DehydratedFragment:
            return;
          case ScopeComponent:
            return;
        }
      }
      function commitNestedUnmounts(finishedRoot, root2, renderPriorityLevel) {
        for (var node = root2; ; ) {
          if (commitUnmount(finishedRoot, node), node.child !== null && node.tag !== HostPortal) {
            node.child.return = node, node = node.child;
            continue;
          }
          if (node === root2)
            return;
          for (; node.sibling === null; ) {
            if (node.return === null || node.return === root2)
              return;
            node = node.return;
          }
          node.sibling.return = node.return, node = node.sibling;
        }
      }
      function detachFiberMutation(fiber) {
        fiber.alternate = null, fiber.child = null, fiber.dependencies = null, fiber.firstEffect = null, fiber.lastEffect = null, fiber.memoizedProps = null, fiber.memoizedState = null, fiber.pendingProps = null, fiber.return = null, fiber.updateQueue = null, fiber._debugOwner = null;
      }
      function getHostParentFiber(fiber) {
        for (var parent = fiber.return; parent !== null; ) {
          if (isHostParent(parent))
            return parent;
          parent = parent.return;
        }
        throw Error("Expected to find a host parent. This error is likely caused by a bug in React. Please file an issue.");
      }
      function isHostParent(fiber) {
        return fiber.tag === HostComponent || fiber.tag === HostRoot || fiber.tag === HostPortal;
      }
      function getHostSibling(fiber) {
        var node = fiber;
        siblings:
          for (; ; ) {
            for (; node.sibling === null; ) {
              if (node.return === null || isHostParent(node.return))
                return null;
              node = node.return;
            }
            for (node.sibling.return = node.return, node = node.sibling; node.tag !== HostComponent && node.tag !== HostText && node.tag !== DehydratedFragment; ) {
              if (node.flags & Placement || node.child === null || node.tag === HostPortal)
                continue siblings;
              node.child.return = node, node = node.child;
            }
            if (!(node.flags & Placement))
              return node.stateNode;
          }
      }
      function commitPlacement(finishedWork) {
        var parentFiber = getHostParentFiber(finishedWork), parent, isContainer, parentStateNode = parentFiber.stateNode;
        switch (parentFiber.tag) {
          case HostComponent:
            parent = parentStateNode, isContainer = !1;
            break;
          case HostRoot:
            parent = parentStateNode.containerInfo, isContainer = !0;
            break;
          case HostPortal:
            parent = parentStateNode.containerInfo, isContainer = !0;
            break;
          case FundamentalComponent:
          default:
            throw Error("Invalid host parent fiber. This error is likely caused by a bug in React. Please file an issue.");
        }
        parentFiber.flags & ContentReset && (resetTextContent(parent), parentFiber.flags &= ~ContentReset);
        var before = getHostSibling(finishedWork);
        isContainer ? insertOrAppendPlacementNodeIntoContainer(finishedWork, before, parent) : insertOrAppendPlacementNode(finishedWork, before, parent);
      }
      function insertOrAppendPlacementNodeIntoContainer(node, before, parent) {
        var tag = node.tag, isHost = tag === HostComponent || tag === HostText;
        if (isHost || enableFundamentalAPI) {
          var stateNode = isHost ? node.stateNode : node.stateNode.instance;
          before ? insertInContainerBefore(parent, stateNode, before) : appendChildToContainer(parent, stateNode);
        } else if (tag !== HostPortal) {
          var child = node.child;
          if (child !== null) {
            insertOrAppendPlacementNodeIntoContainer(child, before, parent);
            for (var sibling = child.sibling; sibling !== null; )
              insertOrAppendPlacementNodeIntoContainer(sibling, before, parent), sibling = sibling.sibling;
          }
        }
      }
      function insertOrAppendPlacementNode(node, before, parent) {
        var tag = node.tag, isHost = tag === HostComponent || tag === HostText;
        if (isHost || enableFundamentalAPI) {
          var stateNode = isHost ? node.stateNode : node.stateNode.instance;
          before ? insertBefore(parent, stateNode, before) : appendChild(parent, stateNode);
        } else if (tag !== HostPortal) {
          var child = node.child;
          if (child !== null) {
            insertOrAppendPlacementNode(child, before, parent);
            for (var sibling = child.sibling; sibling !== null; )
              insertOrAppendPlacementNode(sibling, before, parent), sibling = sibling.sibling;
          }
        }
      }
      function unmountHostComponents(finishedRoot, current2, renderPriorityLevel) {
        for (var node = current2, currentParentIsValid = !1, currentParent, currentParentIsContainer; ; ) {
          if (!currentParentIsValid) {
            var parent = node.return;
            findParent:
              for (; ; ) {
                if (parent === null)
                  throw Error("Expected to find a host parent. This error is likely caused by a bug in React. Please file an issue.");
                var parentStateNode = parent.stateNode;
                switch (parent.tag) {
                  case HostComponent:
                    currentParent = parentStateNode, currentParentIsContainer = !1;
                    break findParent;
                  case HostRoot:
                    currentParent = parentStateNode.containerInfo, currentParentIsContainer = !0;
                    break findParent;
                  case HostPortal:
                    currentParent = parentStateNode.containerInfo, currentParentIsContainer = !0;
                    break findParent;
                }
                parent = parent.return;
              }
            currentParentIsValid = !0;
          }
          if (node.tag === HostComponent || node.tag === HostText)
            commitNestedUnmounts(finishedRoot, node), currentParentIsContainer ? removeChildFromContainer(currentParent, node.stateNode) : removeChild(currentParent, node.stateNode);
          else if (node.tag === HostPortal) {
            if (node.child !== null) {
              currentParent = node.stateNode.containerInfo, currentParentIsContainer = !0, node.child.return = node, node = node.child;
              continue;
            }
          } else if (commitUnmount(finishedRoot, node), node.child !== null) {
            node.child.return = node, node = node.child;
            continue;
          }
          if (node === current2)
            return;
          for (; node.sibling === null; ) {
            if (node.return === null || node.return === current2)
              return;
            node = node.return, node.tag === HostPortal && (currentParentIsValid = !1);
          }
          node.sibling.return = node.return, node = node.sibling;
        }
      }
      function commitDeletion(finishedRoot, current2, renderPriorityLevel) {
        unmountHostComponents(finishedRoot, current2);
        var alternate = current2.alternate;
        detachFiberMutation(current2), alternate !== null && detachFiberMutation(alternate);
      }
      function commitWork(current2, finishedWork) {
        switch (finishedWork.tag) {
          case FunctionComponent:
          case ForwardRef2:
          case MemoComponent:
          case SimpleMemoComponent:
          case Block: {
            commitHookEffectListUnmount(Layout | HasEffect, finishedWork);
            return;
          }
          case ClassComponent:
            return;
          case HostComponent: {
            var instance = finishedWork.stateNode;
            if (instance != null) {
              var newProps = finishedWork.memoizedProps, oldProps = current2 !== null ? current2.memoizedProps : newProps, type = finishedWork.type, updatePayload = finishedWork.updateQueue;
              finishedWork.updateQueue = null, updatePayload !== null && commitUpdate(instance, updatePayload, type, oldProps, newProps);
            }
            return;
          }
          case HostText: {
            if (finishedWork.stateNode === null)
              throw Error("This should have a text node initialized. This error is likely caused by a bug in React. Please file an issue.");
            var textInstance = finishedWork.stateNode, newText = finishedWork.memoizedProps, oldText = current2 !== null ? current2.memoizedProps : newText;
            commitTextUpdate(textInstance, oldText, newText);
            return;
          }
          case HostRoot: {
            {
              var _root = finishedWork.stateNode;
              _root.hydrate && (_root.hydrate = !1, commitHydratedContainer(_root.containerInfo));
            }
            return;
          }
          case Profiler:
            return;
          case SuspenseComponent: {
            commitSuspenseComponent(finishedWork), attachSuspenseRetryListeners(finishedWork);
            return;
          }
          case SuspenseListComponent: {
            attachSuspenseRetryListeners(finishedWork);
            return;
          }
          case IncompleteClassComponent:
            return;
          case FundamentalComponent:
            break;
          case ScopeComponent:
            break;
          case OffscreenComponent:
          case LegacyHiddenComponent: {
            var newState = finishedWork.memoizedState, isHidden = newState !== null;
            hideOrUnhideAllChildren(finishedWork, isHidden);
            return;
          }
        }
        throw Error("This unit of work tag should not have side-effects. This error is likely caused by a bug in React. Please file an issue.");
      }
      function commitSuspenseComponent(finishedWork) {
        var newState = finishedWork.memoizedState;
        if (newState !== null) {
          markCommitTimeOfFallback();
          {
            var primaryChildParent = finishedWork.child;
            hideOrUnhideAllChildren(primaryChildParent, !0);
          }
        }
      }
      function commitSuspenseHydrationCallbacks(finishedRoot, finishedWork) {
        var newState = finishedWork.memoizedState;
        if (newState === null) {
          var current2 = finishedWork.alternate;
          if (current2 !== null) {
            var prevState = current2.memoizedState;
            if (prevState !== null) {
              var suspenseInstance = prevState.dehydrated;
              suspenseInstance !== null && commitHydratedSuspenseInstance(suspenseInstance);
            }
          }
        }
      }
      function attachSuspenseRetryListeners(finishedWork) {
        var wakeables = finishedWork.updateQueue;
        if (wakeables !== null) {
          finishedWork.updateQueue = null;
          var retryCache = finishedWork.stateNode;
          retryCache === null && (retryCache = finishedWork.stateNode = new PossiblyWeakSet()), wakeables.forEach(function(wakeable) {
            var retry = resolveRetryWakeable.bind(null, finishedWork, wakeable);
            retryCache.has(wakeable) || (wakeable.__reactDoNotTraceInteractions !== !0 && (retry = tracing.unstable_wrap(retry)), retryCache.add(wakeable), wakeable.then(retry, retry));
          });
        }
      }
      function isSuspenseBoundaryBeingHidden(current2, finishedWork) {
        if (current2 !== null) {
          var oldState = current2.memoizedState;
          if (oldState === null || oldState.dehydrated !== null) {
            var newState = finishedWork.memoizedState;
            return newState !== null && newState.dehydrated === null;
          }
        }
        return !1;
      }
      function commitResetTextContent(current2) {
        resetTextContent(current2.stateNode);
      }
      var COMPONENT_TYPE = 0, HAS_PSEUDO_CLASS_TYPE = 1, ROLE_TYPE = 2, TEST_NAME_TYPE = 3, TEXT_TYPE = 4;
      if (typeof Symbol == "function" && Symbol.for) {
        var symbolFor$1 = Symbol.for;
        COMPONENT_TYPE = symbolFor$1("selector.component"), HAS_PSEUDO_CLASS_TYPE = symbolFor$1("selector.has_pseudo_class"), ROLE_TYPE = symbolFor$1("selector.role"), TEST_NAME_TYPE = symbolFor$1("selector.test_id"), TEXT_TYPE = symbolFor$1("selector.text");
      }
      var commitHooks = [];
      function onCommitRoot$1() {
        commitHooks.forEach(function(commitHook) {
          return commitHook();
        });
      }
      var ceil = Math.ceil, ReactCurrentDispatcher$2 = ReactSharedInternals.ReactCurrentDispatcher, ReactCurrentOwner$2 = ReactSharedInternals.ReactCurrentOwner, IsSomeRendererActing = ReactSharedInternals.IsSomeRendererActing, NoContext = 0, BatchedContext = 1, EventContext = 2, DiscreteEventContext = 4, LegacyUnbatchedContext = 8, RenderContext = 16, CommitContext = 32, RetryAfterError = 64, RootIncomplete = 0, RootFatalErrored = 1, RootErrored = 2, RootSuspended = 3, RootSuspendedWithDelay = 4, RootCompleted = 5, executionContext = NoContext, workInProgressRoot = null, workInProgress = null, workInProgressRootRenderLanes = NoLanes, subtreeRenderLanes = NoLanes, subtreeRenderLanesCursor = createCursor(NoLanes), workInProgressRootExitStatus = RootIncomplete, workInProgressRootFatalError = null, workInProgressRootIncludedLanes = NoLanes, workInProgressRootSkippedLanes = NoLanes, workInProgressRootUpdatedLanes = NoLanes, workInProgressRootPingedLanes = NoLanes, mostRecentlyUpdatedRoot = null, globalMostRecentFallbackTime = 0, FALLBACK_THROTTLE_MS = 500, workInProgressRootRenderTargetTime = 1 / 0, RENDER_TIMEOUT_MS = 500;
      function resetRenderTimer() {
        workInProgressRootRenderTargetTime = now() + RENDER_TIMEOUT_MS;
      }
      function getRenderTargetTime() {
        return workInProgressRootRenderTargetTime;
      }
      var nextEffect = null, hasUncaughtError = !1, firstUncaughtError = null, legacyErrorBoundariesThatAlreadyFailed = null, rootDoesHavePassiveEffects = !1, rootWithPendingPassiveEffects = null, pendingPassiveEffectsRenderPriority = NoPriority$1, pendingPassiveEffectsLanes = NoLanes, pendingPassiveHookEffectsMount = [], pendingPassiveHookEffectsUnmount = [], rootsWithPendingDiscreteUpdates = null, NESTED_UPDATE_LIMIT = 50, nestedUpdateCount = 0, rootWithNestedUpdates = null, NESTED_PASSIVE_UPDATE_LIMIT = 50, nestedPassiveUpdateCount = 0, spawnedWorkDuringRender = null, currentEventTime = NoTimestamp, currentEventWipLanes = NoLanes, currentEventPendingLanes = NoLanes, isFlushingPassiveEffects = !1, focusedInstanceHandle = null, shouldFireAfterActiveInstanceBlur = !1;
      function getWorkInProgressRoot() {
        return workInProgressRoot;
      }
      function requestEventTime() {
        return (executionContext & (RenderContext | CommitContext)) !== NoContext ? now() : (currentEventTime !== NoTimestamp || (currentEventTime = now()), currentEventTime);
      }
      function requestUpdateLane(fiber) {
        var mode = fiber.mode;
        if ((mode & BlockingMode) === NoMode)
          return SyncLane;
        if ((mode & ConcurrentMode) === NoMode)
          return getCurrentPriorityLevel() === ImmediatePriority$1 ? SyncLane : SyncBatchedLane;
        currentEventWipLanes === NoLanes && (currentEventWipLanes = workInProgressRootIncludedLanes);
        var isTransition = requestCurrentTransition() !== NoTransition;
        if (isTransition)
          return currentEventPendingLanes !== NoLanes && (currentEventPendingLanes = mostRecentlyUpdatedRoot !== null ? mostRecentlyUpdatedRoot.pendingLanes : NoLanes), findTransitionLane(currentEventWipLanes, currentEventPendingLanes);
        var schedulerPriority = getCurrentPriorityLevel(), lane;
        if ((executionContext & DiscreteEventContext) !== NoContext && schedulerPriority === UserBlockingPriority$2)
          lane = findUpdateLane(InputDiscreteLanePriority, currentEventWipLanes);
        else {
          var schedulerLanePriority = schedulerPriorityToLanePriority(schedulerPriority);
          lane = findUpdateLane(schedulerLanePriority, currentEventWipLanes);
        }
        return lane;
      }
      function requestRetryLane(fiber) {
        var mode = fiber.mode;
        return (mode & BlockingMode) === NoMode ? SyncLane : (mode & ConcurrentMode) === NoMode ? getCurrentPriorityLevel() === ImmediatePriority$1 ? SyncLane : SyncBatchedLane : (currentEventWipLanes === NoLanes && (currentEventWipLanes = workInProgressRootIncludedLanes), findRetryLane(currentEventWipLanes));
      }
      function scheduleUpdateOnFiber(fiber, lane, eventTime) {
        checkForNestedUpdates(), warnAboutRenderPhaseUpdatesInDEV(fiber);
        var root2 = markUpdateLaneFromFiberToRoot(fiber, lane);
        if (root2 === null)
          return warnAboutUpdateOnUnmountedFiberInDEV(fiber), null;
        markRootUpdated(root2, lane, eventTime), root2 === workInProgressRoot && (workInProgressRootUpdatedLanes = mergeLanes(workInProgressRootUpdatedLanes, lane), workInProgressRootExitStatus === RootSuspendedWithDelay && markRootSuspended$1(root2, workInProgressRootRenderLanes));
        var priorityLevel = getCurrentPriorityLevel();
        lane === SyncLane ? (executionContext & LegacyUnbatchedContext) !== NoContext && (executionContext & (RenderContext | CommitContext)) === NoContext ? (schedulePendingInteractions(root2, lane), performSyncWorkOnRoot(root2)) : (ensureRootIsScheduled(root2, eventTime), schedulePendingInteractions(root2, lane), executionContext === NoContext && (resetRenderTimer(), flushSyncCallbackQueue())) : ((executionContext & DiscreteEventContext) !== NoContext && (priorityLevel === UserBlockingPriority$2 || priorityLevel === ImmediatePriority$1) && (rootsWithPendingDiscreteUpdates === null ? rootsWithPendingDiscreteUpdates = /* @__PURE__ */ new Set([root2]) : rootsWithPendingDiscreteUpdates.add(root2)), ensureRootIsScheduled(root2, eventTime), schedulePendingInteractions(root2, lane)), mostRecentlyUpdatedRoot = root2;
      }
      function markUpdateLaneFromFiberToRoot(sourceFiber, lane) {
        sourceFiber.lanes = mergeLanes(sourceFiber.lanes, lane);
        var alternate = sourceFiber.alternate;
        alternate !== null && (alternate.lanes = mergeLanes(alternate.lanes, lane)), alternate === null && (sourceFiber.flags & (Placement | Hydrating)) !== NoFlags && warnAboutUpdateOnNotYetMountedFiberInDEV(sourceFiber);
        for (var node = sourceFiber, parent = sourceFiber.return; parent !== null; )
          parent.childLanes = mergeLanes(parent.childLanes, lane), alternate = parent.alternate, alternate !== null ? alternate.childLanes = mergeLanes(alternate.childLanes, lane) : (parent.flags & (Placement | Hydrating)) !== NoFlags && warnAboutUpdateOnNotYetMountedFiberInDEV(sourceFiber), node = parent, parent = parent.return;
        if (node.tag === HostRoot) {
          var root2 = node.stateNode;
          return root2;
        } else
          return null;
      }
      function ensureRootIsScheduled(root2, currentTime) {
        var existingCallbackNode = root2.callbackNode;
        markStarvedLanesAsExpired(root2, currentTime);
        var nextLanes = getNextLanes(root2, root2 === workInProgressRoot ? workInProgressRootRenderLanes : NoLanes), newCallbackPriority = returnNextLanesPriority();
        if (nextLanes === NoLanes) {
          existingCallbackNode !== null && (cancelCallback(existingCallbackNode), root2.callbackNode = null, root2.callbackPriority = NoLanePriority);
          return;
        }
        if (existingCallbackNode !== null) {
          var existingCallbackPriority = root2.callbackPriority;
          if (existingCallbackPriority === newCallbackPriority)
            return;
          cancelCallback(existingCallbackNode);
        }
        var newCallbackNode;
        if (newCallbackPriority === SyncLanePriority)
          newCallbackNode = scheduleSyncCallback(performSyncWorkOnRoot.bind(null, root2));
        else if (newCallbackPriority === SyncBatchedLanePriority)
          newCallbackNode = scheduleCallback(ImmediatePriority$1, performSyncWorkOnRoot.bind(null, root2));
        else {
          var schedulerPriorityLevel = lanePriorityToSchedulerPriority(newCallbackPriority);
          newCallbackNode = scheduleCallback(schedulerPriorityLevel, performConcurrentWorkOnRoot.bind(null, root2));
        }
        root2.callbackPriority = newCallbackPriority, root2.callbackNode = newCallbackNode;
      }
      function performConcurrentWorkOnRoot(root2) {
        if (currentEventTime = NoTimestamp, currentEventWipLanes = NoLanes, currentEventPendingLanes = NoLanes, (executionContext & (RenderContext | CommitContext)) !== NoContext)
          throw Error("Should not already be working.");
        var originalCallbackNode = root2.callbackNode, didFlushPassiveEffects = flushPassiveEffects();
        if (didFlushPassiveEffects && root2.callbackNode !== originalCallbackNode)
          return null;
        var lanes = getNextLanes(root2, root2 === workInProgressRoot ? workInProgressRootRenderLanes : NoLanes);
        if (lanes === NoLanes)
          return null;
        var exitStatus = renderRootConcurrent(root2, lanes);
        if (includesSomeLane(workInProgressRootIncludedLanes, workInProgressRootUpdatedLanes))
          prepareFreshStack(root2, NoLanes);
        else if (exitStatus !== RootIncomplete) {
          if (exitStatus === RootErrored && (executionContext |= RetryAfterError, root2.hydrate && (root2.hydrate = !1, clearContainer(root2.containerInfo)), lanes = getLanesToRetrySynchronouslyOnError(root2), lanes !== NoLanes && (exitStatus = renderRootSync(root2, lanes))), exitStatus === RootFatalErrored) {
            var fatalError = workInProgressRootFatalError;
            throw prepareFreshStack(root2, NoLanes), markRootSuspended$1(root2, lanes), ensureRootIsScheduled(root2, now()), fatalError;
          }
          var finishedWork = root2.current.alternate;
          root2.finishedWork = finishedWork, root2.finishedLanes = lanes, finishConcurrentRender(root2, exitStatus, lanes);
        }
        return ensureRootIsScheduled(root2, now()), root2.callbackNode === originalCallbackNode ? performConcurrentWorkOnRoot.bind(null, root2) : null;
      }
      function finishConcurrentRender(root2, exitStatus, lanes) {
        switch (exitStatus) {
          case RootIncomplete:
          case RootFatalErrored:
            throw Error("Root did not complete. This is a bug in React.");
          case RootErrored: {
            commitRoot(root2);
            break;
          }
          case RootSuspended: {
            if (markRootSuspended$1(root2, lanes), includesOnlyRetries(lanes) && !shouldForceFlushFallbacksInDEV()) {
              var msUntilTimeout = globalMostRecentFallbackTime + FALLBACK_THROTTLE_MS - now();
              if (msUntilTimeout > 10) {
                var nextLanes = getNextLanes(root2, NoLanes);
                if (nextLanes !== NoLanes)
                  break;
                var suspendedLanes = root2.suspendedLanes;
                if (!isSubsetOfLanes(suspendedLanes, lanes)) {
                  var eventTime = requestEventTime();
                  markRootPinged(root2, suspendedLanes);
                  break;
                }
                root2.timeoutHandle = scheduleTimeout(commitRoot.bind(null, root2), msUntilTimeout);
                break;
              }
            }
            commitRoot(root2);
            break;
          }
          case RootSuspendedWithDelay: {
            if (markRootSuspended$1(root2, lanes), includesOnlyTransitions(lanes))
              break;
            if (!shouldForceFlushFallbacksInDEV()) {
              var mostRecentEventTime = getMostRecentEventTime(root2, lanes), eventTimeMs = mostRecentEventTime, timeElapsedMs = now() - eventTimeMs, _msUntilTimeout = jnd(timeElapsedMs) - timeElapsedMs;
              if (_msUntilTimeout > 10) {
                root2.timeoutHandle = scheduleTimeout(commitRoot.bind(null, root2), _msUntilTimeout);
                break;
              }
            }
            commitRoot(root2);
            break;
          }
          case RootCompleted: {
            commitRoot(root2);
            break;
          }
          default:
            throw Error("Unknown root exit status.");
        }
      }
      function markRootSuspended$1(root2, suspendedLanes) {
        suspendedLanes = removeLanes(suspendedLanes, workInProgressRootPingedLanes), suspendedLanes = removeLanes(suspendedLanes, workInProgressRootUpdatedLanes), markRootSuspended(root2, suspendedLanes);
      }
      function performSyncWorkOnRoot(root2) {
        if ((executionContext & (RenderContext | CommitContext)) !== NoContext)
          throw Error("Should not already be working.");
        flushPassiveEffects();
        var lanes, exitStatus;
        if (root2 === workInProgressRoot && includesSomeLane(root2.expiredLanes, workInProgressRootRenderLanes) ? (lanes = workInProgressRootRenderLanes, exitStatus = renderRootSync(root2, lanes), includesSomeLane(workInProgressRootIncludedLanes, workInProgressRootUpdatedLanes) && (lanes = getNextLanes(root2, lanes), exitStatus = renderRootSync(root2, lanes))) : (lanes = getNextLanes(root2, NoLanes), exitStatus = renderRootSync(root2, lanes)), root2.tag !== LegacyRoot && exitStatus === RootErrored && (executionContext |= RetryAfterError, root2.hydrate && (root2.hydrate = !1, clearContainer(root2.containerInfo)), lanes = getLanesToRetrySynchronouslyOnError(root2), lanes !== NoLanes && (exitStatus = renderRootSync(root2, lanes))), exitStatus === RootFatalErrored) {
          var fatalError = workInProgressRootFatalError;
          throw prepareFreshStack(root2, NoLanes), markRootSuspended$1(root2, lanes), ensureRootIsScheduled(root2, now()), fatalError;
        }
        var finishedWork = root2.current.alternate;
        return root2.finishedWork = finishedWork, root2.finishedLanes = lanes, commitRoot(root2), ensureRootIsScheduled(root2, now()), null;
      }
      function flushDiscreteUpdates() {
        if ((executionContext & (BatchedContext | RenderContext | CommitContext)) !== NoContext) {
          (executionContext & RenderContext) !== NoContext && error("unstable_flushDiscreteUpdates: Cannot flush updates when React is already rendering.");
          return;
        }
        flushPendingDiscreteUpdates(), flushPassiveEffects();
      }
      function flushPendingDiscreteUpdates() {
        if (rootsWithPendingDiscreteUpdates !== null) {
          var roots = rootsWithPendingDiscreteUpdates;
          rootsWithPendingDiscreteUpdates = null, roots.forEach(function(root2) {
            markDiscreteUpdatesExpired(root2), ensureRootIsScheduled(root2, now());
          });
        }
        flushSyncCallbackQueue();
      }
      function batchedUpdates$1(fn, a) {
        var prevExecutionContext = executionContext;
        executionContext |= BatchedContext;
        try {
          return fn(a);
        } finally {
          executionContext = prevExecutionContext, executionContext === NoContext && (resetRenderTimer(), flushSyncCallbackQueue());
        }
      }
      function batchedEventUpdates$1(fn, a) {
        var prevExecutionContext = executionContext;
        executionContext |= EventContext;
        try {
          return fn(a);
        } finally {
          executionContext = prevExecutionContext, executionContext === NoContext && (resetRenderTimer(), flushSyncCallbackQueue());
        }
      }
      function discreteUpdates$1(fn, a, b, c, d) {
        var prevExecutionContext = executionContext;
        executionContext |= DiscreteEventContext;
        try {
          return runWithPriority$1(UserBlockingPriority$2, fn.bind(null, a, b, c, d));
        } finally {
          executionContext = prevExecutionContext, executionContext === NoContext && (resetRenderTimer(), flushSyncCallbackQueue());
        }
      }
      function unbatchedUpdates(fn, a) {
        var prevExecutionContext = executionContext;
        executionContext &= ~BatchedContext, executionContext |= LegacyUnbatchedContext;
        try {
          return fn(a);
        } finally {
          executionContext = prevExecutionContext, executionContext === NoContext && (resetRenderTimer(), flushSyncCallbackQueue());
        }
      }
      function flushSync2(fn, a) {
        var prevExecutionContext = executionContext;
        if ((prevExecutionContext & (RenderContext | CommitContext)) !== NoContext)
          return error("flushSync was called from inside a lifecycle method. React cannot flush when React is already rendering. Consider moving this call to a scheduler task or micro task."), fn(a);
        executionContext |= BatchedContext;
        try {
          return fn ? runWithPriority$1(ImmediatePriority$1, fn.bind(null, a)) : void 0;
        } finally {
          executionContext = prevExecutionContext, flushSyncCallbackQueue();
        }
      }
      function pushRenderLanes(fiber, lanes) {
        push(subtreeRenderLanesCursor, subtreeRenderLanes, fiber), subtreeRenderLanes = mergeLanes(subtreeRenderLanes, lanes), workInProgressRootIncludedLanes = mergeLanes(workInProgressRootIncludedLanes, lanes);
      }
      function popRenderLanes(fiber) {
        subtreeRenderLanes = subtreeRenderLanesCursor.current, pop(subtreeRenderLanesCursor, fiber);
      }
      function prepareFreshStack(root2, lanes) {
        root2.finishedWork = null, root2.finishedLanes = NoLanes;
        var timeoutHandle = root2.timeoutHandle;
        if (timeoutHandle !== noTimeout && (root2.timeoutHandle = noTimeout, cancelTimeout(timeoutHandle)), workInProgress !== null)
          for (var interruptedWork = workInProgress.return; interruptedWork !== null; )
            unwindInterruptedWork(interruptedWork), interruptedWork = interruptedWork.return;
        workInProgressRoot = root2, workInProgress = createWorkInProgress(root2.current, null), workInProgressRootRenderLanes = subtreeRenderLanes = workInProgressRootIncludedLanes = lanes, workInProgressRootExitStatus = RootIncomplete, workInProgressRootFatalError = null, workInProgressRootSkippedLanes = NoLanes, workInProgressRootUpdatedLanes = NoLanes, workInProgressRootPingedLanes = NoLanes, spawnedWorkDuringRender = null, ReactStrictModeWarnings.discardPendingWarnings();
      }
      function handleError(root2, thrownValue) {
        do {
          var erroredWork = workInProgress;
          try {
            if (resetContextDependencies(), resetHooksAfterThrow(), resetCurrentFiber(), ReactCurrentOwner$2.current = null, erroredWork === null || erroredWork.return === null) {
              workInProgressRootExitStatus = RootFatalErrored, workInProgressRootFatalError = thrownValue, workInProgress = null;
              return;
            }
            enableProfilerTimer && erroredWork.mode & ProfileMode && stopProfilerTimerIfRunningAndRecordDelta(erroredWork, !0), throwException(root2, erroredWork.return, erroredWork, thrownValue, workInProgressRootRenderLanes), completeUnitOfWork(erroredWork);
          } catch (yetAnotherThrownValue) {
            thrownValue = yetAnotherThrownValue, workInProgress === erroredWork && erroredWork !== null ? (erroredWork = erroredWork.return, workInProgress = erroredWork) : erroredWork = workInProgress;
            continue;
          }
          return;
        } while (!0);
      }
      function pushDispatcher() {
        var prevDispatcher = ReactCurrentDispatcher$2.current;
        return ReactCurrentDispatcher$2.current = ContextOnlyDispatcher, prevDispatcher === null ? ContextOnlyDispatcher : prevDispatcher;
      }
      function popDispatcher(prevDispatcher) {
        ReactCurrentDispatcher$2.current = prevDispatcher;
      }
      function pushInteractions(root2) {
        {
          var prevInteractions = tracing.__interactionsRef.current;
          return tracing.__interactionsRef.current = root2.memoizedInteractions, prevInteractions;
        }
      }
      function popInteractions(prevInteractions) {
        tracing.__interactionsRef.current = prevInteractions;
      }
      function markCommitTimeOfFallback() {
        globalMostRecentFallbackTime = now();
      }
      function markSkippedUpdateLanes(lane) {
        workInProgressRootSkippedLanes = mergeLanes(lane, workInProgressRootSkippedLanes);
      }
      function renderDidSuspend() {
        workInProgressRootExitStatus === RootIncomplete && (workInProgressRootExitStatus = RootSuspended);
      }
      function renderDidSuspendDelayIfPossible() {
        (workInProgressRootExitStatus === RootIncomplete || workInProgressRootExitStatus === RootSuspended) && (workInProgressRootExitStatus = RootSuspendedWithDelay), workInProgressRoot !== null && (includesNonIdleWork(workInProgressRootSkippedLanes) || includesNonIdleWork(workInProgressRootUpdatedLanes)) && markRootSuspended$1(workInProgressRoot, workInProgressRootRenderLanes);
      }
      function renderDidError() {
        workInProgressRootExitStatus !== RootCompleted && (workInProgressRootExitStatus = RootErrored);
      }
      function renderHasNotSuspendedYet() {
        return workInProgressRootExitStatus === RootIncomplete;
      }
      function renderRootSync(root2, lanes) {
        var prevExecutionContext = executionContext;
        executionContext |= RenderContext;
        var prevDispatcher = pushDispatcher();
        (workInProgressRoot !== root2 || workInProgressRootRenderLanes !== lanes) && (prepareFreshStack(root2, lanes), startWorkOnPendingInteractions(root2, lanes));
        var prevInteractions = pushInteractions(root2);
        do
          try {
            workLoopSync();
            break;
          } catch (thrownValue) {
            handleError(root2, thrownValue);
          }
        while (!0);
        if (resetContextDependencies(), popInteractions(prevInteractions), executionContext = prevExecutionContext, popDispatcher(prevDispatcher), workInProgress !== null)
          throw Error("Cannot commit an incomplete root. This error is likely caused by a bug in React. Please file an issue.");
        return workInProgressRoot = null, workInProgressRootRenderLanes = NoLanes, workInProgressRootExitStatus;
      }
      function workLoopSync() {
        for (; workInProgress !== null; )
          performUnitOfWork(workInProgress);
      }
      function renderRootConcurrent(root2, lanes) {
        var prevExecutionContext = executionContext;
        executionContext |= RenderContext;
        var prevDispatcher = pushDispatcher();
        (workInProgressRoot !== root2 || workInProgressRootRenderLanes !== lanes) && (resetRenderTimer(), prepareFreshStack(root2, lanes), startWorkOnPendingInteractions(root2, lanes));
        var prevInteractions = pushInteractions(root2);
        do
          try {
            workLoopConcurrent();
            break;
          } catch (thrownValue) {
            handleError(root2, thrownValue);
          }
        while (!0);
        return resetContextDependencies(), popInteractions(prevInteractions), popDispatcher(prevDispatcher), executionContext = prevExecutionContext, workInProgress !== null ? RootIncomplete : (workInProgressRoot = null, workInProgressRootRenderLanes = NoLanes, workInProgressRootExitStatus);
      }
      function workLoopConcurrent() {
        for (; workInProgress !== null && !shouldYield(); )
          performUnitOfWork(workInProgress);
      }
      function performUnitOfWork(unitOfWork) {
        var current2 = unitOfWork.alternate;
        setCurrentFiber(unitOfWork);
        var next;
        (unitOfWork.mode & ProfileMode) !== NoMode ? (startProfilerTimer(unitOfWork), next = beginWork$1(current2, unitOfWork, subtreeRenderLanes), stopProfilerTimerIfRunningAndRecordDelta(unitOfWork, !0)) : next = beginWork$1(current2, unitOfWork, subtreeRenderLanes), resetCurrentFiber(), unitOfWork.memoizedProps = unitOfWork.pendingProps, next === null ? completeUnitOfWork(unitOfWork) : workInProgress = next, ReactCurrentOwner$2.current = null;
      }
      function completeUnitOfWork(unitOfWork) {
        var completedWork = unitOfWork;
        do {
          var current2 = completedWork.alternate, returnFiber = completedWork.return;
          if ((completedWork.flags & Incomplete) === NoFlags) {
            setCurrentFiber(completedWork);
            var next = void 0;
            if ((completedWork.mode & ProfileMode) === NoMode ? next = completeWork(current2, completedWork, subtreeRenderLanes) : (startProfilerTimer(completedWork), next = completeWork(current2, completedWork, subtreeRenderLanes), stopProfilerTimerIfRunningAndRecordDelta(completedWork, !1)), resetCurrentFiber(), next !== null) {
              workInProgress = next;
              return;
            }
            if (resetChildLanes(completedWork), returnFiber !== null && (returnFiber.flags & Incomplete) === NoFlags) {
              returnFiber.firstEffect === null && (returnFiber.firstEffect = completedWork.firstEffect), completedWork.lastEffect !== null && (returnFiber.lastEffect !== null && (returnFiber.lastEffect.nextEffect = completedWork.firstEffect), returnFiber.lastEffect = completedWork.lastEffect);
              var flags = completedWork.flags;
              flags > PerformedWork && (returnFiber.lastEffect !== null ? returnFiber.lastEffect.nextEffect = completedWork : returnFiber.firstEffect = completedWork, returnFiber.lastEffect = completedWork);
            }
          } else {
            var _next = unwindWork(completedWork);
            if (_next !== null) {
              _next.flags &= HostEffectMask, workInProgress = _next;
              return;
            }
            if ((completedWork.mode & ProfileMode) !== NoMode) {
              stopProfilerTimerIfRunningAndRecordDelta(completedWork, !1);
              for (var actualDuration = completedWork.actualDuration, child = completedWork.child; child !== null; )
                actualDuration += child.actualDuration, child = child.sibling;
              completedWork.actualDuration = actualDuration;
            }
            returnFiber !== null && (returnFiber.firstEffect = returnFiber.lastEffect = null, returnFiber.flags |= Incomplete);
          }
          var siblingFiber = completedWork.sibling;
          if (siblingFiber !== null) {
            workInProgress = siblingFiber;
            return;
          }
          completedWork = returnFiber, workInProgress = completedWork;
        } while (completedWork !== null);
        workInProgressRootExitStatus === RootIncomplete && (workInProgressRootExitStatus = RootCompleted);
      }
      function resetChildLanes(completedWork) {
        if (!((completedWork.tag === LegacyHiddenComponent || completedWork.tag === OffscreenComponent) && completedWork.memoizedState !== null && !includesSomeLane(subtreeRenderLanes, OffscreenLane) && (completedWork.mode & ConcurrentMode) !== NoLanes)) {
          var newChildLanes = NoLanes;
          if ((completedWork.mode & ProfileMode) !== NoMode) {
            for (var actualDuration = completedWork.actualDuration, treeBaseDuration = completedWork.selfBaseDuration, shouldBubbleActualDurations = completedWork.alternate === null || completedWork.child !== completedWork.alternate.child, child = completedWork.child; child !== null; )
              newChildLanes = mergeLanes(newChildLanes, mergeLanes(child.lanes, child.childLanes)), shouldBubbleActualDurations && (actualDuration += child.actualDuration), treeBaseDuration += child.treeBaseDuration, child = child.sibling;
            var isTimedOutSuspense = completedWork.tag === SuspenseComponent && completedWork.memoizedState !== null;
            if (isTimedOutSuspense) {
              var primaryChildFragment = completedWork.child;
              primaryChildFragment !== null && (treeBaseDuration -= primaryChildFragment.treeBaseDuration);
            }
            completedWork.actualDuration = actualDuration, completedWork.treeBaseDuration = treeBaseDuration;
          } else
            for (var _child = completedWork.child; _child !== null; )
              newChildLanes = mergeLanes(newChildLanes, mergeLanes(_child.lanes, _child.childLanes)), _child = _child.sibling;
          completedWork.childLanes = newChildLanes;
        }
      }
      function commitRoot(root2) {
        var renderPriorityLevel = getCurrentPriorityLevel();
        return runWithPriority$1(ImmediatePriority$1, commitRootImpl.bind(null, root2, renderPriorityLevel)), null;
      }
      function commitRootImpl(root2, renderPriorityLevel) {
        do
          flushPassiveEffects();
        while (rootWithPendingPassiveEffects !== null);
        if (flushRenderPhaseStrictModeWarningsInDEV(), (executionContext & (RenderContext | CommitContext)) !== NoContext)
          throw Error("Should not already be working.");
        var finishedWork = root2.finishedWork, lanes = root2.finishedLanes;
        if (finishedWork === null)
          return null;
        if (root2.finishedWork = null, root2.finishedLanes = NoLanes, finishedWork === root2.current)
          throw Error("Cannot commit the same tree as before. This error is likely caused by a bug in React. Please file an issue.");
        root2.callbackNode = null;
        var remainingLanes = mergeLanes(finishedWork.lanes, finishedWork.childLanes);
        markRootFinished(root2, remainingLanes), rootsWithPendingDiscreteUpdates !== null && !hasDiscreteLanes(remainingLanes) && rootsWithPendingDiscreteUpdates.has(root2) && rootsWithPendingDiscreteUpdates.delete(root2), root2 === workInProgressRoot && (workInProgressRoot = null, workInProgress = null, workInProgressRootRenderLanes = NoLanes);
        var firstEffect;
        if (finishedWork.flags > PerformedWork ? finishedWork.lastEffect !== null ? (finishedWork.lastEffect.nextEffect = finishedWork, firstEffect = finishedWork.firstEffect) : firstEffect = finishedWork : firstEffect = finishedWork.firstEffect, firstEffect !== null) {
          var prevExecutionContext = executionContext;
          executionContext |= CommitContext;
          var prevInteractions = pushInteractions(root2);
          ReactCurrentOwner$2.current = null, focusedInstanceHandle = prepareForCommit(root2.containerInfo), shouldFireAfterActiveInstanceBlur = !1, nextEffect = firstEffect;
          do
            if (invokeGuardedCallback(null, commitBeforeMutationEffects, null), hasCaughtError()) {
              if (nextEffect === null)
                throw Error("Should be working on an effect.");
              var error2 = clearCaughtError();
              captureCommitPhaseError(nextEffect, error2), nextEffect = nextEffect.nextEffect;
            }
          while (nextEffect !== null);
          focusedInstanceHandle = null, recordCommitTime(), nextEffect = firstEffect;
          do
            if (invokeGuardedCallback(null, commitMutationEffects, null, root2, renderPriorityLevel), hasCaughtError()) {
              if (nextEffect === null)
                throw Error("Should be working on an effect.");
              var _error = clearCaughtError();
              captureCommitPhaseError(nextEffect, _error), nextEffect = nextEffect.nextEffect;
            }
          while (nextEffect !== null);
          resetAfterCommit(root2.containerInfo), root2.current = finishedWork, nextEffect = firstEffect;
          do
            if (invokeGuardedCallback(null, commitLayoutEffects, null, root2, lanes), hasCaughtError()) {
              if (nextEffect === null)
                throw Error("Should be working on an effect.");
              var _error2 = clearCaughtError();
              captureCommitPhaseError(nextEffect, _error2), nextEffect = nextEffect.nextEffect;
            }
          while (nextEffect !== null);
          nextEffect = null, requestPaint(), popInteractions(prevInteractions), executionContext = prevExecutionContext;
        } else
          root2.current = finishedWork, recordCommitTime();
        var rootDidHavePassiveEffects = rootDoesHavePassiveEffects;
        if (rootDoesHavePassiveEffects)
          rootDoesHavePassiveEffects = !1, rootWithPendingPassiveEffects = root2, pendingPassiveEffectsLanes = lanes, pendingPassiveEffectsRenderPriority = renderPriorityLevel;
        else
          for (nextEffect = firstEffect; nextEffect !== null; ) {
            var nextNextEffect = nextEffect.nextEffect;
            nextEffect.nextEffect = null, nextEffect.flags & Deletion && detachFiberAfterEffects(nextEffect), nextEffect = nextNextEffect;
          }
        if (remainingLanes = root2.pendingLanes, remainingLanes !== NoLanes) {
          if (spawnedWorkDuringRender !== null) {
            var expirationTimes = spawnedWorkDuringRender;
            spawnedWorkDuringRender = null;
            for (var i = 0; i < expirationTimes.length; i++)
              scheduleInteractions(root2, expirationTimes[i], root2.memoizedInteractions);
          }
          schedulePendingInteractions(root2, remainingLanes);
        } else
          legacyErrorBoundariesThatAlreadyFailed = null;
        if (rootDidHavePassiveEffects || finishPendingInteractions(root2, lanes), remainingLanes === SyncLane ? root2 === rootWithNestedUpdates ? nestedUpdateCount++ : (nestedUpdateCount = 0, rootWithNestedUpdates = root2) : nestedUpdateCount = 0, onCommitRoot(finishedWork.stateNode, renderPriorityLevel), onCommitRoot$1(), ensureRootIsScheduled(root2, now()), hasUncaughtError) {
          hasUncaughtError = !1;
          var _error3 = firstUncaughtError;
          throw firstUncaughtError = null, _error3;
        }
        return (executionContext & LegacyUnbatchedContext) !== NoContext || flushSyncCallbackQueue(), null;
      }
      function commitBeforeMutationEffects() {
        for (; nextEffect !== null; ) {
          var current2 = nextEffect.alternate;
          !shouldFireAfterActiveInstanceBlur && focusedInstanceHandle !== null && ((nextEffect.flags & Deletion) !== NoFlags ? doesFiberContain(nextEffect, focusedInstanceHandle) && (shouldFireAfterActiveInstanceBlur = !0) : nextEffect.tag === SuspenseComponent && isSuspenseBoundaryBeingHidden(current2, nextEffect) && doesFiberContain(nextEffect, focusedInstanceHandle) && (shouldFireAfterActiveInstanceBlur = !0));
          var flags = nextEffect.flags;
          (flags & Snapshot) !== NoFlags && (setCurrentFiber(nextEffect), commitBeforeMutationLifeCycles(current2, nextEffect), resetCurrentFiber()), (flags & Passive) !== NoFlags && (rootDoesHavePassiveEffects || (rootDoesHavePassiveEffects = !0, scheduleCallback(NormalPriority$1, function() {
            return flushPassiveEffects(), null;
          }))), nextEffect = nextEffect.nextEffect;
        }
      }
      function commitMutationEffects(root2, renderPriorityLevel) {
        for (; nextEffect !== null; ) {
          setCurrentFiber(nextEffect);
          var flags = nextEffect.flags;
          if (flags & ContentReset && commitResetTextContent(nextEffect), flags & Ref) {
            var current2 = nextEffect.alternate;
            current2 !== null && commitDetachRef(current2);
          }
          var primaryFlags = flags & (Placement | Update | Deletion | Hydrating);
          switch (primaryFlags) {
            case Placement: {
              commitPlacement(nextEffect), nextEffect.flags &= ~Placement;
              break;
            }
            case PlacementAndUpdate: {
              commitPlacement(nextEffect), nextEffect.flags &= ~Placement;
              var _current = nextEffect.alternate;
              commitWork(_current, nextEffect);
              break;
            }
            case Hydrating: {
              nextEffect.flags &= ~Hydrating;
              break;
            }
            case HydratingAndUpdate: {
              nextEffect.flags &= ~Hydrating;
              var _current2 = nextEffect.alternate;
              commitWork(_current2, nextEffect);
              break;
            }
            case Update: {
              var _current3 = nextEffect.alternate;
              commitWork(_current3, nextEffect);
              break;
            }
            case Deletion: {
              commitDeletion(root2, nextEffect);
              break;
            }
          }
          resetCurrentFiber(), nextEffect = nextEffect.nextEffect;
        }
      }
      function commitLayoutEffects(root2, committedLanes) {
        for (; nextEffect !== null; ) {
          setCurrentFiber(nextEffect);
          var flags = nextEffect.flags;
          if (flags & (Update | Callback)) {
            var current2 = nextEffect.alternate;
            commitLifeCycles(root2, current2, nextEffect);
          }
          flags & Ref && commitAttachRef(nextEffect), resetCurrentFiber(), nextEffect = nextEffect.nextEffect;
        }
      }
      function flushPassiveEffects() {
        if (pendingPassiveEffectsRenderPriority !== NoPriority$1) {
          var priorityLevel = pendingPassiveEffectsRenderPriority > NormalPriority$1 ? NormalPriority$1 : pendingPassiveEffectsRenderPriority;
          return pendingPassiveEffectsRenderPriority = NoPriority$1, runWithPriority$1(priorityLevel, flushPassiveEffectsImpl);
        }
        return !1;
      }
      function enqueuePendingPassiveHookEffectMount(fiber, effect) {
        pendingPassiveHookEffectsMount.push(effect, fiber), rootDoesHavePassiveEffects || (rootDoesHavePassiveEffects = !0, scheduleCallback(NormalPriority$1, function() {
          return flushPassiveEffects(), null;
        }));
      }
      function enqueuePendingPassiveHookEffectUnmount(fiber, effect) {
        pendingPassiveHookEffectsUnmount.push(effect, fiber);
        {
          fiber.flags |= PassiveUnmountPendingDev;
          var alternate = fiber.alternate;
          alternate !== null && (alternate.flags |= PassiveUnmountPendingDev);
        }
        rootDoesHavePassiveEffects || (rootDoesHavePassiveEffects = !0, scheduleCallback(NormalPriority$1, function() {
          return flushPassiveEffects(), null;
        }));
      }
      function invokePassiveEffectCreate(effect) {
        var create = effect.create;
        effect.destroy = create();
      }
      function flushPassiveEffectsImpl() {
        if (rootWithPendingPassiveEffects === null)
          return !1;
        var root2 = rootWithPendingPassiveEffects, lanes = pendingPassiveEffectsLanes;
        if (rootWithPendingPassiveEffects = null, pendingPassiveEffectsLanes = NoLanes, (executionContext & (RenderContext | CommitContext)) !== NoContext)
          throw Error("Cannot flush passive effects while already rendering.");
        isFlushingPassiveEffects = !0;
        var prevExecutionContext = executionContext;
        executionContext |= CommitContext;
        var prevInteractions = pushInteractions(root2), unmountEffects = pendingPassiveHookEffectsUnmount;
        pendingPassiveHookEffectsUnmount = [];
        for (var i = 0; i < unmountEffects.length; i += 2) {
          var _effect = unmountEffects[i], fiber = unmountEffects[i + 1], destroy = _effect.destroy;
          _effect.destroy = void 0;
          {
            fiber.flags &= ~PassiveUnmountPendingDev;
            var alternate = fiber.alternate;
            alternate !== null && (alternate.flags &= ~PassiveUnmountPendingDev);
          }
          if (typeof destroy == "function") {
            if (setCurrentFiber(fiber), invokeGuardedCallback(null, destroy, null), hasCaughtError()) {
              if (fiber === null)
                throw Error("Should be working on an effect.");
              var error2 = clearCaughtError();
              captureCommitPhaseError(fiber, error2);
            }
            resetCurrentFiber();
          }
        }
        var mountEffects = pendingPassiveHookEffectsMount;
        pendingPassiveHookEffectsMount = [];
        for (var _i = 0; _i < mountEffects.length; _i += 2) {
          var _effect2 = mountEffects[_i], _fiber = mountEffects[_i + 1];
          {
            if (setCurrentFiber(_fiber), invokeGuardedCallback(null, invokePassiveEffectCreate, null, _effect2), hasCaughtError()) {
              if (_fiber === null)
                throw Error("Should be working on an effect.");
              var _error4 = clearCaughtError();
              captureCommitPhaseError(_fiber, _error4);
            }
            resetCurrentFiber();
          }
        }
        for (var effect = root2.current.firstEffect; effect !== null; ) {
          var nextNextEffect = effect.nextEffect;
          effect.nextEffect = null, effect.flags & Deletion && detachFiberAfterEffects(effect), effect = nextNextEffect;
        }
        return popInteractions(prevInteractions), finishPendingInteractions(root2, lanes), isFlushingPassiveEffects = !1, executionContext = prevExecutionContext, flushSyncCallbackQueue(), nestedPassiveUpdateCount = rootWithPendingPassiveEffects === null ? 0 : nestedPassiveUpdateCount + 1, !0;
      }
      function isAlreadyFailedLegacyErrorBoundary(instance) {
        return legacyErrorBoundariesThatAlreadyFailed !== null && legacyErrorBoundariesThatAlreadyFailed.has(instance);
      }
      function markLegacyErrorBoundaryAsFailed(instance) {
        legacyErrorBoundariesThatAlreadyFailed === null ? legacyErrorBoundariesThatAlreadyFailed = /* @__PURE__ */ new Set([instance]) : legacyErrorBoundariesThatAlreadyFailed.add(instance);
      }
      function prepareToThrowUncaughtError(error2) {
        hasUncaughtError || (hasUncaughtError = !0, firstUncaughtError = error2);
      }
      var onUncaughtError = prepareToThrowUncaughtError;
      function captureCommitPhaseErrorOnRoot(rootFiber, sourceFiber, error2) {
        var errorInfo = createCapturedValue(error2, sourceFiber), update = createRootErrorUpdate(rootFiber, errorInfo, SyncLane);
        enqueueUpdate(rootFiber, update);
        var eventTime = requestEventTime(), root2 = markUpdateLaneFromFiberToRoot(rootFiber, SyncLane);
        root2 !== null && (markRootUpdated(root2, SyncLane, eventTime), ensureRootIsScheduled(root2, eventTime), schedulePendingInteractions(root2, SyncLane));
      }
      function captureCommitPhaseError(sourceFiber, error2) {
        if (sourceFiber.tag === HostRoot) {
          captureCommitPhaseErrorOnRoot(sourceFiber, sourceFiber, error2);
          return;
        }
        for (var fiber = sourceFiber.return; fiber !== null; ) {
          if (fiber.tag === HostRoot) {
            captureCommitPhaseErrorOnRoot(fiber, sourceFiber, error2);
            return;
          } else if (fiber.tag === ClassComponent) {
            var ctor = fiber.type, instance = fiber.stateNode;
            if (typeof ctor.getDerivedStateFromError == "function" || typeof instance.componentDidCatch == "function" && !isAlreadyFailedLegacyErrorBoundary(instance)) {
              var errorInfo = createCapturedValue(error2, sourceFiber), update = createClassErrorUpdate(fiber, errorInfo, SyncLane);
              enqueueUpdate(fiber, update);
              var eventTime = requestEventTime(), root2 = markUpdateLaneFromFiberToRoot(fiber, SyncLane);
              if (root2 !== null)
                markRootUpdated(root2, SyncLane, eventTime), ensureRootIsScheduled(root2, eventTime), schedulePendingInteractions(root2, SyncLane);
              else if (typeof instance.componentDidCatch == "function" && !isAlreadyFailedLegacyErrorBoundary(instance))
                try {
                  instance.componentDidCatch(error2, errorInfo);
                } catch {
                }
              return;
            }
          }
          fiber = fiber.return;
        }
      }
      function pingSuspendedRoot(root2, wakeable, pingedLanes) {
        var pingCache = root2.pingCache;
        pingCache !== null && pingCache.delete(wakeable);
        var eventTime = requestEventTime();
        markRootPinged(root2, pingedLanes), workInProgressRoot === root2 && isSubsetOfLanes(workInProgressRootRenderLanes, pingedLanes) && (workInProgressRootExitStatus === RootSuspendedWithDelay || workInProgressRootExitStatus === RootSuspended && includesOnlyRetries(workInProgressRootRenderLanes) && now() - globalMostRecentFallbackTime < FALLBACK_THROTTLE_MS ? prepareFreshStack(root2, NoLanes) : workInProgressRootPingedLanes = mergeLanes(workInProgressRootPingedLanes, pingedLanes)), ensureRootIsScheduled(root2, eventTime), schedulePendingInteractions(root2, pingedLanes);
      }
      function retryTimedOutBoundary(boundaryFiber, retryLane) {
        retryLane === NoLane && (retryLane = requestRetryLane(boundaryFiber));
        var eventTime = requestEventTime(), root2 = markUpdateLaneFromFiberToRoot(boundaryFiber, retryLane);
        root2 !== null && (markRootUpdated(root2, retryLane, eventTime), ensureRootIsScheduled(root2, eventTime), schedulePendingInteractions(root2, retryLane));
      }
      function resolveRetryWakeable(boundaryFiber, wakeable) {
        var retryLane = NoLane, retryCache;
        retryCache = boundaryFiber.stateNode, retryCache !== null && retryCache.delete(wakeable), retryTimedOutBoundary(boundaryFiber, retryLane);
      }
      function jnd(timeElapsed) {
        return timeElapsed < 120 ? 120 : timeElapsed < 480 ? 480 : timeElapsed < 1080 ? 1080 : timeElapsed < 1920 ? 1920 : timeElapsed < 3e3 ? 3e3 : timeElapsed < 4320 ? 4320 : ceil(timeElapsed / 1960) * 1960;
      }
      function checkForNestedUpdates() {
        if (nestedUpdateCount > NESTED_UPDATE_LIMIT)
          throw nestedUpdateCount = 0, rootWithNestedUpdates = null, Error("Maximum update depth exceeded. This can happen when a component repeatedly calls setState inside componentWillUpdate or componentDidUpdate. React limits the number of nested updates to prevent infinite loops.");
        nestedPassiveUpdateCount > NESTED_PASSIVE_UPDATE_LIMIT && (nestedPassiveUpdateCount = 0, error("Maximum update depth exceeded. This can happen when a component calls setState inside useEffect, but useEffect either doesn't have a dependency array, or one of the dependencies changes on every render."));
      }
      function flushRenderPhaseStrictModeWarningsInDEV() {
        ReactStrictModeWarnings.flushLegacyContextWarning(), ReactStrictModeWarnings.flushPendingUnsafeLifecycleWarnings();
      }
      var didWarnStateUpdateForNotYetMountedComponent = null;
      function warnAboutUpdateOnNotYetMountedFiberInDEV(fiber) {
        {
          if ((executionContext & RenderContext) !== NoContext || !(fiber.mode & (BlockingMode | ConcurrentMode)))
            return;
          var tag = fiber.tag;
          if (tag !== IndeterminateComponent && tag !== HostRoot && tag !== ClassComponent && tag !== FunctionComponent && tag !== ForwardRef2 && tag !== MemoComponent && tag !== SimpleMemoComponent && tag !== Block)
            return;
          var componentName = getComponentName(fiber.type) || "ReactComponent";
          if (didWarnStateUpdateForNotYetMountedComponent !== null) {
            if (didWarnStateUpdateForNotYetMountedComponent.has(componentName))
              return;
            didWarnStateUpdateForNotYetMountedComponent.add(componentName);
          } else
            didWarnStateUpdateForNotYetMountedComponent = /* @__PURE__ */ new Set([componentName]);
          var previousFiber = current;
          try {
            setCurrentFiber(fiber), error("Can't perform a React state update on a component that hasn't mounted yet. This indicates that you have a side-effect in your render function that asynchronously later calls tries to update the component. Move this work to useEffect instead.");
          } finally {
            previousFiber ? setCurrentFiber(fiber) : resetCurrentFiber();
          }
        }
      }
      var didWarnStateUpdateForUnmountedComponent = null;
      function warnAboutUpdateOnUnmountedFiberInDEV(fiber) {
        {
          var tag = fiber.tag;
          if (tag !== HostRoot && tag !== ClassComponent && tag !== FunctionComponent && tag !== ForwardRef2 && tag !== MemoComponent && tag !== SimpleMemoComponent && tag !== Block || (fiber.flags & PassiveUnmountPendingDev) !== NoFlags)
            return;
          var componentName = getComponentName(fiber.type) || "ReactComponent";
          if (didWarnStateUpdateForUnmountedComponent !== null) {
            if (didWarnStateUpdateForUnmountedComponent.has(componentName))
              return;
            didWarnStateUpdateForUnmountedComponent.add(componentName);
          } else
            didWarnStateUpdateForUnmountedComponent = /* @__PURE__ */ new Set([componentName]);
          if (!isFlushingPassiveEffects) {
            var previousFiber = current;
            try {
              setCurrentFiber(fiber), error("Can't perform a React state update on an unmounted component. This is a no-op, but it indicates a memory leak in your application. To fix, cancel all subscriptions and asynchronous tasks in %s.", tag === ClassComponent ? "the componentWillUnmount method" : "a useEffect cleanup function");
            } finally {
              previousFiber ? setCurrentFiber(fiber) : resetCurrentFiber();
            }
          }
        }
      }
      var beginWork$1;
      {
        var dummyFiber = null;
        beginWork$1 = function(current2, unitOfWork, lanes) {
          var originalWorkInProgressCopy = assignFiberPropertiesInDEV(dummyFiber, unitOfWork);
          try {
            return beginWork(current2, unitOfWork, lanes);
          } catch (originalError) {
            if (originalError !== null && typeof originalError == "object" && typeof originalError.then == "function")
              throw originalError;
            if (resetContextDependencies(), resetHooksAfterThrow(), unwindInterruptedWork(unitOfWork), assignFiberPropertiesInDEV(unitOfWork, originalWorkInProgressCopy), unitOfWork.mode & ProfileMode && startProfilerTimer(unitOfWork), invokeGuardedCallback(null, beginWork, null, current2, unitOfWork, lanes), hasCaughtError()) {
              var replayError = clearCaughtError();
              throw replayError;
            } else
              throw originalError;
          }
        };
      }
      var didWarnAboutUpdateInRender = !1, didWarnAboutUpdateInRenderForAnotherComponent;
      didWarnAboutUpdateInRenderForAnotherComponent = /* @__PURE__ */ new Set();
      function warnAboutRenderPhaseUpdatesInDEV(fiber) {
        if (isRendering && (executionContext & RenderContext) !== NoContext && !getIsUpdatingOpaqueValueInRenderPhaseInDEV())
          switch (fiber.tag) {
            case FunctionComponent:
            case ForwardRef2:
            case SimpleMemoComponent: {
              var renderingComponentName = workInProgress && getComponentName(workInProgress.type) || "Unknown", dedupeKey = renderingComponentName;
              if (!didWarnAboutUpdateInRenderForAnotherComponent.has(dedupeKey)) {
                didWarnAboutUpdateInRenderForAnotherComponent.add(dedupeKey);
                var setStateComponentName = getComponentName(fiber.type) || "Unknown";
                error("Cannot update a component (`%s`) while rendering a different component (`%s`). To locate the bad setState() call inside `%s`, follow the stack trace as described in https://reactjs.org/link/setstate-in-render", setStateComponentName, renderingComponentName, renderingComponentName);
              }
              break;
            }
            case ClassComponent: {
              didWarnAboutUpdateInRender || (error("Cannot update during an existing state transition (such as within `render`). Render methods should be a pure function of props and state."), didWarnAboutUpdateInRender = !0);
              break;
            }
          }
      }
      var IsThisRendererActing = {
        current: !1
      };
      function warnIfNotScopedWithMatchingAct(fiber) {
        if (IsSomeRendererActing.current === !0 && IsThisRendererActing.current !== !0) {
          var previousFiber = current;
          try {
            setCurrentFiber(fiber), error(`It looks like you're using the wrong act() around your test interactions.
Be sure to use the matching version of act() corresponding to your renderer:

// for react-dom:
import {act} from 'react-dom/test-utils';
// ...
act(() => ...);

// for react-test-renderer:
import TestRenderer from react-test-renderer';
const {act} = TestRenderer;
// ...
act(() => ...);`);
          } finally {
            previousFiber ? setCurrentFiber(fiber) : resetCurrentFiber();
          }
        }
      }
      function warnIfNotCurrentlyActingEffectsInDEV(fiber) {
        (fiber.mode & StrictMode) !== NoMode && IsSomeRendererActing.current === !1 && IsThisRendererActing.current === !1 && error(`An update to %s ran an effect, but was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() => {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you're testing the behavior the user would see in the browser. Learn more at https://reactjs.org/link/wrap-tests-with-act`, getComponentName(fiber.type));
      }
      function warnIfNotCurrentlyActingUpdatesInDEV(fiber) {
        if (executionContext === NoContext && IsSomeRendererActing.current === !1 && IsThisRendererActing.current === !1) {
          var previousFiber = current;
          try {
            setCurrentFiber(fiber), error(`An update to %s inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() => {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you're testing the behavior the user would see in the browser. Learn more at https://reactjs.org/link/wrap-tests-with-act`, getComponentName(fiber.type));
          } finally {
            previousFiber ? setCurrentFiber(fiber) : resetCurrentFiber();
          }
        }
      }
      var warnIfNotCurrentlyActingUpdatesInDev = warnIfNotCurrentlyActingUpdatesInDEV, didWarnAboutUnmockedScheduler = !1;
      function warnIfUnmockedScheduler(fiber) {
        didWarnAboutUnmockedScheduler === !1 && Scheduler.unstable_flushAllWithoutAsserting === void 0 && (fiber.mode & BlockingMode || fiber.mode & ConcurrentMode) && (didWarnAboutUnmockedScheduler = !0, error(`In Concurrent or Sync modes, the "scheduler" module needs to be mocked to guarantee consistent behaviour across tests and browsers. For example, with jest: 
jest.mock('scheduler', () => require('scheduler/unstable_mock'));

For more info, visit https://reactjs.org/link/mock-scheduler`));
      }
      function computeThreadID(root2, lane) {
        return lane * 1e3 + root2.interactionThreadID;
      }
      function markSpawnedWork(lane) {
        spawnedWorkDuringRender === null ? spawnedWorkDuringRender = [lane] : spawnedWorkDuringRender.push(lane);
      }
      function scheduleInteractions(root2, lane, interactions) {
        if (interactions.size > 0) {
          var pendingInteractionMap = root2.pendingInteractionMap, pendingInteractions = pendingInteractionMap.get(lane);
          pendingInteractions != null ? interactions.forEach(function(interaction) {
            pendingInteractions.has(interaction) || interaction.__count++, pendingInteractions.add(interaction);
          }) : (pendingInteractionMap.set(lane, new Set(interactions)), interactions.forEach(function(interaction) {
            interaction.__count++;
          }));
          var subscriber = tracing.__subscriberRef.current;
          if (subscriber !== null) {
            var threadID = computeThreadID(root2, lane);
            subscriber.onWorkScheduled(interactions, threadID);
          }
        }
      }
      function schedulePendingInteractions(root2, lane) {
        scheduleInteractions(root2, lane, tracing.__interactionsRef.current);
      }
      function startWorkOnPendingInteractions(root2, lanes) {
        var interactions = /* @__PURE__ */ new Set();
        if (root2.pendingInteractionMap.forEach(function(scheduledInteractions, scheduledLane) {
          includesSomeLane(lanes, scheduledLane) && scheduledInteractions.forEach(function(interaction) {
            return interactions.add(interaction);
          });
        }), root2.memoizedInteractions = interactions, interactions.size > 0) {
          var subscriber = tracing.__subscriberRef.current;
          if (subscriber !== null) {
            var threadID = computeThreadID(root2, lanes);
            try {
              subscriber.onWorkStarted(interactions, threadID);
            } catch (error2) {
              scheduleCallback(ImmediatePriority$1, function() {
                throw error2;
              });
            }
          }
        }
      }
      function finishPendingInteractions(root2, committedLanes) {
        var remainingLanesAfterCommit = root2.pendingLanes, subscriber;
        try {
          if (subscriber = tracing.__subscriberRef.current, subscriber !== null && root2.memoizedInteractions.size > 0) {
            var threadID = computeThreadID(root2, committedLanes);
            subscriber.onWorkStopped(root2.memoizedInteractions, threadID);
          }
        } catch (error2) {
          scheduleCallback(ImmediatePriority$1, function() {
            throw error2;
          });
        } finally {
          var pendingInteractionMap = root2.pendingInteractionMap;
          pendingInteractionMap.forEach(function(scheduledInteractions, lane) {
            includesSomeLane(remainingLanesAfterCommit, lane) || (pendingInteractionMap.delete(lane), scheduledInteractions.forEach(function(interaction) {
              if (interaction.__count--, subscriber !== null && interaction.__count === 0)
                try {
                  subscriber.onInteractionScheduledWorkCompleted(interaction);
                } catch (error2) {
                  scheduleCallback(ImmediatePriority$1, function() {
                    throw error2;
                  });
                }
            }));
          });
        }
      }
      function shouldForceFlushFallbacksInDEV() {
        return actingUpdatesScopeDepth > 0;
      }
      var actingUpdatesScopeDepth = 0;
      function detachFiberAfterEffects(fiber) {
        fiber.sibling = null, fiber.stateNode = null;
      }
      var resolveFamily = null, failedBoundaries = null, setRefreshHandler = function(handler) {
        resolveFamily = handler;
      };
      function resolveFunctionForHotReloading(type) {
        {
          if (resolveFamily === null)
            return type;
          var family = resolveFamily(type);
          return family === void 0 ? type : family.current;
        }
      }
      function resolveClassForHotReloading(type) {
        return resolveFunctionForHotReloading(type);
      }
      function resolveForwardRefForHotReloading(type) {
        {
          if (resolveFamily === null)
            return type;
          var family = resolveFamily(type);
          if (family === void 0) {
            if (type != null && typeof type.render == "function") {
              var currentRender = resolveFunctionForHotReloading(type.render);
              if (type.render !== currentRender) {
                var syntheticType = {
                  $$typeof: REACT_FORWARD_REF_TYPE,
                  render: currentRender
                };
                return type.displayName !== void 0 && (syntheticType.displayName = type.displayName), syntheticType;
              }
            }
            return type;
          }
          return family.current;
        }
      }
      function isCompatibleFamilyForHotReloading(fiber, element) {
        {
          if (resolveFamily === null)
            return !1;
          var prevType = fiber.elementType, nextType = element.type, needsCompareFamilies = !1, $$typeofNextType = typeof nextType == "object" && nextType !== null ? nextType.$$typeof : null;
          switch (fiber.tag) {
            case ClassComponent: {
              typeof nextType == "function" && (needsCompareFamilies = !0);
              break;
            }
            case FunctionComponent: {
              (typeof nextType == "function" || $$typeofNextType === REACT_LAZY_TYPE) && (needsCompareFamilies = !0);
              break;
            }
            case ForwardRef2: {
              ($$typeofNextType === REACT_FORWARD_REF_TYPE || $$typeofNextType === REACT_LAZY_TYPE) && (needsCompareFamilies = !0);
              break;
            }
            case MemoComponent:
            case SimpleMemoComponent: {
              ($$typeofNextType === REACT_MEMO_TYPE || $$typeofNextType === REACT_LAZY_TYPE) && (needsCompareFamilies = !0);
              break;
            }
            default:
              return !1;
          }
          if (needsCompareFamilies) {
            var prevFamily = resolveFamily(prevType);
            if (prevFamily !== void 0 && prevFamily === resolveFamily(nextType))
              return !0;
          }
          return !1;
        }
      }
      function markFailedErrorBoundaryForHotReloading(fiber) {
        {
          if (resolveFamily === null || typeof WeakSet != "function")
            return;
          failedBoundaries === null && (failedBoundaries = /* @__PURE__ */ new WeakSet()), failedBoundaries.add(fiber);
        }
      }
      var scheduleRefresh = function(root2, update) {
        {
          if (resolveFamily === null)
            return;
          var staleFamilies = update.staleFamilies, updatedFamilies = update.updatedFamilies;
          flushPassiveEffects(), flushSync2(function() {
            scheduleFibersWithFamiliesRecursively(root2.current, updatedFamilies, staleFamilies);
          });
        }
      }, scheduleRoot = function(root2, element) {
        {
          if (root2.context !== emptyContextObject)
            return;
          flushPassiveEffects(), flushSync2(function() {
            updateContainer(element, root2, null, null);
          });
        }
      };
      function scheduleFibersWithFamiliesRecursively(fiber, updatedFamilies, staleFamilies) {
        {
          var alternate = fiber.alternate, child = fiber.child, sibling = fiber.sibling, tag = fiber.tag, type = fiber.type, candidateType = null;
          switch (tag) {
            case FunctionComponent:
            case SimpleMemoComponent:
            case ClassComponent:
              candidateType = type;
              break;
            case ForwardRef2:
              candidateType = type.render;
              break;
          }
          if (resolveFamily === null)
            throw new Error("Expected resolveFamily to be set during hot reload.");
          var needsRender = !1, needsRemount = !1;
          if (candidateType !== null) {
            var family = resolveFamily(candidateType);
            family !== void 0 && (staleFamilies.has(family) ? needsRemount = !0 : updatedFamilies.has(family) && (tag === ClassComponent ? needsRemount = !0 : needsRender = !0));
          }
          failedBoundaries !== null && (failedBoundaries.has(fiber) || alternate !== null && failedBoundaries.has(alternate)) && (needsRemount = !0), needsRemount && (fiber._debugNeedsRemount = !0), (needsRemount || needsRender) && scheduleUpdateOnFiber(fiber, SyncLane, NoTimestamp), child !== null && !needsRemount && scheduleFibersWithFamiliesRecursively(child, updatedFamilies, staleFamilies), sibling !== null && scheduleFibersWithFamiliesRecursively(sibling, updatedFamilies, staleFamilies);
        }
      }
      var findHostInstancesForRefresh = function(root2, families) {
        {
          var hostInstances = /* @__PURE__ */ new Set(), types = new Set(families.map(function(family) {
            return family.current;
          }));
          return findHostInstancesForMatchingFibersRecursively(root2.current, types, hostInstances), hostInstances;
        }
      };
      function findHostInstancesForMatchingFibersRecursively(fiber, types, hostInstances) {
        {
          var child = fiber.child, sibling = fiber.sibling, tag = fiber.tag, type = fiber.type, candidateType = null;
          switch (tag) {
            case FunctionComponent:
            case SimpleMemoComponent:
            case ClassComponent:
              candidateType = type;
              break;
            case ForwardRef2:
              candidateType = type.render;
              break;
          }
          var didMatch = !1;
          candidateType !== null && types.has(candidateType) && (didMatch = !0), didMatch ? findHostInstancesForFiberShallowly(fiber, hostInstances) : child !== null && findHostInstancesForMatchingFibersRecursively(child, types, hostInstances), sibling !== null && findHostInstancesForMatchingFibersRecursively(sibling, types, hostInstances);
        }
      }
      function findHostInstancesForFiberShallowly(fiber, hostInstances) {
        {
          var foundHostInstances = findChildHostInstancesForFiberShallowly(fiber, hostInstances);
          if (foundHostInstances)
            return;
          for (var node = fiber; ; ) {
            switch (node.tag) {
              case HostComponent:
                hostInstances.add(node.stateNode);
                return;
              case HostPortal:
                hostInstances.add(node.stateNode.containerInfo);
                return;
              case HostRoot:
                hostInstances.add(node.stateNode.containerInfo);
                return;
            }
            if (node.return === null)
              throw new Error("Expected to reach root first.");
            node = node.return;
          }
        }
      }
      function findChildHostInstancesForFiberShallowly(fiber, hostInstances) {
        for (var node = fiber, foundHostInstances = !1; ; ) {
          if (node.tag === HostComponent)
            foundHostInstances = !0, hostInstances.add(node.stateNode);
          else if (node.child !== null) {
            node.child.return = node, node = node.child;
            continue;
          }
          if (node === fiber)
            return foundHostInstances;
          for (; node.sibling === null; ) {
            if (node.return === null || node.return === fiber)
              return foundHostInstances;
            node = node.return;
          }
          node.sibling.return = node.return, node = node.sibling;
        }
        return !1;
      }
      var hasBadMapPolyfill;
      {
        hasBadMapPolyfill = !1;
        try {
          var nonExtensibleObject = Object.preventExtensions({});
        } catch {
          hasBadMapPolyfill = !0;
        }
      }
      var debugCounter = 1;
      function FiberNode(tag, pendingProps, key, mode) {
        this.tag = tag, this.key = key, this.elementType = null, this.type = null, this.stateNode = null, this.return = null, this.child = null, this.sibling = null, this.index = 0, this.ref = null, this.pendingProps = pendingProps, this.memoizedProps = null, this.updateQueue = null, this.memoizedState = null, this.dependencies = null, this.mode = mode, this.flags = NoFlags, this.nextEffect = null, this.firstEffect = null, this.lastEffect = null, this.lanes = NoLanes, this.childLanes = NoLanes, this.alternate = null, this.actualDuration = Number.NaN, this.actualStartTime = Number.NaN, this.selfBaseDuration = Number.NaN, this.treeBaseDuration = Number.NaN, this.actualDuration = 0, this.actualStartTime = -1, this.selfBaseDuration = 0, this.treeBaseDuration = 0, this._debugID = debugCounter++, this._debugSource = null, this._debugOwner = null, this._debugNeedsRemount = !1, this._debugHookTypes = null, !hasBadMapPolyfill && typeof Object.preventExtensions == "function" && Object.preventExtensions(this);
      }
      var createFiber = function(tag, pendingProps, key, mode) {
        return new FiberNode(tag, pendingProps, key, mode);
      };
      function shouldConstruct$1(Component) {
        var prototype = Component.prototype;
        return !!(prototype && prototype.isReactComponent);
      }
      function isSimpleFunctionComponent(type) {
        return typeof type == "function" && !shouldConstruct$1(type) && type.defaultProps === void 0;
      }
      function resolveLazyComponentTag(Component) {
        if (typeof Component == "function")
          return shouldConstruct$1(Component) ? ClassComponent : FunctionComponent;
        if (Component != null) {
          var $$typeof = Component.$$typeof;
          if ($$typeof === REACT_FORWARD_REF_TYPE)
            return ForwardRef2;
          if ($$typeof === REACT_MEMO_TYPE)
            return MemoComponent;
        }
        return IndeterminateComponent;
      }
      function createWorkInProgress(current2, pendingProps) {
        var workInProgress2 = current2.alternate;
        workInProgress2 === null ? (workInProgress2 = createFiber(current2.tag, pendingProps, current2.key, current2.mode), workInProgress2.elementType = current2.elementType, workInProgress2.type = current2.type, workInProgress2.stateNode = current2.stateNode, workInProgress2._debugID = current2._debugID, workInProgress2._debugSource = current2._debugSource, workInProgress2._debugOwner = current2._debugOwner, workInProgress2._debugHookTypes = current2._debugHookTypes, workInProgress2.alternate = current2, current2.alternate = workInProgress2) : (workInProgress2.pendingProps = pendingProps, workInProgress2.type = current2.type, workInProgress2.flags = NoFlags, workInProgress2.nextEffect = null, workInProgress2.firstEffect = null, workInProgress2.lastEffect = null, workInProgress2.actualDuration = 0, workInProgress2.actualStartTime = -1), workInProgress2.childLanes = current2.childLanes, workInProgress2.lanes = current2.lanes, workInProgress2.child = current2.child, workInProgress2.memoizedProps = current2.memoizedProps, workInProgress2.memoizedState = current2.memoizedState, workInProgress2.updateQueue = current2.updateQueue;
        var currentDependencies = current2.dependencies;
        switch (workInProgress2.dependencies = currentDependencies === null ? null : {
          lanes: currentDependencies.lanes,
          firstContext: currentDependencies.firstContext
        }, workInProgress2.sibling = current2.sibling, workInProgress2.index = current2.index, workInProgress2.ref = current2.ref, workInProgress2.selfBaseDuration = current2.selfBaseDuration, workInProgress2.treeBaseDuration = current2.treeBaseDuration, workInProgress2._debugNeedsRemount = current2._debugNeedsRemount, workInProgress2.tag) {
          case IndeterminateComponent:
          case FunctionComponent:
          case SimpleMemoComponent:
            workInProgress2.type = resolveFunctionForHotReloading(current2.type);
            break;
          case ClassComponent:
            workInProgress2.type = resolveClassForHotReloading(current2.type);
            break;
          case ForwardRef2:
            workInProgress2.type = resolveForwardRefForHotReloading(current2.type);
            break;
        }
        return workInProgress2;
      }
      function resetWorkInProgress(workInProgress2, renderLanes2) {
        workInProgress2.flags &= Placement, workInProgress2.nextEffect = null, workInProgress2.firstEffect = null, workInProgress2.lastEffect = null;
        var current2 = workInProgress2.alternate;
        if (current2 === null)
          workInProgress2.childLanes = NoLanes, workInProgress2.lanes = renderLanes2, workInProgress2.child = null, workInProgress2.memoizedProps = null, workInProgress2.memoizedState = null, workInProgress2.updateQueue = null, workInProgress2.dependencies = null, workInProgress2.stateNode = null, workInProgress2.selfBaseDuration = 0, workInProgress2.treeBaseDuration = 0;
        else {
          workInProgress2.childLanes = current2.childLanes, workInProgress2.lanes = current2.lanes, workInProgress2.child = current2.child, workInProgress2.memoizedProps = current2.memoizedProps, workInProgress2.memoizedState = current2.memoizedState, workInProgress2.updateQueue = current2.updateQueue, workInProgress2.type = current2.type;
          var currentDependencies = current2.dependencies;
          workInProgress2.dependencies = currentDependencies === null ? null : {
            lanes: currentDependencies.lanes,
            firstContext: currentDependencies.firstContext
          }, workInProgress2.selfBaseDuration = current2.selfBaseDuration, workInProgress2.treeBaseDuration = current2.treeBaseDuration;
        }
        return workInProgress2;
      }
      function createHostRootFiber(tag) {
        var mode;
        return tag === ConcurrentRoot ? mode = ConcurrentMode | BlockingMode | StrictMode : tag === BlockingRoot ? mode = BlockingMode | StrictMode : mode = NoMode, isDevToolsPresent && (mode |= ProfileMode), createFiber(HostRoot, null, null, mode);
      }
      function createFiberFromTypeAndProps(type, key, pendingProps, owner, mode, lanes) {
        var fiberTag = IndeterminateComponent, resolvedType = type;
        if (typeof type == "function")
          shouldConstruct$1(type) ? (fiberTag = ClassComponent, resolvedType = resolveClassForHotReloading(resolvedType)) : resolvedType = resolveFunctionForHotReloading(resolvedType);
        else if (typeof type == "string")
          fiberTag = HostComponent;
        else {
          getTag:
            switch (type) {
              case REACT_FRAGMENT_TYPE:
                return createFiberFromFragment(pendingProps.children, mode, lanes, key);
              case REACT_DEBUG_TRACING_MODE_TYPE:
                fiberTag = Mode, mode |= DebugTracingMode;
                break;
              case REACT_STRICT_MODE_TYPE:
                fiberTag = Mode, mode |= StrictMode;
                break;
              case REACT_PROFILER_TYPE:
                return createFiberFromProfiler(pendingProps, mode, lanes, key);
              case REACT_SUSPENSE_TYPE:
                return createFiberFromSuspense(pendingProps, mode, lanes, key);
              case REACT_SUSPENSE_LIST_TYPE:
                return createFiberFromSuspenseList(pendingProps, mode, lanes, key);
              case REACT_OFFSCREEN_TYPE:
                return createFiberFromOffscreen(pendingProps, mode, lanes, key);
              case REACT_LEGACY_HIDDEN_TYPE:
                return createFiberFromLegacyHidden(pendingProps, mode, lanes, key);
              case REACT_SCOPE_TYPE:
              default: {
                if (typeof type == "object" && type !== null)
                  switch (type.$$typeof) {
                    case REACT_PROVIDER_TYPE:
                      fiberTag = ContextProvider;
                      break getTag;
                    case REACT_CONTEXT_TYPE:
                      fiberTag = ContextConsumer;
                      break getTag;
                    case REACT_FORWARD_REF_TYPE:
                      fiberTag = ForwardRef2, resolvedType = resolveForwardRefForHotReloading(resolvedType);
                      break getTag;
                    case REACT_MEMO_TYPE:
                      fiberTag = MemoComponent;
                      break getTag;
                    case REACT_LAZY_TYPE:
                      fiberTag = LazyComponent, resolvedType = null;
                      break getTag;
                    case REACT_BLOCK_TYPE:
                      fiberTag = Block;
                      break getTag;
                  }
                var info = "";
                {
                  (type === void 0 || typeof type == "object" && type !== null && Object.keys(type).length === 0) && (info += " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.");
                  var ownerName = owner ? getComponentName(owner.type) : null;
                  ownerName && (info += `

Check the render method of \`` + ownerName + "`.");
                }
                throw Error("Element type is invalid: expected a string (for built-in components) or a class/function (for composite components) but got: " + (type == null ? type : typeof type) + "." + info);
              }
            }
        }
        var fiber = createFiber(fiberTag, pendingProps, key, mode);
        return fiber.elementType = type, fiber.type = resolvedType, fiber.lanes = lanes, fiber._debugOwner = owner, fiber;
      }
      function createFiberFromElement(element, mode, lanes) {
        var owner = null;
        owner = element._owner;
        var type = element.type, key = element.key, pendingProps = element.props, fiber = createFiberFromTypeAndProps(type, key, pendingProps, owner, mode, lanes);
        return fiber._debugSource = element._source, fiber._debugOwner = element._owner, fiber;
      }
      function createFiberFromFragment(elements, mode, lanes, key) {
        var fiber = createFiber(Fragment11, elements, key, mode);
        return fiber.lanes = lanes, fiber;
      }
      function createFiberFromProfiler(pendingProps, mode, lanes, key) {
        typeof pendingProps.id != "string" && error('Profiler must specify an "id" as a prop');
        var fiber = createFiber(Profiler, pendingProps, key, mode | ProfileMode);
        return fiber.elementType = REACT_PROFILER_TYPE, fiber.type = REACT_PROFILER_TYPE, fiber.lanes = lanes, fiber.stateNode = {
          effectDuration: 0,
          passiveEffectDuration: 0
        }, fiber;
      }
      function createFiberFromSuspense(pendingProps, mode, lanes, key) {
        var fiber = createFiber(SuspenseComponent, pendingProps, key, mode);
        return fiber.type = REACT_SUSPENSE_TYPE, fiber.elementType = REACT_SUSPENSE_TYPE, fiber.lanes = lanes, fiber;
      }
      function createFiberFromSuspenseList(pendingProps, mode, lanes, key) {
        var fiber = createFiber(SuspenseListComponent, pendingProps, key, mode);
        return fiber.type = REACT_SUSPENSE_LIST_TYPE, fiber.elementType = REACT_SUSPENSE_LIST_TYPE, fiber.lanes = lanes, fiber;
      }
      function createFiberFromOffscreen(pendingProps, mode, lanes, key) {
        var fiber = createFiber(OffscreenComponent, pendingProps, key, mode);
        return fiber.type = REACT_OFFSCREEN_TYPE, fiber.elementType = REACT_OFFSCREEN_TYPE, fiber.lanes = lanes, fiber;
      }
      function createFiberFromLegacyHidden(pendingProps, mode, lanes, key) {
        var fiber = createFiber(LegacyHiddenComponent, pendingProps, key, mode);
        return fiber.type = REACT_LEGACY_HIDDEN_TYPE, fiber.elementType = REACT_LEGACY_HIDDEN_TYPE, fiber.lanes = lanes, fiber;
      }
      function createFiberFromText(content, mode, lanes) {
        var fiber = createFiber(HostText, content, null, mode);
        return fiber.lanes = lanes, fiber;
      }
      function createFiberFromHostInstanceForDeletion() {
        var fiber = createFiber(HostComponent, null, null, NoMode);
        return fiber.elementType = "DELETED", fiber.type = "DELETED", fiber;
      }
      function createFiberFromPortal(portal, mode, lanes) {
        var pendingProps = portal.children !== null ? portal.children : [], fiber = createFiber(HostPortal, pendingProps, portal.key, mode);
        return fiber.lanes = lanes, fiber.stateNode = {
          containerInfo: portal.containerInfo,
          pendingChildren: null,
          implementation: portal.implementation
        }, fiber;
      }
      function assignFiberPropertiesInDEV(target, source) {
        return target === null && (target = createFiber(IndeterminateComponent, null, null, NoMode)), target.tag = source.tag, target.key = source.key, target.elementType = source.elementType, target.type = source.type, target.stateNode = source.stateNode, target.return = source.return, target.child = source.child, target.sibling = source.sibling, target.index = source.index, target.ref = source.ref, target.pendingProps = source.pendingProps, target.memoizedProps = source.memoizedProps, target.updateQueue = source.updateQueue, target.memoizedState = source.memoizedState, target.dependencies = source.dependencies, target.mode = source.mode, target.flags = source.flags, target.nextEffect = source.nextEffect, target.firstEffect = source.firstEffect, target.lastEffect = source.lastEffect, target.lanes = source.lanes, target.childLanes = source.childLanes, target.alternate = source.alternate, target.actualDuration = source.actualDuration, target.actualStartTime = source.actualStartTime, target.selfBaseDuration = source.selfBaseDuration, target.treeBaseDuration = source.treeBaseDuration, target._debugID = source._debugID, target._debugSource = source._debugSource, target._debugOwner = source._debugOwner, target._debugNeedsRemount = source._debugNeedsRemount, target._debugHookTypes = source._debugHookTypes, target;
      }
      function FiberRootNode(containerInfo, tag, hydrate2) {
        switch (this.tag = tag, this.containerInfo = containerInfo, this.pendingChildren = null, this.current = null, this.pingCache = null, this.finishedWork = null, this.timeoutHandle = noTimeout, this.context = null, this.pendingContext = null, this.hydrate = hydrate2, this.callbackNode = null, this.callbackPriority = NoLanePriority, this.eventTimes = createLaneMap(NoLanes), this.expirationTimes = createLaneMap(NoTimestamp), this.pendingLanes = NoLanes, this.suspendedLanes = NoLanes, this.pingedLanes = NoLanes, this.expiredLanes = NoLanes, this.mutableReadLanes = NoLanes, this.finishedLanes = NoLanes, this.entangledLanes = NoLanes, this.entanglements = createLaneMap(NoLanes), this.mutableSourceEagerHydrationData = null, this.interactionThreadID = tracing.unstable_getThreadID(), this.memoizedInteractions = /* @__PURE__ */ new Set(), this.pendingInteractionMap = /* @__PURE__ */ new Map(), tag) {
          case BlockingRoot:
            this._debugRootType = "createBlockingRoot()";
            break;
          case ConcurrentRoot:
            this._debugRootType = "createRoot()";
            break;
          case LegacyRoot:
            this._debugRootType = "createLegacyRoot()";
            break;
        }
      }
      function createFiberRoot(containerInfo, tag, hydrate2, hydrationCallbacks) {
        var root2 = new FiberRootNode(containerInfo, tag, hydrate2), uninitializedFiber = createHostRootFiber(tag);
        return root2.current = uninitializedFiber, uninitializedFiber.stateNode = root2, initializeUpdateQueue(uninitializedFiber), root2;
      }
      function registerMutableSourceForHydration(root2, mutableSource) {
        var getVersion = mutableSource._getVersion, version2 = getVersion(mutableSource._source);
        root2.mutableSourceEagerHydrationData == null ? root2.mutableSourceEagerHydrationData = [mutableSource, version2] : root2.mutableSourceEagerHydrationData.push(mutableSource, version2);
      }
      function createPortal2(children, containerInfo, implementation) {
        var key = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : null;
        return {
          $$typeof: REACT_PORTAL_TYPE,
          key: key == null ? null : "" + key,
          children,
          containerInfo,
          implementation
        };
      }
      var didWarnAboutNestedUpdates, didWarnAboutFindNodeInStrictMode;
      didWarnAboutNestedUpdates = !1, didWarnAboutFindNodeInStrictMode = {};
      function getContextForSubtree(parentComponent) {
        if (!parentComponent)
          return emptyContextObject;
        var fiber = get(parentComponent), parentContext = findCurrentUnmaskedContext(fiber);
        if (fiber.tag === ClassComponent) {
          var Component = fiber.type;
          if (isContextProvider(Component))
            return processChildContext(fiber, Component, parentContext);
        }
        return parentContext;
      }
      function findHostInstanceWithWarning(component, methodName) {
        {
          var fiber = get(component);
          if (fiber === void 0)
            throw typeof component.render == "function" ? Error("Unable to find node on an unmounted component.") : Error("Argument appears to not be a ReactComponent. Keys: " + Object.keys(component));
          var hostFiber = findCurrentHostFiber(fiber);
          if (hostFiber === null)
            return null;
          if (hostFiber.mode & StrictMode) {
            var componentName = getComponentName(fiber.type) || "Component";
            if (!didWarnAboutFindNodeInStrictMode[componentName]) {
              didWarnAboutFindNodeInStrictMode[componentName] = !0;
              var previousFiber = current;
              try {
                setCurrentFiber(hostFiber), fiber.mode & StrictMode ? error("%s is deprecated in StrictMode. %s was passed an instance of %s which is inside StrictMode. Instead, add a ref directly to the element you want to reference. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-find-node", methodName, methodName, componentName) : error("%s is deprecated in StrictMode. %s was passed an instance of %s which renders StrictMode children. Instead, add a ref directly to the element you want to reference. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-find-node", methodName, methodName, componentName);
              } finally {
                previousFiber ? setCurrentFiber(previousFiber) : resetCurrentFiber();
              }
            }
          }
          return hostFiber.stateNode;
        }
      }
      function createContainer(containerInfo, tag, hydrate2, hydrationCallbacks) {
        return createFiberRoot(containerInfo, tag, hydrate2);
      }
      function updateContainer(element, container, parentComponent, callback) {
        onScheduleRoot(container, element);
        var current$1 = container.current, eventTime = requestEventTime();
        typeof jest < "u" && (warnIfUnmockedScheduler(current$1), warnIfNotScopedWithMatchingAct(current$1));
        var lane = requestUpdateLane(current$1), context = getContextForSubtree(parentComponent);
        container.context === null ? container.context = context : container.pendingContext = context, isRendering && current !== null && !didWarnAboutNestedUpdates && (didWarnAboutNestedUpdates = !0, error(`Render methods should be a pure function of props and state; triggering nested component updates from render is not allowed. If necessary, trigger nested updates in componentDidUpdate.

Check the render method of %s.`, getComponentName(current.type) || "Unknown"));
        var update = createUpdate(eventTime, lane);
        return update.payload = {
          element
        }, callback = callback === void 0 ? null : callback, callback !== null && (typeof callback != "function" && error("render(...): Expected the last optional `callback` argument to be a function. Instead received: %s.", callback), update.callback = callback), enqueueUpdate(current$1, update), scheduleUpdateOnFiber(current$1, lane, eventTime), lane;
      }
      function getPublicRootInstance(container) {
        var containerFiber = container.current;
        if (!containerFiber.child)
          return null;
        switch (containerFiber.child.tag) {
          case HostComponent:
            return containerFiber.child.stateNode;
          default:
            return containerFiber.child.stateNode;
        }
      }
      function markRetryLaneImpl(fiber, retryLane) {
        var suspenseState = fiber.memoizedState;
        suspenseState !== null && suspenseState.dehydrated !== null && (suspenseState.retryLane = higherPriorityLane(suspenseState.retryLane, retryLane));
      }
      function markRetryLaneIfNotHydrated(fiber, retryLane) {
        markRetryLaneImpl(fiber, retryLane);
        var alternate = fiber.alternate;
        alternate && markRetryLaneImpl(alternate, retryLane);
      }
      function attemptUserBlockingHydration$1(fiber) {
        if (fiber.tag === SuspenseComponent) {
          var eventTime = requestEventTime(), lane = InputDiscreteHydrationLane;
          scheduleUpdateOnFiber(fiber, lane, eventTime), markRetryLaneIfNotHydrated(fiber, lane);
        }
      }
      function attemptContinuousHydration$1(fiber) {
        if (fiber.tag === SuspenseComponent) {
          var eventTime = requestEventTime(), lane = SelectiveHydrationLane;
          scheduleUpdateOnFiber(fiber, lane, eventTime), markRetryLaneIfNotHydrated(fiber, lane);
        }
      }
      function attemptHydrationAtCurrentPriority$1(fiber) {
        if (fiber.tag === SuspenseComponent) {
          var eventTime = requestEventTime(), lane = requestUpdateLane(fiber);
          scheduleUpdateOnFiber(fiber, lane, eventTime), markRetryLaneIfNotHydrated(fiber, lane);
        }
      }
      function runWithPriority$2(priority, fn) {
        try {
          return fn();
        } finally {
        }
      }
      function findHostInstanceWithNoPortals(fiber) {
        var hostFiber = findCurrentHostFiberWithNoPortals(fiber);
        return hostFiber === null ? null : hostFiber.tag === FundamentalComponent ? hostFiber.stateNode.instance : hostFiber.stateNode;
      }
      var shouldSuspendImpl = function(fiber) {
        return !1;
      };
      function shouldSuspend(fiber) {
        return shouldSuspendImpl(fiber);
      }
      var overrideHookState = null, overrideHookStateDeletePath = null, overrideHookStateRenamePath = null, overrideProps = null, overridePropsDeletePath = null, overridePropsRenamePath = null, scheduleUpdate = null, setSuspenseHandler = null;
      {
        var copyWithDeleteImpl = function(obj, path, index2) {
          var key = path[index2], updated = Array.isArray(obj) ? obj.slice() : _assign({}, obj);
          return index2 + 1 === path.length ? (Array.isArray(updated) ? updated.splice(key, 1) : delete updated[key], updated) : (updated[key] = copyWithDeleteImpl(obj[key], path, index2 + 1), updated);
        }, copyWithDelete = function(obj, path) {
          return copyWithDeleteImpl(obj, path, 0);
        }, copyWithRenameImpl = function(obj, oldPath, newPath, index2) {
          var oldKey = oldPath[index2], updated = Array.isArray(obj) ? obj.slice() : _assign({}, obj);
          if (index2 + 1 === oldPath.length) {
            var newKey = newPath[index2];
            updated[newKey] = updated[oldKey], Array.isArray(updated) ? updated.splice(oldKey, 1) : delete updated[oldKey];
          } else
            updated[oldKey] = copyWithRenameImpl(
              obj[oldKey],
              oldPath,
              newPath,
              index2 + 1
            );
          return updated;
        }, copyWithRename = function(obj, oldPath, newPath) {
          if (oldPath.length !== newPath.length) {
            warn("copyWithRename() expects paths of the same length");
            return;
          } else
            for (var i = 0; i < newPath.length - 1; i++)
              if (oldPath[i] !== newPath[i]) {
                warn("copyWithRename() expects paths to be the same except for the deepest key");
                return;
              }
          return copyWithRenameImpl(obj, oldPath, newPath, 0);
        }, copyWithSetImpl = function(obj, path, index2, value) {
          if (index2 >= path.length)
            return value;
          var key = path[index2], updated = Array.isArray(obj) ? obj.slice() : _assign({}, obj);
          return updated[key] = copyWithSetImpl(obj[key], path, index2 + 1, value), updated;
        }, copyWithSet = function(obj, path, value) {
          return copyWithSetImpl(obj, path, 0, value);
        }, findHook = function(fiber, id) {
          for (var currentHook2 = fiber.memoizedState; currentHook2 !== null && id > 0; )
            currentHook2 = currentHook2.next, id--;
          return currentHook2;
        };
        overrideHookState = function(fiber, id, path, value) {
          var hook = findHook(fiber, id);
          if (hook !== null) {
            var newState = copyWithSet(hook.memoizedState, path, value);
            hook.memoizedState = newState, hook.baseState = newState, fiber.memoizedProps = _assign({}, fiber.memoizedProps), scheduleUpdateOnFiber(fiber, SyncLane, NoTimestamp);
          }
        }, overrideHookStateDeletePath = function(fiber, id, path) {
          var hook = findHook(fiber, id);
          if (hook !== null) {
            var newState = copyWithDelete(hook.memoizedState, path);
            hook.memoizedState = newState, hook.baseState = newState, fiber.memoizedProps = _assign({}, fiber.memoizedProps), scheduleUpdateOnFiber(fiber, SyncLane, NoTimestamp);
          }
        }, overrideHookStateRenamePath = function(fiber, id, oldPath, newPath) {
          var hook = findHook(fiber, id);
          if (hook !== null) {
            var newState = copyWithRename(hook.memoizedState, oldPath, newPath);
            hook.memoizedState = newState, hook.baseState = newState, fiber.memoizedProps = _assign({}, fiber.memoizedProps), scheduleUpdateOnFiber(fiber, SyncLane, NoTimestamp);
          }
        }, overrideProps = function(fiber, path, value) {
          fiber.pendingProps = copyWithSet(fiber.memoizedProps, path, value), fiber.alternate && (fiber.alternate.pendingProps = fiber.pendingProps), scheduleUpdateOnFiber(fiber, SyncLane, NoTimestamp);
        }, overridePropsDeletePath = function(fiber, path) {
          fiber.pendingProps = copyWithDelete(fiber.memoizedProps, path), fiber.alternate && (fiber.alternate.pendingProps = fiber.pendingProps), scheduleUpdateOnFiber(fiber, SyncLane, NoTimestamp);
        }, overridePropsRenamePath = function(fiber, oldPath, newPath) {
          fiber.pendingProps = copyWithRename(fiber.memoizedProps, oldPath, newPath), fiber.alternate && (fiber.alternate.pendingProps = fiber.pendingProps), scheduleUpdateOnFiber(fiber, SyncLane, NoTimestamp);
        }, scheduleUpdate = function(fiber) {
          scheduleUpdateOnFiber(fiber, SyncLane, NoTimestamp);
        }, setSuspenseHandler = function(newShouldSuspendImpl) {
          shouldSuspendImpl = newShouldSuspendImpl;
        };
      }
      function findHostInstanceByFiber(fiber) {
        var hostFiber = findCurrentHostFiber(fiber);
        return hostFiber === null ? null : hostFiber.stateNode;
      }
      function emptyFindFiberByHostInstance(instance) {
        return null;
      }
      function getCurrentFiberForDevTools() {
        return current;
      }
      function injectIntoDevTools(devToolsConfig) {
        var findFiberByHostInstance = devToolsConfig.findFiberByHostInstance, ReactCurrentDispatcher2 = ReactSharedInternals.ReactCurrentDispatcher;
        return injectInternals({
          bundleType: devToolsConfig.bundleType,
          version: devToolsConfig.version,
          rendererPackageName: devToolsConfig.rendererPackageName,
          rendererConfig: devToolsConfig.rendererConfig,
          overrideHookState,
          overrideHookStateDeletePath,
          overrideHookStateRenamePath,
          overrideProps,
          overridePropsDeletePath,
          overridePropsRenamePath,
          setSuspenseHandler,
          scheduleUpdate,
          currentDispatcherRef: ReactCurrentDispatcher2,
          findHostInstanceByFiber,
          findFiberByHostInstance: findFiberByHostInstance || emptyFindFiberByHostInstance,
          findHostInstancesForRefresh,
          scheduleRefresh,
          scheduleRoot,
          setRefreshHandler,
          getCurrentFiber: getCurrentFiberForDevTools
        });
      }
      function ReactDOMRoot(container, options2) {
        this._internalRoot = createRootImpl(container, ConcurrentRoot, options2);
      }
      function ReactDOMBlockingRoot(container, tag, options2) {
        this._internalRoot = createRootImpl(container, tag, options2);
      }
      ReactDOMRoot.prototype.render = ReactDOMBlockingRoot.prototype.render = function(children) {
        var root2 = this._internalRoot;
        {
          typeof arguments[1] == "function" && error("render(...): does not support the second callback argument. To execute a side effect after rendering, declare it in a component body with useEffect().");
          var container = root2.containerInfo;
          if (container.nodeType !== COMMENT_NODE) {
            var hostInstance = findHostInstanceWithNoPortals(root2.current);
            hostInstance && hostInstance.parentNode !== container && error("render(...): It looks like the React-rendered content of the root container was removed without using React. This is not supported and will cause errors. Instead, call root.unmount() to empty a root's container.");
          }
        }
        updateContainer(children, root2, null, null);
      }, ReactDOMRoot.prototype.unmount = ReactDOMBlockingRoot.prototype.unmount = function() {
        typeof arguments[0] == "function" && error("unmount(...): does not support a callback argument. To execute a side effect after rendering, declare it in a component body with useEffect().");
        var root2 = this._internalRoot, container = root2.containerInfo;
        updateContainer(null, root2, null, function() {
          unmarkContainerAsRoot(container);
        });
      };
      function createRootImpl(container, tag, options2) {
        var hydrate2 = options2 != null && options2.hydrate === !0, hydrationCallbacks = options2 != null && options2.hydrationOptions || null, mutableSources = options2 != null && options2.hydrationOptions != null && options2.hydrationOptions.mutableSources || null, root2 = createContainer(container, tag, hydrate2);
        markContainerAsRoot(root2.current, container);
        var containerNodeType = container.nodeType;
        {
          var rootContainerElement = container.nodeType === COMMENT_NODE ? container.parentNode : container;
          listenToAllSupportedEvents(rootContainerElement);
        }
        if (mutableSources)
          for (var i = 0; i < mutableSources.length; i++) {
            var mutableSource = mutableSources[i];
            registerMutableSourceForHydration(root2, mutableSource);
          }
        return root2;
      }
      function createLegacyRoot(container, options2) {
        return new ReactDOMBlockingRoot(container, LegacyRoot, options2);
      }
      function isValidContainer(node) {
        return !!(node && (node.nodeType === ELEMENT_NODE || node.nodeType === DOCUMENT_NODE || node.nodeType === DOCUMENT_FRAGMENT_NODE || node.nodeType === COMMENT_NODE && node.nodeValue === " react-mount-point-unstable "));
      }
      var ReactCurrentOwner$3 = ReactSharedInternals.ReactCurrentOwner, topLevelUpdateWarnings, warnedAboutHydrateAPI = !1;
      topLevelUpdateWarnings = function(container) {
        if (container._reactRootContainer && container.nodeType !== COMMENT_NODE) {
          var hostInstance = findHostInstanceWithNoPortals(container._reactRootContainer._internalRoot.current);
          hostInstance && hostInstance.parentNode !== container && error("render(...): It looks like the React-rendered content of this container was removed without using React. This is not supported and will cause errors. Instead, call ReactDOM.unmountComponentAtNode to empty a container.");
        }
        var isRootRenderedBySomeReact = !!container._reactRootContainer, rootEl = getReactRootElementInContainer(container), hasNonRootReactChild = !!(rootEl && getInstanceFromNode(rootEl));
        hasNonRootReactChild && !isRootRenderedBySomeReact && error("render(...): Replacing React-rendered children with a new root component. If you intended to update the children of this node, you should instead have the existing children update their state and render the new components instead of calling ReactDOM.render."), container.nodeType === ELEMENT_NODE && container.tagName && container.tagName.toUpperCase() === "BODY" && error("render(): Rendering components directly into document.body is discouraged, since its children are often manipulated by third-party scripts and browser extensions. This may lead to subtle reconciliation issues. Try rendering into a container element created for your app.");
      };
      function getReactRootElementInContainer(container) {
        return container ? container.nodeType === DOCUMENT_NODE ? container.documentElement : container.firstChild : null;
      }
      function shouldHydrateDueToLegacyHeuristic(container) {
        var rootElement = getReactRootElementInContainer(container);
        return !!(rootElement && rootElement.nodeType === ELEMENT_NODE && rootElement.hasAttribute(ROOT_ATTRIBUTE_NAME));
      }
      function legacyCreateRootFromDOMContainer(container, forceHydrate) {
        var shouldHydrate = forceHydrate || shouldHydrateDueToLegacyHeuristic(container);
        if (!shouldHydrate)
          for (var warned = !1, rootSibling; rootSibling = container.lastChild; )
            !warned && rootSibling.nodeType === ELEMENT_NODE && rootSibling.hasAttribute(ROOT_ATTRIBUTE_NAME) && (warned = !0, error("render(): Target node has markup rendered by React, but there are unrelated nodes as well. This is most commonly caused by white-space inserted around server-rendered markup.")), container.removeChild(rootSibling);
        return shouldHydrate && !forceHydrate && !warnedAboutHydrateAPI && (warnedAboutHydrateAPI = !0, warn("render(): Calling ReactDOM.render() to hydrate server-rendered markup will stop working in React v18. Replace the ReactDOM.render() call with ReactDOM.hydrate() if you want React to attach to the server HTML.")), createLegacyRoot(container, shouldHydrate ? {
          hydrate: !0
        } : void 0);
      }
      function warnOnInvalidCallback$1(callback, callerName) {
        callback !== null && typeof callback != "function" && error("%s(...): Expected the last optional `callback` argument to be a function. Instead received: %s.", callerName, callback);
      }
      function legacyRenderSubtreeIntoContainer(parentComponent, children, container, forceHydrate, callback) {
        topLevelUpdateWarnings(container), warnOnInvalidCallback$1(callback === void 0 ? null : callback, "render");
        var root2 = container._reactRootContainer, fiberRoot;
        if (root2) {
          if (fiberRoot = root2._internalRoot, typeof callback == "function") {
            var _originalCallback = callback;
            callback = function() {
              var instance = getPublicRootInstance(fiberRoot);
              _originalCallback.call(instance);
            };
          }
          updateContainer(children, fiberRoot, parentComponent, callback);
        } else {
          if (root2 = container._reactRootContainer = legacyCreateRootFromDOMContainer(container, forceHydrate), fiberRoot = root2._internalRoot, typeof callback == "function") {
            var originalCallback = callback;
            callback = function() {
              var instance = getPublicRootInstance(fiberRoot);
              originalCallback.call(instance);
            };
          }
          unbatchedUpdates(function() {
            updateContainer(children, fiberRoot, parentComponent, callback);
          });
        }
        return getPublicRootInstance(fiberRoot);
      }
      function findDOMNode(componentOrElement) {
        {
          var owner = ReactCurrentOwner$3.current;
          if (owner !== null && owner.stateNode !== null) {
            var warnedAboutRefsInRender = owner.stateNode._warnedAboutRefsInRender;
            warnedAboutRefsInRender || error("%s is accessing findDOMNode inside its render(). render() should be a pure function of props and state. It should never access something that requires stale data from the previous render, such as refs. Move this logic to componentDidMount and componentDidUpdate instead.", getComponentName(owner.type) || "A component"), owner.stateNode._warnedAboutRefsInRender = !0;
          }
        }
        return componentOrElement == null ? null : componentOrElement.nodeType === ELEMENT_NODE ? componentOrElement : findHostInstanceWithWarning(componentOrElement, "findDOMNode");
      }
      function hydrate(element, container, callback) {
        if (!isValidContainer(container))
          throw Error("Target container is not a DOM element.");
        {
          var isModernRoot = isContainerMarkedAsRoot(container) && container._reactRootContainer === void 0;
          isModernRoot && error("You are calling ReactDOM.hydrate() on a container that was previously passed to ReactDOM.createRoot(). This is not supported. Did you mean to call createRoot(container, {hydrate: true}).render(element)?");
        }
        return legacyRenderSubtreeIntoContainer(null, element, container, !0, callback);
      }
      function render(element, container, callback) {
        if (!isValidContainer(container))
          throw Error("Target container is not a DOM element.");
        {
          var isModernRoot = isContainerMarkedAsRoot(container) && container._reactRootContainer === void 0;
          isModernRoot && error("You are calling ReactDOM.render() on a container that was previously passed to ReactDOM.createRoot(). This is not supported. Did you mean to call root.render(element)?");
        }
        return legacyRenderSubtreeIntoContainer(null, element, container, !1, callback);
      }
      function unstable_renderSubtreeIntoContainer(parentComponent, element, containerNode, callback) {
        if (!isValidContainer(containerNode))
          throw Error("Target container is not a DOM element.");
        if (!(parentComponent != null && has(parentComponent)))
          throw Error("parentComponent must be a valid React Component");
        return legacyRenderSubtreeIntoContainer(parentComponent, element, containerNode, !1, callback);
      }
      function unmountComponentAtNode(container) {
        if (!isValidContainer(container))
          throw Error("unmountComponentAtNode(...): Target container is not a DOM element.");
        {
          var isModernRoot = isContainerMarkedAsRoot(container) && container._reactRootContainer === void 0;
          isModernRoot && error("You are calling ReactDOM.unmountComponentAtNode() on a container that was previously passed to ReactDOM.createRoot(). This is not supported. Did you mean to call root.unmount()?");
        }
        if (container._reactRootContainer) {
          {
            var rootEl = getReactRootElementInContainer(container), renderedByDifferentReact = rootEl && !getInstanceFromNode(rootEl);
            renderedByDifferentReact && error("unmountComponentAtNode(): The node you're attempting to unmount was rendered by another copy of React.");
          }
          return unbatchedUpdates(function() {
            legacyRenderSubtreeIntoContainer(null, null, container, !1, function() {
              container._reactRootContainer = null, unmarkContainerAsRoot(container);
            });
          }), !0;
        } else {
          {
            var _rootEl = getReactRootElementInContainer(container), hasNonRootReactChild = !!(_rootEl && getInstanceFromNode(_rootEl)), isContainerReactRoot = container.nodeType === ELEMENT_NODE && isValidContainer(container.parentNode) && !!container.parentNode._reactRootContainer;
            hasNonRootReactChild && error("unmountComponentAtNode(): The node you're attempting to unmount was rendered by React and is not a top-level container. %s", isContainerReactRoot ? "You may have accidentally passed in a React root node instead of its container." : "Instead, have the parent component update its state and rerender in order to remove this component.");
          }
          return !1;
        }
      }
      setAttemptUserBlockingHydration(attemptUserBlockingHydration$1), setAttemptContinuousHydration(attemptContinuousHydration$1), setAttemptHydrationAtCurrentPriority(attemptHydrationAtCurrentPriority$1), setAttemptHydrationAtPriority(runWithPriority$2);
      var didWarnAboutUnstableCreatePortal = !1;
      (typeof Map != "function" || Map.prototype == null || typeof Map.prototype.forEach != "function" || typeof Set != "function" || Set.prototype == null || typeof Set.prototype.clear != "function" || typeof Set.prototype.forEach != "function") && error("React depends on Map and Set built-in types. Make sure that you load a polyfill in older browsers. https://reactjs.org/link/react-polyfills"), setRestoreImplementation(restoreControlledState$3), setBatchingImplementation(batchedUpdates$1, discreteUpdates$1, flushDiscreteUpdates, batchedEventUpdates$1);
      function createPortal$1(children, container) {
        var key = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : null;
        if (!isValidContainer(container))
          throw Error("Target container is not a DOM element.");
        return createPortal2(children, container, null, key);
      }
      function renderSubtreeIntoContainer(parentComponent, element, containerNode, callback) {
        return unstable_renderSubtreeIntoContainer(parentComponent, element, containerNode, callback);
      }
      function unstable_createPortal(children, container) {
        var key = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : null;
        return didWarnAboutUnstableCreatePortal || (didWarnAboutUnstableCreatePortal = !0, warn('The ReactDOM.unstable_createPortal() alias has been deprecated, and will be removed in React 18+. Update your code to use ReactDOM.createPortal() instead. It has the exact same API, but without the "unstable_" prefix.')), createPortal$1(children, container, key);
      }
      var Internals = {
        Events: [
          getInstanceFromNode,
          getNodeFromInstance,
          getFiberCurrentPropsFromNode,
          enqueueStateRestore,
          restoreStateIfNeeded,
          flushPassiveEffects,
          IsThisRendererActing
        ]
      }, foundDevTools = injectIntoDevTools({
        findFiberByHostInstance: getClosestInstanceFromNode,
        bundleType: 1,
        version: ReactVersion,
        rendererPackageName: "react-dom"
      });
      if (!foundDevTools && canUseDOM && window.top === window.self && (navigator.userAgent.indexOf("Chrome") > -1 && navigator.userAgent.indexOf("Edge") === -1 || navigator.userAgent.indexOf("Firefox") > -1)) {
        var protocol = window.location.protocol;
        /^(https?|file):$/.test(protocol) && console.info("%cDownload the React DevTools for a better development experience: https://reactjs.org/link/react-devtools" + (protocol === "file:" ? `
You might need to use a local HTTP server (instead of file://): https://reactjs.org/link/react-devtools-faq` : ""), "font-weight:bold");
      }
      exports.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = Internals, exports.createPortal = createPortal$1, exports.findDOMNode = findDOMNode, exports.flushSync = flushSync2, exports.hydrate = hydrate, exports.render = render, exports.unmountComponentAtNode = unmountComponentAtNode, exports.unstable_batchedUpdates = batchedUpdates$1, exports.unstable_createPortal = unstable_createPortal, exports.unstable_renderSubtreeIntoContainer = renderSubtreeIntoContainer, exports.version = ReactVersion;
    })();
  }
});

// node_modules/react-dom/index.js
var require_react_dom = __commonJS({
  "node_modules/react-dom/index.js"(exports, module) {
    "use strict";
    module.exports = require_react_dom_development();
  }
});

// node_modules/@mui/base/Portal/Portal.js
function getContainer(container) {
  return typeof container == "function" ? container() : container;
}
var React13, ReactDOM, import_prop_types4, import_jsx_runtime, Portal, Portal_default, init_Portal = __esm({
  "node_modules/@mui/base/Portal/Portal.js"() {
    React13 = __toESM(require_react()), ReactDOM = __toESM(require_react_dom()), import_prop_types4 = __toESM(require_prop_types());
    init_esm2();
    import_jsx_runtime = __toESM(require_jsx_runtime());
    Portal = /* @__PURE__ */ React13.forwardRef(function(props, ref) {
      let {
        children,
        container,
        disablePortal = !1
      } = props, [mountNode, setMountNode] = React13.useState(null), handleRef = useForkRef(/* @__PURE__ */ React13.isValidElement(children) ? children.ref : null, ref);
      return useEnhancedEffect_default(() => {
        disablePortal || setMountNode(getContainer(container) || document.body);
      }, [container, disablePortal]), useEnhancedEffect_default(() => {
        if (mountNode && !disablePortal)
          return setRef(ref, mountNode), () => {
            setRef(ref, null);
          };
      }, [ref, mountNode, disablePortal]), disablePortal ? /* @__PURE__ */ React13.isValidElement(children) ? /* @__PURE__ */ React13.cloneElement(children, {
        ref: handleRef
      }) : children : /* @__PURE__ */ (0, import_jsx_runtime.jsx)(React13.Fragment, {
        children: mountNode && /* @__PURE__ */ ReactDOM.createPortal(children, mountNode)
      });
    });
    Portal.propTypes = {
      children: import_prop_types4.default.node,
      container: import_prop_types4.default.oneOfType([HTMLElementType, import_prop_types4.default.func]),
      disablePortal: import_prop_types4.default.bool
    };
    Portal["propTypes"] = exactProp(Portal.propTypes);
    Portal_default = Portal;
  }
});

// node_modules/@mui/base/Portal/index.js
var init_Portal2 = __esm({
  "node_modules/@mui/base/Portal/index.js"() {
    init_Portal();
  }
});

// node_modules/@mui/base/MenuUnstyled/MenuUnstyled.types.js
var init_MenuUnstyled_types = __esm({
  "node_modules/@mui/base/MenuUnstyled/MenuUnstyled.types.js"() {
  }
});

// node_modules/@mui/base/MenuUnstyled/useMenu.types.js
var init_useMenu_types = __esm({
  "node_modules/@mui/base/MenuUnstyled/useMenu.types.js"() {
  }
});

// node_modules/@mui/base/MenuUnstyled/index.js
var init_MenuUnstyled = __esm({
  "node_modules/@mui/base/MenuUnstyled/index.js"() {
    init_MenuUnstyledContext();
    init_menuUnstyledClasses();
    init_MenuUnstyled_types();
    init_useMenu_types();
  }
});

// node_modules/@mui/base/MenuItemUnstyled/menuItemUnstyledClasses.js
var menuItemUnstyledClasses, init_menuItemUnstyledClasses = __esm({
  "node_modules/@mui/base/MenuItemUnstyled/menuItemUnstyledClasses.js"() {
    init_generateUtilityClasses3();
    menuItemUnstyledClasses = generateUtilityClasses("MuiMenuItemUnstyled", ["root", "disabled", "focusVisible"]);
  }
});

// node_modules/@mui/base/MenuItemUnstyled/MenuItemUnstyled.types.js
var init_MenuItemUnstyled_types = __esm({
  "node_modules/@mui/base/MenuItemUnstyled/MenuItemUnstyled.types.js"() {
  }
});

// node_modules/@mui/base/MenuItemUnstyled/useMenuItem.types.js
var init_useMenuItem_types = __esm({
  "node_modules/@mui/base/MenuItemUnstyled/useMenuItem.types.js"() {
  }
});

// node_modules/@mui/base/MenuItemUnstyled/index.js
var init_MenuItemUnstyled = __esm({
  "node_modules/@mui/base/MenuItemUnstyled/index.js"() {
    init_MenuItemUnstyled_types();
    init_menuItemUnstyledClasses();
    init_useMenuItem_types();
  }
});

// node_modules/@mui/base/ModalUnstyled/ModalManager.js
function isOverflowing(container) {
  let doc = ownerDocument(container);
  return doc.body === container ? ownerWindow(container).innerWidth > doc.documentElement.clientWidth : container.scrollHeight > container.clientHeight;
}
function ariaHidden(element, show) {
  show ? element.setAttribute("aria-hidden", "true") : element.removeAttribute("aria-hidden");
}
function getPaddingRight(element) {
  return parseInt(ownerWindow(element).getComputedStyle(element).paddingRight, 10) || 0;
}
function isAriaHiddenForbiddenOnElement(element) {
  let isForbiddenTagName = ["TEMPLATE", "SCRIPT", "STYLE", "LINK", "MAP", "META", "NOSCRIPT", "PICTURE", "COL", "COLGROUP", "PARAM", "SLOT", "SOURCE", "TRACK"].indexOf(element.tagName) !== -1, isInputHidden = element.tagName === "INPUT" && element.getAttribute("type") === "hidden";
  return isForbiddenTagName || isInputHidden;
}
function ariaHiddenSiblings(container, mountElement, currentElement, elementsToExclude = [], show) {
  let blacklist = [mountElement, currentElement, ...elementsToExclude];
  [].forEach.call(container.children, (element) => {
    let isNotExcludedElement = blacklist.indexOf(element) === -1, isNotForbiddenElement = !isAriaHiddenForbiddenOnElement(element);
    isNotExcludedElement && isNotForbiddenElement && ariaHidden(element, show);
  });
}
function findIndexOf(items, callback) {
  let idx = -1;
  return items.some((item, index) => callback(item) ? (idx = index, !0) : !1), idx;
}
function handleContainer(containerInfo, props) {
  let restoreStyle = [], container = containerInfo.container;
  if (!props.disableScrollLock) {
    if (isOverflowing(container)) {
      let scrollbarSize = getScrollbarSize(ownerDocument(container));
      restoreStyle.push({
        value: container.style.paddingRight,
        property: "padding-right",
        el: container
      }), container.style.paddingRight = `${getPaddingRight(container) + scrollbarSize}px`;
      let fixedElements = ownerDocument(container).querySelectorAll(".mui-fixed");
      [].forEach.call(fixedElements, (element) => {
        restoreStyle.push({
          value: element.style.paddingRight,
          property: "padding-right",
          el: element
        }), element.style.paddingRight = `${getPaddingRight(element) + scrollbarSize}px`;
      });
    }
    let scrollContainer;
    if (container.parentNode instanceof DocumentFragment)
      scrollContainer = ownerDocument(container).body;
    else {
      let parent = container.parentElement, containerWindow = ownerWindow(container);
      scrollContainer = (parent == null ? void 0 : parent.nodeName) === "HTML" && containerWindow.getComputedStyle(parent).overflowY === "scroll" ? parent : container;
    }
    restoreStyle.push({
      value: scrollContainer.style.overflow,
      property: "overflow",
      el: scrollContainer
    }, {
      value: scrollContainer.style.overflowX,
      property: "overflow-x",
      el: scrollContainer
    }, {
      value: scrollContainer.style.overflowY,
      property: "overflow-y",
      el: scrollContainer
    }), scrollContainer.style.overflow = "hidden";
  }
  return () => {
    restoreStyle.forEach(({
      value,
      el,
      property
    }) => {
      value ? el.style.setProperty(property, value) : el.style.removeProperty(property);
    });
  };
}
function getHiddenSiblings(container) {
  let hiddenSiblings = [];
  return [].forEach.call(container.children, (element) => {
    element.getAttribute("aria-hidden") === "true" && hiddenSiblings.push(element);
  }), hiddenSiblings;
}
var ModalManager, init_ModalManager = __esm({
  "node_modules/@mui/base/ModalUnstyled/ModalManager.js"() {
    init_esm2();
    ModalManager = class {
      constructor() {
        this.containers = void 0, this.modals = void 0, this.modals = [], this.containers = [];
      }
      add(modal, container) {
        let modalIndex = this.modals.indexOf(modal);
        if (modalIndex !== -1)
          return modalIndex;
        modalIndex = this.modals.length, this.modals.push(modal), modal.modalRef && ariaHidden(modal.modalRef, !1);
        let hiddenSiblings = getHiddenSiblings(container);
        ariaHiddenSiblings(container, modal.mount, modal.modalRef, hiddenSiblings, !0);
        let containerIndex = findIndexOf(this.containers, (item) => item.container === container);
        return containerIndex !== -1 ? (this.containers[containerIndex].modals.push(modal), modalIndex) : (this.containers.push({
          modals: [modal],
          container,
          restore: null,
          hiddenSiblings
        }), modalIndex);
      }
      mount(modal, props) {
        let containerIndex = findIndexOf(this.containers, (item) => item.modals.indexOf(modal) !== -1), containerInfo = this.containers[containerIndex];
        containerInfo.restore || (containerInfo.restore = handleContainer(containerInfo, props));
      }
      remove(modal, ariaHiddenState = !0) {
        let modalIndex = this.modals.indexOf(modal);
        if (modalIndex === -1)
          return modalIndex;
        let containerIndex = findIndexOf(this.containers, (item) => item.modals.indexOf(modal) !== -1), containerInfo = this.containers[containerIndex];
        if (containerInfo.modals.splice(containerInfo.modals.indexOf(modal), 1), this.modals.splice(modalIndex, 1), containerInfo.modals.length === 0)
          containerInfo.restore && containerInfo.restore(), modal.modalRef && ariaHidden(modal.modalRef, ariaHiddenState), ariaHiddenSiblings(containerInfo.container, modal.mount, modal.modalRef, containerInfo.hiddenSiblings, !1), this.containers.splice(containerIndex, 1);
        else {
          let nextTop = containerInfo.modals[containerInfo.modals.length - 1];
          nextTop.modalRef && ariaHidden(nextTop.modalRef, !1);
        }
        return modalIndex;
      }
      isTopModal(modal) {
        return this.modals.length > 0 && this.modals[this.modals.length - 1] === modal;
      }
    };
  }
});

// node_modules/@mui/base/TrapFocus/TrapFocus.js
function getTabIndex(node) {
  let tabindexAttr = parseInt(node.getAttribute("tabindex"), 10);
  return Number.isNaN(tabindexAttr) ? node.contentEditable === "true" || (node.nodeName === "AUDIO" || node.nodeName === "VIDEO" || node.nodeName === "DETAILS") && node.getAttribute("tabindex") === null ? 0 : node.tabIndex : tabindexAttr;
}
function isNonTabbableRadio(node) {
  if (node.tagName !== "INPUT" || node.type !== "radio" || !node.name)
    return !1;
  let getRadio = (selector) => node.ownerDocument.querySelector(`input[type="radio"]${selector}`), roving = getRadio(`[name="${node.name}"]:checked`);
  return roving || (roving = getRadio(`[name="${node.name}"]`)), roving !== node;
}
function isNodeMatchingSelectorFocusable(node) {
  return !(node.disabled || node.tagName === "INPUT" && node.type === "hidden" || isNonTabbableRadio(node));
}
function defaultGetTabbable(root) {
  let regularTabNodes = [], orderedTabNodes = [];
  return Array.from(root.querySelectorAll(candidatesSelector)).forEach((node, i) => {
    let nodeTabIndex = getTabIndex(node);
    nodeTabIndex === -1 || !isNodeMatchingSelectorFocusable(node) || (nodeTabIndex === 0 ? regularTabNodes.push(node) : orderedTabNodes.push({
      documentOrder: i,
      tabIndex: nodeTabIndex,
      node
    }));
  }), orderedTabNodes.sort((a, b) => a.tabIndex === b.tabIndex ? a.documentOrder - b.documentOrder : a.tabIndex - b.tabIndex).map((a) => a.node).concat(regularTabNodes);
}
function defaultIsEnabled() {
  return !0;
}
function TrapFocus(props) {
  let {
    children,
    disableAutoFocus = !1,
    disableEnforceFocus = !1,
    disableRestoreFocus = !1,
    getTabbable = defaultGetTabbable,
    isEnabled = defaultIsEnabled,
    open
  } = props, ignoreNextEnforceFocus = React14.useRef(), sentinelStart = React14.useRef(null), sentinelEnd = React14.useRef(null), nodeToRestore = React14.useRef(null), reactFocusEventTarget = React14.useRef(null), activated = React14.useRef(!1), rootRef = React14.useRef(null), handleRef = useForkRef(children.ref, rootRef), lastKeydown = React14.useRef(null);
  React14.useEffect(() => {
    !open || !rootRef.current || (activated.current = !disableAutoFocus);
  }, [disableAutoFocus, open]), React14.useEffect(() => {
    if (!open || !rootRef.current)
      return;
    let doc = ownerDocument(rootRef.current);
    return rootRef.current.contains(doc.activeElement) || (rootRef.current.hasAttribute("tabIndex") || (console.error(["MUI: The modal content node does not accept focus.", 'For the benefit of assistive technologies, the tabIndex of the node is being set to "-1".'].join(`
`)), rootRef.current.setAttribute("tabIndex", -1)), activated.current && rootRef.current.focus()), () => {
      disableRestoreFocus || (nodeToRestore.current && nodeToRestore.current.focus && (ignoreNextEnforceFocus.current = !0, nodeToRestore.current.focus()), nodeToRestore.current = null);
    };
  }, [open]), React14.useEffect(() => {
    if (!open || !rootRef.current)
      return;
    let doc = ownerDocument(rootRef.current), contain = (nativeEvent) => {
      let {
        current: rootElement
      } = rootRef;
      if (rootElement !== null) {
        if (!doc.hasFocus() || disableEnforceFocus || !isEnabled() || ignoreNextEnforceFocus.current) {
          ignoreNextEnforceFocus.current = !1;
          return;
        }
        if (!rootElement.contains(doc.activeElement)) {
          if (nativeEvent && reactFocusEventTarget.current !== nativeEvent.target || doc.activeElement !== reactFocusEventTarget.current)
            reactFocusEventTarget.current = null;
          else if (reactFocusEventTarget.current !== null)
            return;
          if (!activated.current)
            return;
          let tabbable = [];
          if ((doc.activeElement === sentinelStart.current || doc.activeElement === sentinelEnd.current) && (tabbable = getTabbable(rootRef.current)), tabbable.length > 0) {
            var _lastKeydown$current, _lastKeydown$current2;
            let isShiftTab = Boolean(((_lastKeydown$current = lastKeydown.current) == null ? void 0 : _lastKeydown$current.shiftKey) && ((_lastKeydown$current2 = lastKeydown.current) == null ? void 0 : _lastKeydown$current2.key) === "Tab"), focusNext = tabbable[0], focusPrevious = tabbable[tabbable.length - 1];
            isShiftTab ? focusPrevious.focus() : focusNext.focus();
          } else
            rootElement.focus();
        }
      }
    }, loopFocus = (nativeEvent) => {
      lastKeydown.current = nativeEvent, !(disableEnforceFocus || !isEnabled() || nativeEvent.key !== "Tab") && doc.activeElement === rootRef.current && nativeEvent.shiftKey && (ignoreNextEnforceFocus.current = !0, sentinelEnd.current.focus());
    };
    doc.addEventListener("focusin", contain), doc.addEventListener("keydown", loopFocus, !0);
    let interval = setInterval(() => {
      doc.activeElement.tagName === "BODY" && contain();
    }, 50);
    return () => {
      clearInterval(interval), doc.removeEventListener("focusin", contain), doc.removeEventListener("keydown", loopFocus, !0);
    };
  }, [disableAutoFocus, disableEnforceFocus, disableRestoreFocus, isEnabled, open, getTabbable]);
  let onFocus = (event) => {
    nodeToRestore.current === null && (nodeToRestore.current = event.relatedTarget), activated.current = !0, reactFocusEventTarget.current = event.target;
    let childrenPropsHandler = children.props.onFocus;
    childrenPropsHandler && childrenPropsHandler(event);
  }, handleFocusSentinel = (event) => {
    nodeToRestore.current === null && (nodeToRestore.current = event.relatedTarget), activated.current = !0;
  };
  return /* @__PURE__ */ (0, import_jsx_runtime3.jsxs)(React14.Fragment, {
    children: [/* @__PURE__ */ (0, import_jsx_runtime2.jsx)("div", {
      tabIndex: open ? 0 : -1,
      onFocus: handleFocusSentinel,
      ref: sentinelStart,
      "data-testid": "sentinelStart"
    }), /* @__PURE__ */ React14.cloneElement(children, {
      ref: handleRef,
      onFocus
    }), /* @__PURE__ */ (0, import_jsx_runtime2.jsx)("div", {
      tabIndex: open ? 0 : -1,
      onFocus: handleFocusSentinel,
      ref: sentinelEnd,
      "data-testid": "sentinelEnd"
    })]
  });
}
var React14, import_prop_types5, import_jsx_runtime2, import_jsx_runtime3, candidatesSelector, TrapFocus_default, init_TrapFocus = __esm({
  "node_modules/@mui/base/TrapFocus/TrapFocus.js"() {
    React14 = __toESM(require_react()), import_prop_types5 = __toESM(require_prop_types());
    init_esm2();
    import_jsx_runtime2 = __toESM(require_jsx_runtime()), import_jsx_runtime3 = __toESM(require_jsx_runtime()), candidatesSelector = ["input", "select", "textarea", "a[href]", "button", "[tabindex]", "audio[controls]", "video[controls]", '[contenteditable]:not([contenteditable="false"])'].join(",");
    TrapFocus.propTypes = {
      children: elementAcceptingRef_default,
      disableAutoFocus: import_prop_types5.default.bool,
      disableEnforceFocus: import_prop_types5.default.bool,
      disableRestoreFocus: import_prop_types5.default.bool,
      getTabbable: import_prop_types5.default.func,
      isEnabled: import_prop_types5.default.func,
      open: import_prop_types5.default.bool.isRequired
    };
    TrapFocus["propTypes"] = exactProp(TrapFocus.propTypes);
    TrapFocus_default = TrapFocus;
  }
});

// node_modules/@mui/base/TrapFocus/index.js
var init_TrapFocus2 = __esm({
  "node_modules/@mui/base/TrapFocus/index.js"() {
    init_TrapFocus();
  }
});

// node_modules/@mui/base/ModalUnstyled/modalUnstyledClasses.js
function getModalUtilityClass(slot) {
  return generateUtilityClass("MuiModal", slot);
}
var modalUnstyledClasses, init_modalUnstyledClasses = __esm({
  "node_modules/@mui/base/ModalUnstyled/modalUnstyledClasses.js"() {
    init_generateUtilityClasses3();
    init_generateUtilityClass3();
    modalUnstyledClasses = generateUtilityClasses("MuiModal", ["root", "hidden"]);
  }
});

// node_modules/@mui/base/ModalUnstyled/ModalUnstyled.js
function getContainer2(container) {
  return typeof container == "function" ? container() : container;
}
function getHasTransition(props) {
  return props.children ? props.children.props.hasOwnProperty("in") : !1;
}
var React15, import_prop_types6, import_jsx_runtime4, import_jsx_runtime5, _excluded4, useUtilityClasses, defaultManager, ModalUnstyled, ModalUnstyled_default, init_ModalUnstyled = __esm({
  "node_modules/@mui/base/ModalUnstyled/ModalUnstyled.js"() {
    init_extends();
    init_objectWithoutPropertiesLoose();
    React15 = __toESM(require_react()), import_prop_types6 = __toESM(require_prop_types());
    init_esm2();
    init_composeClasses3();
    init_Portal2();
    init_ModalManager();
    init_TrapFocus2();
    init_modalUnstyledClasses();
    init_utils2();
    import_jsx_runtime4 = __toESM(require_jsx_runtime()), import_jsx_runtime5 = __toESM(require_jsx_runtime()), _excluded4 = ["children", "classes", "closeAfterTransition", "component", "components", "componentsProps", "container", "disableAutoFocus", "disableEnforceFocus", "disableEscapeKeyDown", "disablePortal", "disableRestoreFocus", "disableScrollLock", "hideBackdrop", "keepMounted", "manager", "onBackdropClick", "onClose", "onKeyDown", "open", "onTransitionEnter", "onTransitionExited"], useUtilityClasses = (ownerState) => {
      let {
        open,
        exited,
        classes
      } = ownerState;
      return composeClasses({
        root: ["root", !open && exited && "hidden"]
      }, getModalUtilityClass, classes);
    };
    defaultManager = new ModalManager(), ModalUnstyled = /* @__PURE__ */ React15.forwardRef(function(props, ref) {
      var _props$ariaHidden;
      let {
        children,
        classes: classesProp,
        closeAfterTransition = !1,
        component = "div",
        components = {},
        componentsProps = {},
        container,
        disableAutoFocus = !1,
        disableEnforceFocus = !1,
        disableEscapeKeyDown = !1,
        disablePortal = !1,
        disableRestoreFocus = !1,
        disableScrollLock = !1,
        hideBackdrop = !1,
        keepMounted = !1,
        manager = defaultManager,
        onBackdropClick,
        onClose,
        onKeyDown,
        open,
        onTransitionEnter,
        onTransitionExited
      } = props, other = _objectWithoutPropertiesLoose2(props, _excluded4), [exited, setExited] = React15.useState(!0), modal = React15.useRef({}), mountNodeRef = React15.useRef(null), modalRef = React15.useRef(null), handleRef = useForkRef(modalRef, ref), hasTransition = getHasTransition(props), ariaHiddenProp = (_props$ariaHidden = props["aria-hidden"]) != null ? _props$ariaHidden : !0, getDoc = () => ownerDocument(mountNodeRef.current), getModal = () => (modal.current.modalRef = modalRef.current, modal.current.mountNode = mountNodeRef.current, modal.current), handleMounted = () => {
        manager.mount(getModal(), {
          disableScrollLock
        }), modalRef.current.scrollTop = 0;
      }, handleOpen = useEventCallback(() => {
        let resolvedContainer = getContainer2(container) || getDoc().body;
        manager.add(getModal(), resolvedContainer), modalRef.current && handleMounted();
      }), isTopModal = React15.useCallback(() => manager.isTopModal(getModal()), [manager]), handlePortalRef = useEventCallback((node) => {
        mountNodeRef.current = node, node && (open && isTopModal() ? handleMounted() : ariaHidden(modalRef.current, ariaHiddenProp));
      }), handleClose = React15.useCallback(() => {
        manager.remove(getModal(), ariaHiddenProp);
      }, [manager, ariaHiddenProp]);
      React15.useEffect(() => () => {
        handleClose();
      }, [handleClose]), React15.useEffect(() => {
        open ? handleOpen() : (!hasTransition || !closeAfterTransition) && handleClose();
      }, [open, handleClose, hasTransition, closeAfterTransition, handleOpen]);
      let ownerState = _extends({}, props, {
        classes: classesProp,
        closeAfterTransition,
        disableAutoFocus,
        disableEnforceFocus,
        disableEscapeKeyDown,
        disablePortal,
        disableRestoreFocus,
        disableScrollLock,
        exited,
        hideBackdrop,
        keepMounted
      }), classes = useUtilityClasses(ownerState), handleEnter = () => {
        setExited(!1), onTransitionEnter && onTransitionEnter();
      }, handleExited = () => {
        setExited(!0), onTransitionExited && onTransitionExited(), closeAfterTransition && handleClose();
      }, handleBackdropClick = (event) => {
        event.target === event.currentTarget && (onBackdropClick && onBackdropClick(event), onClose && onClose(event, "backdropClick"));
      }, handleKeyDown2 = (event) => {
        onKeyDown && onKeyDown(event), !(event.key !== "Escape" || !isTopModal()) && (disableEscapeKeyDown || (event.stopPropagation(), onClose && onClose(event, "escapeKeyDown")));
      }, childProps = {};
      children.props.tabIndex === void 0 && (childProps.tabIndex = "-1"), hasTransition && (childProps.onEnter = createChainedFunction(handleEnter, children.props.onEnter), childProps.onExited = createChainedFunction(handleExited, children.props.onExited));
      let Root = components.Root || component, rootProps = useSlotProps({
        elementType: Root,
        externalSlotProps: componentsProps.root,
        externalForwardedProps: other,
        additionalProps: {
          ref: handleRef,
          role: "presentation",
          onKeyDown: handleKeyDown2
        },
        className: classes.root,
        ownerState
      }), BackdropComponent = components.Backdrop, backdropProps = useSlotProps({
        elementType: BackdropComponent,
        externalSlotProps: componentsProps.backdrop,
        additionalProps: {
          "aria-hidden": !0,
          onClick: handleBackdropClick,
          open
        },
        ownerState
      });
      return !keepMounted && !open && (!hasTransition || exited) ? null : /* @__PURE__ */ (0, import_jsx_runtime4.jsx)(Portal_default, {
        ref: handlePortalRef,
        container,
        disablePortal,
        children: /* @__PURE__ */ (0, import_jsx_runtime5.jsxs)(Root, _extends({}, rootProps, {
          children: [!hideBackdrop && BackdropComponent ? /* @__PURE__ */ (0, import_jsx_runtime4.jsx)(BackdropComponent, _extends({}, backdropProps)) : null, /* @__PURE__ */ (0, import_jsx_runtime4.jsx)(TrapFocus_default, {
            disableEnforceFocus,
            disableAutoFocus,
            disableRestoreFocus,
            isEnabled: isTopModal,
            open,
            children: /* @__PURE__ */ React15.cloneElement(children, childProps)
          })]
        }))
      });
    });
    ModalUnstyled.propTypes = {
      children: elementAcceptingRef_default.isRequired,
      classes: import_prop_types6.default.object,
      closeAfterTransition: import_prop_types6.default.bool,
      component: import_prop_types6.default.elementType,
      components: import_prop_types6.default.shape({
        Backdrop: import_prop_types6.default.elementType,
        Root: import_prop_types6.default.elementType
      }),
      componentsProps: import_prop_types6.default.shape({
        backdrop: import_prop_types6.default.oneOfType([import_prop_types6.default.func, import_prop_types6.default.object]),
        root: import_prop_types6.default.oneOfType([import_prop_types6.default.func, import_prop_types6.default.object])
      }),
      container: import_prop_types6.default.oneOfType([HTMLElementType, import_prop_types6.default.func]),
      disableAutoFocus: import_prop_types6.default.bool,
      disableEnforceFocus: import_prop_types6.default.bool,
      disableEscapeKeyDown: import_prop_types6.default.bool,
      disablePortal: import_prop_types6.default.bool,
      disableRestoreFocus: import_prop_types6.default.bool,
      disableScrollLock: import_prop_types6.default.bool,
      hideBackdrop: import_prop_types6.default.bool,
      keepMounted: import_prop_types6.default.bool,
      onBackdropClick: import_prop_types6.default.func,
      onClose: import_prop_types6.default.func,
      onKeyDown: import_prop_types6.default.func,
      open: import_prop_types6.default.bool.isRequired
    };
    ModalUnstyled_default = ModalUnstyled;
  }
});

// node_modules/@mui/base/ModalUnstyled/index.js
var init_ModalUnstyled2 = __esm({
  "node_modules/@mui/base/ModalUnstyled/index.js"() {
    init_ModalUnstyled();
  }
});

// node_modules/@mui/base/SelectUnstyled/useSelect.types.js
var init_useSelect_types = __esm({
  "node_modules/@mui/base/SelectUnstyled/useSelect.types.js"() {
  }
});

// node_modules/@mui/base/SelectUnstyled/utils.js
var import_react6, init_utils3 = __esm({
  "node_modules/@mui/base/SelectUnstyled/utils.js"() {
    init_extends();
    import_react6 = __toESM(require_react());
  }
});

// node_modules/@mui/base/SelectUnstyled/SelectUnstyledContext.js
var React17, init_SelectUnstyledContext = __esm({
  "node_modules/@mui/base/SelectUnstyled/SelectUnstyledContext.js"() {
    React17 = __toESM(require_react());
  }
});

// node_modules/@mui/base/SelectUnstyled/selectUnstyledClasses.js
var selectUnstyledClasses, init_selectUnstyledClasses = __esm({
  "node_modules/@mui/base/SelectUnstyled/selectUnstyledClasses.js"() {
    init_generateUtilityClasses3();
    selectUnstyledClasses = generateUtilityClasses("MuiSelectUnstyled", ["root", "button", "listbox", "popper", "active", "expanded", "disabled", "focusVisible"]);
  }
});

// node_modules/@mui/base/MultiSelectUnstyled/MultiSelectUnstyled.types.js
var init_MultiSelectUnstyled_types = __esm({
  "node_modules/@mui/base/MultiSelectUnstyled/MultiSelectUnstyled.types.js"() {
  }
});

// node_modules/@mui/base/MultiSelectUnstyled/index.js
var init_MultiSelectUnstyled = __esm({
  "node_modules/@mui/base/MultiSelectUnstyled/index.js"() {
    init_MultiSelectUnstyled_types();
  }
});

// node_modules/@mui/base/OptionGroupUnstyled/optionGroupUnstyledClasses.js
var optionGroupUnstyledClasses, init_optionGroupUnstyledClasses = __esm({
  "node_modules/@mui/base/OptionGroupUnstyled/optionGroupUnstyledClasses.js"() {
    init_generateUtilityClasses3();
    optionGroupUnstyledClasses = generateUtilityClasses("MuiOptionGroupUnstyled", ["root", "label", "list"]);
  }
});

// node_modules/@mui/base/OptionGroupUnstyled/OptionGroupUnstyled.types.js
var init_OptionGroupUnstyled_types = __esm({
  "node_modules/@mui/base/OptionGroupUnstyled/OptionGroupUnstyled.types.js"() {
  }
});

// node_modules/@mui/base/OptionGroupUnstyled/index.js
var init_OptionGroupUnstyled = __esm({
  "node_modules/@mui/base/OptionGroupUnstyled/index.js"() {
    init_OptionGroupUnstyled_types();
    init_optionGroupUnstyledClasses();
  }
});

// node_modules/@mui/base/OptionUnstyled/optionUnstyledClasses.js
var optionUnstyledClasses, init_optionUnstyledClasses = __esm({
  "node_modules/@mui/base/OptionUnstyled/optionUnstyledClasses.js"() {
    init_generateUtilityClasses3();
    optionUnstyledClasses = generateUtilityClasses("MuiOptionUnstyled", ["root", "disabled", "selected", "highlighted"]);
  }
});

// node_modules/@mui/base/OptionUnstyled/OptionUnstyled.types.js
var init_OptionUnstyled_types = __esm({
  "node_modules/@mui/base/OptionUnstyled/OptionUnstyled.types.js"() {
  }
});

// node_modules/@mui/base/OptionUnstyled/index.js
var init_OptionUnstyled = __esm({
  "node_modules/@mui/base/OptionUnstyled/index.js"() {
    init_OptionUnstyled_types();
    init_optionUnstyledClasses();
  }
});

// node_modules/@mui/base/SelectUnstyled/SelectUnstyled.types.js
var init_SelectUnstyled_types = __esm({
  "node_modules/@mui/base/SelectUnstyled/SelectUnstyled.types.js"() {
  }
});

// node_modules/@mui/base/SelectUnstyled/index.js
var init_SelectUnstyled = __esm({
  "node_modules/@mui/base/SelectUnstyled/index.js"() {
    init_SelectUnstyledContext();
    init_selectUnstyledClasses();
    init_SelectUnstyled_types();
    init_useSelect_types();
    init_utils3();
  }
});

// node_modules/@mui/base/SliderUnstyled/sliderUnstyledClasses.js
var sliderUnstyledClasses, init_sliderUnstyledClasses = __esm({
  "node_modules/@mui/base/SliderUnstyled/sliderUnstyledClasses.js"() {
    init_generateUtilityClasses3();
    sliderUnstyledClasses = generateUtilityClasses("MuiSlider", ["root", "active", "focusVisible", "disabled", "dragging", "marked", "vertical", "trackInverted", "trackFalse", "rail", "track", "mark", "markActive", "markLabel", "markLabelActive", "thumb", "valueLabel", "valueLabelOpen", "valueLabelCircle", "valueLabelLabel"]);
  }
});

// node_modules/@mui/base/SliderUnstyled/index.js
var init_SliderUnstyled = __esm({
  "node_modules/@mui/base/SliderUnstyled/index.js"() {
    init_sliderUnstyledClasses();
  }
});

// node_modules/@mui/base/SwitchUnstyled/switchUnstyledClasses.js
var switchUnstyledClasses, init_switchUnstyledClasses = __esm({
  "node_modules/@mui/base/SwitchUnstyled/switchUnstyledClasses.js"() {
    init_generateUtilityClasses3();
    switchUnstyledClasses = generateUtilityClasses("MuiSwitch", ["root", "input", "track", "thumb", "checked", "disabled", "focusVisible", "readOnly"]);
  }
});

// node_modules/@mui/base/SwitchUnstyled/SwitchUnstyled.types.js
var init_SwitchUnstyled_types = __esm({
  "node_modules/@mui/base/SwitchUnstyled/SwitchUnstyled.types.js"() {
  }
});

// node_modules/@mui/base/SwitchUnstyled/useSwitch.types.js
var init_useSwitch_types = __esm({
  "node_modules/@mui/base/SwitchUnstyled/useSwitch.types.js"() {
  }
});

// node_modules/@mui/base/SwitchUnstyled/index.js
var init_SwitchUnstyled = __esm({
  "node_modules/@mui/base/SwitchUnstyled/index.js"() {
    init_SwitchUnstyled_types();
    init_useSwitch_types();
    init_switchUnstyledClasses();
  }
});

// node_modules/@mui/base/TablePaginationUnstyled/tablePaginationUnstyledClasses.js
var tablePaginationClasses, init_tablePaginationUnstyledClasses = __esm({
  "node_modules/@mui/base/TablePaginationUnstyled/tablePaginationUnstyledClasses.js"() {
    init_generateUtilityClasses3();
    tablePaginationClasses = generateUtilityClasses("MuiTablePaginationUnstyled", ["root", "toolbar", "spacer", "selectLabel", "selectRoot", "select", "selectIcon", "input", "menuItem", "displayedRows", "actions"]);
  }
});

// node_modules/@mui/base/TablePaginationUnstyled/TablePaginationUnstyled.types.js
var init_TablePaginationUnstyled_types = __esm({
  "node_modules/@mui/base/TablePaginationUnstyled/TablePaginationUnstyled.types.js"() {
  }
});

// node_modules/@mui/base/TablePaginationUnstyled/TablePaginationActionsUnstyled.types.js
var init_TablePaginationActionsUnstyled_types = __esm({
  "node_modules/@mui/base/TablePaginationUnstyled/TablePaginationActionsUnstyled.types.js"() {
  }
});

// node_modules/@mui/base/TablePaginationUnstyled/index.js
var init_TablePaginationUnstyled = __esm({
  "node_modules/@mui/base/TablePaginationUnstyled/index.js"() {
    init_TablePaginationUnstyled_types();
    init_TablePaginationActionsUnstyled_types();
    init_tablePaginationUnstyledClasses();
  }
});

// node_modules/@mui/base/TabPanelUnstyled/tabPanelUnstyledClasses.js
var tabPanelUnstyledClasses, init_tabPanelUnstyledClasses = __esm({
  "node_modules/@mui/base/TabPanelUnstyled/tabPanelUnstyledClasses.js"() {
    init_generateUtilityClasses3();
    tabPanelUnstyledClasses = generateUtilityClasses("TabPanelUnstyled", ["root", "hidden"]);
  }
});

// node_modules/@mui/base/TabsUnstyled/tabsUnstyledClasses.js
var tabsUnstyledClasses, init_tabsUnstyledClasses = __esm({
  "node_modules/@mui/base/TabsUnstyled/tabsUnstyledClasses.js"() {
    init_generateUtilityClasses3();
    tabsUnstyledClasses = generateUtilityClasses("TabsUnstyled", ["root", "horizontal", "vertical"]);
  }
});

// node_modules/@mui/base/TabsUnstyled/useTabs.js
var React18, init_useTabs = __esm({
  "node_modules/@mui/base/TabsUnstyled/useTabs.js"() {
    React18 = __toESM(require_react());
  }
});

// node_modules/@mui/base/TabsUnstyled/TabsContext.js
var React19, Context, init_TabsContext = __esm({
  "node_modules/@mui/base/TabsUnstyled/TabsContext.js"() {
    React19 = __toESM(require_react()), Context = /* @__PURE__ */ React19.createContext(null);
    Context.displayName = "TabsContext";
  }
});

// node_modules/@mui/base/TabsUnstyled/TabsUnstyled.types.js
var init_TabsUnstyled_types = __esm({
  "node_modules/@mui/base/TabsUnstyled/TabsUnstyled.types.js"() {
  }
});

// node_modules/@mui/base/TabsUnstyled/index.js
var init_TabsUnstyled = __esm({
  "node_modules/@mui/base/TabsUnstyled/index.js"() {
    init_TabsContext();
    init_tabsUnstyledClasses();
    init_TabsUnstyled_types();
    init_useTabs();
  }
});

// node_modules/@mui/base/TabPanelUnstyled/TabPanelUnstyled.types.js
var init_TabPanelUnstyled_types = __esm({
  "node_modules/@mui/base/TabPanelUnstyled/TabPanelUnstyled.types.js"() {
  }
});

// node_modules/@mui/base/TabPanelUnstyled/index.js
var init_TabPanelUnstyled = __esm({
  "node_modules/@mui/base/TabPanelUnstyled/index.js"() {
    init_TabPanelUnstyled_types();
    init_tabPanelUnstyledClasses();
  }
});

// node_modules/@mui/base/TabsListUnstyled/tabsListUnstyledClasses.js
var tabsListUnstyledClasses, init_tabsListUnstyledClasses = __esm({
  "node_modules/@mui/base/TabsListUnstyled/tabsListUnstyledClasses.js"() {
    init_generateUtilityClasses3();
    tabsListUnstyledClasses = generateUtilityClasses("TabsListUnstyled", ["root", "horizontal", "vertical"]);
  }
});

// node_modules/@mui/base/TabsListUnstyled/TabsListUnstyled.types.js
var init_TabsListUnstyled_types = __esm({
  "node_modules/@mui/base/TabsListUnstyled/TabsListUnstyled.types.js"() {
  }
});

// node_modules/@mui/base/TabsListUnstyled/useTabsList.types.js
var init_useTabsList_types = __esm({
  "node_modules/@mui/base/TabsListUnstyled/useTabsList.types.js"() {
  }
});

// node_modules/@mui/base/TabsListUnstyled/index.js
var init_TabsListUnstyled = __esm({
  "node_modules/@mui/base/TabsListUnstyled/index.js"() {
    init_TabsListUnstyled_types();
    init_tabsListUnstyledClasses();
    init_useTabsList_types();
  }
});

// node_modules/@mui/base/TabUnstyled/tabUnstyledClasses.js
var tabUnstyledClasses, init_tabUnstyledClasses = __esm({
  "node_modules/@mui/base/TabUnstyled/tabUnstyledClasses.js"() {
    init_generateUtilityClasses3();
    tabUnstyledClasses = generateUtilityClasses("TabUnstyled", ["root", "selected", "disabled"]);
  }
});

// node_modules/@mui/base/TabUnstyled/TabUnstyled.types.js
var init_TabUnstyled_types = __esm({
  "node_modules/@mui/base/TabUnstyled/TabUnstyled.types.js"() {
  }
});

// node_modules/@mui/base/TabUnstyled/useTab.types.js
var init_useTab_types = __esm({
  "node_modules/@mui/base/TabUnstyled/useTab.types.js"() {
  }
});

// node_modules/@mui/base/TabUnstyled/index.js
var init_TabUnstyled = __esm({
  "node_modules/@mui/base/TabUnstyled/index.js"() {
    init_TabUnstyled_types();
    init_tabUnstyledClasses();
    init_useTab_types();
  }
});

// node_modules/@mui/base/TextareaAutosize/TextareaAutosize.js
function getStyleValue(computedStyle, property) {
  return parseInt(computedStyle[property], 10) || 0;
}
function isEmpty(obj) {
  return obj == null || Object.keys(obj).length === 0;
}
var React20, import_prop_types7, import_react_dom, import_jsx_runtime6, import_jsx_runtime7, _excluded5, styles, TextareaAutosize, TextareaAutosize_default, init_TextareaAutosize = __esm({
  "node_modules/@mui/base/TextareaAutosize/TextareaAutosize.js"() {
    init_extends();
    init_objectWithoutPropertiesLoose();
    React20 = __toESM(require_react()), import_prop_types7 = __toESM(require_prop_types()), import_react_dom = __toESM(require_react_dom());
    init_esm2();
    import_jsx_runtime6 = __toESM(require_jsx_runtime()), import_jsx_runtime7 = __toESM(require_jsx_runtime()), _excluded5 = ["onChange", "maxRows", "minRows", "style", "value"];
    styles = {
      shadow: {
        visibility: "hidden",
        position: "absolute",
        overflow: "hidden",
        height: 0,
        top: 0,
        left: 0,
        transform: "translateZ(0)"
      }
    };
    TextareaAutosize = /* @__PURE__ */ React20.forwardRef(function(props, ref) {
      let {
        onChange,
        maxRows,
        minRows = 1,
        style: style3,
        value
      } = props, other = _objectWithoutPropertiesLoose2(props, _excluded5), {
        current: isControlled
      } = React20.useRef(value != null), inputRef = React20.useRef(null), handleRef = useForkRef(ref, inputRef), shadowRef = React20.useRef(null), renders = React20.useRef(0), [state, setState] = React20.useState({}), getUpdatedState = React20.useCallback(() => {
        let input = inputRef.current, computedStyle = ownerWindow(input).getComputedStyle(input);
        if (computedStyle.width === "0px")
          return {};
        let inputShallow = shadowRef.current;
        inputShallow.style.width = computedStyle.width, inputShallow.value = input.value || props.placeholder || "x", inputShallow.value.slice(-1) === `
` && (inputShallow.value += " ");
        let boxSizing2 = computedStyle["box-sizing"], padding2 = getStyleValue(computedStyle, "padding-bottom") + getStyleValue(computedStyle, "padding-top"), border2 = getStyleValue(computedStyle, "border-bottom-width") + getStyleValue(computedStyle, "border-top-width"), innerHeight = inputShallow.scrollHeight;
        inputShallow.value = "x";
        let singleRowHeight = inputShallow.scrollHeight, outerHeight = innerHeight;
        minRows && (outerHeight = Math.max(Number(minRows) * singleRowHeight, outerHeight)), maxRows && (outerHeight = Math.min(Number(maxRows) * singleRowHeight, outerHeight)), outerHeight = Math.max(outerHeight, singleRowHeight);
        let outerHeightStyle = outerHeight + (boxSizing2 === "border-box" ? padding2 + border2 : 0), overflow2 = Math.abs(outerHeight - innerHeight) <= 1;
        return {
          outerHeightStyle,
          overflow: overflow2
        };
      }, [maxRows, minRows, props.placeholder]), updateState = (prevState, newState) => {
        let {
          outerHeightStyle,
          overflow: overflow2
        } = newState;
        return renders.current < 20 && (outerHeightStyle > 0 && Math.abs((prevState.outerHeightStyle || 0) - outerHeightStyle) > 1 || prevState.overflow !== overflow2) ? (renders.current += 1, {
          overflow: overflow2,
          outerHeightStyle
        }) : (renders.current === 20 && console.error(["MUI: Too many re-renders. The layout is unstable.", "TextareaAutosize limits the number of renders to prevent an infinite loop."].join(`
`)), prevState);
      }, syncHeight = React20.useCallback(() => {
        let newState = getUpdatedState();
        isEmpty(newState) || setState((prevState) => updateState(prevState, newState));
      }, [getUpdatedState]), syncHeightWithFlushSycn = () => {
        let newState = getUpdatedState();
        isEmpty(newState) || (0, import_react_dom.flushSync)(() => {
          setState((prevState) => updateState(prevState, newState));
        });
      };
      return React20.useEffect(() => {
        let handleResize = debounce(() => {
          renders.current = 0, inputRef.current && syncHeightWithFlushSycn();
        }), containerWindow = ownerWindow(inputRef.current);
        containerWindow.addEventListener("resize", handleResize);
        let resizeObserver;
        return typeof ResizeObserver < "u" && (resizeObserver = new ResizeObserver(handleResize), resizeObserver.observe(inputRef.current)), () => {
          handleResize.clear(), containerWindow.removeEventListener("resize", handleResize), resizeObserver && resizeObserver.disconnect();
        };
      }), useEnhancedEffect_default(() => {
        syncHeight();
      }), React20.useEffect(() => {
        renders.current = 0;
      }, [value]), /* @__PURE__ */ (0, import_jsx_runtime7.jsxs)(React20.Fragment, {
        children: [/* @__PURE__ */ (0, import_jsx_runtime6.jsx)("textarea", _extends({
          value,
          onChange: (event) => {
            renders.current = 0, isControlled || syncHeight(), onChange && onChange(event);
          },
          ref: handleRef,
          rows: minRows,
          style: _extends({
            height: state.outerHeightStyle,
            overflow: state.overflow ? "hidden" : null
          }, style3)
        }, other)), /* @__PURE__ */ (0, import_jsx_runtime6.jsx)("textarea", {
          "aria-hidden": !0,
          className: props.className,
          readOnly: !0,
          ref: shadowRef,
          tabIndex: -1,
          style: _extends({}, styles.shadow, style3, {
            padding: 0
          })
        })]
      });
    });
    TextareaAutosize.propTypes = {
      className: import_prop_types7.default.string,
      maxRows: import_prop_types7.default.oneOfType([import_prop_types7.default.number, import_prop_types7.default.string]),
      minRows: import_prop_types7.default.oneOfType([import_prop_types7.default.number, import_prop_types7.default.string]),
      onChange: import_prop_types7.default.func,
      placeholder: import_prop_types7.default.string,
      style: import_prop_types7.default.object,
      value: import_prop_types7.default.oneOfType([import_prop_types7.default.arrayOf(import_prop_types7.default.string), import_prop_types7.default.number, import_prop_types7.default.string])
    };
    TextareaAutosize_default = TextareaAutosize;
  }
});

// node_modules/@mui/base/TextareaAutosize/index.js
var init_TextareaAutosize2 = __esm({
  "node_modules/@mui/base/TextareaAutosize/index.js"() {
    init_TextareaAutosize();
  }
});

// node_modules/@mui/base/index.js
var init_base = __esm({
  "node_modules/@mui/base/index.js"() {
    init_utils2();
    init_AutocompleteUnstyled();
    init_BadgeUnstyled();
    init_ButtonUnstyled();
    init_composeClasses3();
    init_generateUtilityClass3();
    init_generateUtilityClass3();
    init_generateUtilityClasses3();
    init_FormControlUnstyled();
    init_InputUnstyled();
    init_ListboxUnstyled();
    init_MenuUnstyled();
    init_MenuItemUnstyled();
    init_ModalUnstyled2();
    init_MultiSelectUnstyled();
    init_OptionGroupUnstyled();
    init_OptionUnstyled();
    init_SelectUnstyled();
    init_SliderUnstyled();
    init_SwitchUnstyled();
    init_TablePaginationUnstyled();
    init_TabPanelUnstyled();
    init_TabsListUnstyled();
    init_TabsUnstyled();
    init_TabUnstyled();
    init_TextareaAutosize2();
  }
});

// node_modules/@babel/runtime/helpers/extends.js
var require_extends = __commonJS({
  "node_modules/@babel/runtime/helpers/extends.js"(exports, module) {
    function _extends4() {
      return module.exports = _extends4 = Object.assign ? Object.assign.bind() : function(target) {
        for (var i = 1; i < arguments.length; i++) {
          var source = arguments[i];
          for (var key in source)
            Object.prototype.hasOwnProperty.call(source, key) && (target[key] = source[key]);
        }
        return target;
      }, module.exports.__esModule = !0, module.exports.default = module.exports, _extends4.apply(this, arguments);
    }
    module.exports = _extends4, module.exports.__esModule = !0, module.exports.default = module.exports;
  }
});

// node_modules/@emotion/memoize/dist/emotion-memoize.cjs.dev.js
var require_emotion_memoize_cjs_dev = __commonJS({
  "node_modules/@emotion/memoize/dist/emotion-memoize.cjs.dev.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: !0 });
    function memoize2(fn) {
      var cache = /* @__PURE__ */ Object.create(null);
      return function(arg) {
        return cache[arg] === void 0 && (cache[arg] = fn(arg)), cache[arg];
      };
    }
    exports.default = memoize2;
  }
});

// node_modules/@emotion/memoize/dist/emotion-memoize.cjs.js
var require_emotion_memoize_cjs = __commonJS({
  "node_modules/@emotion/memoize/dist/emotion-memoize.cjs.js"(exports, module) {
    "use strict";
    module.exports = require_emotion_memoize_cjs_dev();
  }
});

// node_modules/@emotion/is-prop-valid/dist/emotion-is-prop-valid.cjs.dev.js
var require_emotion_is_prop_valid_cjs_dev = __commonJS({
  "node_modules/@emotion/is-prop-valid/dist/emotion-is-prop-valid.cjs.dev.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: !0 });
    var memoize2 = require_emotion_memoize_cjs();
    function _interopDefault(e) {
      return e && e.__esModule ? e : { default: e };
    }
    var memoize__default = /* @__PURE__ */ _interopDefault(memoize2), reactPropsRegex = /^((children|dangerouslySetInnerHTML|key|ref|autoFocus|defaultValue|defaultChecked|innerHTML|suppressContentEditableWarning|suppressHydrationWarning|valueLink|abbr|accept|acceptCharset|accessKey|action|allow|allowUserMedia|allowPaymentRequest|allowFullScreen|allowTransparency|alt|async|autoComplete|autoPlay|capture|cellPadding|cellSpacing|challenge|charSet|checked|cite|classID|className|cols|colSpan|content|contentEditable|contextMenu|controls|controlsList|coords|crossOrigin|data|dateTime|decoding|default|defer|dir|disabled|disablePictureInPicture|download|draggable|encType|enterKeyHint|form|formAction|formEncType|formMethod|formNoValidate|formTarget|frameBorder|headers|height|hidden|high|href|hrefLang|htmlFor|httpEquiv|id|inputMode|integrity|is|keyParams|keyType|kind|label|lang|list|loading|loop|low|marginHeight|marginWidth|max|maxLength|media|mediaGroup|method|min|minLength|multiple|muted|name|nonce|noValidate|open|optimum|pattern|placeholder|playsInline|poster|preload|profile|radioGroup|readOnly|referrerPolicy|rel|required|reversed|role|rows|rowSpan|sandbox|scope|scoped|scrolling|seamless|selected|shape|size|sizes|slot|span|spellCheck|src|srcDoc|srcLang|srcSet|start|step|style|summary|tabIndex|target|title|translate|type|useMap|value|width|wmode|wrap|about|datatype|inlist|prefix|property|resource|typeof|vocab|autoCapitalize|autoCorrect|autoSave|color|incremental|fallback|inert|itemProp|itemScope|itemType|itemID|itemRef|on|option|results|security|unselectable|accentHeight|accumulate|additive|alignmentBaseline|allowReorder|alphabetic|amplitude|arabicForm|ascent|attributeName|attributeType|autoReverse|azimuth|baseFrequency|baselineShift|baseProfile|bbox|begin|bias|by|calcMode|capHeight|clip|clipPathUnits|clipPath|clipRule|colorInterpolation|colorInterpolationFilters|colorProfile|colorRendering|contentScriptType|contentStyleType|cursor|cx|cy|d|decelerate|descent|diffuseConstant|direction|display|divisor|dominantBaseline|dur|dx|dy|edgeMode|elevation|enableBackground|end|exponent|externalResourcesRequired|fill|fillOpacity|fillRule|filter|filterRes|filterUnits|floodColor|floodOpacity|focusable|fontFamily|fontSize|fontSizeAdjust|fontStretch|fontStyle|fontVariant|fontWeight|format|from|fr|fx|fy|g1|g2|glyphName|glyphOrientationHorizontal|glyphOrientationVertical|glyphRef|gradientTransform|gradientUnits|hanging|horizAdvX|horizOriginX|ideographic|imageRendering|in|in2|intercept|k|k1|k2|k3|k4|kernelMatrix|kernelUnitLength|kerning|keyPoints|keySplines|keyTimes|lengthAdjust|letterSpacing|lightingColor|limitingConeAngle|local|markerEnd|markerMid|markerStart|markerHeight|markerUnits|markerWidth|mask|maskContentUnits|maskUnits|mathematical|mode|numOctaves|offset|opacity|operator|order|orient|orientation|origin|overflow|overlinePosition|overlineThickness|panose1|paintOrder|pathLength|patternContentUnits|patternTransform|patternUnits|pointerEvents|points|pointsAtX|pointsAtY|pointsAtZ|preserveAlpha|preserveAspectRatio|primitiveUnits|r|radius|refX|refY|renderingIntent|repeatCount|repeatDur|requiredExtensions|requiredFeatures|restart|result|rotate|rx|ry|scale|seed|shapeRendering|slope|spacing|specularConstant|specularExponent|speed|spreadMethod|startOffset|stdDeviation|stemh|stemv|stitchTiles|stopColor|stopOpacity|strikethroughPosition|strikethroughThickness|string|stroke|strokeDasharray|strokeDashoffset|strokeLinecap|strokeLinejoin|strokeMiterlimit|strokeOpacity|strokeWidth|surfaceScale|systemLanguage|tableValues|targetX|targetY|textAnchor|textDecoration|textRendering|textLength|to|transform|u1|u2|underlinePosition|underlineThickness|unicode|unicodeBidi|unicodeRange|unitsPerEm|vAlphabetic|vHanging|vIdeographic|vMathematical|values|vectorEffect|version|vertAdvY|vertOriginX|vertOriginY|viewBox|viewTarget|visibility|widths|wordSpacing|writingMode|x|xHeight|x1|x2|xChannelSelector|xlinkActuate|xlinkArcrole|xlinkHref|xlinkRole|xlinkShow|xlinkTitle|xlinkType|xmlBase|xmlns|xmlnsXlink|xmlLang|xmlSpace|y|y1|y2|yChannelSelector|z|zoomAndPan|for|class|autofocus)|(([Dd][Aa][Tt][Aa]|[Aa][Rr][Ii][Aa]|x)-.*))$/, isPropValid = /* @__PURE__ */ memoize__default.default(
      function(prop) {
        return reactPropsRegex.test(prop) || prop.charCodeAt(0) === 111 && prop.charCodeAt(1) === 110 && prop.charCodeAt(2) < 91;
      }
    );
    exports.default = isPropValid;
  }
});

// node_modules/@emotion/is-prop-valid/dist/emotion-is-prop-valid.cjs.js
var require_emotion_is_prop_valid_cjs = __commonJS({
  "node_modules/@emotion/is-prop-valid/dist/emotion-is-prop-valid.cjs.js"(exports, module) {
    "use strict";
    module.exports = require_emotion_is_prop_valid_cjs_dev();
  }
});

// node_modules/@emotion/sheet/dist/emotion-sheet.cjs.dev.js
var require_emotion_sheet_cjs_dev = __commonJS({
  "node_modules/@emotion/sheet/dist/emotion-sheet.cjs.dev.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: !0 });
    function sheetForTag(tag) {
      if (tag.sheet)
        return tag.sheet;
      for (var i = 0; i < document.styleSheets.length; i++)
        if (document.styleSheets[i].ownerNode === tag)
          return document.styleSheets[i];
    }
    function createStyleElement(options) {
      var tag = document.createElement("style");
      return tag.setAttribute("data-emotion", options.key), options.nonce !== void 0 && tag.setAttribute("nonce", options.nonce), tag.appendChild(document.createTextNode("")), tag.setAttribute("data-s", ""), tag;
    }
    var StyleSheet = /* @__PURE__ */ function() {
      function StyleSheet2(options) {
        var _this = this;
        this._insertTag = function(tag) {
          var before;
          _this.tags.length === 0 ? _this.insertionPoint ? before = _this.insertionPoint.nextSibling : _this.prepend ? before = _this.container.firstChild : before = _this.before : before = _this.tags[_this.tags.length - 1].nextSibling, _this.container.insertBefore(tag, before), _this.tags.push(tag);
        }, this.isSpeedy = options.speedy === void 0 ? !1 : options.speedy, this.tags = [], this.ctr = 0, this.nonce = options.nonce, this.key = options.key, this.container = options.container, this.prepend = options.prepend, this.insertionPoint = options.insertionPoint, this.before = null;
      }
      var _proto = StyleSheet2.prototype;
      return _proto.hydrate = function(nodes) {
        nodes.forEach(this._insertTag);
      }, _proto.insert = function(rule) {
        this.ctr % (this.isSpeedy ? 65e3 : 1) === 0 && this._insertTag(createStyleElement(this));
        var tag = this.tags[this.tags.length - 1], isImportRule = rule.charCodeAt(0) === 64 && rule.charCodeAt(1) === 105;
        if (isImportRule && this._alreadyInsertedOrderInsensitiveRule && console.error(`You're attempting to insert the following rule:
` + rule + "\n\n`@import` rules must be before all other types of rules in a stylesheet but other rules have already been inserted. Please ensure that `@import` rules are before all other rules."), this._alreadyInsertedOrderInsensitiveRule = this._alreadyInsertedOrderInsensitiveRule || !isImportRule, this.isSpeedy) {
          var sheet = sheetForTag(tag);
          try {
            sheet.insertRule(rule, sheet.cssRules.length);
          } catch (e) {
            /:(-moz-placeholder|-moz-focus-inner|-moz-focusring|-ms-input-placeholder|-moz-read-write|-moz-read-only|-ms-clear){/.test(rule) || console.error('There was a problem inserting the following rule: "' + rule + '"', e);
          }
        } else
          tag.appendChild(document.createTextNode(rule));
        this.ctr++;
      }, _proto.flush = function() {
        this.tags.forEach(function(tag) {
          return tag.parentNode && tag.parentNode.removeChild(tag);
        }), this.tags = [], this.ctr = 0, this._alreadyInsertedOrderInsensitiveRule = !1;
      }, StyleSheet2;
    }();
    exports.StyleSheet = StyleSheet;
  }
});

// node_modules/@emotion/sheet/dist/emotion-sheet.cjs.js
var require_emotion_sheet_cjs = __commonJS({
  "node_modules/@emotion/sheet/dist/emotion-sheet.cjs.js"(exports, module) {
    "use strict";
    module.exports = require_emotion_sheet_cjs_dev();
  }
});

// node_modules/stylis/dist/umd/stylis.js
var require_stylis = __commonJS({
  "node_modules/stylis/dist/umd/stylis.js"(exports, module) {
    (function(e, r2) {
      typeof exports == "object" && typeof module < "u" ? r2(exports) : typeof define == "function" && define.amd ? define(["exports"], r2) : (e = e || self, r2(e.stylis = {}));
    })(exports, function(e) {
      "use strict";
      var r2 = "-ms-", a = "-moz-", c = "-webkit-", t = "comm", n = "rule", s = "decl", i = "@page", u = "@media", o = "@import", f = "@charset", l = "@viewport", h = "@supports", p = "@document", v = "@namespace", b = "@keyframes", d = "@font-face", m = "@counter-style", w = "@font-feature-values", k = Math.abs, $ = String.fromCharCode, g = Object.assign;
      function x(e2, r3) {
        return (((r3 << 2 ^ O(e2, 0)) << 2 ^ O(e2, 1)) << 2 ^ O(e2, 2)) << 2 ^ O(e2, 3);
      }
      function E(e2) {
        return e2.trim();
      }
      function y(e2, r3) {
        return (e2 = r3.exec(e2)) ? e2[0] : e2;
      }
      function T(e2, r3, a2) {
        return e2.replace(r3, a2);
      }
      function A(e2, r3) {
        return e2.indexOf(r3);
      }
      function O(e2, r3) {
        return e2.charCodeAt(r3) | 0;
      }
      function C(e2, r3, a2) {
        return e2.slice(r3, a2);
      }
      function M(e2) {
        return e2.length;
      }
      function S(e2) {
        return e2.length;
      }
      function R(e2, r3) {
        return r3.push(e2), e2;
      }
      function z(e2, r3) {
        return e2.map(r3).join("");
      }
      e.line = 1, e.column = 1, e.length = 0, e.position = 0, e.character = 0, e.characters = "";
      function N(r3, a2, c2, t2, n2, s2, i2) {
        return { value: r3, root: a2, parent: c2, type: t2, props: n2, children: s2, line: e.line, column: e.column, length: i2, return: "" };
      }
      function P(e2, r3) {
        return g(N("", null, null, "", null, null, 0), e2, { length: -e2.length }, r3);
      }
      function j() {
        return e.character;
      }
      function U() {
        return e.character = e.position > 0 ? O(e.characters, --e.position) : 0, e.column--, e.character === 10 && (e.column = 1, e.line--), e.character;
      }
      function _2() {
        return e.character = e.position < e.length ? O(e.characters, e.position++) : 0, e.column++, e.character === 10 && (e.column = 1, e.line++), e.character;
      }
      function F() {
        return O(e.characters, e.position);
      }
      function I() {
        return e.position;
      }
      function L(r3, a2) {
        return C(e.characters, r3, a2);
      }
      function D(e2) {
        switch (e2) {
          case 0:
          case 9:
          case 10:
          case 13:
          case 32:
            return 5;
          case 33:
          case 43:
          case 44:
          case 47:
          case 62:
          case 64:
          case 126:
          case 59:
          case 123:
          case 125:
            return 4;
          case 58:
            return 3;
          case 34:
          case 39:
          case 40:
          case 91:
            return 2;
          case 41:
          case 93:
            return 1;
        }
        return 0;
      }
      function K(r3) {
        return e.line = e.column = 1, e.length = M(e.characters = r3), e.position = 0, [];
      }
      function V(r3) {
        return e.characters = "", r3;
      }
      function W(r3) {
        return E(L(e.position - 1, Z(r3 === 91 ? r3 + 2 : r3 === 40 ? r3 + 1 : r3)));
      }
      function Y(e2) {
        return V(G(K(e2)));
      }
      function B(r3) {
        for (; (e.character = F()) && e.character < 33; )
          _2();
        return D(r3) > 2 || D(e.character) > 3 ? "" : " ";
      }
      function G(r3) {
        for (; _2(); )
          switch (D(e.character)) {
            case 0:
              R(J(e.position - 1), r3);
              break;
            case 2:
              R(W(e.character), r3);
              break;
            default:
              R($(e.character), r3);
          }
        return r3;
      }
      function H(r3, a2) {
        for (; --a2 && _2() && !(e.character < 48 || e.character > 102 || e.character > 57 && e.character < 65 || e.character > 70 && e.character < 97); )
          ;
        return L(r3, I() + (a2 < 6 && F() == 32 && _2() == 32));
      }
      function Z(r3) {
        for (; _2(); )
          switch (e.character) {
            case r3:
              return e.position;
            case 34:
            case 39:
              r3 !== 34 && r3 !== 39 && Z(e.character);
              break;
            case 40:
              r3 === 41 && Z(r3);
              break;
            case 92:
              _2();
              break;
          }
        return e.position;
      }
      function q(r3, a2) {
        for (; _2() && r3 + e.character !== 47 + 10; )
          if (r3 + e.character === 42 + 42 && F() === 47)
            break;
        return "/*" + L(a2, e.position - 1) + "*" + $(r3 === 47 ? r3 : _2());
      }
      function J(r3) {
        for (; !D(F()); )
          _2();
        return L(r3, e.position);
      }
      function Q(e2) {
        return V(X("", null, null, null, [""], e2 = K(e2), 0, [0], e2));
      }
      function X(e2, r3, a2, c2, t2, n2, s2, i2, u2) {
        for (var o2 = 0, f2 = 0, l2 = s2, h2 = 0, p2 = 0, v2 = 0, b2 = 1, d2 = 1, m2 = 1, w2 = 0, k2 = "", g2 = t2, x2 = n2, E2 = c2, y2 = k2; d2; )
          switch (v2 = w2, w2 = _2()) {
            case 40:
              if (v2 != 108 && y2.charCodeAt(l2 - 1) == 58) {
                A(y2 += T(W(w2), "&", "&\f"), "&\f") != -1 && (m2 = -1);
                break;
              }
            case 34:
            case 39:
            case 91:
              y2 += W(w2);
              break;
            case 9:
            case 10:
            case 13:
            case 32:
              y2 += B(v2);
              break;
            case 92:
              y2 += H(I() - 1, 7);
              continue;
            case 47:
              switch (F()) {
                case 42:
                case 47:
                  R(re(q(_2(), I()), r3, a2), u2);
                  break;
                default:
                  y2 += "/";
              }
              break;
            case 123 * b2:
              i2[o2++] = M(y2) * m2;
            case 125 * b2:
            case 59:
            case 0:
              switch (w2) {
                case 0:
                case 125:
                  d2 = 0;
                case 59 + f2:
                  p2 > 0 && M(y2) - l2 && R(p2 > 32 ? ae(y2 + ";", c2, a2, l2 - 1) : ae(T(y2, " ", "") + ";", c2, a2, l2 - 2), u2);
                  break;
                case 59:
                  y2 += ";";
                default:
                  if (R(E2 = ee(y2, r3, a2, o2, f2, t2, i2, k2, g2 = [], x2 = [], l2), n2), w2 === 123)
                    if (f2 === 0)
                      X(y2, r3, E2, E2, g2, n2, l2, i2, x2);
                    else
                      switch (h2) {
                        case 100:
                        case 109:
                        case 115:
                          X(e2, E2, E2, c2 && R(ee(e2, E2, E2, 0, 0, t2, i2, k2, t2, g2 = [], l2), x2), t2, x2, l2, i2, c2 ? g2 : x2);
                          break;
                        default:
                          X(y2, E2, E2, E2, [""], x2, 0, i2, x2);
                      }
              }
              o2 = f2 = p2 = 0, b2 = m2 = 1, k2 = y2 = "", l2 = s2;
              break;
            case 58:
              l2 = 1 + M(y2), p2 = v2;
            default:
              if (b2 < 1) {
                if (w2 == 123)
                  --b2;
                else if (w2 == 125 && b2++ == 0 && U() == 125)
                  continue;
              }
              switch (y2 += $(w2), w2 * b2) {
                case 38:
                  m2 = f2 > 0 ? 1 : (y2 += "\f", -1);
                  break;
                case 44:
                  i2[o2++] = (M(y2) - 1) * m2, m2 = 1;
                  break;
                case 64:
                  F() === 45 && (y2 += W(_2())), h2 = F(), f2 = l2 = M(k2 = y2 += J(I())), w2++;
                  break;
                case 45:
                  v2 === 45 && M(y2) == 2 && (b2 = 0);
              }
          }
        return n2;
      }
      function ee(e2, r3, a2, c2, t2, s2, i2, u2, o2, f2, l2) {
        for (var h2 = t2 - 1, p2 = t2 === 0 ? s2 : [""], v2 = S(p2), b2 = 0, d2 = 0, m2 = 0; b2 < c2; ++b2)
          for (var w2 = 0, $2 = C(e2, h2 + 1, h2 = k(d2 = i2[b2])), g2 = e2; w2 < v2; ++w2)
            (g2 = E(d2 > 0 ? p2[w2] + " " + $2 : T($2, /&\f/g, p2[w2]))) && (o2[m2++] = g2);
        return N(e2, r3, a2, t2 === 0 ? n : u2, o2, f2, l2);
      }
      function re(e2, r3, a2) {
        return N(e2, r3, a2, t, $(j()), C(e2, 2, -2), 0);
      }
      function ae(e2, r3, a2, c2) {
        return N(e2, r3, a2, s, C(e2, 0, c2), C(e2, c2 + 1, -1), c2);
      }
      function ce(e2, t2) {
        switch (x(e2, t2)) {
          case 5103:
            return c + "print-" + e2 + e2;
          case 5737:
          case 4201:
          case 3177:
          case 3433:
          case 1641:
          case 4457:
          case 2921:
          case 5572:
          case 6356:
          case 5844:
          case 3191:
          case 6645:
          case 3005:
          case 6391:
          case 5879:
          case 5623:
          case 6135:
          case 4599:
          case 4855:
          case 4215:
          case 6389:
          case 5109:
          case 5365:
          case 5621:
          case 3829:
            return c + e2 + e2;
          case 5349:
          case 4246:
          case 4810:
          case 6968:
          case 2756:
            return c + e2 + a + e2 + r2 + e2 + e2;
          case 6828:
          case 4268:
            return c + e2 + r2 + e2 + e2;
          case 6165:
            return c + e2 + r2 + "flex-" + e2 + e2;
          case 5187:
            return c + e2 + T(e2, /(\w+).+(:[^]+)/, c + "box-$1$2" + r2 + "flex-$1$2") + e2;
          case 5443:
            return c + e2 + r2 + "flex-item-" + T(e2, /flex-|-self/, "") + e2;
          case 4675:
            return c + e2 + r2 + "flex-line-pack" + T(e2, /align-content|flex-|-self/, "") + e2;
          case 5548:
            return c + e2 + r2 + T(e2, "shrink", "negative") + e2;
          case 5292:
            return c + e2 + r2 + T(e2, "basis", "preferred-size") + e2;
          case 6060:
            return c + "box-" + T(e2, "-grow", "") + c + e2 + r2 + T(e2, "grow", "positive") + e2;
          case 4554:
            return c + T(e2, /([^-])(transform)/g, "$1" + c + "$2") + e2;
          case 6187:
            return T(T(T(e2, /(zoom-|grab)/, c + "$1"), /(image-set)/, c + "$1"), e2, "") + e2;
          case 5495:
          case 3959:
            return T(e2, /(image-set\([^]*)/, c + "$1$`$1");
          case 4968:
            return T(T(e2, /(.+:)(flex-)?(.*)/, c + "box-pack:$3" + r2 + "flex-pack:$3"), /s.+-b[^;]+/, "justify") + c + e2 + e2;
          case 4095:
          case 3583:
          case 4068:
          case 2532:
            return T(e2, /(.+)-inline(.+)/, c + "$1$2") + e2;
          case 8116:
          case 7059:
          case 5753:
          case 5535:
          case 5445:
          case 5701:
          case 4933:
          case 4677:
          case 5533:
          case 5789:
          case 5021:
          case 4765:
            if (M(e2) - 1 - t2 > 6)
              switch (O(e2, t2 + 1)) {
                case 109:
                  if (O(e2, t2 + 4) !== 45)
                    break;
                case 102:
                  return T(e2, /(.+:)(.+)-([^]+)/, "$1" + c + "$2-$3$1" + a + (O(e2, t2 + 3) == 108 ? "$3" : "$2-$3")) + e2;
                case 115:
                  return ~A(e2, "stretch") ? ce(T(e2, "stretch", "fill-available"), t2) + e2 : e2;
              }
            break;
          case 4949:
            if (O(e2, t2 + 1) !== 115)
              break;
          case 6444:
            switch (O(e2, M(e2) - 3 - (~A(e2, "!important") && 10))) {
              case 107:
                return T(e2, ":", ":" + c) + e2;
              case 101:
                return T(e2, /(.+:)([^;!]+)(;|!.+)?/, "$1" + c + (O(e2, 14) === 45 ? "inline-" : "") + "box$3$1" + c + "$2$3$1" + r2 + "$2box$3") + e2;
            }
            break;
          case 5936:
            switch (O(e2, t2 + 11)) {
              case 114:
                return c + e2 + r2 + T(e2, /[svh]\w+-[tblr]{2}/, "tb") + e2;
              case 108:
                return c + e2 + r2 + T(e2, /[svh]\w+-[tblr]{2}/, "tb-rl") + e2;
              case 45:
                return c + e2 + r2 + T(e2, /[svh]\w+-[tblr]{2}/, "lr") + e2;
            }
            return c + e2 + r2 + e2 + e2;
        }
        return e2;
      }
      function te(e2, r3) {
        for (var a2 = "", c2 = S(e2), t2 = 0; t2 < c2; t2++)
          a2 += r3(e2[t2], t2, e2, r3) || "";
        return a2;
      }
      function ne(e2, r3, a2, c2) {
        switch (e2.type) {
          case o:
          case s:
            return e2.return = e2.return || e2.value;
          case t:
            return "";
          case b:
            return e2.return = e2.value + "{" + te(e2.children, c2) + "}";
          case n:
            e2.value = e2.props.join(",");
        }
        return M(a2 = te(e2.children, c2)) ? e2.return = e2.value + "{" + a2 + "}" : "";
      }
      function se(e2) {
        var r3 = S(e2);
        return function(a2, c2, t2, n2) {
          for (var s2 = "", i2 = 0; i2 < r3; i2++)
            s2 += e2[i2](a2, c2, t2, n2) || "";
          return s2;
        };
      }
      function ie(e2) {
        return function(r3) {
          r3.root || (r3 = r3.return) && e2(r3);
        };
      }
      function ue(e2, t2, i2, u2) {
        if (e2.length > -1 && !e2.return)
          switch (e2.type) {
            case s:
              e2.return = ce(e2.value, e2.length);
              break;
            case b:
              return te([P(e2, { value: T(e2.value, "@", "@" + c) })], u2);
            case n:
              if (e2.length)
                return z(e2.props, function(t3) {
                  switch (y(t3, /(::plac\w+|:read-\w+)/)) {
                    case ":read-only":
                    case ":read-write":
                      return te([P(e2, { props: [T(t3, /:(read-\w+)/, ":" + a + "$1")] })], u2);
                    case "::placeholder":
                      return te([P(e2, { props: [T(t3, /:(plac\w+)/, ":" + c + "input-$1")] }), P(e2, { props: [T(t3, /:(plac\w+)/, ":" + a + "$1")] }), P(e2, { props: [T(t3, /:(plac\w+)/, r2 + "input-$1")] })], u2);
                  }
                  return "";
                });
          }
      }
      function oe(e2) {
        switch (e2.type) {
          case n:
            e2.props = e2.props.map(function(r3) {
              return z(Y(r3), function(r4, a2, c2) {
                switch (O(r4, 0)) {
                  case 12:
                    return C(r4, 1, M(r4));
                  case 0:
                  case 40:
                  case 43:
                  case 62:
                  case 126:
                    return r4;
                  case 58:
                    c2[++a2] === "global" && (c2[a2] = "", c2[++a2] = "\f" + C(c2[a2], a2 = 1, -1));
                  case 32:
                    return a2 === 1 ? "" : r4;
                  default:
                    switch (a2) {
                      case 0:
                        return e2 = r4, S(c2) > 1 ? "" : r4;
                      case (a2 = S(c2) - 1):
                      case 2:
                        return a2 === 2 ? r4 + e2 + e2 : r4 + e2;
                      default:
                        return r4;
                    }
                }
              });
            });
        }
      }
      e.CHARSET = f, e.COMMENT = t, e.COUNTER_STYLE = m, e.DECLARATION = s, e.DOCUMENT = p, e.FONT_FACE = d, e.FONT_FEATURE_VALUES = w, e.IMPORT = o, e.KEYFRAMES = b, e.MEDIA = u, e.MOZ = a, e.MS = r2, e.NAMESPACE = v, e.PAGE = i, e.RULESET = n, e.SUPPORTS = h, e.VIEWPORT = l, e.WEBKIT = c, e.abs = k, e.alloc = K, e.append = R, e.assign = g, e.caret = I, e.char = j, e.charat = O, e.combine = z, e.comment = re, e.commenter = q, e.compile = Q, e.copy = P, e.dealloc = V, e.declaration = ae, e.delimit = W, e.delimiter = Z, e.escaping = H, e.from = $, e.hash = x, e.identifier = J, e.indexof = A, e.match = y, e.middleware = se, e.namespace = oe, e.next = _2, e.node = N, e.parse = X, e.peek = F, e.prefix = ce, e.prefixer = ue, e.prev = U, e.replace = T, e.ruleset = ee, e.rulesheet = ie, e.serialize = te, e.sizeof = S, e.slice = L, e.stringify = ne, e.strlen = M, e.substr = C, e.token = D, e.tokenize = Y, e.tokenizer = G, e.trim = E, e.whitespace = B, Object.defineProperty(e, "__esModule", { value: !0 });
    });
  }
});

// node_modules/@emotion/weak-memoize/dist/emotion-weak-memoize.cjs.dev.js
var require_emotion_weak_memoize_cjs_dev = __commonJS({
  "node_modules/@emotion/weak-memoize/dist/emotion-weak-memoize.cjs.dev.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: !0 });
    var weakMemoize = function(func) {
      var cache = /* @__PURE__ */ new WeakMap();
      return function(arg) {
        if (cache.has(arg))
          return cache.get(arg);
        var ret = func(arg);
        return cache.set(arg, ret), ret;
      };
    };
    exports.default = weakMemoize;
  }
});

// node_modules/@emotion/weak-memoize/dist/emotion-weak-memoize.cjs.js
var require_emotion_weak_memoize_cjs = __commonJS({
  "node_modules/@emotion/weak-memoize/dist/emotion-weak-memoize.cjs.js"(exports, module) {
    "use strict";
    module.exports = require_emotion_weak_memoize_cjs_dev();
  }
});

// node_modules/@emotion/cache/dist/emotion-cache.cjs.dev.js
var require_emotion_cache_cjs_dev = __commonJS({
  "node_modules/@emotion/cache/dist/emotion-cache.cjs.dev.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: !0 });
    var sheet = require_emotion_sheet_cjs(), stylis = require_stylis(), weakMemoize = require_emotion_weak_memoize_cjs(), memoize2 = require_emotion_memoize_cjs();
    function _interopDefault(e) {
      return e && e.__esModule ? e : { default: e };
    }
    var weakMemoize__default = /* @__PURE__ */ _interopDefault(weakMemoize), memoize__default = /* @__PURE__ */ _interopDefault(memoize2), identifierWithPointTracking = function(begin, points, index) {
      for (var previous = 0, character = 0; previous = character, character = stylis.peek(), previous === 38 && character === 12 && (points[index] = 1), !stylis.token(character); )
        stylis.next();
      return stylis.slice(begin, stylis.position);
    }, toRules = function(parsed, points) {
      var index = -1, character = 44;
      do
        switch (stylis.token(character)) {
          case 0:
            character === 38 && stylis.peek() === 12 && (points[index] = 1), parsed[index] += identifierWithPointTracking(stylis.position - 1, points, index);
            break;
          case 2:
            parsed[index] += stylis.delimit(character);
            break;
          case 4:
            if (character === 44) {
              parsed[++index] = stylis.peek() === 58 ? "&\f" : "", points[index] = parsed[index].length;
              break;
            }
          default:
            parsed[index] += stylis.from(character);
        }
      while (character = stylis.next());
      return parsed;
    }, getRules = function(value, points) {
      return stylis.dealloc(toRules(stylis.alloc(value), points));
    }, fixedElements = /* @__PURE__ */ new WeakMap(), compat = function(element) {
      if (!(element.type !== "rule" || !element.parent || element.length < 1)) {
        for (var value = element.value, parent = element.parent, isImplicitRule = element.column === parent.column && element.line === parent.line; parent.type !== "rule"; )
          if (parent = parent.parent, !parent)
            return;
        if (!(element.props.length === 1 && value.charCodeAt(0) !== 58 && !fixedElements.get(parent)) && !isImplicitRule) {
          fixedElements.set(element, !0);
          for (var points = [], rules = getRules(value, points), parentRules = parent.props, i = 0, k = 0; i < rules.length; i++)
            for (var j = 0; j < parentRules.length; j++, k++)
              element.props[k] = points[i] ? rules[i].replace(/&\f/g, parentRules[j]) : parentRules[j] + " " + rules[i];
        }
      }
    }, removeLabel = function(element) {
      if (element.type === "decl") {
        var value = element.value;
        value.charCodeAt(0) === 108 && value.charCodeAt(2) === 98 && (element.return = "", element.value = "");
      }
    }, ignoreFlag = "emotion-disable-server-rendering-unsafe-selector-warning-please-do-not-use-this-the-warning-exists-for-a-reason", isIgnoringComment = function(element) {
      return element.type === "comm" && element.children.indexOf(ignoreFlag) > -1;
    }, createUnsafeSelectorsAlarm = function(cache) {
      return function(element, index, children) {
        if (!(element.type !== "rule" || cache.compat)) {
          var unsafePseudoClasses = element.value.match(/(:first|:nth|:nth-last)-child/g);
          if (unsafePseudoClasses) {
            for (var isNested = element.parent === children[0], commentContainer = isNested ? children[0].children : children, i = commentContainer.length - 1; i >= 0; i--) {
              var node = commentContainer[i];
              if (node.line < element.line)
                break;
              if (node.column < element.column) {
                if (isIgnoringComment(node))
                  return;
                break;
              }
            }
            unsafePseudoClasses.forEach(function(unsafePseudoClass) {
              console.error('The pseudo class "' + unsafePseudoClass + '" is potentially unsafe when doing server-side rendering. Try changing it to "' + unsafePseudoClass.split("-child")[0] + '-of-type".');
            });
          }
        }
      };
    }, isImportRule = function(element) {
      return element.type.charCodeAt(1) === 105 && element.type.charCodeAt(0) === 64;
    }, isPrependedWithRegularRules = function(index, children) {
      for (var i = index - 1; i >= 0; i--)
        if (!isImportRule(children[i]))
          return !0;
      return !1;
    }, nullifyElement = function(element) {
      element.type = "", element.value = "", element.return = "", element.children = "", element.props = "";
    }, incorrectImportAlarm = function(element, index, children) {
      !isImportRule(element) || (element.parent ? (console.error("`@import` rules can't be nested inside other rules. Please move it to the top level and put it before regular rules. Keep in mind that they can only be used within global styles."), nullifyElement(element)) : isPrependedWithRegularRules(index, children) && (console.error("`@import` rules can't be after other rules. Please put your `@import` rules before your other rules."), nullifyElement(element)));
    }, isBrowser = typeof document < "u", getServerStylisCache = isBrowser ? void 0 : weakMemoize__default.default(function() {
      return memoize__default.default(function() {
        var cache = {};
        return function(name) {
          return cache[name];
        };
      });
    }), defaultStylisPlugins = [stylis.prefixer], createCache = function(options) {
      var key = options.key;
      if (!key)
        throw new Error(`You have to configure \`key\` for your cache. Please make sure it's unique (and not equal to 'css') as it's used for linking styles to your cache.
If multiple caches share the same key they might "fight" for each other's style elements.`);
      if (isBrowser && key === "css") {
        var ssrStyles = document.querySelectorAll("style[data-emotion]:not([data-s])");
        Array.prototype.forEach.call(ssrStyles, function(node) {
          var dataEmotionAttribute = node.getAttribute("data-emotion");
          dataEmotionAttribute.indexOf(" ") !== -1 && (document.head.appendChild(node), node.setAttribute("data-s", ""));
        });
      }
      var stylisPlugins = options.stylisPlugins || defaultStylisPlugins;
      if (/[^a-z-]/.test(key))
        throw new Error('Emotion key must only contain lower case alphabetical characters and - but "' + key + '" was passed');
      var inserted = {}, container, nodesToHydrate = [];
      isBrowser && (container = options.container || document.head, Array.prototype.forEach.call(
        document.querySelectorAll('style[data-emotion^="' + key + ' "]'),
        function(node) {
          for (var attrib = node.getAttribute("data-emotion").split(" "), i = 1; i < attrib.length; i++)
            inserted[attrib[i]] = !0;
          nodesToHydrate.push(node);
        }
      ));
      var _insert, omnipresentPlugins = [compat, removeLabel];
      if (omnipresentPlugins.push(createUnsafeSelectorsAlarm({
        get compat() {
          return cache.compat;
        }
      }), incorrectImportAlarm), isBrowser) {
        var currentSheet, finalizingPlugins = [stylis.stringify, function(element) {
          element.root || (element.return ? currentSheet.insert(element.return) : element.value && element.type !== stylis.COMMENT && currentSheet.insert(element.value + "{}"));
        }], serializer = stylis.middleware(omnipresentPlugins.concat(stylisPlugins, finalizingPlugins)), stylis$1 = function(styles4) {
          return stylis.serialize(stylis.compile(styles4), serializer);
        };
        _insert = function(selector, serialized, sheet2, shouldCache) {
          currentSheet = sheet2, serialized.map !== void 0 && (currentSheet = {
            insert: function(rule) {
              sheet2.insert(rule + serialized.map);
            }
          }), stylis$1(selector ? selector + "{" + serialized.styles + "}" : serialized.styles), shouldCache && (cache.inserted[serialized.name] = !0);
        };
      } else {
        var _finalizingPlugins = [stylis.stringify], _serializer = stylis.middleware(omnipresentPlugins.concat(stylisPlugins, _finalizingPlugins)), _stylis = function(styles4) {
          return stylis.serialize(stylis.compile(styles4), _serializer);
        }, serverStylisCache = getServerStylisCache(stylisPlugins)(key), getRules2 = function(selector, serialized) {
          var name = serialized.name;
          return serverStylisCache[name] === void 0 && (serverStylisCache[name] = _stylis(selector ? selector + "{" + serialized.styles + "}" : serialized.styles)), serverStylisCache[name];
        };
        _insert = function(selector, serialized, sheet2, shouldCache) {
          var name = serialized.name, rules = getRules2(selector, serialized);
          if (cache.compat === void 0)
            return shouldCache && (cache.inserted[name] = !0), serialized.map !== void 0 ? rules + serialized.map : rules;
          if (shouldCache)
            cache.inserted[name] = rules;
          else
            return rules;
        };
      }
      var cache = {
        key,
        sheet: new sheet.StyleSheet({
          key,
          container,
          nonce: options.nonce,
          speedy: options.speedy,
          prepend: options.prepend,
          insertionPoint: options.insertionPoint
        }),
        nonce: options.nonce,
        inserted,
        registered: {},
        insert: _insert
      };
      return cache.sheet.hydrate(nodesToHydrate), cache;
    };
    exports.default = createCache;
  }
});

// node_modules/@emotion/cache/dist/emotion-cache.cjs.js
var require_emotion_cache_cjs = __commonJS({
  "node_modules/@emotion/cache/dist/emotion-cache.cjs.js"(exports, module) {
    "use strict";
    module.exports = require_emotion_cache_cjs_dev();
  }
});

// node_modules/hoist-non-react-statics/node_modules/react-is/cjs/react-is.development.js
var require_react_is_development3 = __commonJS({
  "node_modules/hoist-non-react-statics/node_modules/react-is/cjs/react-is.development.js"(exports) {
    "use strict";
    (function() {
      "use strict";
      var hasSymbol = typeof Symbol == "function" && Symbol.for, REACT_ELEMENT_TYPE = hasSymbol ? Symbol.for("react.element") : 60103, REACT_PORTAL_TYPE = hasSymbol ? Symbol.for("react.portal") : 60106, REACT_FRAGMENT_TYPE = hasSymbol ? Symbol.for("react.fragment") : 60107, REACT_STRICT_MODE_TYPE = hasSymbol ? Symbol.for("react.strict_mode") : 60108, REACT_PROFILER_TYPE = hasSymbol ? Symbol.for("react.profiler") : 60114, REACT_PROVIDER_TYPE = hasSymbol ? Symbol.for("react.provider") : 60109, REACT_CONTEXT_TYPE = hasSymbol ? Symbol.for("react.context") : 60110, REACT_ASYNC_MODE_TYPE = hasSymbol ? Symbol.for("react.async_mode") : 60111, REACT_CONCURRENT_MODE_TYPE = hasSymbol ? Symbol.for("react.concurrent_mode") : 60111, REACT_FORWARD_REF_TYPE = hasSymbol ? Symbol.for("react.forward_ref") : 60112, REACT_SUSPENSE_TYPE = hasSymbol ? Symbol.for("react.suspense") : 60113, REACT_SUSPENSE_LIST_TYPE = hasSymbol ? Symbol.for("react.suspense_list") : 60120, REACT_MEMO_TYPE = hasSymbol ? Symbol.for("react.memo") : 60115, REACT_LAZY_TYPE = hasSymbol ? Symbol.for("react.lazy") : 60116, REACT_BLOCK_TYPE = hasSymbol ? Symbol.for("react.block") : 60121, REACT_FUNDAMENTAL_TYPE = hasSymbol ? Symbol.for("react.fundamental") : 60117, REACT_RESPONDER_TYPE = hasSymbol ? Symbol.for("react.responder") : 60118, REACT_SCOPE_TYPE = hasSymbol ? Symbol.for("react.scope") : 60119;
      function isValidElementType(type) {
        return typeof type == "string" || typeof type == "function" || type === REACT_FRAGMENT_TYPE || type === REACT_CONCURRENT_MODE_TYPE || type === REACT_PROFILER_TYPE || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || typeof type == "object" && type !== null && (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_PROVIDER_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE || type.$$typeof === REACT_FUNDAMENTAL_TYPE || type.$$typeof === REACT_RESPONDER_TYPE || type.$$typeof === REACT_SCOPE_TYPE || type.$$typeof === REACT_BLOCK_TYPE);
      }
      function typeOf(object) {
        if (typeof object == "object" && object !== null) {
          var $$typeof = object.$$typeof;
          switch ($$typeof) {
            case REACT_ELEMENT_TYPE:
              var type = object.type;
              switch (type) {
                case REACT_ASYNC_MODE_TYPE:
                case REACT_CONCURRENT_MODE_TYPE:
                case REACT_FRAGMENT_TYPE:
                case REACT_PROFILER_TYPE:
                case REACT_STRICT_MODE_TYPE:
                case REACT_SUSPENSE_TYPE:
                  return type;
                default:
                  var $$typeofType = type && type.$$typeof;
                  switch ($$typeofType) {
                    case REACT_CONTEXT_TYPE:
                    case REACT_FORWARD_REF_TYPE:
                    case REACT_LAZY_TYPE:
                    case REACT_MEMO_TYPE:
                    case REACT_PROVIDER_TYPE:
                      return $$typeofType;
                    default:
                      return $$typeof;
                  }
              }
            case REACT_PORTAL_TYPE:
              return $$typeof;
          }
        }
      }
      var AsyncMode = REACT_ASYNC_MODE_TYPE, ConcurrentMode = REACT_CONCURRENT_MODE_TYPE, ContextConsumer = REACT_CONTEXT_TYPE, ContextProvider = REACT_PROVIDER_TYPE, Element2 = REACT_ELEMENT_TYPE, ForwardRef2 = REACT_FORWARD_REF_TYPE, Fragment11 = REACT_FRAGMENT_TYPE, Lazy = REACT_LAZY_TYPE, Memo2 = REACT_MEMO_TYPE, Portal3 = REACT_PORTAL_TYPE, Profiler = REACT_PROFILER_TYPE, StrictMode = REACT_STRICT_MODE_TYPE, Suspense = REACT_SUSPENSE_TYPE, hasWarnedAboutDeprecatedIsAsyncMode = !1;
      function isAsyncMode(object) {
        return hasWarnedAboutDeprecatedIsAsyncMode || (hasWarnedAboutDeprecatedIsAsyncMode = !0, console.warn("The ReactIs.isAsyncMode() alias has been deprecated, and will be removed in React 17+. Update your code to use ReactIs.isConcurrentMode() instead. It has the exact same API.")), isConcurrentMode(object) || typeOf(object) === REACT_ASYNC_MODE_TYPE;
      }
      function isConcurrentMode(object) {
        return typeOf(object) === REACT_CONCURRENT_MODE_TYPE;
      }
      function isContextConsumer(object) {
        return typeOf(object) === REACT_CONTEXT_TYPE;
      }
      function isContextProvider(object) {
        return typeOf(object) === REACT_PROVIDER_TYPE;
      }
      function isElement(object) {
        return typeof object == "object" && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;
      }
      function isForwardRef(object) {
        return typeOf(object) === REACT_FORWARD_REF_TYPE;
      }
      function isFragment4(object) {
        return typeOf(object) === REACT_FRAGMENT_TYPE;
      }
      function isLazy(object) {
        return typeOf(object) === REACT_LAZY_TYPE;
      }
      function isMemo(object) {
        return typeOf(object) === REACT_MEMO_TYPE;
      }
      function isPortal(object) {
        return typeOf(object) === REACT_PORTAL_TYPE;
      }
      function isProfiler(object) {
        return typeOf(object) === REACT_PROFILER_TYPE;
      }
      function isStrictMode(object) {
        return typeOf(object) === REACT_STRICT_MODE_TYPE;
      }
      function isSuspense(object) {
        return typeOf(object) === REACT_SUSPENSE_TYPE;
      }
      exports.AsyncMode = AsyncMode, exports.ConcurrentMode = ConcurrentMode, exports.ContextConsumer = ContextConsumer, exports.ContextProvider = ContextProvider, exports.Element = Element2, exports.ForwardRef = ForwardRef2, exports.Fragment = Fragment11, exports.Lazy = Lazy, exports.Memo = Memo2, exports.Portal = Portal3, exports.Profiler = Profiler, exports.StrictMode = StrictMode, exports.Suspense = Suspense, exports.isAsyncMode = isAsyncMode, exports.isConcurrentMode = isConcurrentMode, exports.isContextConsumer = isContextConsumer, exports.isContextProvider = isContextProvider, exports.isElement = isElement, exports.isForwardRef = isForwardRef, exports.isFragment = isFragment4, exports.isLazy = isLazy, exports.isMemo = isMemo, exports.isPortal = isPortal, exports.isProfiler = isProfiler, exports.isStrictMode = isStrictMode, exports.isSuspense = isSuspense, exports.isValidElementType = isValidElementType, exports.typeOf = typeOf;
    })();
  }
});

// node_modules/hoist-non-react-statics/node_modules/react-is/index.js
var require_react_is3 = __commonJS({
  "node_modules/hoist-non-react-statics/node_modules/react-is/index.js"(exports, module) {
    "use strict";
    module.exports = require_react_is_development3();
  }
});

// node_modules/hoist-non-react-statics/dist/hoist-non-react-statics.cjs.js
var require_hoist_non_react_statics_cjs = __commonJS({
  "node_modules/hoist-non-react-statics/dist/hoist-non-react-statics.cjs.js"(exports, module) {
    "use strict";
    var reactIs = require_react_is3(), REACT_STATICS = {
      childContextTypes: !0,
      contextType: !0,
      contextTypes: !0,
      defaultProps: !0,
      displayName: !0,
      getDefaultProps: !0,
      getDerivedStateFromError: !0,
      getDerivedStateFromProps: !0,
      mixins: !0,
      propTypes: !0,
      type: !0
    }, KNOWN_STATICS = {
      name: !0,
      length: !0,
      prototype: !0,
      caller: !0,
      callee: !0,
      arguments: !0,
      arity: !0
    }, FORWARD_REF_STATICS = {
      $$typeof: !0,
      render: !0,
      defaultProps: !0,
      displayName: !0,
      propTypes: !0
    }, MEMO_STATICS = {
      $$typeof: !0,
      compare: !0,
      defaultProps: !0,
      displayName: !0,
      propTypes: !0,
      type: !0
    }, TYPE_STATICS = {};
    TYPE_STATICS[reactIs.ForwardRef] = FORWARD_REF_STATICS;
    TYPE_STATICS[reactIs.Memo] = MEMO_STATICS;
    function getStatics(component) {
      return reactIs.isMemo(component) ? MEMO_STATICS : TYPE_STATICS[component.$$typeof] || REACT_STATICS;
    }
    var defineProperty = Object.defineProperty, getOwnPropertyNames = Object.getOwnPropertyNames, getOwnPropertySymbols = Object.getOwnPropertySymbols, getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor, getPrototypeOf = Object.getPrototypeOf, objectPrototype = Object.prototype;
    function hoistNonReactStatics(targetComponent, sourceComponent, blacklist) {
      if (typeof sourceComponent != "string") {
        if (objectPrototype) {
          var inheritedComponent = getPrototypeOf(sourceComponent);
          inheritedComponent && inheritedComponent !== objectPrototype && hoistNonReactStatics(targetComponent, inheritedComponent, blacklist);
        }
        var keys2 = getOwnPropertyNames(sourceComponent);
        getOwnPropertySymbols && (keys2 = keys2.concat(getOwnPropertySymbols(sourceComponent)));
        for (var targetStatics = getStatics(targetComponent), sourceStatics = getStatics(sourceComponent), i = 0; i < keys2.length; ++i) {
          var key = keys2[i];
          if (!KNOWN_STATICS[key] && !(blacklist && blacklist[key]) && !(sourceStatics && sourceStatics[key]) && !(targetStatics && targetStatics[key])) {
            var descriptor = getOwnPropertyDescriptor(sourceComponent, key);
            try {
              defineProperty(targetComponent, key, descriptor);
            } catch {
            }
          }
        }
      }
      return targetComponent;
    }
    module.exports = hoistNonReactStatics;
  }
});

// node_modules/@emotion/react/_isolated-hnrs/dist/emotion-react-_isolated-hnrs.cjs.dev.js
var require_emotion_react_isolated_hnrs_cjs_dev = __commonJS({
  "node_modules/@emotion/react/_isolated-hnrs/dist/emotion-react-_isolated-hnrs.cjs.dev.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: !0 });
    var hoistNonReactStatics$1 = require_hoist_non_react_statics_cjs();
    function _interopDefault(e) {
      return e && e.__esModule ? e : { default: e };
    }
    var hoistNonReactStatics__default = /* @__PURE__ */ _interopDefault(hoistNonReactStatics$1), hoistNonReactStatics = function(targetComponent, sourceComponent) {
      return hoistNonReactStatics__default.default(targetComponent, sourceComponent);
    };
    exports.default = hoistNonReactStatics;
  }
});

// node_modules/@emotion/utils/dist/emotion-utils.cjs.dev.js
var require_emotion_utils_cjs_dev = __commonJS({
  "node_modules/@emotion/utils/dist/emotion-utils.cjs.dev.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: !0 });
    var isBrowser = typeof document < "u";
    function getRegisteredStyles(registered, registeredStyles, classNames) {
      var rawClassName = "";
      return classNames.split(" ").forEach(function(className) {
        registered[className] !== void 0 ? registeredStyles.push(registered[className] + ";") : rawClassName += className + " ";
      }), rawClassName;
    }
    var registerStyles = function(cache, serialized, isStringTag2) {
      var className = cache.key + "-" + serialized.name;
      (isStringTag2 === !1 || isBrowser === !1 && cache.compat !== void 0) && cache.registered[className] === void 0 && (cache.registered[className] = serialized.styles);
    }, insertStyles = function(cache, serialized, isStringTag2) {
      registerStyles(cache, serialized, isStringTag2);
      var className = cache.key + "-" + serialized.name;
      if (cache.inserted[serialized.name] === void 0) {
        var stylesForSSR = "", current = serialized;
        do {
          var maybeStyles = cache.insert(serialized === current ? "." + className : "", current, cache.sheet, !0);
          !isBrowser && maybeStyles !== void 0 && (stylesForSSR += maybeStyles), current = current.next;
        } while (current !== void 0);
        if (!isBrowser && stylesForSSR.length !== 0)
          return stylesForSSR;
      }
    };
    exports.getRegisteredStyles = getRegisteredStyles;
    exports.insertStyles = insertStyles;
    exports.registerStyles = registerStyles;
  }
});

// node_modules/@emotion/utils/dist/emotion-utils.cjs.js
var require_emotion_utils_cjs = __commonJS({
  "node_modules/@emotion/utils/dist/emotion-utils.cjs.js"(exports, module) {
    "use strict";
    module.exports = require_emotion_utils_cjs_dev();
  }
});

// node_modules/@emotion/hash/dist/emotion-hash.cjs.dev.js
var require_emotion_hash_cjs_dev = __commonJS({
  "node_modules/@emotion/hash/dist/emotion-hash.cjs.dev.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: !0 });
    function murmur2(str) {
      for (var h = 0, k, i = 0, len = str.length; len >= 4; ++i, len -= 4)
        k = str.charCodeAt(i) & 255 | (str.charCodeAt(++i) & 255) << 8 | (str.charCodeAt(++i) & 255) << 16 | (str.charCodeAt(++i) & 255) << 24, k = (k & 65535) * 1540483477 + ((k >>> 16) * 59797 << 16), k ^= k >>> 24, h = (k & 65535) * 1540483477 + ((k >>> 16) * 59797 << 16) ^ (h & 65535) * 1540483477 + ((h >>> 16) * 59797 << 16);
      switch (len) {
        case 3:
          h ^= (str.charCodeAt(i + 2) & 255) << 16;
        case 2:
          h ^= (str.charCodeAt(i + 1) & 255) << 8;
        case 1:
          h ^= str.charCodeAt(i) & 255, h = (h & 65535) * 1540483477 + ((h >>> 16) * 59797 << 16);
      }
      return h ^= h >>> 13, h = (h & 65535) * 1540483477 + ((h >>> 16) * 59797 << 16), ((h ^ h >>> 15) >>> 0).toString(36);
    }
    exports.default = murmur2;
  }
});

// node_modules/@emotion/hash/dist/emotion-hash.cjs.js
var require_emotion_hash_cjs = __commonJS({
  "node_modules/@emotion/hash/dist/emotion-hash.cjs.js"(exports, module) {
    "use strict";
    module.exports = require_emotion_hash_cjs_dev();
  }
});

// node_modules/@emotion/unitless/dist/emotion-unitless.cjs.dev.js
var require_emotion_unitless_cjs_dev = __commonJS({
  "node_modules/@emotion/unitless/dist/emotion-unitless.cjs.dev.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: !0 });
    var unitlessKeys = {
      animationIterationCount: 1,
      borderImageOutset: 1,
      borderImageSlice: 1,
      borderImageWidth: 1,
      boxFlex: 1,
      boxFlexGroup: 1,
      boxOrdinalGroup: 1,
      columnCount: 1,
      columns: 1,
      flex: 1,
      flexGrow: 1,
      flexPositive: 1,
      flexShrink: 1,
      flexNegative: 1,
      flexOrder: 1,
      gridRow: 1,
      gridRowEnd: 1,
      gridRowSpan: 1,
      gridRowStart: 1,
      gridColumn: 1,
      gridColumnEnd: 1,
      gridColumnSpan: 1,
      gridColumnStart: 1,
      msGridRow: 1,
      msGridRowSpan: 1,
      msGridColumn: 1,
      msGridColumnSpan: 1,
      fontWeight: 1,
      lineHeight: 1,
      opacity: 1,
      order: 1,
      orphans: 1,
      tabSize: 1,
      widows: 1,
      zIndex: 1,
      zoom: 1,
      WebkitLineClamp: 1,
      fillOpacity: 1,
      floodOpacity: 1,
      stopOpacity: 1,
      strokeDasharray: 1,
      strokeDashoffset: 1,
      strokeMiterlimit: 1,
      strokeOpacity: 1,
      strokeWidth: 1
    };
    exports.default = unitlessKeys;
  }
});

// node_modules/@emotion/unitless/dist/emotion-unitless.cjs.js
var require_emotion_unitless_cjs = __commonJS({
  "node_modules/@emotion/unitless/dist/emotion-unitless.cjs.js"(exports, module) {
    "use strict";
    module.exports = require_emotion_unitless_cjs_dev();
  }
});

// node_modules/@emotion/serialize/dist/emotion-serialize.cjs.dev.js
var require_emotion_serialize_cjs_dev = __commonJS({
  "node_modules/@emotion/serialize/dist/emotion-serialize.cjs.dev.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: !0 });
    var hashString = require_emotion_hash_cjs(), unitless = require_emotion_unitless_cjs(), memoize2 = require_emotion_memoize_cjs();
    function _interopDefault(e) {
      return e && e.__esModule ? e : { default: e };
    }
    var hashString__default = /* @__PURE__ */ _interopDefault(hashString), unitless__default = /* @__PURE__ */ _interopDefault(unitless), memoize__default = /* @__PURE__ */ _interopDefault(memoize2), ILLEGAL_ESCAPE_SEQUENCE_ERROR = `You have illegal escape sequence in your template literal, most likely inside content's property value.
Because you write your CSS inside a JavaScript string you actually have to do double escaping, so for example "content: '\\00d7';" should become "content: '\\\\00d7';".
You can read more about this here:
https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals#ES2018_revision_of_illegal_escape_sequences`, UNDEFINED_AS_OBJECT_KEY_ERROR = "You have passed in falsy value as style object's key (can happen when in example you pass unexported component as computed key).", hyphenateRegex = /[A-Z]|^ms/g, animationRegex = /_EMO_([^_]+?)_([^]*?)_EMO_/g, isCustomProperty = function(property) {
      return property.charCodeAt(1) === 45;
    }, isProcessableValue = function(value) {
      return value != null && typeof value != "boolean";
    }, processStyleName = /* @__PURE__ */ memoize__default.default(function(styleName) {
      return isCustomProperty(styleName) ? styleName : styleName.replace(hyphenateRegex, "-$&").toLowerCase();
    }), processStyleValue = function(key, value) {
      switch (key) {
        case "animation":
        case "animationName":
          if (typeof value == "string")
            return value.replace(animationRegex, function(match, p1, p2) {
              return cursor = {
                name: p1,
                styles: p2,
                next: cursor
              }, p1;
            });
      }
      return unitless__default.default[key] !== 1 && !isCustomProperty(key) && typeof value == "number" && value !== 0 ? value + "px" : value;
    };
    contentValuePattern = /(var|attr|counters?|url|(((repeating-)?(linear|radial))|conic)-gradient)\(|(no-)?(open|close)-quote/, contentValues = ["normal", "none", "initial", "inherit", "unset"], oldProcessStyleValue = processStyleValue, msPattern = /^-ms-/, hyphenPattern = /-(.)/g, hyphenatedCache = {}, processStyleValue = function(key, value) {
      if (key === "content" && (typeof value != "string" || contentValues.indexOf(value) === -1 && !contentValuePattern.test(value) && (value.charAt(0) !== value.charAt(value.length - 1) || value.charAt(0) !== '"' && value.charAt(0) !== "'")))
        throw new Error("You seem to be using a value for 'content' without quotes, try replacing it with `content: '\"" + value + "\"'`");
      var processed = oldProcessStyleValue(key, value);
      return processed !== "" && !isCustomProperty(key) && key.indexOf("-") !== -1 && hyphenatedCache[key] === void 0 && (hyphenatedCache[key] = !0, console.error("Using kebab-case for css properties in objects is not supported. Did you mean " + key.replace(msPattern, "ms-").replace(hyphenPattern, function(str, _char) {
        return _char.toUpperCase();
      }) + "?")), processed;
    };
    var contentValuePattern, contentValues, oldProcessStyleValue, msPattern, hyphenPattern, hyphenatedCache, noComponentSelectorMessage = "Component selectors can only be used in conjunction with @emotion/babel-plugin, the swc Emotion plugin, or another Emotion-aware compiler transform.";
    function handleInterpolation(mergedProps, registered, interpolation) {
      if (interpolation == null)
        return "";
      if (interpolation.__emotion_styles !== void 0) {
        if (interpolation.toString() === "NO_COMPONENT_SELECTOR")
          throw new Error(noComponentSelectorMessage);
        return interpolation;
      }
      switch (typeof interpolation) {
        case "boolean":
          return "";
        case "object": {
          if (interpolation.anim === 1)
            return cursor = {
              name: interpolation.name,
              styles: interpolation.styles,
              next: cursor
            }, interpolation.name;
          if (interpolation.styles !== void 0) {
            var next = interpolation.next;
            if (next !== void 0)
              for (; next !== void 0; )
                cursor = {
                  name: next.name,
                  styles: next.styles,
                  next: cursor
                }, next = next.next;
            var styles4 = interpolation.styles + ";";
            return interpolation.map !== void 0 && (styles4 += interpolation.map), styles4;
          }
          return createStringFromObject(mergedProps, registered, interpolation);
        }
        case "function": {
          if (mergedProps !== void 0) {
            var previousCursor = cursor, result = interpolation(mergedProps);
            return cursor = previousCursor, handleInterpolation(mergedProps, registered, result);
          } else
            console.error("Functions that are interpolated in css calls will be stringified.\nIf you want to have a css call based on props, create a function that returns a css call like this\nlet dynamicStyle = (props) => css`color: ${props.color}`\nIt can be called directly with props or interpolated in a styled call like this\nlet SomeComponent = styled('div')`${dynamicStyle}`");
          break;
        }
        case "string":
          var matched = [], replaced = interpolation.replace(animationRegex, function(match, p1, p2) {
            var fakeVarName = "animation" + matched.length;
            return matched.push("const " + fakeVarName + " = keyframes`" + p2.replace(/^@keyframes animation-\w+/, "") + "`"), "${" + fakeVarName + "}";
          });
          matched.length && console.error("`keyframes` output got interpolated into plain string, please wrap it with `css`.\n\nInstead of doing this:\n\n" + [].concat(matched, ["`" + replaced + "`"]).join(`
`) + `

You should wrap it with \`css\` like this:

` + ("css`" + replaced + "`"));
          break;
      }
      if (registered == null)
        return interpolation;
      var cached = registered[interpolation];
      return cached !== void 0 ? cached : interpolation;
    }
    function createStringFromObject(mergedProps, registered, obj) {
      var string = "";
      if (Array.isArray(obj))
        for (var i = 0; i < obj.length; i++)
          string += handleInterpolation(mergedProps, registered, obj[i]) + ";";
      else
        for (var _key in obj) {
          var value = obj[_key];
          if (typeof value != "object")
            registered != null && registered[value] !== void 0 ? string += _key + "{" + registered[value] + "}" : isProcessableValue(value) && (string += processStyleName(_key) + ":" + processStyleValue(_key, value) + ";");
          else {
            if (_key === "NO_COMPONENT_SELECTOR")
              throw new Error(noComponentSelectorMessage);
            if (Array.isArray(value) && typeof value[0] == "string" && (registered == null || registered[value[0]] === void 0))
              for (var _i = 0; _i < value.length; _i++)
                isProcessableValue(value[_i]) && (string += processStyleName(_key) + ":" + processStyleValue(_key, value[_i]) + ";");
            else {
              var interpolated = handleInterpolation(mergedProps, registered, value);
              switch (_key) {
                case "animation":
                case "animationName": {
                  string += processStyleName(_key) + ":" + interpolated + ";";
                  break;
                }
                default:
                  _key === "undefined" && console.error(UNDEFINED_AS_OBJECT_KEY_ERROR), string += _key + "{" + interpolated + "}";
              }
            }
          }
        }
      return string;
    }
    var labelPattern = /label:\s*([^\s;\n{]+)\s*(;|$)/g, sourceMapPattern;
    sourceMapPattern = /\/\*#\ssourceMappingURL=data:application\/json;\S+\s+\*\//g;
    var cursor, serializeStyles = function(args, registered, mergedProps) {
      if (args.length === 1 && typeof args[0] == "object" && args[0] !== null && args[0].styles !== void 0)
        return args[0];
      var stringMode = !0, styles4 = "";
      cursor = void 0;
      var strings = args[0];
      strings == null || strings.raw === void 0 ? (stringMode = !1, styles4 += handleInterpolation(mergedProps, registered, strings)) : (strings[0] === void 0 && console.error(ILLEGAL_ESCAPE_SEQUENCE_ERROR), styles4 += strings[0]);
      for (var i = 1; i < args.length; i++)
        styles4 += handleInterpolation(mergedProps, registered, args[i]), stringMode && (strings[i] === void 0 && console.error(ILLEGAL_ESCAPE_SEQUENCE_ERROR), styles4 += strings[i]);
      var sourceMap;
      styles4 = styles4.replace(sourceMapPattern, function(match2) {
        return sourceMap = match2, "";
      }), labelPattern.lastIndex = 0;
      for (var identifierName = "", match; (match = labelPattern.exec(styles4)) !== null; )
        identifierName += "-" + match[1];
      var name = hashString__default.default(styles4) + identifierName;
      return {
        name,
        styles: styles4,
        map: sourceMap,
        next: cursor,
        toString: function() {
          return "You have tried to stringify object returned from `css` function. It isn't supposed to be used directly (e.g. as value of the `className` prop), but rather handed to emotion so it can handle it (e.g. as value of `css` prop).";
        }
      };
    };
    exports.serializeStyles = serializeStyles;
  }
});

// node_modules/@emotion/serialize/dist/emotion-serialize.cjs.js
var require_emotion_serialize_cjs = __commonJS({
  "node_modules/@emotion/serialize/dist/emotion-serialize.cjs.js"(exports, module) {
    "use strict";
    module.exports = require_emotion_serialize_cjs_dev();
  }
});

// node_modules/@emotion/use-insertion-effect-with-fallbacks/dist/emotion-use-insertion-effect-with-fallbacks.cjs.dev.js
var require_emotion_use_insertion_effect_with_fallbacks_cjs_dev = __commonJS({
  "node_modules/@emotion/use-insertion-effect-with-fallbacks/dist/emotion-use-insertion-effect-with-fallbacks.cjs.dev.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: !0 });
    var React90 = require_react();
    function _interopNamespace(e) {
      if (e && e.__esModule)
        return e;
      var n = /* @__PURE__ */ Object.create(null);
      return e && Object.keys(e).forEach(function(k) {
        if (k !== "default") {
          var d = Object.getOwnPropertyDescriptor(e, k);
          Object.defineProperty(n, k, d.get ? d : {
            enumerable: !0,
            get: function() {
              return e[k];
            }
          });
        }
      }), n.default = e, Object.freeze(n);
    }
    var React__namespace = /* @__PURE__ */ _interopNamespace(React90), isBrowser = typeof document < "u", syncFallback = function(create) {
      return create();
    }, useInsertionEffect = React__namespace["useInsertionEffect"] ? React__namespace["useInsertionEffect"] : !1, useInsertionEffectAlwaysWithSyncFallback = isBrowser && useInsertionEffect || syncFallback, useInsertionEffectWithLayoutFallback = useInsertionEffect || React90.useLayoutEffect;
    exports.useInsertionEffectAlwaysWithSyncFallback = useInsertionEffectAlwaysWithSyncFallback;
    exports.useInsertionEffectWithLayoutFallback = useInsertionEffectWithLayoutFallback;
  }
});

// node_modules/@emotion/use-insertion-effect-with-fallbacks/dist/emotion-use-insertion-effect-with-fallbacks.cjs.js
var require_emotion_use_insertion_effect_with_fallbacks_cjs = __commonJS({
  "node_modules/@emotion/use-insertion-effect-with-fallbacks/dist/emotion-use-insertion-effect-with-fallbacks.cjs.js"(exports, module) {
    "use strict";
    module.exports = require_emotion_use_insertion_effect_with_fallbacks_cjs_dev();
  }
});

// node_modules/@emotion/react/dist/emotion-element-b63ca7c6.cjs.dev.js
var require_emotion_element_b63ca7c6_cjs_dev = __commonJS({
  "node_modules/@emotion/react/dist/emotion-element-b63ca7c6.cjs.dev.js"(exports) {
    "use strict";
    var React90 = require_react(), createCache = require_emotion_cache_cjs(), _extends4 = require_extends(), weakMemoize = require_emotion_weak_memoize_cjs(), _isolatedHnrs_dist_emotionReact_isolatedHnrs = require_emotion_react_isolated_hnrs_cjs_dev(), utils = require_emotion_utils_cjs(), serialize2 = require_emotion_serialize_cjs(), useInsertionEffectWithFallbacks = require_emotion_use_insertion_effect_with_fallbacks_cjs();
    function _interopDefault(e) {
      return e && e.__esModule ? e : { default: e };
    }
    var createCache__default = /* @__PURE__ */ _interopDefault(createCache), weakMemoize__default = /* @__PURE__ */ _interopDefault(weakMemoize), isBrowser = typeof document < "u", hasOwnProperty2 = {}.hasOwnProperty, EmotionCacheContext = /* @__PURE__ */ React90.createContext(
      typeof HTMLElement < "u" ? /* @__PURE__ */ createCache__default.default({
        key: "css"
      }) : null
    );
    EmotionCacheContext.displayName = "EmotionCacheContext";
    var CacheProvider = EmotionCacheContext.Provider, __unsafe_useEmotionCache = function() {
      return React90.useContext(EmotionCacheContext);
    };
    exports.withEmotionCache = function(func) {
      return /* @__PURE__ */ React90.forwardRef(function(props, ref) {
        var cache = React90.useContext(EmotionCacheContext);
        return func(props, cache, ref);
      });
    };
    isBrowser || (exports.withEmotionCache = function(func) {
      return function(props) {
        var cache = React90.useContext(EmotionCacheContext);
        return cache === null ? (cache = createCache__default.default({
          key: "css"
        }), /* @__PURE__ */ React90.createElement(EmotionCacheContext.Provider, {
          value: cache
        }, func(props, cache))) : func(props, cache);
      };
    });
    var ThemeContext3 = /* @__PURE__ */ React90.createContext({});
    ThemeContext3.displayName = "EmotionThemeContext";
    var useTheme5 = function() {
      return React90.useContext(ThemeContext3);
    }, getTheme = function(outerTheme, theme) {
      if (typeof theme == "function") {
        var mergedTheme = theme(outerTheme);
        if (mergedTheme == null || typeof mergedTheme != "object" || Array.isArray(mergedTheme))
          throw new Error("[ThemeProvider] Please return an object from your theme function, i.e. theme={() => ({})}!");
        return mergedTheme;
      }
      if (theme == null || typeof theme != "object" || Array.isArray(theme))
        throw new Error("[ThemeProvider] Please make your theme prop a plain object");
      return _extends4({}, outerTheme, theme);
    }, createCacheWithTheme = /* @__PURE__ */ weakMemoize__default.default(function(outerTheme) {
      return weakMemoize__default.default(function(theme) {
        return getTheme(outerTheme, theme);
      });
    }), ThemeProvider = function(props) {
      var theme = React90.useContext(ThemeContext3);
      return props.theme !== theme && (theme = createCacheWithTheme(theme)(props.theme)), /* @__PURE__ */ React90.createElement(ThemeContext3.Provider, {
        value: theme
      }, props.children);
    };
    function withTheme(Component) {
      var componentName = Component.displayName || Component.name || "Component", render = function(props, ref) {
        var theme = React90.useContext(ThemeContext3);
        return /* @__PURE__ */ React90.createElement(Component, _extends4({
          theme,
          ref
        }, props));
      }, WithTheme = /* @__PURE__ */ React90.forwardRef(render);
      return WithTheme.displayName = "WithTheme(" + componentName + ")", _isolatedHnrs_dist_emotionReact_isolatedHnrs.default(WithTheme, Component);
    }
    var getLastPart = function(functionName) {
      var parts = functionName.split(".");
      return parts[parts.length - 1];
    }, getFunctionNameFromStackTraceLine = function(line) {
      var match = /^\s+at\s+([A-Za-z0-9$.]+)\s/.exec(line);
      if (match || (match = /^([A-Za-z0-9$.]+)@/.exec(line), match))
        return getLastPart(match[1]);
    }, internalReactFunctionNames = /* @__PURE__ */ new Set(["renderWithHooks", "processChild", "finishClassComponent", "renderToString"]), sanitizeIdentifier = function(identifier) {
      return identifier.replace(/\$/g, "-");
    }, getLabelFromStackTrace = function(stackTrace) {
      if (!!stackTrace)
        for (var lines = stackTrace.split(`
`), i = 0; i < lines.length; i++) {
          var functionName = getFunctionNameFromStackTraceLine(lines[i]);
          if (!!functionName) {
            if (internalReactFunctionNames.has(functionName))
              break;
            if (/^[A-Z]/.test(functionName))
              return sanitizeIdentifier(functionName);
          }
        }
    }, typePropName = "__EMOTION_TYPE_PLEASE_DO_NOT_USE__", labelPropName = "__EMOTION_LABEL_PLEASE_DO_NOT_USE__", createEmotionProps = function(type, props) {
      if (typeof props.css == "string" && props.css.indexOf(":") !== -1)
        throw new Error("Strings are not allowed as css prop values, please wrap it in a css template literal from '@emotion/react' like this: css`" + props.css + "`");
      var newProps = {};
      for (var key in props)
        hasOwnProperty2.call(props, key) && (newProps[key] = props[key]);
      if (newProps[typePropName] = type, !!props.css && (typeof props.css != "object" || typeof props.css.name != "string" || props.css.name.indexOf("-") === -1)) {
        var label = getLabelFromStackTrace(new Error().stack);
        label && (newProps[labelPropName] = label);
      }
      return newProps;
    }, Insertion = function(_ref) {
      var cache = _ref.cache, serialized = _ref.serialized, isStringTag2 = _ref.isStringTag;
      utils.registerStyles(cache, serialized, isStringTag2);
      var rules = useInsertionEffectWithFallbacks.useInsertionEffectAlwaysWithSyncFallback(function() {
        return utils.insertStyles(cache, serialized, isStringTag2);
      });
      if (!isBrowser && rules !== void 0) {
        for (var _ref2, serializedNames = serialized.name, next = serialized.next; next !== void 0; )
          serializedNames += " " + next.name, next = next.next;
        return /* @__PURE__ */ React90.createElement("style", (_ref2 = {}, _ref2["data-emotion"] = cache.key + " " + serializedNames, _ref2.dangerouslySetInnerHTML = {
          __html: rules
        }, _ref2.nonce = cache.sheet.nonce, _ref2));
      }
      return null;
    }, Emotion = /* @__PURE__ */ exports.withEmotionCache(function(props, cache, ref) {
      var cssProp = props.css;
      typeof cssProp == "string" && cache.registered[cssProp] !== void 0 && (cssProp = cache.registered[cssProp]);
      var WrappedComponent = props[typePropName], registeredStyles = [cssProp], className = "";
      typeof props.className == "string" ? className = utils.getRegisteredStyles(cache.registered, registeredStyles, props.className) : props.className != null && (className = props.className + " ");
      var serialized = serialize2.serializeStyles(registeredStyles, void 0, React90.useContext(ThemeContext3));
      if (serialized.name.indexOf("-") === -1) {
        var labelFromStack = props[labelPropName];
        labelFromStack && (serialized = serialize2.serializeStyles([serialized, "label:" + labelFromStack + ";"]));
      }
      className += cache.key + "-" + serialized.name;
      var newProps = {};
      for (var key in props)
        hasOwnProperty2.call(props, key) && key !== "css" && key !== typePropName && key !== labelPropName && (newProps[key] = props[key]);
      return newProps.ref = ref, newProps.className = className, /* @__PURE__ */ React90.createElement(React90.Fragment, null, /* @__PURE__ */ React90.createElement(Insertion, {
        cache,
        serialized,
        isStringTag: typeof WrappedComponent == "string"
      }), /* @__PURE__ */ React90.createElement(WrappedComponent, newProps));
    });
    Emotion.displayName = "EmotionCssPropInternal";
    exports.CacheProvider = CacheProvider;
    exports.Emotion = Emotion;
    exports.ThemeContext = ThemeContext3;
    exports.ThemeProvider = ThemeProvider;
    exports.__unsafe_useEmotionCache = __unsafe_useEmotionCache;
    exports.createEmotionProps = createEmotionProps;
    exports.hasOwnProperty = hasOwnProperty2;
    exports.isBrowser = isBrowser;
    exports.useTheme = useTheme5;
    exports.withTheme = withTheme;
  }
});

// node_modules/@emotion/react/dist/emotion-react.cjs.dev.js
var require_emotion_react_cjs_dev = __commonJS({
  "node_modules/@emotion/react/dist/emotion-react.cjs.dev.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: !0 });
    var React90 = require_react();
    require_emotion_cache_cjs();
    var emotionElement = require_emotion_element_b63ca7c6_cjs_dev();
    require_extends();
    require_emotion_weak_memoize_cjs();
    require_hoist_non_react_statics_cjs();
    require_emotion_react_isolated_hnrs_cjs_dev();
    var utils = require_emotion_utils_cjs(), serialize2 = require_emotion_serialize_cjs(), useInsertionEffectWithFallbacks = require_emotion_use_insertion_effect_with_fallbacks_cjs(), pkg = {
      name: "@emotion/react",
      version: "11.10.4",
      main: "dist/emotion-react.cjs.js",
      module: "dist/emotion-react.esm.js",
      browser: {
        "./dist/emotion-react.esm.js": "./dist/emotion-react.browser.esm.js"
      },
      exports: {
        ".": {
          module: {
            worker: "./dist/emotion-react.worker.esm.js",
            browser: "./dist/emotion-react.browser.esm.js",
            default: "./dist/emotion-react.esm.js"
          },
          default: "./dist/emotion-react.cjs.js"
        },
        "./jsx-runtime": {
          module: {
            worker: "./jsx-runtime/dist/emotion-react-jsx-runtime.worker.esm.js",
            browser: "./jsx-runtime/dist/emotion-react-jsx-runtime.browser.esm.js",
            default: "./jsx-runtime/dist/emotion-react-jsx-runtime.esm.js"
          },
          default: "./jsx-runtime/dist/emotion-react-jsx-runtime.cjs.js"
        },
        "./_isolated-hnrs": {
          module: {
            worker: "./_isolated-hnrs/dist/emotion-react-_isolated-hnrs.worker.esm.js",
            browser: "./_isolated-hnrs/dist/emotion-react-_isolated-hnrs.browser.esm.js",
            default: "./_isolated-hnrs/dist/emotion-react-_isolated-hnrs.esm.js"
          },
          default: "./_isolated-hnrs/dist/emotion-react-_isolated-hnrs.cjs.js"
        },
        "./jsx-dev-runtime": {
          module: {
            worker: "./jsx-dev-runtime/dist/emotion-react-jsx-dev-runtime.worker.esm.js",
            browser: "./jsx-dev-runtime/dist/emotion-react-jsx-dev-runtime.browser.esm.js",
            default: "./jsx-dev-runtime/dist/emotion-react-jsx-dev-runtime.esm.js"
          },
          default: "./jsx-dev-runtime/dist/emotion-react-jsx-dev-runtime.cjs.js"
        },
        "./package.json": "./package.json",
        "./types/css-prop": "./types/css-prop.d.ts",
        "./macro": "./macro.js"
      },
      types: "types/index.d.ts",
      files: [
        "src",
        "dist",
        "jsx-runtime",
        "jsx-dev-runtime",
        "_isolated-hnrs",
        "types/*.d.ts",
        "macro.js",
        "macro.d.ts",
        "macro.js.flow"
      ],
      sideEffects: !1,
      author: "Emotion Contributors",
      license: "MIT",
      scripts: {
        "test:typescript": "dtslint types"
      },
      dependencies: {
        "@babel/runtime": "^7.18.3",
        "@emotion/babel-plugin": "^11.10.0",
        "@emotion/cache": "^11.10.0",
        "@emotion/serialize": "^1.1.0",
        "@emotion/use-insertion-effect-with-fallbacks": "^1.0.0",
        "@emotion/utils": "^1.2.0",
        "@emotion/weak-memoize": "^0.3.0",
        "hoist-non-react-statics": "^3.3.1"
      },
      peerDependencies: {
        "@babel/core": "^7.0.0",
        react: ">=16.8.0"
      },
      peerDependenciesMeta: {
        "@babel/core": {
          optional: !0
        },
        "@types/react": {
          optional: !0
        }
      },
      devDependencies: {
        "@babel/core": "^7.18.5",
        "@definitelytyped/dtslint": "0.0.112",
        "@emotion/css": "11.10.0",
        "@emotion/css-prettifier": "1.1.0",
        "@emotion/server": "11.10.0",
        "@emotion/styled": "11.10.4",
        "html-tag-names": "^1.1.2",
        react: "16.14.0",
        "svg-tag-names": "^1.1.1",
        typescript: "^4.5.5"
      },
      repository: "https://github.com/emotion-js/emotion/tree/main/packages/react",
      publishConfig: {
        access: "public"
      },
      "umd:main": "dist/emotion-react.umd.min.js",
      preconstruct: {
        entrypoints: [
          "./index.js",
          "./jsx-runtime.js",
          "./jsx-dev-runtime.js",
          "./_isolated-hnrs.js"
        ],
        umdName: "emotionReact",
        exports: {
          envConditions: [
            "browser",
            "worker"
          ],
          extra: {
            "./types/css-prop": "./types/css-prop.d.ts",
            "./macro": "./macro.js"
          }
        }
      }
    }, jsx = function(type, props) {
      var args = arguments;
      if (props == null || !emotionElement.hasOwnProperty.call(props, "css"))
        return React90.createElement.apply(void 0, args);
      var argsLength = args.length, createElementArgArray = new Array(argsLength);
      createElementArgArray[0] = emotionElement.Emotion, createElementArgArray[1] = emotionElement.createEmotionProps(type, props);
      for (var i = 2; i < argsLength; i++)
        createElementArgArray[i] = args[i];
      return React90.createElement.apply(null, createElementArgArray);
    }, warnedAboutCssPropForGlobal = !1, Global2 = /* @__PURE__ */ emotionElement.withEmotionCache(function(props, cache) {
      !warnedAboutCssPropForGlobal && (props.className || props.css) && (console.error("It looks like you're using the css prop on Global, did you mean to use the styles prop instead?"), warnedAboutCssPropForGlobal = !0);
      var styles4 = props.styles, serialized = serialize2.serializeStyles([styles4], void 0, React90.useContext(emotionElement.ThemeContext));
      if (!emotionElement.isBrowser) {
        for (var _ref, serializedNames = serialized.name, serializedStyles = serialized.styles, next = serialized.next; next !== void 0; )
          serializedNames += " " + next.name, serializedStyles += next.styles, next = next.next;
        var shouldCache = cache.compat === !0, rules = cache.insert("", {
          name: serializedNames,
          styles: serializedStyles
        }, cache.sheet, shouldCache);
        return shouldCache ? null : /* @__PURE__ */ React90.createElement("style", (_ref = {}, _ref["data-emotion"] = cache.key + "-global " + serializedNames, _ref.dangerouslySetInnerHTML = {
          __html: rules
        }, _ref.nonce = cache.sheet.nonce, _ref));
      }
      var sheetRef = React90.useRef();
      return useInsertionEffectWithFallbacks.useInsertionEffectWithLayoutFallback(function() {
        var key = cache.key + "-global", sheet = new cache.sheet.constructor({
          key,
          nonce: cache.sheet.nonce,
          container: cache.sheet.container,
          speedy: cache.sheet.isSpeedy
        }), rehydrating = !1, node = document.querySelector('style[data-emotion="' + key + " " + serialized.name + '"]');
        return cache.sheet.tags.length && (sheet.before = cache.sheet.tags[0]), node !== null && (rehydrating = !0, node.setAttribute("data-emotion", key), sheet.hydrate([node])), sheetRef.current = [sheet, rehydrating], function() {
          sheet.flush();
        };
      }, [cache]), useInsertionEffectWithFallbacks.useInsertionEffectWithLayoutFallback(function() {
        var sheetRefCurrent = sheetRef.current, sheet = sheetRefCurrent[0], rehydrating = sheetRefCurrent[1];
        if (rehydrating) {
          sheetRefCurrent[1] = !1;
          return;
        }
        if (serialized.next !== void 0 && utils.insertStyles(cache, serialized.next, !0), sheet.tags.length) {
          var element = sheet.tags[sheet.tags.length - 1].nextElementSibling;
          sheet.before = element, sheet.flush();
        }
        cache.insert("", serialized, sheet, !1);
      }, [cache, serialized.name]), null;
    });
    Global2.displayName = "EmotionGlobal";
    function css2() {
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++)
        args[_key] = arguments[_key];
      return serialize2.serializeStyles(args);
    }
    var keyframes2 = function() {
      var insertable = css2.apply(void 0, arguments), name = "animation-" + insertable.name;
      return {
        name,
        styles: "@keyframes " + name + "{" + insertable.styles + "}",
        anim: 1,
        toString: function() {
          return "_EMO_" + this.name + "_" + this.styles + "_EMO_";
        }
      };
    }, classnames = function classnames2(args) {
      for (var len = args.length, i = 0, cls = ""; i < len; i++) {
        var arg = args[i];
        if (arg != null) {
          var toAdd = void 0;
          switch (typeof arg) {
            case "boolean":
              break;
            case "object": {
              if (Array.isArray(arg))
                toAdd = classnames2(arg);
              else {
                arg.styles !== void 0 && arg.name !== void 0 && console.error("You have passed styles created with `css` from `@emotion/react` package to the `cx`.\n`cx` is meant to compose class names (strings) so you should convert those styles to a class name by passing them to the `css` received from <ClassNames/> component."), toAdd = "";
                for (var k in arg)
                  arg[k] && k && (toAdd && (toAdd += " "), toAdd += k);
              }
              break;
            }
            default:
              toAdd = arg;
          }
          toAdd && (cls && (cls += " "), cls += toAdd);
        }
      }
      return cls;
    };
    function merge2(registered, css3, className) {
      var registeredStyles = [], rawClassName = utils.getRegisteredStyles(registered, registeredStyles, className);
      return registeredStyles.length < 2 ? className : rawClassName + css3(registeredStyles);
    }
    var Insertion = function(_ref) {
      var cache = _ref.cache, serializedArr = _ref.serializedArr, rules = useInsertionEffectWithFallbacks.useInsertionEffectAlwaysWithSyncFallback(function() {
        for (var rules2 = "", i = 0; i < serializedArr.length; i++) {
          var res = utils.insertStyles(cache, serializedArr[i], !1);
          !emotionElement.isBrowser && res !== void 0 && (rules2 += res);
        }
        if (!emotionElement.isBrowser)
          return rules2;
      });
      if (!emotionElement.isBrowser && rules.length !== 0) {
        var _ref2;
        return /* @__PURE__ */ React90.createElement("style", (_ref2 = {}, _ref2["data-emotion"] = cache.key + " " + serializedArr.map(function(serialized) {
          return serialized.name;
        }).join(" "), _ref2.dangerouslySetInnerHTML = {
          __html: rules
        }, _ref2.nonce = cache.sheet.nonce, _ref2));
      }
      return null;
    }, ClassNames = /* @__PURE__ */ emotionElement.withEmotionCache(function(props, cache) {
      var hasRendered = !1, serializedArr = [], css3 = function() {
        if (hasRendered)
          throw new Error("css can only be used during render");
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++)
          args[_key] = arguments[_key];
        var serialized = serialize2.serializeStyles(args, cache.registered);
        return serializedArr.push(serialized), utils.registerStyles(cache, serialized, !1), cache.key + "-" + serialized.name;
      }, cx = function() {
        if (hasRendered)
          throw new Error("cx can only be used during render");
        for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++)
          args[_key2] = arguments[_key2];
        return merge2(cache.registered, css3, classnames(args));
      }, content = {
        css: css3,
        cx,
        theme: React90.useContext(emotionElement.ThemeContext)
      }, ele = props.children(content);
      return hasRendered = !0, /* @__PURE__ */ React90.createElement(React90.Fragment, null, /* @__PURE__ */ React90.createElement(Insertion, {
        cache,
        serializedArr
      }), ele);
    });
    ClassNames.displayName = "EmotionClassNames";
    isBrowser = typeof document < "u", isJest = typeof jest < "u", isBrowser && !isJest && (globalContext = typeof globalThis < "u" ? globalThis : isBrowser ? window : globalThis, globalKey = "__EMOTION_REACT_" + pkg.version.split(".")[0] + "__", globalContext[globalKey] && console.warn("You are loading @emotion/react when it is already loaded. Running multiple instances may cause problems. This can happen if multiple versions are used, or if multiple builds of the same version are used."), globalContext[globalKey] = !0);
    var isBrowser, isJest, globalContext, globalKey;
    exports.CacheProvider = emotionElement.CacheProvider;
    exports.ThemeContext = emotionElement.ThemeContext;
    exports.ThemeProvider = emotionElement.ThemeProvider;
    exports.__unsafe_useEmotionCache = emotionElement.__unsafe_useEmotionCache;
    exports.useTheme = emotionElement.useTheme;
    Object.defineProperty(exports, "withEmotionCache", {
      enumerable: !0,
      get: function() {
        return emotionElement.withEmotionCache;
      }
    });
    exports.withTheme = emotionElement.withTheme;
    exports.ClassNames = ClassNames;
    exports.Global = Global2;
    exports.createElement = jsx;
    exports.css = css2;
    exports.jsx = jsx;
    exports.keyframes = keyframes2;
  }
});

// node_modules/@emotion/react/dist/emotion-react.cjs.js
var require_emotion_react_cjs = __commonJS({
  "node_modules/@emotion/react/dist/emotion-react.cjs.js"(exports, module) {
    "use strict";
    module.exports = require_emotion_react_cjs_dev();
  }
});

// node_modules/@emotion/styled/base/dist/emotion-styled-base.cjs.dev.js
var require_emotion_styled_base_cjs_dev = __commonJS({
  "node_modules/@emotion/styled/base/dist/emotion-styled-base.cjs.dev.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: !0 });
    var _extends4 = require_extends(), React90 = require_react(), isPropValid = require_emotion_is_prop_valid_cjs(), react = require_emotion_react_cjs(), utils = require_emotion_utils_cjs(), serialize2 = require_emotion_serialize_cjs(), useInsertionEffectWithFallbacks = require_emotion_use_insertion_effect_with_fallbacks_cjs();
    function _interopDefault(e) {
      return e && e.__esModule ? e : { default: e };
    }
    var isPropValid__default = /* @__PURE__ */ _interopDefault(isPropValid), testOmitPropsOnStringTag = isPropValid__default.default, testOmitPropsOnComponent = function(key) {
      return key !== "theme";
    }, getDefaultShouldForwardProp = function(tag) {
      return typeof tag == "string" && tag.charCodeAt(0) > 96 ? testOmitPropsOnStringTag : testOmitPropsOnComponent;
    }, composeShouldForwardProps = function(tag, options, isReal) {
      var shouldForwardProp2;
      if (options) {
        var optionsShouldForwardProp = options.shouldForwardProp;
        shouldForwardProp2 = tag.__emotion_forwardProp && optionsShouldForwardProp ? function(propName) {
          return tag.__emotion_forwardProp(propName) && optionsShouldForwardProp(propName);
        } : optionsShouldForwardProp;
      }
      return typeof shouldForwardProp2 != "function" && isReal && (shouldForwardProp2 = tag.__emotion_forwardProp), shouldForwardProp2;
    }, ILLEGAL_ESCAPE_SEQUENCE_ERROR = `You have illegal escape sequence in your template literal, most likely inside content's property value.
Because you write your CSS inside a JavaScript string you actually have to do double escaping, so for example "content: '\\00d7';" should become "content: '\\\\00d7';".
You can read more about this here:
https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals#ES2018_revision_of_illegal_escape_sequences`, isBrowser = typeof document < "u", Insertion = function(_ref) {
      var cache = _ref.cache, serialized = _ref.serialized, isStringTag2 = _ref.isStringTag;
      utils.registerStyles(cache, serialized, isStringTag2);
      var rules = useInsertionEffectWithFallbacks.useInsertionEffectAlwaysWithSyncFallback(function() {
        return utils.insertStyles(cache, serialized, isStringTag2);
      });
      if (!isBrowser && rules !== void 0) {
        for (var _ref2, serializedNames = serialized.name, next = serialized.next; next !== void 0; )
          serializedNames += " " + next.name, next = next.next;
        return /* @__PURE__ */ React90.createElement("style", (_ref2 = {}, _ref2["data-emotion"] = cache.key + " " + serializedNames, _ref2.dangerouslySetInnerHTML = {
          __html: rules
        }, _ref2.nonce = cache.sheet.nonce, _ref2));
      }
      return null;
    }, createStyled2 = function createStyled3(tag, options) {
      if (tag === void 0)
        throw new Error(`You are trying to create a styled element with an undefined component.
You may have forgotten to import it.`);
      var isReal = tag.__emotion_real === tag, baseTag = isReal && tag.__emotion_base || tag, identifierName, targetClassName;
      options !== void 0 && (identifierName = options.label, targetClassName = options.target);
      var shouldForwardProp2 = composeShouldForwardProps(tag, options, isReal), defaultShouldForwardProp = shouldForwardProp2 || getDefaultShouldForwardProp(baseTag), shouldUseAs = !defaultShouldForwardProp("as");
      return function() {
        var args = arguments, styles4 = isReal && tag.__emotion_styles !== void 0 ? tag.__emotion_styles.slice(0) : [];
        if (identifierName !== void 0 && styles4.push("label:" + identifierName + ";"), args[0] == null || args[0].raw === void 0)
          styles4.push.apply(styles4, args);
        else {
          args[0][0] === void 0 && console.error(ILLEGAL_ESCAPE_SEQUENCE_ERROR), styles4.push(args[0][0]);
          for (var len = args.length, i = 1; i < len; i++)
            args[0][i] === void 0 && console.error(ILLEGAL_ESCAPE_SEQUENCE_ERROR), styles4.push(args[i], args[0][i]);
        }
        var Styled = react.withEmotionCache(function(props, cache, ref) {
          var FinalTag = shouldUseAs && props.as || baseTag, className = "", classInterpolations = [], mergedProps = props;
          if (props.theme == null) {
            mergedProps = {};
            for (var key in props)
              mergedProps[key] = props[key];
            mergedProps.theme = React90.useContext(react.ThemeContext);
          }
          typeof props.className == "string" ? className = utils.getRegisteredStyles(cache.registered, classInterpolations, props.className) : props.className != null && (className = props.className + " ");
          var serialized = serialize2.serializeStyles(styles4.concat(classInterpolations), cache.registered, mergedProps);
          className += cache.key + "-" + serialized.name, targetClassName !== void 0 && (className += " " + targetClassName);
          var finalShouldForwardProp = shouldUseAs && shouldForwardProp2 === void 0 ? getDefaultShouldForwardProp(FinalTag) : defaultShouldForwardProp, newProps = {};
          for (var _key in props)
            shouldUseAs && _key === "as" || finalShouldForwardProp(_key) && (newProps[_key] = props[_key]);
          return newProps.className = className, newProps.ref = ref, /* @__PURE__ */ React90.createElement(React90.Fragment, null, /* @__PURE__ */ React90.createElement(Insertion, {
            cache,
            serialized,
            isStringTag: typeof FinalTag == "string"
          }), /* @__PURE__ */ React90.createElement(FinalTag, newProps));
        });
        return Styled.displayName = identifierName !== void 0 ? identifierName : "Styled(" + (typeof baseTag == "string" ? baseTag : baseTag.displayName || baseTag.name || "Component") + ")", Styled.defaultProps = tag.defaultProps, Styled.__emotion_real = Styled, Styled.__emotion_base = baseTag, Styled.__emotion_styles = styles4, Styled.__emotion_forwardProp = shouldForwardProp2, Object.defineProperty(Styled, "toString", {
          value: function() {
            return targetClassName === void 0 ? "NO_COMPONENT_SELECTOR" : "." + targetClassName;
          }
        }), Styled.withComponent = function(nextTag, nextOptions) {
          return createStyled3(nextTag, _extends4({}, options, nextOptions, {
            shouldForwardProp: composeShouldForwardProps(Styled, nextOptions, !0)
          })).apply(void 0, styles4);
        }, Styled;
      };
    };
    exports.default = createStyled2;
  }
});

// node_modules/@emotion/styled/dist/emotion-styled.cjs.dev.js
var require_emotion_styled_cjs_dev = __commonJS({
  "node_modules/@emotion/styled/dist/emotion-styled.cjs.dev.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: !0 });
    require_extends();
    require_react();
    require_emotion_is_prop_valid_cjs();
    var base_dist_emotionStyledBase = require_emotion_styled_base_cjs_dev();
    require_emotion_react_cjs();
    require_emotion_utils_cjs();
    require_emotion_serialize_cjs();
    require_emotion_use_insertion_effect_with_fallbacks_cjs();
    var tags = [
      "a",
      "abbr",
      "address",
      "area",
      "article",
      "aside",
      "audio",
      "b",
      "base",
      "bdi",
      "bdo",
      "big",
      "blockquote",
      "body",
      "br",
      "button",
      "canvas",
      "caption",
      "cite",
      "code",
      "col",
      "colgroup",
      "data",
      "datalist",
      "dd",
      "del",
      "details",
      "dfn",
      "dialog",
      "div",
      "dl",
      "dt",
      "em",
      "embed",
      "fieldset",
      "figcaption",
      "figure",
      "footer",
      "form",
      "h1",
      "h2",
      "h3",
      "h4",
      "h5",
      "h6",
      "head",
      "header",
      "hgroup",
      "hr",
      "html",
      "i",
      "iframe",
      "img",
      "input",
      "ins",
      "kbd",
      "keygen",
      "label",
      "legend",
      "li",
      "link",
      "main",
      "map",
      "mark",
      "marquee",
      "menu",
      "menuitem",
      "meta",
      "meter",
      "nav",
      "noscript",
      "object",
      "ol",
      "optgroup",
      "option",
      "output",
      "p",
      "param",
      "picture",
      "pre",
      "progress",
      "q",
      "rp",
      "rt",
      "ruby",
      "s",
      "samp",
      "script",
      "section",
      "select",
      "small",
      "source",
      "span",
      "strong",
      "style",
      "sub",
      "summary",
      "sup",
      "table",
      "tbody",
      "td",
      "textarea",
      "tfoot",
      "th",
      "thead",
      "time",
      "title",
      "tr",
      "track",
      "u",
      "ul",
      "var",
      "video",
      "wbr",
      "circle",
      "clipPath",
      "defs",
      "ellipse",
      "foreignObject",
      "g",
      "image",
      "line",
      "linearGradient",
      "mask",
      "path",
      "pattern",
      "polygon",
      "polyline",
      "radialGradient",
      "rect",
      "stop",
      "svg",
      "text",
      "tspan"
    ], newStyled = base_dist_emotionStyledBase.default.bind();
    tags.forEach(function(tagName) {
      newStyled[tagName] = newStyled(tagName);
    });
    exports.default = newStyled;
  }
});

// node_modules/@emotion/styled/dist/emotion-styled.cjs.js
var require_emotion_styled_cjs = __commonJS({
  "node_modules/@emotion/styled/dist/emotion-styled.cjs.js"(exports, module) {
    "use strict";
    module.exports = require_emotion_styled_cjs_dev();
  }
});

// node_modules/@mui/styled-engine/GlobalStyles/GlobalStyles.js
function isEmpty2(obj) {
  return obj == null || Object.keys(obj).length === 0;
}
function GlobalStyles(props) {
  let {
    styles: styles4,
    defaultTheme: defaultTheme3 = {}
  } = props;
  return /* @__PURE__ */ (0, import_jsx_runtime8.jsx)(import_react7.Global, {
    styles: typeof styles4 == "function" ? (themeInput) => styles4(isEmpty2(themeInput) ? defaultTheme3 : themeInput) : styles4
  });
}
var React21, import_prop_types8, import_react7, import_jsx_runtime8, init_GlobalStyles = __esm({
  "node_modules/@mui/styled-engine/GlobalStyles/GlobalStyles.js"() {
    React21 = __toESM(require_react()), import_prop_types8 = __toESM(require_prop_types()), import_react7 = __toESM(require_emotion_react_cjs()), import_jsx_runtime8 = __toESM(require_jsx_runtime());
    GlobalStyles.propTypes = {
      defaultTheme: import_prop_types8.default.object,
      styles: import_prop_types8.default.oneOfType([import_prop_types8.default.string, import_prop_types8.default.object, import_prop_types8.default.func])
    };
  }
});

// node_modules/@mui/styled-engine/GlobalStyles/index.js
var init_GlobalStyles2 = __esm({
  "node_modules/@mui/styled-engine/GlobalStyles/index.js"() {
    init_GlobalStyles();
  }
});

// node_modules/@mui/styled-engine/index.js
function styled(tag, options) {
  let stylesFactory = (0, import_styled.default)(tag, options);
  return (...styles4) => {
    let component = typeof tag == "string" ? `"${tag}"` : "component";
    return styles4.length === 0 ? console.error([`MUI: Seems like you called \`styled(${component})()\` without a \`style\` argument.`, 'You must provide a `styles` argument: `styled("div")(styleYouForgotToPass)`.'].join(`
`)) : styles4.some((style3) => style3 === void 0) && console.error(`MUI: the styled(${component})(...args) API requires all its args to be defined.`), stylesFactory(...styles4);
  };
}
var import_styled, import_react8, internal_processStyles, init_styled_engine = __esm({
  "node_modules/@mui/styled-engine/index.js"() {
    import_styled = __toESM(require_emotion_styled_cjs()), import_react8 = __toESM(require_emotion_react_cjs());
    init_GlobalStyles2();
    internal_processStyles = (tag, processor) => {
      Array.isArray(tag.__emotion_styles) && (tag.__emotion_styles = processor(tag.__emotion_styles));
    };
  }
});

// node_modules/@mui/system/esm/responsivePropType.js
var import_prop_types9, responsivePropType, responsivePropType_default, init_responsivePropType = __esm({
  "node_modules/@mui/system/esm/responsivePropType.js"() {
    import_prop_types9 = __toESM(require_prop_types()), responsivePropType = import_prop_types9.default.oneOfType([import_prop_types9.default.number, import_prop_types9.default.string, import_prop_types9.default.object, import_prop_types9.default.array]), responsivePropType_default = responsivePropType;
  }
});

// node_modules/@mui/system/esm/merge.js
function merge(acc, item) {
  return item ? deepmerge(acc, item, {
    clone: !1
  }) : acc;
}
var merge_default, init_merge = __esm({
  "node_modules/@mui/system/esm/merge.js"() {
    init_esm2();
    merge_default = merge;
  }
});

// node_modules/@mui/system/esm/breakpoints.js
function handleBreakpoints(props, propValue, styleFromPropValue) {
  let theme = props.theme || {};
  if (Array.isArray(propValue)) {
    let themeBreakpoints = theme.breakpoints || defaultBreakpoints;
    return propValue.reduce((acc, item, index) => (acc[themeBreakpoints.up(themeBreakpoints.keys[index])] = styleFromPropValue(propValue[index]), acc), {});
  }
  if (typeof propValue == "object") {
    let themeBreakpoints = theme.breakpoints || defaultBreakpoints;
    return Object.keys(propValue).reduce((acc, breakpoint) => {
      if (Object.keys(themeBreakpoints.values || values).indexOf(breakpoint) !== -1) {
        let mediaKey = themeBreakpoints.up(breakpoint);
        acc[mediaKey] = styleFromPropValue(propValue[breakpoint], breakpoint);
      } else {
        let cssKey = breakpoint;
        acc[cssKey] = propValue[cssKey];
      }
      return acc;
    }, {});
  }
  return styleFromPropValue(propValue);
}
function createEmptyBreakpointObject(breakpointsInput = {}) {
  var _breakpointsInput$key;
  return ((_breakpointsInput$key = breakpointsInput.keys) == null ? void 0 : _breakpointsInput$key.reduce((acc, key) => {
    let breakpointStyleKey = breakpointsInput.up(key);
    return acc[breakpointStyleKey] = {}, acc;
  }, {})) || {};
}
function removeUnusedBreakpoints(breakpointKeys, style3) {
  return breakpointKeys.reduce((acc, key) => {
    let breakpointOutput = acc[key];
    return (!breakpointOutput || Object.keys(breakpointOutput).length === 0) && delete acc[key], acc;
  }, style3);
}
var values, defaultBreakpoints, init_breakpoints = __esm({
  "node_modules/@mui/system/esm/breakpoints.js"() {
    init_extends();
    values = {
      xs: 0,
      sm: 600,
      md: 900,
      lg: 1200,
      xl: 1536
    }, defaultBreakpoints = {
      keys: ["xs", "sm", "md", "lg", "xl"],
      up: (key) => `@media (min-width:${values[key]}px)`
    };
  }
});

// node_modules/@mui/system/esm/style.js
function getPath(obj, path, checkVars = !0) {
  if (!path || typeof path != "string")
    return null;
  if (obj && obj.vars && checkVars) {
    let val = `vars.${path}`.split(".").reduce((acc, item) => acc && acc[item] ? acc[item] : null, obj);
    if (val != null)
      return val;
  }
  return path.split(".").reduce((acc, item) => acc && acc[item] != null ? acc[item] : null, obj);
}
function getValue(themeMapping, transform2, propValueFinal, userValue = propValueFinal) {
  let value;
  return typeof themeMapping == "function" ? value = themeMapping(propValueFinal) : Array.isArray(themeMapping) ? value = themeMapping[propValueFinal] || userValue : value = getPath(themeMapping, propValueFinal) || userValue, transform2 && (value = transform2(value)), value;
}
function style(options) {
  let {
    prop,
    cssProperty = options.prop,
    themeKey,
    transform: transform2
  } = options, fn = (props) => {
    if (props[prop] == null)
      return null;
    let propValue = props[prop], theme = props.theme, themeMapping = getPath(theme, themeKey) || {};
    return handleBreakpoints(props, propValue, (propValueFinal) => {
      let value = getValue(themeMapping, transform2, propValueFinal);
      return propValueFinal === value && typeof propValueFinal == "string" && (value = getValue(themeMapping, transform2, `${prop}${propValueFinal === "default" ? "" : capitalize(propValueFinal)}`, propValueFinal)), cssProperty === !1 ? value : {
        [cssProperty]: value
      };
    });
  };
  return fn.propTypes = {
    [prop]: responsivePropType_default
  }, fn.filterProps = [prop], fn;
}
var style_default, init_style = __esm({
  "node_modules/@mui/system/esm/style.js"() {
    init_esm2();
    init_responsivePropType();
    init_breakpoints();
    style_default = style;
  }
});

// node_modules/@mui/system/esm/compose.js
function compose(...styles4) {
  let handlers = styles4.reduce((acc, style3) => (style3.filterProps.forEach((prop) => {
    acc[prop] = style3;
  }), acc), {}), fn = (props) => Object.keys(props).reduce((acc, prop) => handlers[prop] ? merge_default(acc, handlers[prop](props)) : acc, {});
  return fn.propTypes = styles4.reduce((acc, style3) => Object.assign(acc, style3.propTypes), {}), fn.filterProps = styles4.reduce((acc, style3) => acc.concat(style3.filterProps), []), fn;
}
var compose_default, init_compose = __esm({
  "node_modules/@mui/system/esm/compose.js"() {
    init_merge();
    compose_default = compose;
  }
});

// node_modules/@mui/system/esm/memoize.js
function memoize(fn) {
  let cache = {};
  return (arg) => (cache[arg] === void 0 && (cache[arg] = fn(arg)), cache[arg]);
}
var init_memoize = __esm({
  "node_modules/@mui/system/esm/memoize.js"() {
  }
});

// node_modules/@mui/system/esm/spacing.js
function createUnaryUnit(theme, themeKey, defaultValue, propName) {
  var _getPath;
  let themeSpacing = (_getPath = getPath(theme, themeKey, !1)) != null ? _getPath : defaultValue;
  return typeof themeSpacing == "number" ? (abs) => typeof abs == "string" ? abs : (typeof abs != "number" && console.error(`MUI: Expected ${propName} argument to be a number or a string, got ${abs}.`), themeSpacing * abs) : Array.isArray(themeSpacing) ? (abs) => typeof abs == "string" ? abs : (Number.isInteger(abs) ? abs > themeSpacing.length - 1 && console.error([`MUI: The value provided (${abs}) overflows.`, `The supported values are: ${JSON.stringify(themeSpacing)}.`, `${abs} > ${themeSpacing.length - 1}, you need to add the missing values.`].join(`
`)) : console.error([`MUI: The \`theme.${themeKey}\` array type cannot be combined with non integer values.You should either use an integer value that can be used as index, or define the \`theme.${themeKey}\` as a number.`].join(`
`)), themeSpacing[abs]) : typeof themeSpacing == "function" ? themeSpacing : (console.error([`MUI: The \`theme.${themeKey}\` value (${themeSpacing}) is invalid.`, "It should be a number, an array or a function."].join(`
`)), () => {
  });
}
function createUnarySpacing(theme) {
  return createUnaryUnit(theme, "spacing", 8, "spacing");
}
function getValue2(transformer, propValue) {
  if (typeof propValue == "string" || propValue == null)
    return propValue;
  let abs = Math.abs(propValue), transformed = transformer(abs);
  return propValue >= 0 ? transformed : typeof transformed == "number" ? -transformed : `-${transformed}`;
}
function getStyleFromPropValue(cssProperties, transformer) {
  return (propValue) => cssProperties.reduce((acc, cssProperty) => (acc[cssProperty] = getValue2(transformer, propValue), acc), {});
}
function resolveCssProperty(props, keys2, prop, transformer) {
  if (keys2.indexOf(prop) === -1)
    return null;
  let cssProperties = getCssProperties(prop), styleFromPropValue = getStyleFromPropValue(cssProperties, transformer), propValue = props[prop];
  return handleBreakpoints(props, propValue, styleFromPropValue);
}
function style2(props, keys2) {
  let transformer = createUnarySpacing(props.theme);
  return Object.keys(props).map((prop) => resolveCssProperty(props, keys2, prop, transformer)).reduce(merge_default, {});
}
function margin(props) {
  return style2(props, marginKeys);
}
function padding(props) {
  return style2(props, paddingKeys);
}
function spacing(props) {
  return style2(props, spacingKeys);
}
var properties, directions, aliases, getCssProperties, marginKeys, paddingKeys, spacingKeys, spacing_default, init_spacing = __esm({
  "node_modules/@mui/system/esm/spacing.js"() {
    init_responsivePropType();
    init_breakpoints();
    init_style();
    init_merge();
    init_memoize();
    properties = {
      m: "margin",
      p: "padding"
    }, directions = {
      t: "Top",
      r: "Right",
      b: "Bottom",
      l: "Left",
      x: ["Left", "Right"],
      y: ["Top", "Bottom"]
    }, aliases = {
      marginX: "mx",
      marginY: "my",
      paddingX: "px",
      paddingY: "py"
    }, getCssProperties = memoize((prop) => {
      if (prop.length > 2)
        if (aliases[prop])
          prop = aliases[prop];
        else
          return [prop];
      let [a, b] = prop.split(""), property = properties[a], direction = directions[b] || "";
      return Array.isArray(direction) ? direction.map((dir) => property + dir) : [property + direction];
    }), marginKeys = ["m", "mt", "mr", "mb", "ml", "mx", "my", "margin", "marginTop", "marginRight", "marginBottom", "marginLeft", "marginX", "marginY", "marginInline", "marginInlineStart", "marginInlineEnd", "marginBlock", "marginBlockStart", "marginBlockEnd"], paddingKeys = ["p", "pt", "pr", "pb", "pl", "px", "py", "padding", "paddingTop", "paddingRight", "paddingBottom", "paddingLeft", "paddingX", "paddingY", "paddingInline", "paddingInlineStart", "paddingInlineEnd", "paddingBlock", "paddingBlockStart", "paddingBlockEnd"], spacingKeys = [...marginKeys, ...paddingKeys];
    margin.propTypes = marginKeys.reduce((obj, key) => (obj[key] = responsivePropType_default, obj), {});
    margin.filterProps = marginKeys;
    padding.propTypes = paddingKeys.reduce((obj, key) => (obj[key] = responsivePropType_default, obj), {});
    padding.filterProps = paddingKeys;
    spacing.propTypes = spacingKeys.reduce((obj, key) => (obj[key] = responsivePropType_default, obj), {});
    spacing.filterProps = spacingKeys;
    spacing_default = spacing;
  }
});

// node_modules/@mui/system/esm/borders.js
function getBorder(value) {
  return typeof value != "number" ? value : `${value}px solid`;
}
var border, borderTop, borderRight, borderBottom, borderLeft, borderColor, borderTopColor, borderRightColor, borderBottomColor, borderLeftColor, borderRadius, borders, borders_default, init_borders = __esm({
  "node_modules/@mui/system/esm/borders.js"() {
    init_responsivePropType();
    init_style();
    init_compose();
    init_spacing();
    init_breakpoints();
    border = style_default({
      prop: "border",
      themeKey: "borders",
      transform: getBorder
    }), borderTop = style_default({
      prop: "borderTop",
      themeKey: "borders",
      transform: getBorder
    }), borderRight = style_default({
      prop: "borderRight",
      themeKey: "borders",
      transform: getBorder
    }), borderBottom = style_default({
      prop: "borderBottom",
      themeKey: "borders",
      transform: getBorder
    }), borderLeft = style_default({
      prop: "borderLeft",
      themeKey: "borders",
      transform: getBorder
    }), borderColor = style_default({
      prop: "borderColor",
      themeKey: "palette"
    }), borderTopColor = style_default({
      prop: "borderTopColor",
      themeKey: "palette"
    }), borderRightColor = style_default({
      prop: "borderRightColor",
      themeKey: "palette"
    }), borderBottomColor = style_default({
      prop: "borderBottomColor",
      themeKey: "palette"
    }), borderLeftColor = style_default({
      prop: "borderLeftColor",
      themeKey: "palette"
    }), borderRadius = (props) => {
      if (props.borderRadius !== void 0 && props.borderRadius !== null) {
        let transformer = createUnaryUnit(props.theme, "shape.borderRadius", 4, "borderRadius"), styleFromPropValue = (propValue) => ({
          borderRadius: getValue2(transformer, propValue)
        });
        return handleBreakpoints(props, props.borderRadius, styleFromPropValue);
      }
      return null;
    };
    borderRadius.propTypes = {
      borderRadius: responsivePropType_default
    };
    borderRadius.filterProps = ["borderRadius"];
    borders = compose_default(border, borderTop, borderRight, borderBottom, borderLeft, borderColor, borderTopColor, borderRightColor, borderBottomColor, borderLeftColor, borderRadius), borders_default = borders;
  }
});

// node_modules/@mui/system/esm/display.js
var displayPrint, displayRaw, overflow, textOverflow, visibility, whiteSpace, display_default, init_display = __esm({
  "node_modules/@mui/system/esm/display.js"() {
    init_style();
    init_compose();
    displayPrint = style_default({
      prop: "displayPrint",
      cssProperty: !1,
      transform: (value) => ({
        "@media print": {
          display: value
        }
      })
    }), displayRaw = style_default({
      prop: "display"
    }), overflow = style_default({
      prop: "overflow"
    }), textOverflow = style_default({
      prop: "textOverflow"
    }), visibility = style_default({
      prop: "visibility"
    }), whiteSpace = style_default({
      prop: "whiteSpace"
    }), display_default = compose_default(displayPrint, displayRaw, overflow, textOverflow, visibility, whiteSpace);
  }
});

// node_modules/@mui/system/esm/flexbox.js
var flexBasis, flexDirection, flexWrap, justifyContent, alignItems, alignContent, order, flex, flexGrow, flexShrink, alignSelf, justifyItems, justifySelf, flexbox, flexbox_default, init_flexbox = __esm({
  "node_modules/@mui/system/esm/flexbox.js"() {
    init_style();
    init_compose();
    flexBasis = style_default({
      prop: "flexBasis"
    }), flexDirection = style_default({
      prop: "flexDirection"
    }), flexWrap = style_default({
      prop: "flexWrap"
    }), justifyContent = style_default({
      prop: "justifyContent"
    }), alignItems = style_default({
      prop: "alignItems"
    }), alignContent = style_default({
      prop: "alignContent"
    }), order = style_default({
      prop: "order"
    }), flex = style_default({
      prop: "flex"
    }), flexGrow = style_default({
      prop: "flexGrow"
    }), flexShrink = style_default({
      prop: "flexShrink"
    }), alignSelf = style_default({
      prop: "alignSelf"
    }), justifyItems = style_default({
      prop: "justifyItems"
    }), justifySelf = style_default({
      prop: "justifySelf"
    }), flexbox = compose_default(flexBasis, flexDirection, flexWrap, justifyContent, alignItems, alignContent, order, flex, flexGrow, flexShrink, alignSelf, justifyItems, justifySelf), flexbox_default = flexbox;
  }
});

// node_modules/@mui/system/esm/cssGrid.js
var gap, columnGap, rowGap, gridColumn, gridRow, gridAutoFlow, gridAutoColumns, gridAutoRows, gridTemplateColumns, gridTemplateRows, gridTemplateAreas, gridArea, grid, cssGrid_default, init_cssGrid = __esm({
  "node_modules/@mui/system/esm/cssGrid.js"() {
    init_style();
    init_compose();
    init_spacing();
    init_breakpoints();
    init_responsivePropType();
    gap = (props) => {
      if (props.gap !== void 0 && props.gap !== null) {
        let transformer = createUnaryUnit(props.theme, "spacing", 8, "gap"), styleFromPropValue = (propValue) => ({
          gap: getValue2(transformer, propValue)
        });
        return handleBreakpoints(props, props.gap, styleFromPropValue);
      }
      return null;
    };
    gap.propTypes = {
      gap: responsivePropType_default
    };
    gap.filterProps = ["gap"];
    columnGap = (props) => {
      if (props.columnGap !== void 0 && props.columnGap !== null) {
        let transformer = createUnaryUnit(props.theme, "spacing", 8, "columnGap"), styleFromPropValue = (propValue) => ({
          columnGap: getValue2(transformer, propValue)
        });
        return handleBreakpoints(props, props.columnGap, styleFromPropValue);
      }
      return null;
    };
    columnGap.propTypes = {
      columnGap: responsivePropType_default
    };
    columnGap.filterProps = ["columnGap"];
    rowGap = (props) => {
      if (props.rowGap !== void 0 && props.rowGap !== null) {
        let transformer = createUnaryUnit(props.theme, "spacing", 8, "rowGap"), styleFromPropValue = (propValue) => ({
          rowGap: getValue2(transformer, propValue)
        });
        return handleBreakpoints(props, props.rowGap, styleFromPropValue);
      }
      return null;
    };
    rowGap.propTypes = {
      rowGap: responsivePropType_default
    };
    rowGap.filterProps = ["rowGap"];
    gridColumn = style_default({
      prop: "gridColumn"
    }), gridRow = style_default({
      prop: "gridRow"
    }), gridAutoFlow = style_default({
      prop: "gridAutoFlow"
    }), gridAutoColumns = style_default({
      prop: "gridAutoColumns"
    }), gridAutoRows = style_default({
      prop: "gridAutoRows"
    }), gridTemplateColumns = style_default({
      prop: "gridTemplateColumns"
    }), gridTemplateRows = style_default({
      prop: "gridTemplateRows"
    }), gridTemplateAreas = style_default({
      prop: "gridTemplateAreas"
    }), gridArea = style_default({
      prop: "gridArea"
    }), grid = compose_default(gap, columnGap, rowGap, gridColumn, gridRow, gridAutoFlow, gridAutoColumns, gridAutoRows, gridTemplateColumns, gridTemplateRows, gridTemplateAreas, gridArea), cssGrid_default = grid;
  }
});

// node_modules/@mui/system/esm/palette.js
var color, bgcolor, backgroundColor, palette, palette_default, init_palette = __esm({
  "node_modules/@mui/system/esm/palette.js"() {
    init_style();
    init_compose();
    color = style_default({
      prop: "color",
      themeKey: "palette"
    }), bgcolor = style_default({
      prop: "bgcolor",
      cssProperty: "backgroundColor",
      themeKey: "palette"
    }), backgroundColor = style_default({
      prop: "backgroundColor",
      themeKey: "palette"
    }), palette = compose_default(color, bgcolor, backgroundColor), palette_default = palette;
  }
});

// node_modules/@mui/system/esm/positions.js
var position, zIndex, top, right, bottom, left, positions_default, init_positions = __esm({
  "node_modules/@mui/system/esm/positions.js"() {
    init_style();
    init_compose();
    position = style_default({
      prop: "position"
    }), zIndex = style_default({
      prop: "zIndex",
      themeKey: "zIndex"
    }), top = style_default({
      prop: "top"
    }), right = style_default({
      prop: "right"
    }), bottom = style_default({
      prop: "bottom"
    }), left = style_default({
      prop: "left"
    }), positions_default = compose_default(position, zIndex, top, right, bottom, left);
  }
});

// node_modules/@mui/system/esm/shadows.js
var boxShadow, shadows_default, init_shadows = __esm({
  "node_modules/@mui/system/esm/shadows.js"() {
    init_style();
    boxShadow = style_default({
      prop: "boxShadow",
      themeKey: "shadows"
    }), shadows_default = boxShadow;
  }
});

// node_modules/@mui/system/esm/sizing.js
function transform(value) {
  return value <= 1 && value !== 0 ? `${value * 100}%` : value;
}
var width, maxWidth, minWidth, height, maxHeight, minHeight, sizeWidth, sizeHeight, boxSizing, sizing, sizing_default, init_sizing = __esm({
  "node_modules/@mui/system/esm/sizing.js"() {
    init_style();
    init_compose();
    init_breakpoints();
    width = style_default({
      prop: "width",
      transform
    }), maxWidth = (props) => {
      if (props.maxWidth !== void 0 && props.maxWidth !== null) {
        let styleFromPropValue = (propValue) => {
          var _props$theme, _props$theme$breakpoi, _props$theme$breakpoi2;
          return {
            maxWidth: ((_props$theme = props.theme) == null || (_props$theme$breakpoi = _props$theme.breakpoints) == null || (_props$theme$breakpoi2 = _props$theme$breakpoi.values) == null ? void 0 : _props$theme$breakpoi2[propValue]) || values[propValue] || transform(propValue)
          };
        };
        return handleBreakpoints(props, props.maxWidth, styleFromPropValue);
      }
      return null;
    };
    maxWidth.filterProps = ["maxWidth"];
    minWidth = style_default({
      prop: "minWidth",
      transform
    }), height = style_default({
      prop: "height",
      transform
    }), maxHeight = style_default({
      prop: "maxHeight",
      transform
    }), minHeight = style_default({
      prop: "minHeight",
      transform
    }), sizeWidth = style_default({
      prop: "size",
      cssProperty: "width",
      transform
    }), sizeHeight = style_default({
      prop: "size",
      cssProperty: "height",
      transform
    }), boxSizing = style_default({
      prop: "boxSizing"
    }), sizing = compose_default(width, maxWidth, minWidth, height, maxHeight, minHeight, boxSizing), sizing_default = sizing;
  }
});

// node_modules/@mui/system/esm/typography.js
var fontFamily, fontSize, fontStyle, fontWeight, letterSpacing, textTransform, lineHeight, textAlign, typographyVariant, typography, typography_default, init_typography = __esm({
  "node_modules/@mui/system/esm/typography.js"() {
    init_style();
    init_compose();
    fontFamily = style_default({
      prop: "fontFamily",
      themeKey: "typography"
    }), fontSize = style_default({
      prop: "fontSize",
      themeKey: "typography"
    }), fontStyle = style_default({
      prop: "fontStyle",
      themeKey: "typography"
    }), fontWeight = style_default({
      prop: "fontWeight",
      themeKey: "typography"
    }), letterSpacing = style_default({
      prop: "letterSpacing"
    }), textTransform = style_default({
      prop: "textTransform"
    }), lineHeight = style_default({
      prop: "lineHeight"
    }), textAlign = style_default({
      prop: "textAlign"
    }), typographyVariant = style_default({
      prop: "typography",
      cssProperty: !1,
      themeKey: "typography"
    }), typography = compose_default(typographyVariant, fontFamily, fontSize, fontStyle, fontWeight, letterSpacing, lineHeight, textAlign, textTransform), typography_default = typography;
  }
});

// node_modules/@mui/system/esm/getThemeValue.js
var filterPropsMapping, styleFunctionMapping, propToStyleFunction, init_getThemeValue = __esm({
  "node_modules/@mui/system/esm/getThemeValue.js"() {
    init_borders();
    init_display();
    init_flexbox();
    init_cssGrid();
    init_positions();
    init_palette();
    init_shadows();
    init_sizing();
    init_spacing();
    init_typography();
    filterPropsMapping = {
      borders: borders_default.filterProps,
      display: display_default.filterProps,
      flexbox: flexbox_default.filterProps,
      grid: cssGrid_default.filterProps,
      positions: positions_default.filterProps,
      palette: palette_default.filterProps,
      shadows: shadows_default.filterProps,
      sizing: sizing_default.filterProps,
      spacing: spacing_default.filterProps,
      typography: typography_default.filterProps
    }, styleFunctionMapping = {
      borders: borders_default,
      display: display_default,
      flexbox: flexbox_default,
      grid: cssGrid_default,
      positions: positions_default,
      palette: palette_default,
      shadows: shadows_default,
      sizing: sizing_default,
      spacing: spacing_default,
      typography: typography_default
    }, propToStyleFunction = Object.keys(filterPropsMapping).reduce((acc, styleFnName) => (filterPropsMapping[styleFnName].forEach((propName) => {
      acc[propName] = styleFunctionMapping[styleFnName];
    }), acc), {});
  }
});

// node_modules/@mui/system/esm/styleFunctionSx/styleFunctionSx.js
function objectsHaveSameKeys(...objects) {
  let allKeys = objects.reduce((keys2, object) => keys2.concat(Object.keys(object)), []), union = new Set(allKeys);
  return objects.every((object) => union.size === Object.keys(object).length);
}
function callIfFn(maybeFn, arg) {
  return typeof maybeFn == "function" ? maybeFn(arg) : maybeFn;
}
function unstable_createStyleFunctionSx(styleFunctionMapping2 = styleFunctionMapping) {
  let propToStyleFunction2 = Object.keys(styleFunctionMapping2).reduce((acc, styleFnName) => (styleFunctionMapping2[styleFnName].filterProps.forEach((propName) => {
    acc[propName] = styleFunctionMapping2[styleFnName];
  }), acc), {});
  function getThemeValue(prop, value, theme) {
    let inputProps = {
      [prop]: value,
      theme
    }, styleFunction = propToStyleFunction2[prop];
    return styleFunction ? styleFunction(inputProps) : {
      [prop]: value
    };
  }
  function styleFunctionSx2(props) {
    let {
      sx,
      theme = {}
    } = props || {};
    if (!sx)
      return null;
    function traverse(sxInput) {
      let sxObject = sxInput;
      if (typeof sxInput == "function")
        sxObject = sxInput(theme);
      else if (typeof sxInput != "object")
        return sxInput;
      if (!sxObject)
        return null;
      let emptyBreakpoints = createEmptyBreakpointObject(theme.breakpoints), breakpointsKeys = Object.keys(emptyBreakpoints), css2 = emptyBreakpoints;
      return Object.keys(sxObject).forEach((styleKey) => {
        let value = callIfFn(sxObject[styleKey], theme);
        if (value != null)
          if (typeof value == "object")
            if (propToStyleFunction2[styleKey])
              css2 = merge_default(css2, getThemeValue(styleKey, value, theme));
            else {
              let breakpointsValues = handleBreakpoints({
                theme
              }, value, (x) => ({
                [styleKey]: x
              }));
              objectsHaveSameKeys(breakpointsValues, value) ? css2[styleKey] = styleFunctionSx2({
                sx: value,
                theme
              }) : css2 = merge_default(css2, breakpointsValues);
            }
          else
            css2 = merge_default(css2, getThemeValue(styleKey, value, theme));
      }), removeUnusedBreakpoints(breakpointsKeys, css2);
    }
    return Array.isArray(sx) ? sx.map(traverse) : traverse(sx);
  }
  return styleFunctionSx2;
}
var styleFunctionSx, styleFunctionSx_default, init_styleFunctionSx = __esm({
  "node_modules/@mui/system/esm/styleFunctionSx/styleFunctionSx.js"() {
    init_merge();
    init_getThemeValue();
    init_breakpoints();
    styleFunctionSx = unstable_createStyleFunctionSx();
    styleFunctionSx.filterProps = ["sx"];
    styleFunctionSx_default = styleFunctionSx;
  }
});

// node_modules/@mui/system/esm/styleFunctionSx/extendSxProp.js
function extendSxProp(props) {
  let {
    sx: inSx
  } = props, other = _objectWithoutPropertiesLoose2(props, _excluded6), {
    systemProps,
    otherProps
  } = splitProps(other), finalSx;
  return Array.isArray(inSx) ? finalSx = [systemProps, ...inSx] : typeof inSx == "function" ? finalSx = (...args) => {
    let result = inSx(...args);
    return isPlainObject(result) ? _extends({}, systemProps, result) : systemProps;
  } : finalSx = _extends({}, systemProps, inSx), _extends({}, otherProps, {
    sx: finalSx
  });
}
var _excluded6, splitProps, init_extendSxProp = __esm({
  "node_modules/@mui/system/esm/styleFunctionSx/extendSxProp.js"() {
    init_extends();
    init_objectWithoutPropertiesLoose();
    init_esm2();
    init_getThemeValue();
    _excluded6 = ["sx"], splitProps = (props) => {
      let result = {
        systemProps: {},
        otherProps: {}
      };
      return Object.keys(props).forEach((prop) => {
        propToStyleFunction[prop] ? result.systemProps[prop] = props[prop] : result.otherProps[prop] = props[prop];
      }), result;
    };
  }
});

// node_modules/@mui/system/esm/styleFunctionSx/index.js
var init_styleFunctionSx2 = __esm({
  "node_modules/@mui/system/esm/styleFunctionSx/index.js"() {
    init_styleFunctionSx();
    init_extendSxProp();
  }
});

// node_modules/@mui/system/esm/createTheme/createBreakpoints.js
function createBreakpoints(breakpoints) {
  let {
    values: values3 = {
      xs: 0,
      sm: 600,
      md: 900,
      lg: 1200,
      xl: 1536
    },
    unit = "px",
    step = 5
  } = breakpoints, other = _objectWithoutPropertiesLoose2(breakpoints, _excluded7), sortedValues = sortBreakpointsValues(values3), keys2 = Object.keys(sortedValues);
  function up(key) {
    return `@media (min-width:${typeof values3[key] == "number" ? values3[key] : key}${unit})`;
  }
  function down(key) {
    return `@media (max-width:${(typeof values3[key] == "number" ? values3[key] : key) - step / 100}${unit})`;
  }
  function between(start, end) {
    let endIndex = keys2.indexOf(end);
    return `@media (min-width:${typeof values3[start] == "number" ? values3[start] : start}${unit}) and (max-width:${(endIndex !== -1 && typeof values3[keys2[endIndex]] == "number" ? values3[keys2[endIndex]] : end) - step / 100}${unit})`;
  }
  function only(key) {
    return keys2.indexOf(key) + 1 < keys2.length ? between(key, keys2[keys2.indexOf(key) + 1]) : up(key);
  }
  function not(key) {
    let keyIndex = keys2.indexOf(key);
    return keyIndex === 0 ? up(keys2[1]) : keyIndex === keys2.length - 1 ? down(keys2[keyIndex]) : between(key, keys2[keys2.indexOf(key) + 1]).replace("@media", "@media not all and");
  }
  return _extends({
    keys: keys2,
    values: sortedValues,
    up,
    down,
    between,
    only,
    not,
    unit
  }, other);
}
var _excluded7, sortBreakpointsValues, init_createBreakpoints = __esm({
  "node_modules/@mui/system/esm/createTheme/createBreakpoints.js"() {
    init_objectWithoutPropertiesLoose();
    init_extends();
    _excluded7 = ["values", "unit", "step"], sortBreakpointsValues = (values3) => {
      let breakpointsAsArray = Object.keys(values3).map((key) => ({
        key,
        val: values3[key]
      })) || [];
      return breakpointsAsArray.sort((breakpoint1, breakpoint2) => breakpoint1.val - breakpoint2.val), breakpointsAsArray.reduce((acc, obj) => _extends({}, acc, {
        [obj.key]: obj.val
      }), {});
    };
  }
});

// node_modules/@mui/system/esm/createTheme/shape.js
var shape, shape_default, init_shape = __esm({
  "node_modules/@mui/system/esm/createTheme/shape.js"() {
    shape = {
      borderRadius: 4
    }, shape_default = shape;
  }
});

// node_modules/@mui/system/esm/createTheme/createSpacing.js
function createSpacing(spacingInput = 8) {
  if (spacingInput.mui)
    return spacingInput;
  let transform2 = createUnarySpacing({
    spacing: spacingInput
  }), spacing2 = (...argsInput) => (argsInput.length <= 4 || console.error(`MUI: Too many arguments provided, expected between 0 and 4, got ${argsInput.length}`), (argsInput.length === 0 ? [1] : argsInput).map((argument) => {
    let output = transform2(argument);
    return typeof output == "number" ? `${output}px` : output;
  }).join(" "));
  return spacing2.mui = !0, spacing2;
}
var init_createSpacing = __esm({
  "node_modules/@mui/system/esm/createTheme/createSpacing.js"() {
    init_spacing();
  }
});

// node_modules/@mui/system/esm/createTheme/createTheme.js
function createTheme(options = {}, ...args) {
  let {
    breakpoints: breakpointsInput = {},
    palette: paletteInput = {},
    spacing: spacingInput,
    shape: shapeInput = {}
  } = options, other = _objectWithoutPropertiesLoose2(options, _excluded8), breakpoints = createBreakpoints(breakpointsInput), spacing2 = createSpacing(spacingInput), muiTheme = deepmerge({
    breakpoints,
    direction: "ltr",
    components: {},
    palette: _extends({
      mode: "light"
    }, paletteInput),
    spacing: spacing2,
    shape: _extends({}, shape_default, shapeInput)
  }, other);
  return muiTheme = args.reduce((acc, argument) => deepmerge(acc, argument), muiTheme), muiTheme;
}
var _excluded8, createTheme_default, init_createTheme = __esm({
  "node_modules/@mui/system/esm/createTheme/createTheme.js"() {
    init_extends();
    init_objectWithoutPropertiesLoose();
    init_esm2();
    init_createBreakpoints();
    init_shape();
    init_createSpacing();
    _excluded8 = ["breakpoints", "palette", "spacing", "shape"];
    createTheme_default = createTheme;
  }
});

// node_modules/@mui/system/esm/createTheme/index.js
var init_createTheme2 = __esm({
  "node_modules/@mui/system/esm/createTheme/index.js"() {
    init_createTheme();
  }
});

// node_modules/@mui/private-theming/useTheme/ThemeContext.js
var React22, ThemeContext2, ThemeContext_default, init_ThemeContext = __esm({
  "node_modules/@mui/private-theming/useTheme/ThemeContext.js"() {
    React22 = __toESM(require_react()), ThemeContext2 = /* @__PURE__ */ React22.createContext(null);
    ThemeContext2.displayName = "ThemeContext";
    ThemeContext_default = ThemeContext2;
  }
});

// node_modules/@mui/private-theming/useTheme/useTheme.js
function useTheme() {
  let theme = React23.useContext(ThemeContext_default);
  return React23.useDebugValue(theme), theme;
}
var React23, init_useTheme = __esm({
  "node_modules/@mui/private-theming/useTheme/useTheme.js"() {
    React23 = __toESM(require_react());
    init_ThemeContext();
  }
});

// node_modules/@mui/private-theming/useTheme/index.js
var init_useTheme2 = __esm({
  "node_modules/@mui/private-theming/useTheme/index.js"() {
    init_useTheme();
  }
});

// node_modules/@mui/private-theming/ThemeProvider/index.js
var init_ThemeProvider = __esm({
  "node_modules/@mui/private-theming/ThemeProvider/index.js"() {
  }
});

// node_modules/@mui/private-theming/index.js
var init_private_theming = __esm({
  "node_modules/@mui/private-theming/index.js"() {
    init_ThemeProvider();
    init_useTheme2();
  }
});

// node_modules/@mui/system/esm/useThemeWithoutDefault.js
function isObjectEmpty(obj) {
  return Object.keys(obj).length === 0;
}
function useTheme2(defaultTheme3 = null) {
  let contextTheme = useTheme();
  return !contextTheme || isObjectEmpty(contextTheme) ? defaultTheme3 : contextTheme;
}
var useThemeWithoutDefault_default, init_useThemeWithoutDefault = __esm({
  "node_modules/@mui/system/esm/useThemeWithoutDefault.js"() {
    init_private_theming();
    useThemeWithoutDefault_default = useTheme2;
  }
});

// node_modules/@mui/system/esm/useTheme.js
function useTheme3(defaultTheme3 = systemDefaultTheme) {
  return useThemeWithoutDefault_default(defaultTheme3);
}
var systemDefaultTheme, useTheme_default, init_useTheme3 = __esm({
  "node_modules/@mui/system/esm/useTheme.js"() {
    init_createTheme2();
    init_useThemeWithoutDefault();
    systemDefaultTheme = createTheme_default();
    useTheme_default = useTheme3;
  }
});

// node_modules/@mui/system/esm/createBox.js
function createBox(options = {}) {
  let {
    defaultTheme: defaultTheme3,
    defaultClassName = "MuiBox-root",
    generateClassName,
    styleFunctionSx: styleFunctionSx2 = styleFunctionSx_default
  } = options, BoxRoot = styled("div", {
    shouldForwardProp: (prop) => prop !== "theme" && prop !== "sx" && prop !== "as"
  })(styleFunctionSx2);
  return /* @__PURE__ */ React24.forwardRef(function(inProps, ref) {
    let theme = useTheme_default(defaultTheme3), _extendSxProp = extendSxProp(inProps), {
      className,
      component = "div"
    } = _extendSxProp, other = _objectWithoutPropertiesLoose2(_extendSxProp, _excluded9);
    return /* @__PURE__ */ (0, import_jsx_runtime9.jsx)(BoxRoot, _extends({
      as: component,
      ref,
      className: clsx_m_default(className, generateClassName ? generateClassName(defaultClassName) : defaultClassName),
      theme
    }, other));
  });
}
var React24, import_jsx_runtime9, _excluded9, init_createBox = __esm({
  "node_modules/@mui/system/esm/createBox.js"() {
    init_extends();
    init_objectWithoutPropertiesLoose();
    React24 = __toESM(require_react());
    init_clsx_m();
    init_styled_engine();
    init_styleFunctionSx2();
    init_useTheme3();
    import_jsx_runtime9 = __toESM(require_jsx_runtime()), _excluded9 = ["className", "component"];
  }
});

// node_modules/@mui/system/esm/propsToClassKey.js
function isEmpty3(string) {
  return string.length === 0;
}
function propsToClassKey(props) {
  let {
    variant
  } = props, other = _objectWithoutPropertiesLoose2(props, _excluded10), classKey = variant || "";
  return Object.keys(other).sort().forEach((key) => {
    key === "color" ? classKey += isEmpty3(classKey) ? props[key] : capitalize(props[key]) : classKey += `${isEmpty3(classKey) ? key : capitalize(key)}${capitalize(props[key].toString())}`;
  }), classKey;
}
var _excluded10, init_propsToClassKey = __esm({
  "node_modules/@mui/system/esm/propsToClassKey.js"() {
    init_objectWithoutPropertiesLoose();
    init_esm2();
    _excluded10 = ["variant"];
  }
});

// node_modules/@mui/system/esm/createStyled.js
function isEmpty4(obj) {
  return Object.keys(obj).length === 0;
}
function isStringTag(tag) {
  return typeof tag == "string" && tag.charCodeAt(0) > 96;
}
function shouldForwardProp(prop) {
  return prop !== "ownerState" && prop !== "theme" && prop !== "sx" && prop !== "as";
}
function createStyled(input = {}) {
  let {
    defaultTheme: defaultTheme3 = systemDefaultTheme2,
    rootShouldForwardProp: rootShouldForwardProp2 = shouldForwardProp,
    slotShouldForwardProp: slotShouldForwardProp2 = shouldForwardProp,
    styleFunctionSx: styleFunctionSx2 = styleFunctionSx_default
  } = input, systemSx = (props) => {
    let theme = isEmpty4(props.theme) ? defaultTheme3 : props.theme;
    return styleFunctionSx2(_extends({}, props, {
      theme
    }));
  };
  return systemSx.__mui_systemSx = !0, (tag, inputOptions = {}) => {
    internal_processStyles(tag, (styles4) => styles4.filter((style3) => !(style3 != null && style3.__mui_systemSx)));
    let {
      name: componentName,
      slot: componentSlot,
      skipVariantsResolver: inputSkipVariantsResolver,
      skipSx: inputSkipSx,
      overridesResolver: overridesResolver2
    } = inputOptions, options = _objectWithoutPropertiesLoose2(inputOptions, _excluded11), skipVariantsResolver = inputSkipVariantsResolver !== void 0 ? inputSkipVariantsResolver : componentSlot && componentSlot !== "Root" || !1, skipSx = inputSkipSx || !1, label;
    componentName && (label = `${componentName}-${lowercaseFirstLetter(componentSlot || "Root")}`);
    let shouldForwardPropOption = shouldForwardProp;
    componentSlot === "Root" ? shouldForwardPropOption = rootShouldForwardProp2 : componentSlot ? shouldForwardPropOption = slotShouldForwardProp2 : isStringTag(tag) && (shouldForwardPropOption = void 0);
    let defaultStyledResolver = styled(tag, _extends({
      shouldForwardProp: shouldForwardPropOption,
      label
    }, options)), muiStyledResolver = (styleArg, ...expressions) => {
      let expressionsWithDefaultTheme = expressions ? expressions.map((stylesArg) => typeof stylesArg == "function" && stylesArg.__emotion_real !== stylesArg ? (_ref) => {
        let {
          theme: themeInput
        } = _ref, other = _objectWithoutPropertiesLoose2(_ref, _excluded22);
        return stylesArg(_extends({
          theme: isEmpty4(themeInput) ? defaultTheme3 : themeInput
        }, other));
      } : stylesArg) : [], transformedStyleArg = styleArg;
      componentName && overridesResolver2 && expressionsWithDefaultTheme.push((props) => {
        let theme = isEmpty4(props.theme) ? defaultTheme3 : props.theme, styleOverrides = getStyleOverrides(componentName, theme);
        if (styleOverrides) {
          let resolvedStyleOverrides = {};
          return Object.entries(styleOverrides).forEach(([slotKey, slotStyle]) => {
            resolvedStyleOverrides[slotKey] = typeof slotStyle == "function" ? slotStyle(_extends({}, props, {
              theme
            })) : slotStyle;
          }), overridesResolver2(props, resolvedStyleOverrides);
        }
        return null;
      }), componentName && !skipVariantsResolver && expressionsWithDefaultTheme.push((props) => {
        let theme = isEmpty4(props.theme) ? defaultTheme3 : props.theme;
        return variantsResolver(props, getVariantStyles(componentName, theme), theme, componentName);
      }), skipSx || expressionsWithDefaultTheme.push(systemSx);
      let numOfCustomFnsApplied = expressionsWithDefaultTheme.length - expressions.length;
      if (Array.isArray(styleArg) && numOfCustomFnsApplied > 0) {
        let placeholders = new Array(numOfCustomFnsApplied).fill("");
        transformedStyleArg = [...styleArg, ...placeholders], transformedStyleArg.raw = [...styleArg.raw, ...placeholders];
      } else
        typeof styleArg == "function" && styleArg.__emotion_real !== styleArg && (transformedStyleArg = (_ref2) => {
          let {
            theme: themeInput
          } = _ref2, other = _objectWithoutPropertiesLoose2(_ref2, _excluded32);
          return styleArg(_extends({
            theme: isEmpty4(themeInput) ? defaultTheme3 : themeInput
          }, other));
        });
      let Component = defaultStyledResolver(transformedStyleArg, ...expressionsWithDefaultTheme);
      {
        let displayName;
        componentName && (displayName = `${componentName}${componentSlot || ""}`), displayName === void 0 && (displayName = `Styled(${getDisplayName(tag)})`), Component.displayName = displayName;
      }
      return Component;
    };
    return defaultStyledResolver.withConfig && (muiStyledResolver.withConfig = defaultStyledResolver.withConfig), muiStyledResolver;
  };
}
var _excluded11, _excluded22, _excluded32, getStyleOverrides, getVariantStyles, variantsResolver, systemDefaultTheme2, lowercaseFirstLetter, init_createStyled = __esm({
  "node_modules/@mui/system/esm/createStyled.js"() {
    init_objectWithoutPropertiesLoose();
    init_extends();
    init_styled_engine();
    init_esm2();
    init_createTheme2();
    init_propsToClassKey();
    init_styleFunctionSx2();
    _excluded11 = ["name", "slot", "skipVariantsResolver", "skipSx", "overridesResolver"], _excluded22 = ["theme"], _excluded32 = ["theme"];
    getStyleOverrides = (name, theme) => theme.components && theme.components[name] && theme.components[name].styleOverrides ? theme.components[name].styleOverrides : null, getVariantStyles = (name, theme) => {
      let variants = [];
      theme && theme.components && theme.components[name] && theme.components[name].variants && (variants = theme.components[name].variants);
      let variantsStyles = {};
      return variants.forEach((definition) => {
        let key = propsToClassKey(definition.props);
        variantsStyles[key] = definition.style;
      }), variantsStyles;
    }, variantsResolver = (props, styles4, theme, name) => {
      var _theme$components, _theme$components$nam;
      let {
        ownerState = {}
      } = props, variantsStyles = [], themeVariants = theme == null || (_theme$components = theme.components) == null || (_theme$components$nam = _theme$components[name]) == null ? void 0 : _theme$components$nam.variants;
      return themeVariants && themeVariants.forEach((themeVariant) => {
        let isMatch = !0;
        Object.keys(themeVariant.props).forEach((key) => {
          ownerState[key] !== themeVariant.props[key] && props[key] !== themeVariant.props[key] && (isMatch = !1);
        }), isMatch && variantsStyles.push(styles4[propsToClassKey(themeVariant.props)]);
      }), variantsStyles;
    };
    systemDefaultTheme2 = createTheme_default(), lowercaseFirstLetter = (string) => string.charAt(0).toLowerCase() + string.slice(1);
  }
});

// node_modules/@mui/system/esm/useThemeProps/getThemeProps.js
function getThemeProps(params) {
  let {
    theme,
    name,
    props
  } = params;
  return !theme || !theme.components || !theme.components[name] || !theme.components[name].defaultProps ? props : resolveProps(theme.components[name].defaultProps, props);
}
var init_getThemeProps = __esm({
  "node_modules/@mui/system/esm/useThemeProps/getThemeProps.js"() {
    init_esm2();
  }
});

// node_modules/@mui/system/esm/useThemeProps/useThemeProps.js
function useThemeProps({
  props,
  name,
  defaultTheme: defaultTheme3
}) {
  let theme = useTheme_default(defaultTheme3);
  return getThemeProps({
    theme,
    name,
    props
  });
}
var init_useThemeProps = __esm({
  "node_modules/@mui/system/esm/useThemeProps/useThemeProps.js"() {
    init_getThemeProps();
    init_useTheme3();
  }
});

// node_modules/@mui/system/esm/useThemeProps/index.js
var init_useThemeProps2 = __esm({
  "node_modules/@mui/system/esm/useThemeProps/index.js"() {
    init_useThemeProps();
  }
});

// node_modules/@mui/system/esm/colorManipulator.js
function clamp(value, min = 0, max = 1) {
  return (value < min || value > max) && console.error(`MUI: The value provided ${value} is out of range [${min}, ${max}].`), Math.min(Math.max(min, value), max);
}
function hexToRgb(color2) {
  color2 = color2.slice(1);
  let re = new RegExp(`.{1,${color2.length >= 6 ? 2 : 1}}`, "g"), colors = color2.match(re);
  return colors && colors[0].length === 1 && (colors = colors.map((n) => n + n)), colors ? `rgb${colors.length === 4 ? "a" : ""}(${colors.map((n, index) => index < 3 ? parseInt(n, 16) : Math.round(parseInt(n, 16) / 255 * 1e3) / 1e3).join(", ")})` : "";
}
function decomposeColor(color2) {
  if (color2.type)
    return color2;
  if (color2.charAt(0) === "#")
    return decomposeColor(hexToRgb(color2));
  let marker = color2.indexOf("("), type = color2.substring(0, marker);
  if (["rgb", "rgba", "hsl", "hsla", "color"].indexOf(type) === -1)
    throw new Error(`MUI: Unsupported \`${color2}\` color.
The following formats are supported: #nnn, #nnnnnn, rgb(), rgba(), hsl(), hsla(), color().`);
  let values3 = color2.substring(marker + 1, color2.length - 1), colorSpace;
  if (type === "color") {
    if (values3 = values3.split(" "), colorSpace = values3.shift(), values3.length === 4 && values3[3].charAt(0) === "/" && (values3[3] = values3[3].slice(1)), ["srgb", "display-p3", "a98-rgb", "prophoto-rgb", "rec-2020"].indexOf(colorSpace) === -1)
      throw new Error(`MUI: unsupported \`${colorSpace}\` color space.
The following color spaces are supported: srgb, display-p3, a98-rgb, prophoto-rgb, rec-2020.`);
  } else
    values3 = values3.split(",");
  return values3 = values3.map((value) => parseFloat(value)), {
    type,
    values: values3,
    colorSpace
  };
}
function recomposeColor(color2) {
  let {
    type,
    colorSpace
  } = color2, {
    values: values3
  } = color2;
  return type.indexOf("rgb") !== -1 ? values3 = values3.map((n, i) => i < 3 ? parseInt(n, 10) : n) : type.indexOf("hsl") !== -1 && (values3[1] = `${values3[1]}%`, values3[2] = `${values3[2]}%`), type.indexOf("color") !== -1 ? values3 = `${colorSpace} ${values3.join(" ")}` : values3 = `${values3.join(", ")}`, `${type}(${values3})`;
}
function hslToRgb(color2) {
  color2 = decomposeColor(color2);
  let {
    values: values3
  } = color2, h = values3[0], s = values3[1] / 100, l = values3[2] / 100, a = s * Math.min(l, 1 - l), f = (n, k = (n + h / 30) % 12) => l - a * Math.max(Math.min(k - 3, 9 - k, 1), -1), type = "rgb", rgb = [Math.round(f(0) * 255), Math.round(f(8) * 255), Math.round(f(4) * 255)];
  return color2.type === "hsla" && (type += "a", rgb.push(values3[3])), recomposeColor({
    type,
    values: rgb
  });
}
function getLuminance(color2) {
  color2 = decomposeColor(color2);
  let rgb = color2.type === "hsl" ? decomposeColor(hslToRgb(color2)).values : color2.values;
  return rgb = rgb.map((val) => (color2.type !== "color" && (val /= 255), val <= 0.03928 ? val / 12.92 : ((val + 0.055) / 1.055) ** 2.4)), Number((0.2126 * rgb[0] + 0.7152 * rgb[1] + 0.0722 * rgb[2]).toFixed(3));
}
function getContrastRatio(foreground, background) {
  let lumA = getLuminance(foreground), lumB = getLuminance(background);
  return (Math.max(lumA, lumB) + 0.05) / (Math.min(lumA, lumB) + 0.05);
}
function alpha(color2, value) {
  return color2 = decomposeColor(color2), value = clamp(value), (color2.type === "rgb" || color2.type === "hsl") && (color2.type += "a"), color2.type === "color" ? color2.values[3] = `/${value}` : color2.values[3] = value, recomposeColor(color2);
}
function darken(color2, coefficient) {
  if (color2 = decomposeColor(color2), coefficient = clamp(coefficient), color2.type.indexOf("hsl") !== -1)
    color2.values[2] *= 1 - coefficient;
  else if (color2.type.indexOf("rgb") !== -1 || color2.type.indexOf("color") !== -1)
    for (let i = 0; i < 3; i += 1)
      color2.values[i] *= 1 - coefficient;
  return recomposeColor(color2);
}
function lighten(color2, coefficient) {
  if (color2 = decomposeColor(color2), coefficient = clamp(coefficient), color2.type.indexOf("hsl") !== -1)
    color2.values[2] += (100 - color2.values[2]) * coefficient;
  else if (color2.type.indexOf("rgb") !== -1)
    for (let i = 0; i < 3; i += 1)
      color2.values[i] += (255 - color2.values[i]) * coefficient;
  else if (color2.type.indexOf("color") !== -1)
    for (let i = 0; i < 3; i += 1)
      color2.values[i] += (1 - color2.values[i]) * coefficient;
  return recomposeColor(color2);
}
var init_colorManipulator = __esm({
  "node_modules/@mui/system/esm/colorManipulator.js"() {
  }
});

// node_modules/@mui/system/esm/Container/containerClasses.js
var containerClasses, init_containerClasses = __esm({
  "node_modules/@mui/system/esm/Container/containerClasses.js"() {
    init_esm2();
    containerClasses = generateUtilityClasses("MuiContainer", ["root", "disableGutters", "fixed", "maxWidthXs", "maxWidthSm", "maxWidthMd", "maxWidthLg", "maxWidthXl"]);
  }
});

// node_modules/@mui/system/esm/Container/index.js
var init_Container = __esm({
  "node_modules/@mui/system/esm/Container/index.js"() {
    init_containerClasses();
  }
});

// node_modules/@mui/system/esm/Unstable_Grid/GridProps.js
var init_GridProps = __esm({
  "node_modules/@mui/system/esm/Unstable_Grid/GridProps.js"() {
  }
});

// node_modules/@mui/system/esm/Unstable_Grid/gridClasses.js
var SPACINGS, DIRECTIONS, WRAPS, GRID_SIZES, gridClasses, init_gridClasses = __esm({
  "node_modules/@mui/system/esm/Unstable_Grid/gridClasses.js"() {
    init_esm2();
    SPACINGS = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10], DIRECTIONS = ["column-reverse", "column", "row-reverse", "row"], WRAPS = ["nowrap", "wrap-reverse", "wrap"], GRID_SIZES = ["auto", !0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12], gridClasses = generateUtilityClasses("MuiGrid", [
      "root",
      "container",
      "item",
      ...SPACINGS.map((spacing2) => `spacing-xs-${spacing2}`),
      ...DIRECTIONS.map((direction) => `direction-xs-${direction}`),
      ...WRAPS.map((wrap) => `wrap-xs-${wrap}`),
      ...GRID_SIZES.map((size) => `grid-xs-${size}`),
      ...GRID_SIZES.map((size) => `grid-sm-${size}`),
      ...GRID_SIZES.map((size) => `grid-md-${size}`),
      ...GRID_SIZES.map((size) => `grid-lg-${size}`),
      ...GRID_SIZES.map((size) => `grid-xl-${size}`)
    ]);
  }
});

// node_modules/@mui/system/esm/Unstable_Grid/index.js
var init_Unstable_Grid = __esm({
  "node_modules/@mui/system/esm/Unstable_Grid/index.js"() {
    init_GridProps();
    init_gridClasses();
  }
});

// node_modules/@mui/system/esm/Stack/StackProps.js
var init_StackProps = __esm({
  "node_modules/@mui/system/esm/Stack/StackProps.js"() {
  }
});

// node_modules/@mui/system/esm/Stack/stackClasses.js
var stackClasses, init_stackClasses = __esm({
  "node_modules/@mui/system/esm/Stack/stackClasses.js"() {
    init_esm2();
    stackClasses = generateUtilityClasses("MuiStack", ["root"]);
  }
});

// node_modules/@mui/system/esm/Stack/index.js
var init_Stack = __esm({
  "node_modules/@mui/system/esm/Stack/index.js"() {
    init_StackProps();
    init_stackClasses();
  }
});

// node_modules/@mui/system/esm/index.js
var init_esm3 = __esm({
  "node_modules/@mui/system/esm/index.js"() {
    init_styled_engine();
    init_borders();
    init_flexbox();
    init_cssGrid();
    init_palette();
    init_positions();
    init_sizing();
    init_spacing();
    init_typography();
    init_styleFunctionSx2();
    init_createBox();
    init_createStyled();
    init_createStyled();
    init_createTheme2();
    init_useThemeProps2();
    init_useTheme3();
    init_colorManipulator();
    init_Container();
    init_Unstable_Grid();
    init_Stack();
  }
});

// node_modules/@mui/material/esm/styles/createMixins.js
function createMixins(breakpoints, mixins) {
  return _extends({
    toolbar: {
      minHeight: 56,
      [breakpoints.up("xs")]: {
        "@media (orientation: landscape)": {
          minHeight: 48
        }
      },
      [breakpoints.up("sm")]: {
        minHeight: 64
      }
    }
  }, mixins);
}
var init_createMixins = __esm({
  "node_modules/@mui/material/esm/styles/createMixins.js"() {
    init_extends();
  }
});

// node_modules/@mui/material/esm/colors/common.js
var common, common_default, init_common = __esm({
  "node_modules/@mui/material/esm/colors/common.js"() {
    common = {
      black: "#000",
      white: "#fff"
    }, common_default = common;
  }
});

// node_modules/@mui/material/esm/colors/grey.js
var grey, grey_default, init_grey = __esm({
  "node_modules/@mui/material/esm/colors/grey.js"() {
    grey = {
      50: "#fafafa",
      100: "#f5f5f5",
      200: "#eeeeee",
      300: "#e0e0e0",
      400: "#bdbdbd",
      500: "#9e9e9e",
      600: "#757575",
      700: "#616161",
      800: "#424242",
      900: "#212121",
      A100: "#f5f5f5",
      A200: "#eeeeee",
      A400: "#bdbdbd",
      A700: "#616161"
    }, grey_default = grey;
  }
});

// node_modules/@mui/material/esm/colors/purple.js
var purple, purple_default, init_purple = __esm({
  "node_modules/@mui/material/esm/colors/purple.js"() {
    purple = {
      50: "#f3e5f5",
      100: "#e1bee7",
      200: "#ce93d8",
      300: "#ba68c8",
      400: "#ab47bc",
      500: "#9c27b0",
      600: "#8e24aa",
      700: "#7b1fa2",
      800: "#6a1b9a",
      900: "#4a148c",
      A100: "#ea80fc",
      A200: "#e040fb",
      A400: "#d500f9",
      A700: "#aa00ff"
    }, purple_default = purple;
  }
});

// node_modules/@mui/material/esm/colors/red.js
var red, red_default, init_red = __esm({
  "node_modules/@mui/material/esm/colors/red.js"() {
    red = {
      50: "#ffebee",
      100: "#ffcdd2",
      200: "#ef9a9a",
      300: "#e57373",
      400: "#ef5350",
      500: "#f44336",
      600: "#e53935",
      700: "#d32f2f",
      800: "#c62828",
      900: "#b71c1c",
      A100: "#ff8a80",
      A200: "#ff5252",
      A400: "#ff1744",
      A700: "#d50000"
    }, red_default = red;
  }
});

// node_modules/@mui/material/esm/colors/orange.js
var orange, orange_default, init_orange = __esm({
  "node_modules/@mui/material/esm/colors/orange.js"() {
    orange = {
      50: "#fff3e0",
      100: "#ffe0b2",
      200: "#ffcc80",
      300: "#ffb74d",
      400: "#ffa726",
      500: "#ff9800",
      600: "#fb8c00",
      700: "#f57c00",
      800: "#ef6c00",
      900: "#e65100",
      A100: "#ffd180",
      A200: "#ffab40",
      A400: "#ff9100",
      A700: "#ff6d00"
    }, orange_default = orange;
  }
});

// node_modules/@mui/material/esm/colors/blue.js
var blue, blue_default, init_blue = __esm({
  "node_modules/@mui/material/esm/colors/blue.js"() {
    blue = {
      50: "#e3f2fd",
      100: "#bbdefb",
      200: "#90caf9",
      300: "#64b5f6",
      400: "#42a5f5",
      500: "#2196f3",
      600: "#1e88e5",
      700: "#1976d2",
      800: "#1565c0",
      900: "#0d47a1",
      A100: "#82b1ff",
      A200: "#448aff",
      A400: "#2979ff",
      A700: "#2962ff"
    }, blue_default = blue;
  }
});

// node_modules/@mui/material/esm/colors/lightBlue.js
var lightBlue, lightBlue_default, init_lightBlue = __esm({
  "node_modules/@mui/material/esm/colors/lightBlue.js"() {
    lightBlue = {
      50: "#e1f5fe",
      100: "#b3e5fc",
      200: "#81d4fa",
      300: "#4fc3f7",
      400: "#29b6f6",
      500: "#03a9f4",
      600: "#039be5",
      700: "#0288d1",
      800: "#0277bd",
      900: "#01579b",
      A100: "#80d8ff",
      A200: "#40c4ff",
      A400: "#00b0ff",
      A700: "#0091ea"
    }, lightBlue_default = lightBlue;
  }
});

// node_modules/@mui/material/esm/colors/green.js
var green, green_default, init_green = __esm({
  "node_modules/@mui/material/esm/colors/green.js"() {
    green = {
      50: "#e8f5e9",
      100: "#c8e6c9",
      200: "#a5d6a7",
      300: "#81c784",
      400: "#66bb6a",
      500: "#4caf50",
      600: "#43a047",
      700: "#388e3c",
      800: "#2e7d32",
      900: "#1b5e20",
      A100: "#b9f6ca",
      A200: "#69f0ae",
      A400: "#00e676",
      A700: "#00c853"
    }, green_default = green;
  }
});

// node_modules/@mui/material/esm/styles/createPalette.js
function addLightOrDark(intent, direction, shade, tonalOffset) {
  let tonalOffsetLight = tonalOffset.light || tonalOffset, tonalOffsetDark = tonalOffset.dark || tonalOffset * 1.5;
  intent[direction] || (intent.hasOwnProperty(shade) ? intent[direction] = intent[shade] : direction === "light" ? intent.light = lighten(intent.main, tonalOffsetLight) : direction === "dark" && (intent.dark = darken(intent.main, tonalOffsetDark)));
}
function getDefaultPrimary(mode = "light") {
  return mode === "dark" ? {
    main: blue_default[200],
    light: blue_default[50],
    dark: blue_default[400]
  } : {
    main: blue_default[700],
    light: blue_default[400],
    dark: blue_default[800]
  };
}
function getDefaultSecondary(mode = "light") {
  return mode === "dark" ? {
    main: purple_default[200],
    light: purple_default[50],
    dark: purple_default[400]
  } : {
    main: purple_default[500],
    light: purple_default[300],
    dark: purple_default[700]
  };
}
function getDefaultError(mode = "light") {
  return mode === "dark" ? {
    main: red_default[500],
    light: red_default[300],
    dark: red_default[700]
  } : {
    main: red_default[700],
    light: red_default[400],
    dark: red_default[800]
  };
}
function getDefaultInfo(mode = "light") {
  return mode === "dark" ? {
    main: lightBlue_default[400],
    light: lightBlue_default[300],
    dark: lightBlue_default[700]
  } : {
    main: lightBlue_default[700],
    light: lightBlue_default[500],
    dark: lightBlue_default[900]
  };
}
function getDefaultSuccess(mode = "light") {
  return mode === "dark" ? {
    main: green_default[400],
    light: green_default[300],
    dark: green_default[700]
  } : {
    main: green_default[800],
    light: green_default[500],
    dark: green_default[900]
  };
}
function getDefaultWarning(mode = "light") {
  return mode === "dark" ? {
    main: orange_default[400],
    light: orange_default[300],
    dark: orange_default[700]
  } : {
    main: "#ed6c02",
    light: orange_default[500],
    dark: orange_default[900]
  };
}
function createPalette(palette2) {
  let {
    mode = "light",
    contrastThreshold = 3,
    tonalOffset = 0.2
  } = palette2, other = _objectWithoutPropertiesLoose2(palette2, _excluded12), primary = palette2.primary || getDefaultPrimary(mode), secondary = palette2.secondary || getDefaultSecondary(mode), error = palette2.error || getDefaultError(mode), info = palette2.info || getDefaultInfo(mode), success = palette2.success || getDefaultSuccess(mode), warning2 = palette2.warning || getDefaultWarning(mode);
  function getContrastText(background) {
    let contrastText = getContrastRatio(background, dark.text.primary) >= contrastThreshold ? dark.text.primary : light.text.primary;
    {
      let contrast = getContrastRatio(background, contrastText);
      contrast < 3 && console.error([`MUI: The contrast ratio of ${contrast}:1 for ${contrastText} on ${background}`, "falls below the WCAG recommended absolute minimum contrast ratio of 3:1.", "https://www.w3.org/TR/2008/REC-WCAG20-20081211/#visual-audio-contrast-contrast"].join(`
`));
    }
    return contrastText;
  }
  let augmentColor = ({
    color: color2,
    name,
    mainShade = 500,
    lightShade = 300,
    darkShade = 700
  }) => {
    if (color2 = _extends({}, color2), !color2.main && color2[mainShade] && (color2.main = color2[mainShade]), !color2.hasOwnProperty("main"))
      throw new Error(`MUI: The color${name ? ` (${name})` : ""} provided to augmentColor(color) is invalid.
The color object needs to have a \`main\` property or a \`${mainShade}\` property.`);
    if (typeof color2.main != "string")
      throw new Error(`MUI: The color${name ? ` (${name})` : ""} provided to augmentColor(color) is invalid.
\`color.main\` should be a string, but \`${JSON.stringify(color2.main)}\` was provided instead.

Did you intend to use one of the following approaches?

import { green } from "@mui/material/colors";

const theme1 = createTheme({ palette: {
  primary: green,
} });

const theme2 = createTheme({ palette: {
  primary: { main: green[500] },
} });`);
    return addLightOrDark(color2, "light", lightShade, tonalOffset), addLightOrDark(color2, "dark", darkShade, tonalOffset), color2.contrastText || (color2.contrastText = getContrastText(color2.main)), color2;
  }, modes = {
    dark,
    light
  };
  return modes[mode] || console.error(`MUI: The palette mode \`${mode}\` is not supported.`), deepmerge(_extends({
    common: _extends({}, common_default),
    mode,
    primary: augmentColor({
      color: primary,
      name: "primary"
    }),
    secondary: augmentColor({
      color: secondary,
      name: "secondary",
      mainShade: "A400",
      lightShade: "A200",
      darkShade: "A700"
    }),
    error: augmentColor({
      color: error,
      name: "error"
    }),
    warning: augmentColor({
      color: warning2,
      name: "warning"
    }),
    info: augmentColor({
      color: info,
      name: "info"
    }),
    success: augmentColor({
      color: success,
      name: "success"
    }),
    grey: grey_default,
    contrastThreshold,
    getContrastText,
    augmentColor,
    tonalOffset
  }, modes[mode]), other);
}
var _excluded12, light, dark, init_createPalette = __esm({
  "node_modules/@mui/material/esm/styles/createPalette.js"() {
    init_extends();
    init_objectWithoutPropertiesLoose();
    init_esm2();
    init_esm3();
    init_common();
    init_grey();
    init_purple();
    init_red();
    init_orange();
    init_blue();
    init_lightBlue();
    init_green();
    _excluded12 = ["mode", "contrastThreshold", "tonalOffset"], light = {
      text: {
        primary: "rgba(0, 0, 0, 0.87)",
        secondary: "rgba(0, 0, 0, 0.6)",
        disabled: "rgba(0, 0, 0, 0.38)"
      },
      divider: "rgba(0, 0, 0, 0.12)",
      background: {
        paper: common_default.white,
        default: common_default.white
      },
      action: {
        active: "rgba(0, 0, 0, 0.54)",
        hover: "rgba(0, 0, 0, 0.04)",
        hoverOpacity: 0.04,
        selected: "rgba(0, 0, 0, 0.08)",
        selectedOpacity: 0.08,
        disabled: "rgba(0, 0, 0, 0.26)",
        disabledBackground: "rgba(0, 0, 0, 0.12)",
        disabledOpacity: 0.38,
        focus: "rgba(0, 0, 0, 0.12)",
        focusOpacity: 0.12,
        activatedOpacity: 0.12
      }
    }, dark = {
      text: {
        primary: common_default.white,
        secondary: "rgba(255, 255, 255, 0.7)",
        disabled: "rgba(255, 255, 255, 0.5)",
        icon: "rgba(255, 255, 255, 0.5)"
      },
      divider: "rgba(255, 255, 255, 0.12)",
      background: {
        paper: "#121212",
        default: "#121212"
      },
      action: {
        active: common_default.white,
        hover: "rgba(255, 255, 255, 0.08)",
        hoverOpacity: 0.08,
        selected: "rgba(255, 255, 255, 0.16)",
        selectedOpacity: 0.16,
        disabled: "rgba(255, 255, 255, 0.3)",
        disabledBackground: "rgba(255, 255, 255, 0.12)",
        disabledOpacity: 0.38,
        focus: "rgba(255, 255, 255, 0.12)",
        focusOpacity: 0.12,
        activatedOpacity: 0.24
      }
    };
  }
});

// node_modules/@mui/material/esm/styles/createTypography.js
function round(value) {
  return Math.round(value * 1e5) / 1e5;
}
function createTypography(palette2, typography2) {
  let _ref = typeof typography2 == "function" ? typography2(palette2) : typography2, {
    fontFamily: fontFamily2 = defaultFontFamily,
    fontSize: fontSize2 = 14,
    fontWeightLight = 300,
    fontWeightRegular = 400,
    fontWeightMedium = 500,
    fontWeightBold = 700,
    htmlFontSize = 16,
    allVariants,
    pxToRem: pxToRem2
  } = _ref, other = _objectWithoutPropertiesLoose2(_ref, _excluded13);
  typeof fontSize2 != "number" && console.error("MUI: `fontSize` is required to be a number."), typeof htmlFontSize != "number" && console.error("MUI: `htmlFontSize` is required to be a number.");
  let coef = fontSize2 / 14, pxToRem = pxToRem2 || ((size) => `${size / htmlFontSize * coef}rem`), buildVariant = (fontWeight2, size, lineHeight2, letterSpacing2, casing) => _extends({
    fontFamily: fontFamily2,
    fontWeight: fontWeight2,
    fontSize: pxToRem(size),
    lineHeight: lineHeight2
  }, fontFamily2 === defaultFontFamily ? {
    letterSpacing: `${round(letterSpacing2 / size)}em`
  } : {}, casing, allVariants), variants = {
    h1: buildVariant(fontWeightLight, 96, 1.167, -1.5),
    h2: buildVariant(fontWeightLight, 60, 1.2, -0.5),
    h3: buildVariant(fontWeightRegular, 48, 1.167, 0),
    h4: buildVariant(fontWeightRegular, 34, 1.235, 0.25),
    h5: buildVariant(fontWeightRegular, 24, 1.334, 0),
    h6: buildVariant(fontWeightMedium, 20, 1.6, 0.15),
    subtitle1: buildVariant(fontWeightRegular, 16, 1.75, 0.15),
    subtitle2: buildVariant(fontWeightMedium, 14, 1.57, 0.1),
    body1: buildVariant(fontWeightRegular, 16, 1.5, 0.15),
    body2: buildVariant(fontWeightRegular, 14, 1.43, 0.15),
    button: buildVariant(fontWeightMedium, 14, 1.75, 0.4, caseAllCaps),
    caption: buildVariant(fontWeightRegular, 12, 1.66, 0.4),
    overline: buildVariant(fontWeightRegular, 12, 2.66, 1, caseAllCaps)
  };
  return deepmerge(_extends({
    htmlFontSize,
    pxToRem,
    fontFamily: fontFamily2,
    fontSize: fontSize2,
    fontWeightLight,
    fontWeightRegular,
    fontWeightMedium,
    fontWeightBold
  }, variants), other, {
    clone: !1
  });
}
var _excluded13, caseAllCaps, defaultFontFamily, init_createTypography = __esm({
  "node_modules/@mui/material/esm/styles/createTypography.js"() {
    init_extends();
    init_objectWithoutPropertiesLoose();
    init_esm2();
    _excluded13 = ["fontFamily", "fontSize", "fontWeightLight", "fontWeightRegular", "fontWeightMedium", "fontWeightBold", "htmlFontSize", "allVariants", "pxToRem"];
    caseAllCaps = {
      textTransform: "uppercase"
    }, defaultFontFamily = '"Roboto", "Helvetica", "Arial", sans-serif';
  }
});

// node_modules/@mui/material/esm/styles/shadows.js
function createShadow(...px) {
  return [`${px[0]}px ${px[1]}px ${px[2]}px ${px[3]}px rgba(0,0,0,${0.2})`, `${px[4]}px ${px[5]}px ${px[6]}px ${px[7]}px rgba(0,0,0,${0.14})`, `${px[8]}px ${px[9]}px ${px[10]}px ${px[11]}px rgba(0,0,0,${0.12})`].join(",");
}
var shadows, shadows_default2, init_shadows2 = __esm({
  "node_modules/@mui/material/esm/styles/shadows.js"() {
    shadows = ["none", createShadow(0, 2, 1, -1, 0, 1, 1, 0, 0, 1, 3, 0), createShadow(0, 3, 1, -2, 0, 2, 2, 0, 0, 1, 5, 0), createShadow(0, 3, 3, -2, 0, 3, 4, 0, 0, 1, 8, 0), createShadow(0, 2, 4, -1, 0, 4, 5, 0, 0, 1, 10, 0), createShadow(0, 3, 5, -1, 0, 5, 8, 0, 0, 1, 14, 0), createShadow(0, 3, 5, -1, 0, 6, 10, 0, 0, 1, 18, 0), createShadow(0, 4, 5, -2, 0, 7, 10, 1, 0, 2, 16, 1), createShadow(0, 5, 5, -3, 0, 8, 10, 1, 0, 3, 14, 2), createShadow(0, 5, 6, -3, 0, 9, 12, 1, 0, 3, 16, 2), createShadow(0, 6, 6, -3, 0, 10, 14, 1, 0, 4, 18, 3), createShadow(0, 6, 7, -4, 0, 11, 15, 1, 0, 4, 20, 3), createShadow(0, 7, 8, -4, 0, 12, 17, 2, 0, 5, 22, 4), createShadow(0, 7, 8, -4, 0, 13, 19, 2, 0, 5, 24, 4), createShadow(0, 7, 9, -4, 0, 14, 21, 2, 0, 5, 26, 4), createShadow(0, 8, 9, -5, 0, 15, 22, 2, 0, 6, 28, 5), createShadow(0, 8, 10, -5, 0, 16, 24, 2, 0, 6, 30, 5), createShadow(0, 8, 11, -5, 0, 17, 26, 2, 0, 6, 32, 5), createShadow(0, 9, 11, -5, 0, 18, 28, 2, 0, 7, 34, 6), createShadow(0, 9, 12, -6, 0, 19, 29, 2, 0, 7, 36, 6), createShadow(0, 10, 13, -6, 0, 20, 31, 3, 0, 8, 38, 7), createShadow(0, 10, 13, -6, 0, 21, 33, 3, 0, 8, 40, 7), createShadow(0, 10, 14, -6, 0, 22, 35, 3, 0, 8, 42, 7), createShadow(0, 11, 14, -7, 0, 23, 36, 3, 0, 9, 44, 8), createShadow(0, 11, 15, -7, 0, 24, 38, 3, 0, 9, 46, 8)], shadows_default2 = shadows;
  }
});

// node_modules/@mui/material/esm/styles/createTransitions.js
function formatMs(milliseconds) {
  return `${Math.round(milliseconds)}ms`;
}
function getAutoHeightDuration(height2) {
  if (!height2)
    return 0;
  let constant = height2 / 36;
  return Math.round((4 + 15 * constant ** 0.25 + constant / 5) * 10);
}
function createTransitions(inputTransitions) {
  let mergedEasing = _extends({}, easing, inputTransitions.easing), mergedDuration = _extends({}, duration, inputTransitions.duration);
  return _extends({
    getAutoHeightDuration,
    create: (props = ["all"], options = {}) => {
      let {
        duration: durationOption = mergedDuration.standard,
        easing: easingOption = mergedEasing.easeInOut,
        delay = 0
      } = options, other = _objectWithoutPropertiesLoose2(options, _excluded14);
      {
        let isString2 = (value) => typeof value == "string", isNumber2 = (value) => !isNaN(parseFloat(value));
        !isString2(props) && !Array.isArray(props) && console.error('MUI: Argument "props" must be a string or Array.'), !isNumber2(durationOption) && !isString2(durationOption) && console.error(`MUI: Argument "duration" must be a number or a string but found ${durationOption}.`), isString2(easingOption) || console.error('MUI: Argument "easing" must be a string.'), !isNumber2(delay) && !isString2(delay) && console.error('MUI: Argument "delay" must be a number or a string.'), Object.keys(other).length !== 0 && console.error(`MUI: Unrecognized argument(s) [${Object.keys(other).join(",")}].`);
      }
      return (Array.isArray(props) ? props : [props]).map((animatedProp) => `${animatedProp} ${typeof durationOption == "string" ? durationOption : formatMs(durationOption)} ${easingOption} ${typeof delay == "string" ? delay : formatMs(delay)}`).join(",");
    }
  }, inputTransitions, {
    easing: mergedEasing,
    duration: mergedDuration
  });
}
var _excluded14, easing, duration, init_createTransitions = __esm({
  "node_modules/@mui/material/esm/styles/createTransitions.js"() {
    init_objectWithoutPropertiesLoose();
    init_extends();
    _excluded14 = ["duration", "easing", "delay"], easing = {
      easeInOut: "cubic-bezier(0.4, 0, 0.2, 1)",
      easeOut: "cubic-bezier(0.0, 0, 0.2, 1)",
      easeIn: "cubic-bezier(0.4, 0, 1, 1)",
      sharp: "cubic-bezier(0.4, 0, 0.6, 1)"
    }, duration = {
      shortest: 150,
      shorter: 200,
      short: 250,
      standard: 300,
      complex: 375,
      enteringScreen: 225,
      leavingScreen: 195
    };
  }
});

// node_modules/@mui/material/esm/styles/zIndex.js
var zIndex2, zIndex_default, init_zIndex = __esm({
  "node_modules/@mui/material/esm/styles/zIndex.js"() {
    zIndex2 = {
      mobileStepper: 1e3,
      fab: 1050,
      speedDial: 1050,
      appBar: 1100,
      drawer: 1200,
      modal: 1300,
      snackbar: 1400,
      tooltip: 1500
    }, zIndex_default = zIndex2;
  }
});

// node_modules/@mui/material/esm/styles/createTheme.js
function createTheme2(options = {}, ...args) {
  let {
    mixins: mixinsInput = {},
    palette: paletteInput = {},
    transitions: transitionsInput = {},
    typography: typographyInput = {}
  } = options, other = _objectWithoutPropertiesLoose2(options, _excluded15);
  if (options.vars)
    throw new Error("MUI: `vars` is a private field used for CSS variables support.\nPlease use another name.");
  let palette2 = createPalette(paletteInput), systemTheme = createTheme_default(options), muiTheme = deepmerge(systemTheme, {
    mixins: createMixins(systemTheme.breakpoints, mixinsInput),
    palette: palette2,
    shadows: shadows_default2.slice(),
    typography: createTypography(palette2, typographyInput),
    transitions: createTransitions(transitionsInput),
    zIndex: _extends({}, zIndex_default)
  });
  muiTheme = deepmerge(muiTheme, other), muiTheme = args.reduce((acc, argument) => deepmerge(acc, argument), muiTheme);
  {
    let stateClasses = ["active", "checked", "completed", "disabled", "error", "expanded", "focused", "focusVisible", "required", "selected"], traverse = (node, component) => {
      let key;
      for (key in node) {
        let child = node[key];
        if (stateClasses.indexOf(key) !== -1 && Object.keys(child).length > 0) {
          {
            let stateClass = generateUtilityClass("", key);
            console.error([`MUI: The \`${component}\` component increases the CSS specificity of the \`${key}\` internal state.`, "You can not override it like this: ", JSON.stringify(node, null, 2), "", `Instead, you need to use the '&.${stateClass}' syntax:`, JSON.stringify({
              root: {
                [`&.${stateClass}`]: child
              }
            }, null, 2), "", "https://mui.com/r/state-classes-guide"].join(`
`));
          }
          node[key] = {};
        }
      }
    };
    Object.keys(muiTheme.components).forEach((component) => {
      let styleOverrides = muiTheme.components[component].styleOverrides;
      styleOverrides && component.indexOf("Mui") === 0 && traverse(styleOverrides, component);
    });
  }
  return muiTheme;
}
var _excluded15, createTheme_default2, init_createTheme3 = __esm({
  "node_modules/@mui/material/esm/styles/createTheme.js"() {
    init_extends();
    init_objectWithoutPropertiesLoose();
    init_esm2();
    init_base();
    init_esm3();
    init_createMixins();
    init_createPalette();
    init_createTypography();
    init_shadows2();
    init_createTransitions();
    init_zIndex();
    _excluded15 = ["breakpoints", "mixins", "spacing", "palette", "transitions", "typography", "shape"];
    createTheme_default2 = createTheme2;
  }
});

// node_modules/@mui/material/esm/styles/defaultTheme.js
var defaultTheme, defaultTheme_default, init_defaultTheme = __esm({
  "node_modules/@mui/material/esm/styles/defaultTheme.js"() {
    init_createTheme3();
    defaultTheme = createTheme_default2(), defaultTheme_default = defaultTheme;
  }
});

// node_modules/@mui/material/esm/styles/styled.js
var rootShouldForwardProp, slotShouldForwardProp, styled2, styled_default, init_styled = __esm({
  "node_modules/@mui/material/esm/styles/styled.js"() {
    init_esm3();
    init_defaultTheme();
    rootShouldForwardProp = (prop) => shouldForwardProp(prop) && prop !== "classes", slotShouldForwardProp = shouldForwardProp, styled2 = createStyled({
      defaultTheme: defaultTheme_default,
      rootShouldForwardProp
    }), styled_default = styled2;
  }
});

// node_modules/@mui/material/esm/styles/useThemeProps.js
function useThemeProps2({
  props,
  name
}) {
  return useThemeProps({
    props,
    name,
    defaultTheme: defaultTheme_default
  });
}
var init_useThemeProps3 = __esm({
  "node_modules/@mui/material/esm/styles/useThemeProps.js"() {
    init_esm3();
    init_defaultTheme();
  }
});

// node_modules/@mui/material/esm/utils/useForkRef.js
var useForkRef_default, init_useForkRef2 = __esm({
  "node_modules/@mui/material/esm/utils/useForkRef.js"() {
    init_esm2();
    useForkRef_default = useForkRef;
  }
});

// node_modules/@mui/material/esm/utils/useEventCallback.js
var useEventCallback_default, init_useEventCallback2 = __esm({
  "node_modules/@mui/material/esm/utils/useEventCallback.js"() {
    init_esm2();
    useEventCallback_default = useEventCallback;
  }
});

// node_modules/@mui/material/esm/utils/useIsFocusVisible.js
var useIsFocusVisible_default, init_useIsFocusVisible2 = __esm({
  "node_modules/@mui/material/esm/utils/useIsFocusVisible.js"() {
    init_esm2();
    useIsFocusVisible_default = useIsFocusVisible;
  }
});

// node_modules/@mui/material/esm/utils/capitalize.js
var capitalize_default, init_capitalize2 = __esm({
  "node_modules/@mui/material/esm/utils/capitalize.js"() {
    init_esm2();
    capitalize_default = capitalize;
  }
});

// node_modules/@babel/runtime/helpers/interopRequireDefault.js
var require_interopRequireDefault = __commonJS({
  "node_modules/@babel/runtime/helpers/interopRequireDefault.js"(exports, module) {
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    module.exports = _interopRequireDefault, module.exports.__esModule = !0, module.exports.default = module.exports;
  }
});

// node_modules/@mui/base/className/index.js
var init_className = __esm({
  "node_modules/@mui/base/className/index.js"() {
    init_esm2();
  }
});

// node_modules/@mui/material/esm/utils/createChainedFunction.js
var createChainedFunction_default, init_createChainedFunction2 = __esm({
  "node_modules/@mui/material/esm/utils/createChainedFunction.js"() {
    init_esm2();
    createChainedFunction_default = createChainedFunction;
  }
});

// node_modules/@mui/material/esm/SvgIcon/svgIconClasses.js
function getSvgIconUtilityClass(slot) {
  return generateUtilityClass("MuiSvgIcon", slot);
}
var svgIconClasses, init_svgIconClasses = __esm({
  "node_modules/@mui/material/esm/SvgIcon/svgIconClasses.js"() {
    init_base();
    svgIconClasses = generateUtilityClasses("MuiSvgIcon", ["root", "colorPrimary", "colorSecondary", "colorAction", "colorError", "colorDisabled", "fontSizeInherit", "fontSizeSmall", "fontSizeMedium", "fontSizeLarge"]);
  }
});

// node_modules/@mui/material/esm/SvgIcon/SvgIcon.js
var React33, import_prop_types17, import_jsx_runtime16, import_jsx_runtime17, _excluded19, useUtilityClasses4, SvgIconRoot, SvgIcon, SvgIcon_default, init_SvgIcon = __esm({
  "node_modules/@mui/material/esm/SvgIcon/SvgIcon.js"() {
    init_extends();
    init_objectWithoutPropertiesLoose();
    React33 = __toESM(require_react()), import_prop_types17 = __toESM(require_prop_types());
    init_clsx_m();
    init_base();
    init_capitalize2();
    init_useThemeProps3();
    init_styled();
    init_svgIconClasses();
    import_jsx_runtime16 = __toESM(require_jsx_runtime()), import_jsx_runtime17 = __toESM(require_jsx_runtime()), _excluded19 = ["children", "className", "color", "component", "fontSize", "htmlColor", "inheritViewBox", "titleAccess", "viewBox"], useUtilityClasses4 = (ownerState) => {
      let {
        color: color2,
        fontSize: fontSize2,
        classes
      } = ownerState, slots = {
        root: ["root", color2 !== "inherit" && `color${capitalize_default(color2)}`, `fontSize${capitalize_default(fontSize2)}`]
      };
      return composeClasses(slots, getSvgIconUtilityClass, classes);
    }, SvgIconRoot = styled_default("svg", {
      name: "MuiSvgIcon",
      slot: "Root",
      overridesResolver: (props, styles4) => {
        let {
          ownerState
        } = props;
        return [styles4.root, ownerState.color !== "inherit" && styles4[`color${capitalize_default(ownerState.color)}`], styles4[`fontSize${capitalize_default(ownerState.fontSize)}`]];
      }
    })(({
      theme,
      ownerState
    }) => {
      var _theme$transitions, _theme$transitions$cr, _theme$transitions2, _theme$transitions2$d, _theme$typography, _theme$typography$pxT, _theme$typography2, _theme$typography2$px, _theme$typography3, _theme$typography3$px, _palette$ownerState$c, _palette, _palette$ownerState$c2, _palette2, _palette2$action, _palette3, _palette3$action;
      return {
        userSelect: "none",
        width: "1em",
        height: "1em",
        display: "inline-block",
        fill: "currentColor",
        flexShrink: 0,
        transition: (_theme$transitions = theme.transitions) == null || (_theme$transitions$cr = _theme$transitions.create) == null ? void 0 : _theme$transitions$cr.call(_theme$transitions, "fill", {
          duration: (_theme$transitions2 = theme.transitions) == null || (_theme$transitions2$d = _theme$transitions2.duration) == null ? void 0 : _theme$transitions2$d.shorter
        }),
        fontSize: {
          inherit: "inherit",
          small: ((_theme$typography = theme.typography) == null || (_theme$typography$pxT = _theme$typography.pxToRem) == null ? void 0 : _theme$typography$pxT.call(_theme$typography, 20)) || "1.25rem",
          medium: ((_theme$typography2 = theme.typography) == null || (_theme$typography2$px = _theme$typography2.pxToRem) == null ? void 0 : _theme$typography2$px.call(_theme$typography2, 24)) || "1.5rem",
          large: ((_theme$typography3 = theme.typography) == null || (_theme$typography3$px = _theme$typography3.pxToRem) == null ? void 0 : _theme$typography3$px.call(_theme$typography3, 35)) || "2.1875"
        }[ownerState.fontSize],
        color: (_palette$ownerState$c = (_palette = (theme.vars || theme).palette) == null || (_palette$ownerState$c2 = _palette[ownerState.color]) == null ? void 0 : _palette$ownerState$c2.main) != null ? _palette$ownerState$c : {
          action: (_palette2 = (theme.vars || theme).palette) == null || (_palette2$action = _palette2.action) == null ? void 0 : _palette2$action.active,
          disabled: (_palette3 = (theme.vars || theme).palette) == null || (_palette3$action = _palette3.action) == null ? void 0 : _palette3$action.disabled,
          inherit: void 0
        }[ownerState.color]
      };
    }), SvgIcon = /* @__PURE__ */ React33.forwardRef(function(inProps, ref) {
      let props = useThemeProps2({
        props: inProps,
        name: "MuiSvgIcon"
      }), {
        children,
        className,
        color: color2 = "inherit",
        component = "svg",
        fontSize: fontSize2 = "medium",
        htmlColor,
        inheritViewBox = !1,
        titleAccess,
        viewBox = "0 0 24 24"
      } = props, other = _objectWithoutPropertiesLoose2(props, _excluded19), ownerState = _extends({}, props, {
        color: color2,
        component,
        fontSize: fontSize2,
        instanceFontSize: inProps.fontSize,
        inheritViewBox,
        viewBox
      }), more = {};
      inheritViewBox || (more.viewBox = viewBox);
      let classes = useUtilityClasses4(ownerState);
      return /* @__PURE__ */ (0, import_jsx_runtime17.jsxs)(SvgIconRoot, _extends({
        as: component,
        className: clsx_m_default(classes.root, className),
        ownerState,
        focusable: "false",
        color: htmlColor,
        "aria-hidden": titleAccess ? void 0 : !0,
        role: titleAccess ? "img" : void 0,
        ref
      }, more, other, {
        children: [children, titleAccess ? /* @__PURE__ */ (0, import_jsx_runtime16.jsx)("title", {
          children: titleAccess
        }) : null]
      }));
    });
    SvgIcon.propTypes = {
      children: import_prop_types17.default.node,
      classes: import_prop_types17.default.object,
      className: import_prop_types17.default.string,
      color: import_prop_types17.default.oneOfType([import_prop_types17.default.oneOf(["inherit", "action", "disabled", "primary", "secondary", "error", "info", "success", "warning"]), import_prop_types17.default.string]),
      component: import_prop_types17.default.elementType,
      fontSize: import_prop_types17.default.oneOfType([import_prop_types17.default.oneOf(["inherit", "large", "medium", "small"]), import_prop_types17.default.string]),
      htmlColor: import_prop_types17.default.string,
      inheritViewBox: import_prop_types17.default.bool,
      shapeRendering: import_prop_types17.default.string,
      sx: import_prop_types17.default.oneOfType([import_prop_types17.default.arrayOf(import_prop_types17.default.oneOfType([import_prop_types17.default.func, import_prop_types17.default.object, import_prop_types17.default.bool])), import_prop_types17.default.func, import_prop_types17.default.object]),
      titleAccess: import_prop_types17.default.string,
      viewBox: import_prop_types17.default.string
    };
    SvgIcon.muiName = "SvgIcon";
    SvgIcon_default = SvgIcon;
  }
});

// node_modules/@mui/material/esm/SvgIcon/index.js
var init_SvgIcon2 = __esm({
  "node_modules/@mui/material/esm/SvgIcon/index.js"() {
    init_SvgIcon();
    init_svgIconClasses();
  }
});

// node_modules/@mui/material/esm/utils/createSvgIcon.js
function createSvgIcon(path, displayName) {
  let Component = (props, ref) => /* @__PURE__ */ (0, import_jsx_runtime18.jsx)(SvgIcon_default, _extends({
    "data-testid": `${displayName}Icon`,
    ref
  }, props, {
    children: path
  }));
  return Component.displayName = `${displayName}Icon`, Component.muiName = SvgIcon_default.muiName, /* @__PURE__ */ React34.memo(/* @__PURE__ */ React34.forwardRef(Component));
}
var React34, import_jsx_runtime18, init_createSvgIcon = __esm({
  "node_modules/@mui/material/esm/utils/createSvgIcon.js"() {
    init_extends();
    React34 = __toESM(require_react());
    init_SvgIcon2();
    import_jsx_runtime18 = __toESM(require_jsx_runtime());
  }
});

// node_modules/@mui/material/esm/utils/debounce.js
var debounce_default, init_debounce2 = __esm({
  "node_modules/@mui/material/esm/utils/debounce.js"() {
    init_esm2();
    debounce_default = debounce;
  }
});

// node_modules/@mui/material/esm/utils/deprecatedPropType.js
var deprecatedPropType_default, init_deprecatedPropType2 = __esm({
  "node_modules/@mui/material/esm/utils/deprecatedPropType.js"() {
    init_esm2();
    deprecatedPropType_default = deprecatedPropType;
  }
});

// node_modules/@mui/material/esm/utils/isMuiElement.js
var isMuiElement_default, init_isMuiElement2 = __esm({
  "node_modules/@mui/material/esm/utils/isMuiElement.js"() {
    init_esm2();
    isMuiElement_default = isMuiElement;
  }
});

// node_modules/@mui/material/esm/utils/ownerDocument.js
var ownerDocument_default, init_ownerDocument2 = __esm({
  "node_modules/@mui/material/esm/utils/ownerDocument.js"() {
    init_esm2();
    ownerDocument_default = ownerDocument;
  }
});

// node_modules/@mui/material/esm/utils/ownerWindow.js
var ownerWindow_default, init_ownerWindow2 = __esm({
  "node_modules/@mui/material/esm/utils/ownerWindow.js"() {
    init_esm2();
    ownerWindow_default = ownerWindow;
  }
});

// node_modules/@mui/material/esm/utils/requirePropFactory.js
var requirePropFactory_default, init_requirePropFactory2 = __esm({
  "node_modules/@mui/material/esm/utils/requirePropFactory.js"() {
    init_esm2();
    requirePropFactory_default = requirePropFactory;
  }
});

// node_modules/@mui/material/esm/utils/setRef.js
var setRef_default, init_setRef2 = __esm({
  "node_modules/@mui/material/esm/utils/setRef.js"() {
    init_esm2();
    setRef_default = setRef;
  }
});

// node_modules/@mui/material/esm/utils/useEnhancedEffect.js
var useEnhancedEffect_default2, init_useEnhancedEffect2 = __esm({
  "node_modules/@mui/material/esm/utils/useEnhancedEffect.js"() {
    init_esm2();
    useEnhancedEffect_default2 = useEnhancedEffect_default;
  }
});

// node_modules/@mui/material/esm/utils/useId.js
var useId_default, init_useId2 = __esm({
  "node_modules/@mui/material/esm/utils/useId.js"() {
    init_esm2();
    useId_default = useId2;
  }
});

// node_modules/@mui/material/esm/utils/unsupportedProp.js
var unsupportedProp_default, init_unsupportedProp2 = __esm({
  "node_modules/@mui/material/esm/utils/unsupportedProp.js"() {
    init_esm2();
    unsupportedProp_default = unsupportedProp;
  }
});

// node_modules/@mui/material/esm/utils/useControlled.js
var useControlled_default, init_useControlled2 = __esm({
  "node_modules/@mui/material/esm/utils/useControlled.js"() {
    init_esm2();
    useControlled_default = useControlled;
  }
});

// node_modules/@mui/material/esm/utils/index.js
var utils_exports = {};
__export(utils_exports, {
  capitalize: () => capitalize_default,
  createChainedFunction: () => createChainedFunction_default,
  createSvgIcon: () => createSvgIcon,
  debounce: () => debounce_default,
  deprecatedPropType: () => deprecatedPropType_default,
  isMuiElement: () => isMuiElement_default,
  ownerDocument: () => ownerDocument_default,
  ownerWindow: () => ownerWindow_default,
  requirePropFactory: () => requirePropFactory_default,
  setRef: () => setRef_default,
  unstable_ClassNameGenerator: () => unstable_ClassNameGenerator,
  unstable_useEnhancedEffect: () => useEnhancedEffect_default2,
  unstable_useId: () => useId_default,
  unsupportedProp: () => unsupportedProp_default,
  useControlled: () => useControlled_default,
  useEventCallback: () => useEventCallback_default,
  useForkRef: () => useForkRef_default,
  useIsFocusVisible: () => useIsFocusVisible_default
});
var unstable_ClassNameGenerator, init_utils4 = __esm({
  "node_modules/@mui/material/esm/utils/index.js"() {
    init_className();
    init_capitalize2();
    init_createChainedFunction2();
    init_createSvgIcon();
    init_debounce2();
    init_deprecatedPropType2();
    init_isMuiElement2();
    init_ownerDocument2();
    init_ownerWindow2();
    init_requirePropFactory2();
    init_setRef2();
    init_useEnhancedEffect2();
    init_useId2();
    init_unsupportedProp2();
    init_useControlled2();
    init_useEventCallback2();
    init_useForkRef2();
    init_useIsFocusVisible2();
    unstable_ClassNameGenerator = {
      configure: (generator) => {
        console.warn(["MUI: `ClassNameGenerator` import from `@mui/material/utils` is outdated and might cause unexpected issues.", "", "You should use `import { unstable_ClassNameGenerator } from '@mui/material/className'` instead", "", "The detail of the issue: https://github.com/mui/material-ui/issues/30011#issuecomment-1024993401", "", "The updated documentation: https://mui.com/guides/classname-generator/"].join(`
`)), ClassNameGenerator_default.configure(generator);
      }
    };
  }
});

// node_modules/@mui/icons-material/utils/createSvgIcon.js
var require_createSvgIcon = __commonJS({
  "node_modules/@mui/icons-material/utils/createSvgIcon.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: !0
    });
    Object.defineProperty(exports, "default", {
      enumerable: !0,
      get: function() {
        return _utils.createSvgIcon;
      }
    });
    var _utils = (init_utils4(), __toCommonJS(utils_exports));
  }
});

// node_modules/@mui/icons-material/Clear.js
var require_Clear = __commonJS({
  "node_modules/@mui/icons-material/Clear.js"(exports) {
    "use strict";
    var _interopRequireDefault = require_interopRequireDefault();
    Object.defineProperty(exports, "__esModule", {
      value: !0
    });
    exports.default = void 0;
    var _createSvgIcon = _interopRequireDefault(require_createSvgIcon()), _jsxRuntime = require_jsx_runtime(), _default = (0, _createSvgIcon.default)(/* @__PURE__ */ (0, _jsxRuntime.jsx)("path", {
      d: "M19 6.41 17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z"
    }), "Clear");
    exports.default = _default;
  }
});

// node_modules/@mui/icons-material/FirstPage.js
var require_FirstPage = __commonJS({
  "node_modules/@mui/icons-material/FirstPage.js"(exports) {
    "use strict";
    var _interopRequireDefault = require_interopRequireDefault();
    Object.defineProperty(exports, "__esModule", {
      value: !0
    });
    exports.default = void 0;
    var _createSvgIcon = _interopRequireDefault(require_createSvgIcon()), _jsxRuntime = require_jsx_runtime(), _default = (0, _createSvgIcon.default)(/* @__PURE__ */ (0, _jsxRuntime.jsx)("path", {
      d: "M18.41 16.59 13.82 12l4.59-4.59L17 6l-6 6 6 6zM6 6h2v12H6z"
    }), "FirstPage");
    exports.default = _default;
  }
});

// node_modules/@mui/icons-material/KeyboardArrowLeft.js
var require_KeyboardArrowLeft = __commonJS({
  "node_modules/@mui/icons-material/KeyboardArrowLeft.js"(exports) {
    "use strict";
    var _interopRequireDefault = require_interopRequireDefault();
    Object.defineProperty(exports, "__esModule", {
      value: !0
    });
    exports.default = void 0;
    var _createSvgIcon = _interopRequireDefault(require_createSvgIcon()), _jsxRuntime = require_jsx_runtime(), _default = (0, _createSvgIcon.default)(/* @__PURE__ */ (0, _jsxRuntime.jsx)("path", {
      d: "M15.41 16.59 10.83 12l4.58-4.59L14 6l-6 6 6 6 1.41-1.41z"
    }), "KeyboardArrowLeft");
    exports.default = _default;
  }
});

// node_modules/@mui/icons-material/KeyboardArrowRight.js
var require_KeyboardArrowRight = __commonJS({
  "node_modules/@mui/icons-material/KeyboardArrowRight.js"(exports) {
    "use strict";
    var _interopRequireDefault = require_interopRequireDefault();
    Object.defineProperty(exports, "__esModule", {
      value: !0
    });
    exports.default = void 0;
    var _createSvgIcon = _interopRequireDefault(require_createSvgIcon()), _jsxRuntime = require_jsx_runtime(), _default = (0, _createSvgIcon.default)(/* @__PURE__ */ (0, _jsxRuntime.jsx)("path", {
      d: "M8.59 16.59 13.17 12 8.59 7.41 10 6l6 6-6 6-1.41-1.41z"
    }), "KeyboardArrowRight");
    exports.default = _default;
  }
});

// node_modules/@mui/icons-material/LastPage.js
var require_LastPage = __commonJS({
  "node_modules/@mui/icons-material/LastPage.js"(exports) {
    "use strict";
    var _interopRequireDefault = require_interopRequireDefault();
    Object.defineProperty(exports, "__esModule", {
      value: !0
    });
    exports.default = void 0;
    var _createSvgIcon = _interopRequireDefault(require_createSvgIcon()), _jsxRuntime = require_jsx_runtime(), _default = (0, _createSvgIcon.default)(/* @__PURE__ */ (0, _jsxRuntime.jsx)("path", {
      d: "M5.59 7.41 10.18 12l-4.59 4.59L7 18l6-6-6-6zM16 6h2v12h-2z"
    }), "LastPage");
    exports.default = _default;
  }
});

// node_modules/@remix-run/cloudflare-pages/dist/esm/worker.js
var import_cloudflare = __toESM(require_dist());
function createRequestHandler2({
  build,
  getLoadContext,
  mode
}) {
  let handleRequest3 = (0, import_cloudflare.createRequestHandler)(build, mode);
  return (context) => {
    let loadContext = getLoadContext == null ? void 0 : getLoadContext(context);
    return handleRequest3(context.request, loadContext);
  };
}
function createPagesFunctionHandler({
  build,
  getLoadContext,
  mode
}) {
  let handleRequest3 = createRequestHandler2({
    build,
    getLoadContext,
    mode
  }), handleFetch = async (context) => {
    let response;
    context.request.headers.delete("if-none-match");
    try {
      response = await context.env.ASSETS.fetch(context.request.url, context.request.clone()), response = response && response.status >= 200 && response.status < 400 ? new Response(response.body, response) : void 0;
    } catch {
    }
    return response || (response = await handleRequest3(context)), response;
  };
  return async (context) => {
    try {
      return await handleFetch(context);
    } catch (e) {
      return e instanceof Error ? (console.error(e), new Response(e.message || e.toString(), {
        status: 500
      })) : new Response("Internal Error", {
        status: 500
      });
    }
  };
}

// server-entry-module:@remix-run/dev/server-build
var server_build_exports = {};
__export(server_build_exports, {
  assets: () => assets_manifest_default,
  assetsBuildDirectory: () => assetsBuildDirectory,
  entry: () => entry,
  publicPath: () => publicPath,
  routes: () => routes
});

// app/entry.server.tsx
var entry_server_exports = {};
__export(entry_server_exports, {
  default: () => handleRequest
});

// node_modules/@remix-run/react/dist/esm/_virtual/_rollupPluginBabelHelpers.js
function _extends3() {
  return _extends3 = Object.assign ? Object.assign.bind() : function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source)
        Object.prototype.hasOwnProperty.call(source, key) && (target[key] = source[key]);
    }
    return target;
  }, _extends3.apply(this, arguments);
}

// node_modules/@remix-run/react/dist/esm/components.js
var React2 = __toESM(require_react());
init_react_router_dom();
init_history();

// node_modules/@remix-run/react/dist/esm/errorBoundaries.js
var import_react3 = __toESM(require_react());
var RemixErrorBoundary = class extends import_react3.default.Component {
  constructor(props) {
    super(props), this.state = {
      error: props.error || null,
      location: props.location
    };
  }
  static getDerivedStateFromError(error) {
    return {
      error
    };
  }
  static getDerivedStateFromProps(props, state) {
    return state.location !== props.location ? {
      error: props.error || null,
      location: props.location
    } : {
      error: props.error || state.error,
      location: state.location
    };
  }
  render() {
    return this.state.error ? /* @__PURE__ */ import_react3.default.createElement(this.props.component, {
      error: this.state.error
    }) : this.props.children;
  }
};
function RemixRootDefaultErrorBoundary({
  error
}) {
  return console.error(error), /* @__PURE__ */ import_react3.default.createElement("html", {
    lang: "en"
  }, /* @__PURE__ */ import_react3.default.createElement("head", null, /* @__PURE__ */ import_react3.default.createElement("meta", {
    charSet: "utf-8"
  }), /* @__PURE__ */ import_react3.default.createElement("meta", {
    name: "viewport",
    content: "width=device-width,initial-scale=1,viewport-fit=cover"
  }), /* @__PURE__ */ import_react3.default.createElement("title", null, "Application Error!")), /* @__PURE__ */ import_react3.default.createElement("body", null, /* @__PURE__ */ import_react3.default.createElement("main", {
    style: {
      fontFamily: "system-ui, sans-serif",
      padding: "2rem"
    }
  }, /* @__PURE__ */ import_react3.default.createElement("h1", {
    style: {
      fontSize: "24px"
    }
  }, "Application Error"), /* @__PURE__ */ import_react3.default.createElement("pre", {
    style: {
      padding: "2rem",
      background: "hsla(10, 50%, 50%, 0.1)",
      color: "red",
      overflow: "auto"
    }
  }, error.stack)), /* @__PURE__ */ import_react3.default.createElement("script", {
    dangerouslySetInnerHTML: {
      __html: `
              console.log(
                "\u{1F4BF} Hey developer\u{1F44B}. You can provide a way better UX than this when your app throws errors. Check out https://remix.run/guides/errors for more information."
              );
            `
    }
  })));
}
var RemixCatchContext = /* @__PURE__ */ import_react3.default.createContext(void 0);
function useCatch() {
  return (0, import_react3.useContext)(RemixCatchContext);
}
function RemixCatchBoundary({
  catch: catchVal,
  component: Component,
  children
}) {
  return catchVal ? /* @__PURE__ */ import_react3.default.createElement(RemixCatchContext.Provider, {
    value: catchVal
  }, /* @__PURE__ */ import_react3.default.createElement(Component, null)) : /* @__PURE__ */ import_react3.default.createElement(import_react3.default.Fragment, null, children);
}
function RemixRootDefaultCatchBoundary() {
  let caught = useCatch();
  return /* @__PURE__ */ import_react3.default.createElement("html", {
    lang: "en"
  }, /* @__PURE__ */ import_react3.default.createElement("head", null, /* @__PURE__ */ import_react3.default.createElement("meta", {
    charSet: "utf-8"
  }), /* @__PURE__ */ import_react3.default.createElement("meta", {
    name: "viewport",
    content: "width=device-width,initial-scale=1,viewport-fit=cover"
  }), /* @__PURE__ */ import_react3.default.createElement("title", null, "Unhandled Thrown Response!")), /* @__PURE__ */ import_react3.default.createElement("body", null, /* @__PURE__ */ import_react3.default.createElement("h1", {
    style: {
      fontFamily: "system-ui, sans-serif",
      padding: "2rem"
    }
  }, caught.status, " ", caught.statusText), /* @__PURE__ */ import_react3.default.createElement("script", {
    dangerouslySetInnerHTML: {
      __html: `
              console.log(
                "\u{1F4BF} Hey developer\u{1F44B}. You can provide a way better UX than this when your app throws 404s (and other responses). Check out https://remix.run/guides/not-found for more information."
              );
            `
    }
  })));
}

// node_modules/@remix-run/react/dist/esm/invariant.js
function invariant2(value, message) {
  if (value === !1 || value === null || typeof value > "u")
    throw new Error(message);
}

// node_modules/@remix-run/react/dist/esm/links.js
init_history();

// node_modules/@remix-run/react/dist/esm/routeModules.js
async function loadRouteModule(route, routeModulesCache) {
  if (route.id in routeModulesCache)
    return routeModulesCache[route.id];
  try {
    let routeModule = await import(
      /* webpackIgnore: true */
      route.module
    );
    return routeModulesCache[route.id] = routeModule, routeModule;
  } catch {
    return window.location.reload(), new Promise(() => {
    });
  }
}

// node_modules/@remix-run/react/dist/esm/links.js
function getLinksForMatches(matches, routeModules, manifest) {
  let descriptors = matches.map((match) => {
    var _module$links;
    let module = routeModules[match.route.id];
    return ((_module$links = module.links) === null || _module$links === void 0 ? void 0 : _module$links.call(module)) || [];
  }).flat(1), preloads = getCurrentPageModulePreloadHrefs(matches, manifest);
  return dedupe(descriptors, preloads);
}
async function prefetchStyleLinks(routeModule) {
  if (!routeModule.links)
    return;
  let descriptors = routeModule.links();
  if (!descriptors)
    return;
  let styleLinks = [];
  for (let descriptor of descriptors)
    !isPageLinkDescriptor(descriptor) && descriptor.rel === "stylesheet" && styleLinks.push({
      ...descriptor,
      rel: "preload",
      as: "style"
    });
  let matchingLinks = styleLinks.filter((link) => !link.media || window.matchMedia(link.media).matches);
  await Promise.all(matchingLinks.map(prefetchStyleLink));
}
async function prefetchStyleLink(descriptor) {
  return new Promise((resolve) => {
    let link = document.createElement("link");
    Object.assign(link, descriptor);
    function removeLink() {
      document.head.contains(link) && document.head.removeChild(link);
    }
    link.onload = () => {
      removeLink(), resolve();
    }, link.onerror = () => {
      removeLink(), resolve();
    }, document.head.appendChild(link);
  });
}
function isPageLinkDescriptor(object) {
  return object != null && typeof object.page == "string";
}
function isHtmlLinkDescriptor(object) {
  return object == null ? !1 : object.href == null ? object.rel === "preload" && (typeof object.imageSrcSet == "string" || typeof object.imagesrcset == "string") && (typeof object.imageSizes == "string" || typeof object.imagesizes == "string") : typeof object.rel == "string" && typeof object.href == "string";
}
async function getStylesheetPrefetchLinks(matches, routeModules) {
  return (await Promise.all(matches.map(async (match) => {
    let mod = await loadRouteModule(match.route, routeModules);
    return mod.links ? mod.links() : [];
  }))).flat(1).filter(isHtmlLinkDescriptor).filter((link) => link.rel === "stylesheet" || link.rel === "preload").map((link) => link.rel === "preload" ? {
    ...link,
    rel: "prefetch"
  } : {
    ...link,
    rel: "prefetch",
    as: "style"
  });
}
function getNewMatchesForLinks(page, nextMatches, currentMatches, location, mode) {
  let path = parsePathPatch(page), isNew = (match, index) => currentMatches[index] ? match.route.id !== currentMatches[index].route.id : !0, matchPathChanged = (match, index) => {
    var _currentMatches$index;
    return currentMatches[index].pathname !== match.pathname || ((_currentMatches$index = currentMatches[index].route.path) === null || _currentMatches$index === void 0 ? void 0 : _currentMatches$index.endsWith("*")) && currentMatches[index].params["*"] !== match.params["*"];
  };
  return mode === "data" && location.search !== path.search ? nextMatches.filter((match, index) => match.route.hasLoader ? isNew(match, index) || matchPathChanged(match, index) ? !0 : match.route.shouldReload ? match.route.shouldReload({
    params: match.params,
    prevUrl: new URL(location.pathname + location.search + location.hash, window.origin),
    url: new URL(page, window.origin)
  }) : !0 : !1) : nextMatches.filter((match, index) => (mode === "assets" || match.route.hasLoader) && (isNew(match, index) || matchPathChanged(match, index)));
}
function getDataLinkHrefs(page, matches, manifest) {
  let path = parsePathPatch(page);
  return dedupeHrefs(matches.filter((match) => manifest.routes[match.route.id].hasLoader).map((match) => {
    let {
      pathname,
      search
    } = path, searchParams = new URLSearchParams(search);
    return searchParams.set("_data", match.route.id), `${pathname}?${searchParams}`;
  }));
}
function getModuleLinkHrefs(matches, manifestPatch) {
  return dedupeHrefs(matches.map((match) => {
    let route = manifestPatch.routes[match.route.id], hrefs = [route.module];
    return route.imports && (hrefs = hrefs.concat(route.imports)), hrefs;
  }).flat(1));
}
function getCurrentPageModulePreloadHrefs(matches, manifest) {
  return dedupeHrefs(matches.map((match) => {
    let route = manifest.routes[match.route.id], hrefs = [route.module];
    return route.imports && (hrefs = hrefs.concat(route.imports)), hrefs;
  }).flat(1));
}
function dedupeHrefs(hrefs) {
  return [...new Set(hrefs)];
}
function dedupe(descriptors, preloads) {
  let set = /* @__PURE__ */ new Set(), preloadsSet = new Set(preloads);
  return descriptors.reduce((deduped, descriptor) => {
    if (!isPageLinkDescriptor(descriptor) && descriptor.as === "script" && descriptor.href && preloadsSet.has(descriptor.href))
      return deduped;
    let str = JSON.stringify(descriptor);
    return set.has(str) || (set.add(str), deduped.push(descriptor)), deduped;
  }, []);
}
function parsePathPatch(href) {
  let path = parsePath(href);
  return path.search === void 0 && (path.search = ""), path;
}

// node_modules/@remix-run/react/dist/esm/markup.js
function createHtml(html) {
  return {
    __html: html
  };
}

// node_modules/@remix-run/react/dist/esm/routes.js
var React = __toESM(require_react());

// node_modules/@remix-run/react/dist/esm/data.js
function isCatchResponse2(response) {
  return response instanceof Response && response.headers.get("X-Remix-Catch") != null;
}
function isErrorResponse(response) {
  return response instanceof Response && response.headers.get("X-Remix-Error") != null;
}
function isRedirectResponse2(response) {
  return response instanceof Response && response.headers.get("X-Remix-Redirect") != null;
}
async function fetchData(url, routeId, signal, submission) {
  url.searchParams.set("_data", routeId);
  let init2 = submission ? getActionInit(submission, signal) : {
    credentials: "same-origin",
    signal
  }, response = await fetch(url.href, init2);
  if (isErrorResponse(response)) {
    let data = await response.json(), error = new Error(data.message);
    return error.stack = data.stack, error;
  }
  return response;
}
async function extractData2(response) {
  let contentType = response.headers.get("Content-Type");
  return contentType && /\bapplication\/json\b/.test(contentType) ? response.json() : response.text();
}
function getActionInit(submission, signal) {
  let {
    encType,
    method,
    formData
  } = submission, headers, body = formData;
  if (encType === "application/x-www-form-urlencoded") {
    body = new URLSearchParams();
    for (let [key, value] of formData)
      invariant2(typeof value == "string", 'File inputs are not supported with encType "application/x-www-form-urlencoded", please use "multipart/form-data" instead.'), body.append(key, value);
    headers = {
      "Content-Type": encType
    };
  }
  return {
    method,
    body,
    signal,
    credentials: "same-origin",
    headers
  };
}

// node_modules/@remix-run/react/dist/esm/transition.js
init_history();

// node_modules/@remix-run/react/dist/esm/routeMatching.js
init_react_router_dom();
function matchClientRoutes(routes2, location) {
  let matches = matchRoutes(routes2, location);
  return matches ? matches.map((match) => ({
    params: match.params,
    pathname: match.pathname,
    route: match.route
  })) : null;
}

// node_modules/@remix-run/react/dist/esm/transition.js
var CatchValue = class {
  constructor(status, statusText, data) {
    this.status = status, this.statusText = statusText, this.data = data;
  }
};
function isActionSubmission(submission) {
  return ["POST", "PUT", "PATCH", "DELETE"].includes(submission.method);
}
function isLoaderSubmission(submission) {
  return submission.method === "GET";
}
function isRedirectLocation(location) {
  return Boolean(location.state) && location.state.isRedirect;
}
function isLoaderRedirectLocation(location) {
  return isRedirectLocation(location) && location.state.type === "loader";
}
function isActionRedirectLocation(location) {
  return isRedirectLocation(location) && location.state.type === "action";
}
function isFetchActionRedirect(location) {
  return isRedirectLocation(location) && location.state.type === "fetchAction";
}
function isLoaderSubmissionRedirectLocation(location) {
  return isRedirectLocation(location) && location.state.type === "loaderSubmission";
}
var TransitionRedirect = class {
  constructor(location, setCookie) {
    this.setCookie = setCookie, this.location = typeof location == "string" ? location : location.pathname + location.search;
  }
}, IDLE_TRANSITION = {
  state: "idle",
  submission: void 0,
  location: void 0,
  type: "idle"
}, IDLE_FETCHER = {
  state: "idle",
  type: "init",
  data: void 0,
  submission: void 0
};
function createTransitionManager(init2) {
  let {
    routes: routes2
  } = init2, pendingNavigationController, fetchControllers = /* @__PURE__ */ new Map(), incrementingLoadId = 0, navigationLoadId = -1, fetchReloadIds = /* @__PURE__ */ new Map(), fetchRedirectIds = /* @__PURE__ */ new Set(), subscribers = /* @__PURE__ */ new Set(), matches = matchClientRoutes(routes2, init2.location);
  matches || (matches = [{
    params: {},
    pathname: "",
    route: routes2[0]
  }]);
  let state = {
    location: init2.location,
    loaderData: init2.loaderData || {},
    actionData: init2.actionData,
    catch: init2.catch,
    error: init2.error,
    catchBoundaryId: init2.catchBoundaryId || null,
    errorBoundaryId: init2.errorBoundaryId || null,
    matches,
    nextMatches: void 0,
    transition: IDLE_TRANSITION,
    fetchers: /* @__PURE__ */ new Map()
  };
  function update(updates) {
    updates.transition && updates.transition === IDLE_TRANSITION && (pendingNavigationController = void 0), state = Object.assign({}, state, updates);
    for (let subscriber of subscribers.values())
      subscriber(state);
  }
  function getState() {
    return state;
  }
  function getFetcher(key) {
    return state.fetchers.get(key) || IDLE_FETCHER;
  }
  function setFetcher(key, fetcher) {
    state.fetchers.set(key, fetcher);
  }
  function deleteFetcher(key) {
    fetchControllers.has(key) && abortFetcher(key), fetchReloadIds.delete(key), fetchRedirectIds.delete(key), state.fetchers.delete(key);
  }
  async function send(event) {
    switch (event.type) {
      case "navigation": {
        let {
          action,
          location,
          submission
        } = event, matches2 = matchClientRoutes(routes2, location);
        matches2 ? !submission && isHashChangeOnly(location) ? await handleHashChange(location, matches2) : action === Action.Pop ? await handleLoad(location, matches2) : submission && isActionSubmission(submission) ? await handleActionSubmissionNavigation(location, submission, matches2) : submission && isLoaderSubmission(submission) ? await handleLoaderSubmissionNavigation(location, submission, matches2) : isActionRedirectLocation(location) ? await handleActionRedirect(location, matches2) : isLoaderSubmissionRedirectLocation(location) ? await handleLoaderSubmissionRedirect(location, matches2) : isLoaderRedirectLocation(location) ? await handleLoaderRedirect(location, matches2) : isFetchActionRedirect(location) ? await handleFetchActionRedirect(location, matches2) : await handleLoad(location, matches2) : (matches2 = [{
          params: {},
          pathname: "",
          route: routes2[0]
        }], await handleNotFoundNavigation(location, matches2)), navigationLoadId = -1;
        break;
      }
      case "fetcher": {
        let {
          key,
          submission,
          href
        } = event, matches2 = matchClientRoutes(routes2, href);
        invariant2(matches2, "No matches found"), fetchControllers.has(key) && abortFetcher(key);
        let match = getFetcherRequestMatch(new URL(href, window.location.href), matches2);
        submission && isActionSubmission(submission) ? await handleActionFetchSubmission(key, submission, match) : submission && isLoaderSubmission(submission) ? await handleLoaderFetchSubmission(href, key, submission, match) : await handleLoaderFetch(href, key, match);
        break;
      }
      default:
        throw new Error(`Unknown data event type: ${event.type}`);
    }
  }
  function dispose() {
    abortNormalNavigation();
    for (let [, controller] of fetchControllers)
      controller.abort();
  }
  function isIndexRequestUrl2(url) {
    for (let param of url.searchParams.getAll("index"))
      if (param === "")
        return !0;
    return !1;
  }
  function getFetcherRequestMatch(url, matches2) {
    let match = matches2.slice(-1)[0];
    return !isIndexRequestUrl2(url) && match.route.index ? matches2.slice(-2)[0] : match;
  }
  async function handleActionFetchSubmission(key, submission, match) {
    let currentFetcher = state.fetchers.get(key), fetcher = {
      state: "submitting",
      type: "actionSubmission",
      submission,
      data: (currentFetcher == null ? void 0 : currentFetcher.data) || void 0
    };
    setFetcher(key, fetcher), update({
      fetchers: new Map(state.fetchers)
    });
    let controller = new AbortController();
    fetchControllers.set(key, controller);
    let result = await callAction(submission, match, controller.signal);
    if (controller.signal.aborted)
      return;
    if (isRedirectResult(result)) {
      let locationState = {
        isRedirect: !0,
        type: "fetchAction",
        setCookie: result.value.setCookie
      };
      fetchRedirectIds.add(key), init2.onRedirect(result.value.location, locationState), setFetcher(key, {
        state: "loading",
        type: "actionRedirect",
        submission,
        data: void 0
      }), update({
        fetchers: new Map(state.fetchers)
      });
      return;
    }
    if (maybeBailOnError(match, key, result) || await maybeBailOnCatch(match, key, result))
      return;
    let loadFetcher = {
      state: "loading",
      type: "actionReload",
      data: result.value,
      submission
    };
    setFetcher(key, loadFetcher), update({
      fetchers: new Map(state.fetchers)
    });
    let maybeActionErrorResult = isErrorResult(result) ? result : void 0, maybeActionCatchResult = isCatchResult(result) ? result : void 0, loadId = ++incrementingLoadId;
    fetchReloadIds.set(key, loadId);
    let matchesToLoad = state.nextMatches || state.matches, results = await callLoaders(state, state.transition.location || state.location, matchesToLoad, controller.signal, maybeActionErrorResult, maybeActionCatchResult, submission, match.route.id, loadFetcher);
    if (controller.signal.aborted)
      return;
    fetchReloadIds.delete(key), fetchControllers.delete(key);
    let redirect2 = findRedirect(results);
    if (redirect2) {
      let locationState = {
        isRedirect: !0,
        type: "loader",
        setCookie: redirect2.setCookie
      };
      init2.onRedirect(redirect2.location, locationState);
      return;
    }
    let [error, errorBoundaryId] = findErrorAndBoundaryId(results, state.matches, maybeActionErrorResult), [catchVal, catchBoundaryId] = await findCatchAndBoundaryId(results, state.matches, maybeActionCatchResult) || [], doneFetcher = {
      state: "idle",
      type: "done",
      data: result.value,
      submission: void 0
    };
    setFetcher(key, doneFetcher);
    let abortedKeys = abortStaleFetchLoads(loadId);
    if (abortedKeys && markFetchersDone(abortedKeys), yeetStaleNavigationLoad(loadId)) {
      let {
        transition
      } = state;
      invariant2(transition.state === "loading", "Expected loading transition"), update({
        location: transition.location,
        matches: state.nextMatches,
        error,
        errorBoundaryId,
        catch: catchVal,
        catchBoundaryId,
        loaderData: makeLoaderData(state, results, matchesToLoad),
        actionData: transition.type === "actionReload" ? state.actionData : void 0,
        transition: IDLE_TRANSITION,
        fetchers: new Map(state.fetchers)
      });
    } else
      update({
        fetchers: new Map(state.fetchers),
        error,
        errorBoundaryId,
        loaderData: makeLoaderData(state, results, matchesToLoad)
      });
  }
  function yeetStaleNavigationLoad(landedId) {
    return state.transition.state === "loading" && navigationLoadId < landedId ? (abortNormalNavigation(), !0) : !1;
  }
  function markFetchersDone(keys2) {
    for (let key of keys2) {
      let fetcher = getFetcher(key), doneFetcher = {
        state: "idle",
        type: "done",
        data: fetcher.data,
        submission: void 0
      };
      setFetcher(key, doneFetcher);
    }
  }
  function abortStaleFetchLoads(landedId) {
    let yeetedKeys = [];
    for (let [key, id] of fetchReloadIds)
      if (id < landedId) {
        let fetcher = state.fetchers.get(key);
        invariant2(fetcher, `Expected fetcher: ${key}`), fetcher.state === "loading" && (abortFetcher(key), fetchReloadIds.delete(key), yeetedKeys.push(key));
      }
    return yeetedKeys.length ? yeetedKeys : !1;
  }
  async function handleLoaderFetchSubmission(href, key, submission, match) {
    let currentFetcher = state.fetchers.get(key), fetcher = {
      state: "submitting",
      type: "loaderSubmission",
      submission,
      data: (currentFetcher == null ? void 0 : currentFetcher.data) || void 0
    };
    setFetcher(key, fetcher), update({
      fetchers: new Map(state.fetchers)
    });
    let controller = new AbortController();
    fetchControllers.set(key, controller);
    let result = await callLoader(match, createUrl(href), controller.signal);
    if (fetchControllers.delete(key), controller.signal.aborted)
      return;
    if (isRedirectResult(result)) {
      let locationState = {
        isRedirect: !0,
        type: "loader",
        setCookie: result.value.setCookie
      };
      init2.onRedirect(result.value.location, locationState);
      return;
    }
    if (maybeBailOnError(match, key, result) || await maybeBailOnCatch(match, key, result))
      return;
    let doneFetcher = {
      state: "idle",
      type: "done",
      data: result.value,
      submission: void 0
    };
    setFetcher(key, doneFetcher), update({
      fetchers: new Map(state.fetchers)
    });
  }
  async function handleLoaderFetch(href, key, match) {
    if (typeof AbortController > "u")
      throw new Error("handleLoaderFetch was called during the server render, but it shouldn't be. You are likely calling useFetcher.load() in the body of your component. Try moving it to a useEffect or a callback.");
    let currentFetcher = state.fetchers.get(key), fetcher = {
      state: "loading",
      type: "normalLoad",
      submission: void 0,
      data: (currentFetcher == null ? void 0 : currentFetcher.data) || void 0
    };
    setFetcher(key, fetcher), update({
      fetchers: new Map(state.fetchers)
    });
    let controller = new AbortController();
    fetchControllers.set(key, controller);
    let result = await callLoader(match, createUrl(href), controller.signal);
    if (controller.signal.aborted)
      return;
    if (fetchControllers.delete(key), isRedirectResult(result)) {
      let locationState = {
        isRedirect: !0,
        type: "loader",
        setCookie: result.value.setCookie
      };
      init2.onRedirect(result.value.location, locationState);
      return;
    }
    if (maybeBailOnError(match, key, result) || await maybeBailOnCatch(match, key, result))
      return;
    let doneFetcher = {
      state: "idle",
      type: "done",
      data: result.value,
      submission: void 0
    };
    setFetcher(key, doneFetcher), update({
      fetchers: new Map(state.fetchers)
    });
  }
  async function maybeBailOnCatch(match, key, result) {
    if (isCatchResult(result)) {
      let catchBoundaryId = findNearestCatchBoundary(match, state.matches);
      return state.fetchers.delete(key), update({
        transition: IDLE_TRANSITION,
        fetchers: new Map(state.fetchers),
        catch: {
          data: result.value.data,
          status: result.value.status,
          statusText: result.value.statusText
        },
        catchBoundaryId
      }), !0;
    }
    return !1;
  }
  function maybeBailOnError(match, key, result) {
    if (isErrorResult(result)) {
      let errorBoundaryId = findNearestBoundary(match, state.matches);
      return state.fetchers.delete(key), update({
        fetchers: new Map(state.fetchers),
        error: result.value,
        errorBoundaryId
      }), !0;
    }
    return !1;
  }
  async function handleNotFoundNavigation(location, matches2) {
    abortNormalNavigation(), update({
      transition: {
        state: "loading",
        type: "normalLoad",
        submission: void 0,
        location
      },
      nextMatches: matches2
    }), await Promise.resolve();
    let catchBoundaryId = findNearestCatchBoundary(matches2[0], matches2);
    update({
      location,
      matches: matches2,
      catch: {
        data: null,
        status: 404,
        statusText: "Not Found"
      },
      catchBoundaryId,
      transition: IDLE_TRANSITION
    });
  }
  async function handleActionSubmissionNavigation(location, submission, matches2) {
    abortNormalNavigation(), update({
      transition: {
        state: "submitting",
        type: "actionSubmission",
        submission,
        location
      },
      nextMatches: matches2
    });
    let controller = new AbortController();
    pendingNavigationController = controller;
    let actionMatches = matches2;
    !isIndexRequestUrl2(createUrl(submission.action)) && actionMatches[matches2.length - 1].route.index && (actionMatches = actionMatches.slice(0, -1));
    let leafMatch = actionMatches.slice(-1)[0], result = await callAction(submission, leafMatch, controller.signal);
    if (controller.signal.aborted)
      return;
    if (isRedirectResult(result)) {
      let locationState = {
        isRedirect: !0,
        type: "action",
        setCookie: result.value.setCookie
      };
      init2.onRedirect(result.value.location, locationState);
      return;
    }
    let catchVal, catchBoundaryId;
    isCatchResult(result) && ([catchVal, catchBoundaryId] = await findCatchAndBoundaryId([result], actionMatches, result) || []), update({
      transition: {
        state: "loading",
        type: "actionReload",
        submission,
        location
      },
      actionData: {
        [leafMatch.route.id]: result.value
      }
    }), await loadPageData(location, matches2, submission, leafMatch.route.id, result, catchVal, catchBoundaryId);
  }
  async function handleLoaderSubmissionNavigation(location, submission, matches2) {
    abortNormalNavigation(), update({
      transition: {
        state: "submitting",
        type: "loaderSubmission",
        submission,
        location
      },
      nextMatches: matches2
    }), await loadPageData(location, matches2, submission);
  }
  async function handleHashChange(location, matches2) {
    abortNormalNavigation(), update({
      transition: {
        state: "loading",
        type: "normalLoad",
        submission: void 0,
        location
      },
      nextMatches: matches2
    }), await Promise.resolve(), update({
      location,
      matches: matches2,
      transition: IDLE_TRANSITION
    });
  }
  async function handleLoad(location, matches2) {
    abortNormalNavigation(), update({
      transition: {
        state: "loading",
        type: "normalLoad",
        submission: void 0,
        location
      },
      nextMatches: matches2
    }), await loadPageData(location, matches2);
  }
  async function handleLoaderRedirect(location, matches2) {
    abortNormalNavigation(), update({
      transition: {
        state: "loading",
        type: "normalRedirect",
        submission: void 0,
        location
      },
      nextMatches: matches2
    }), await loadPageData(location, matches2);
  }
  async function handleLoaderSubmissionRedirect(location, matches2) {
    abortNormalNavigation(), invariant2(state.transition.type === "loaderSubmission", `Unexpected transition: ${JSON.stringify(state.transition)}`);
    let {
      submission
    } = state.transition;
    update({
      transition: {
        state: "loading",
        type: "loaderSubmissionRedirect",
        submission,
        location
      },
      nextMatches: matches2
    }), await loadPageData(location, matches2, submission);
  }
  async function handleFetchActionRedirect(location, matches2) {
    abortNormalNavigation(), update({
      transition: {
        state: "loading",
        type: "fetchActionRedirect",
        submission: void 0,
        location
      },
      nextMatches: matches2
    }), await loadPageData(location, matches2);
  }
  async function handleActionRedirect(location, matches2) {
    abortNormalNavigation(), invariant2(state.transition.type === "actionSubmission" || state.transition.type === "actionReload" || state.transition.type === "actionRedirect", `Unexpected transition: ${JSON.stringify(state.transition)}`);
    let {
      submission
    } = state.transition;
    update({
      transition: {
        state: "loading",
        type: "actionRedirect",
        submission,
        location
      },
      nextMatches: matches2
    }), await loadPageData(location, matches2, submission);
  }
  function isHashChangeOnly(location) {
    return createHref(state.location) === createHref(location) && state.location.hash !== location.hash;
  }
  async function loadPageData(location, matches2, submission, submissionRouteId, actionResult, catchVal, catchBoundaryId) {
    let maybeActionErrorResult = actionResult && isErrorResult(actionResult) ? actionResult : void 0, maybeActionCatchResult = actionResult && isCatchResult(actionResult) ? actionResult : void 0, controller = new AbortController();
    pendingNavigationController = controller, navigationLoadId = ++incrementingLoadId;
    let results = await callLoaders(state, location, matches2, controller.signal, maybeActionErrorResult, maybeActionCatchResult, submission, submissionRouteId, void 0, catchBoundaryId);
    if (controller.signal.aborted)
      return;
    let redirect2 = findRedirect(results);
    if (redirect2) {
      if (state.transition.type === "actionReload" || isActionRedirectLocation(location)) {
        let locationState = {
          isRedirect: !0,
          type: "action",
          setCookie: redirect2.setCookie
        };
        init2.onRedirect(redirect2.location, locationState);
      } else if (state.transition.type === "loaderSubmission") {
        let locationState = {
          isRedirect: !0,
          type: "loaderSubmission",
          setCookie: redirect2.setCookie
        };
        init2.onRedirect(redirect2.location, locationState);
      } else {
        var _location$state;
        let locationState = {
          isRedirect: !0,
          type: "loader",
          setCookie: redirect2.setCookie || ((_location$state = location.state) === null || _location$state === void 0 ? void 0 : _location$state.setCookie) === !0
        };
        init2.onRedirect(redirect2.location, locationState);
      }
      return;
    }
    let [error, errorBoundaryId] = findErrorAndBoundaryId(results, matches2, maybeActionErrorResult);
    [catchVal, catchBoundaryId] = await findCatchAndBoundaryId(results, matches2, maybeActionErrorResult) || [catchVal, catchBoundaryId], markFetchRedirectsDone();
    let abortedIds = abortStaleFetchLoads(navigationLoadId);
    abortedIds && markFetchersDone(abortedIds), update({
      location,
      matches: matches2,
      error,
      errorBoundaryId,
      catch: catchVal,
      catchBoundaryId,
      loaderData: makeLoaderData(state, results, matches2),
      actionData: state.transition.type === "actionReload" ? state.actionData : void 0,
      transition: IDLE_TRANSITION,
      fetchers: abortedIds ? new Map(state.fetchers) : state.fetchers
    });
  }
  function abortNormalNavigation() {
    pendingNavigationController && pendingNavigationController.abort();
  }
  function abortFetcher(key) {
    let controller = fetchControllers.get(key);
    invariant2(controller, `Expected fetch controller: ${key}`), controller.abort(), fetchControllers.delete(key);
  }
  function markFetchRedirectsDone() {
    let doneKeys = [];
    for (let key of fetchRedirectIds) {
      let fetcher = state.fetchers.get(key);
      invariant2(fetcher, `Expected fetcher: ${key}`), fetcher.type === "actionRedirect" && (fetchRedirectIds.delete(key), doneKeys.push(key));
    }
    markFetchersDone(doneKeys);
  }
  function subscribe(subscriber) {
    return subscribers.add(subscriber), () => {
      subscribers.delete(subscriber);
    };
  }
  return {
    subscribe,
    send,
    getState,
    getFetcher,
    deleteFetcher,
    dispose,
    get _internalFetchControllers() {
      return fetchControllers;
    }
  };
}
async function callLoaders(state, location, matches, signal, actionErrorResult, actionCatchResult, submission, submissionRouteId, fetcher, catchBoundaryId) {
  let url = createUrl(createHref(location)), matchesToLoad = filterMatchesToLoad(state, location, matches, actionErrorResult, actionCatchResult, submission, submissionRouteId, fetcher, catchBoundaryId);
  return Promise.all(matchesToLoad.map((match) => callLoader(match, url, signal)));
}
async function callLoader(match, url, signal) {
  invariant2(match.route.loader, `Expected loader for ${match.route.id}`);
  try {
    let {
      params
    } = match, value = await match.route.loader({
      params,
      url,
      signal
    });
    return {
      match,
      value
    };
  } catch (error) {
    return {
      match,
      value: error
    };
  }
}
async function callAction(submission, match, signal) {
  try {
    let value = await match.route.action({
      url: createUrl(submission.action),
      params: match.params,
      submission,
      signal
    });
    return {
      match,
      value
    };
  } catch (error) {
    return {
      match,
      value: error
    };
  }
}
function filterMatchesToLoad(state, location, matches, actionErrorResult, actionCatchResult, submission, submissionRouteId, fetcher, catchBoundaryId) {
  var _location$state2;
  if (catchBoundaryId || submissionRouteId && (actionCatchResult || actionErrorResult)) {
    let foundProblematicRoute = !1;
    matches = matches.filter((match) => foundProblematicRoute ? !1 : match.route.id === submissionRouteId || match.route.id === catchBoundaryId ? (foundProblematicRoute = !0, !1) : !0);
  }
  let isNew = (match, index) => state.matches[index] ? match.route.id !== state.matches[index].route.id : !0, matchPathChanged = (match, index) => {
    var _state$matches$index$;
    return state.matches[index].pathname !== match.pathname || ((_state$matches$index$ = state.matches[index].route.path) === null || _state$matches$index$ === void 0 ? void 0 : _state$matches$index$.endsWith("*")) && state.matches[index].params["*"] !== match.params["*"];
  }, url = createUrl(createHref(location)), filterByRouteProps = (match, index) => {
    if (!match.route.loader)
      return !1;
    if (isNew(match, index) || matchPathChanged(match, index))
      return !0;
    if (match.route.shouldReload) {
      let prevUrl = createUrl(createHref(state.location));
      return match.route.shouldReload({
        prevUrl,
        url,
        submission,
        params: match.params
      });
    }
    return !0;
  };
  return state.matches.length === 1 ? matches.filter((match) => !!match.route.loader) : (fetcher == null ? void 0 : fetcher.type) === "actionReload" || state.transition.type === "actionReload" || state.transition.type === "actionRedirect" || state.transition.type === "fetchActionRedirect" || createHref(url) === createHref(state.location) || url.searchParams.toString() !== state.location.search.substring(1) || (_location$state2 = location.state) !== null && _location$state2 !== void 0 && _location$state2.setCookie ? matches.filter(filterByRouteProps) : matches.filter((match, index, arr) => {
    var _location$state3;
    return (actionErrorResult || actionCatchResult) && arr.length - 1 === index ? !1 : match.route.loader && (isNew(match, index) || matchPathChanged(match, index) || ((_location$state3 = location.state) === null || _location$state3 === void 0 ? void 0 : _location$state3.setCookie));
  });
}
function isRedirectResult(result) {
  return result.value instanceof TransitionRedirect;
}
function createHref(location) {
  return location.pathname + location.search;
}
function findRedirect(results) {
  for (let result of results)
    if (isRedirectResult(result))
      return result.value;
  return null;
}
async function findCatchAndBoundaryId(results, matches, actionCatchResult) {
  let loaderCatchResult;
  for (let result of results)
    if (isCatchResult(result)) {
      loaderCatchResult = result;
      break;
    }
  let extractCatchData = async (res) => ({
    status: res.status,
    statusText: res.statusText,
    data: res.data
  });
  if (actionCatchResult && loaderCatchResult) {
    let boundaryId = findNearestCatchBoundary(loaderCatchResult.match, matches);
    return [await extractCatchData(actionCatchResult.value), boundaryId];
  }
  if (loaderCatchResult) {
    let boundaryId = findNearestCatchBoundary(loaderCatchResult.match, matches);
    return [await extractCatchData(loaderCatchResult.value), boundaryId];
  }
  return null;
}
function findErrorAndBoundaryId(results, matches, actionErrorResult) {
  let loaderErrorResult;
  for (let result of results)
    if (isErrorResult(result)) {
      loaderErrorResult = result;
      break;
    }
  if (actionErrorResult && loaderErrorResult) {
    let boundaryId = findNearestBoundary(loaderErrorResult.match, matches);
    return [actionErrorResult.value, boundaryId];
  }
  if (actionErrorResult) {
    let boundaryId = findNearestBoundary(actionErrorResult.match, matches);
    return [actionErrorResult.value, boundaryId];
  }
  if (loaderErrorResult) {
    let boundaryId = findNearestBoundary(loaderErrorResult.match, matches);
    return [loaderErrorResult.value, boundaryId];
  }
  return [void 0, void 0];
}
function findNearestCatchBoundary(matchWithError, matches) {
  let nearestBoundaryId = null;
  for (let match of matches)
    if (match.route.CatchBoundary && (nearestBoundaryId = match.route.id), match === matchWithError)
      break;
  return nearestBoundaryId;
}
function findNearestBoundary(matchWithError, matches) {
  let nearestBoundaryId = null;
  for (let match of matches)
    if (match.route.ErrorBoundary && (nearestBoundaryId = match.route.id), match === matchWithError)
      break;
  return nearestBoundaryId;
}
function makeLoaderData(state, results, matches) {
  let newData = {};
  for (let {
    match,
    value
  } of results)
    newData[match.route.id] = value;
  let loaderData = {};
  for (let {
    route
  } of matches) {
    let value = newData[route.id] !== void 0 ? newData[route.id] : state.loaderData[route.id];
    value !== void 0 && (loaderData[route.id] = value);
  }
  return loaderData;
}
function isCatchResult(result) {
  return result.value instanceof CatchValue;
}
function isErrorResult(result) {
  return result.value instanceof Error;
}
function createUrl(href) {
  return new URL(href, window.location.origin);
}

// node_modules/@remix-run/react/dist/esm/routes.js
function createClientRoute(entryRoute, routeModulesCache, Component) {
  return {
    caseSensitive: !!entryRoute.caseSensitive,
    element: /* @__PURE__ */ React.createElement(Component, {
      id: entryRoute.id
    }),
    id: entryRoute.id,
    path: entryRoute.path,
    index: entryRoute.index,
    module: entryRoute.module,
    loader: createLoader(entryRoute, routeModulesCache),
    action: createAction(entryRoute, routeModulesCache),
    shouldReload: createShouldReload(entryRoute, routeModulesCache),
    ErrorBoundary: entryRoute.hasErrorBoundary,
    CatchBoundary: entryRoute.hasCatchBoundary,
    hasLoader: entryRoute.hasLoader
  };
}
function createClientRoutes(routeManifest, routeModulesCache, Component, parentId) {
  return Object.keys(routeManifest).filter((key) => routeManifest[key].parentId === parentId).map((key) => {
    let route = createClientRoute(routeManifest[key], routeModulesCache, Component), children = createClientRoutes(routeManifest, routeModulesCache, Component, route.id);
    return children.length > 0 && (route.children = children), route;
  });
}
function createShouldReload(route, routeModules) {
  return (arg) => {
    let module = routeModules[route.id];
    return invariant2(module, `Expected route module to be loaded for ${route.id}`), module.unstable_shouldReload ? module.unstable_shouldReload(arg) : !0;
  };
}
async function loadRouteModuleWithBlockingLinks(route, routeModules) {
  let routeModule = await loadRouteModule(route, routeModules);
  return await prefetchStyleLinks(routeModule), routeModule;
}
function createLoader(route, routeModules) {
  return async ({
    url,
    signal,
    submission
  }) => {
    if (route.hasLoader) {
      let [result] = await Promise.all([fetchData(url, route.id, signal, submission), loadRouteModuleWithBlockingLinks(route, routeModules)]);
      if (result instanceof Error)
        throw result;
      let redirect2 = await checkRedirect(result);
      if (redirect2)
        return redirect2;
      if (isCatchResponse2(result))
        throw new CatchValue(result.status, result.statusText, await extractData2(result));
      return extractData2(result);
    } else
      await loadRouteModuleWithBlockingLinks(route, routeModules);
  };
}
function createAction(route, routeModules) {
  return async ({
    url,
    signal,
    submission
  }) => {
    route.hasAction || console.error(`Route "${route.id}" does not have an action, but you are trying to submit to it. To fix this, please add an \`action\` function to the route`);
    let result = await fetchData(url, route.id, signal, submission);
    if (result instanceof Error)
      throw result;
    let redirect2 = await checkRedirect(result);
    if (redirect2)
      return redirect2;
    if (await loadRouteModuleWithBlockingLinks(route, routeModules), isCatchResponse2(result))
      throw new CatchValue(result.status, result.statusText, await extractData2(result));
    return extractData2(result);
  };
}
async function checkRedirect(response) {
  if (isRedirectResponse2(response)) {
    let url = new URL(response.headers.get("X-Remix-Redirect"), window.location.origin);
    if (url.origin !== window.location.origin)
      await new Promise(() => {
        window.location.replace(url.href);
      });
    else
      return new TransitionRedirect(url.pathname + url.search + url.hash, response.headers.get("X-Remix-Revalidate") !== null);
  }
  return null;
}

// node_modules/@remix-run/react/dist/esm/components.js
var RemixEntryContext = /* @__PURE__ */ React2.createContext(void 0);
function useRemixEntryContext() {
  let context = React2.useContext(RemixEntryContext);
  return invariant2(context, "You must render this element inside a <Remix> element"), context;
}
function RemixEntry({
  context: entryContext,
  action,
  location: historyLocation,
  navigator: _navigator,
  static: staticProp = !1
}) {
  let {
    manifest,
    routeData: documentLoaderData,
    actionData: documentActionData,
    routeModules,
    serverHandoffString,
    appState: entryComponentDidCatchEmulator
  } = entryContext, clientRoutes = React2.useMemo(() => createClientRoutes(manifest.routes, routeModules, RemixRoute), [manifest, routeModules]), [clientState, setClientState] = React2.useState(entryComponentDidCatchEmulator), [transitionManager] = React2.useState(() => createTransitionManager({
    routes: clientRoutes,
    actionData: documentActionData,
    loaderData: documentLoaderData,
    location: historyLocation,
    catch: entryComponentDidCatchEmulator.catch,
    catchBoundaryId: entryComponentDidCatchEmulator.catchBoundaryRouteId,
    onRedirect: _navigator.replace
  }));
  React2.useEffect(() => {
    let subscriber = (state) => {
      setClientState({
        catch: state.catch,
        error: state.error,
        catchBoundaryRouteId: state.catchBoundaryId,
        loaderBoundaryRouteId: state.errorBoundaryId,
        renderBoundaryRouteId: null,
        trackBoundaries: !1,
        trackCatchBoundaries: !1
      });
    };
    return transitionManager.subscribe(subscriber);
  }, [transitionManager]);
  let navigator2 = React2.useMemo(() => ({
    ..._navigator,
    push: (to, state) => transitionManager.getState().transition.state !== "idle" ? _navigator.replace(to, state) : _navigator.push(to, state)
  }), [_navigator, transitionManager]), {
    location,
    matches,
    loaderData,
    actionData
  } = transitionManager.getState();
  React2.useEffect(() => {
    let {
      location: location2
    } = transitionManager.getState();
    historyLocation !== location2 && transitionManager.send({
      type: "navigation",
      location: historyLocation,
      submission: consumeNextNavigationSubmission(),
      action
    });
  }, [transitionManager, historyLocation, action]);
  let ssrErrorBeforeRoutesRendered = clientState.error && clientState.renderBoundaryRouteId === null && clientState.loaderBoundaryRouteId === null ? deserializeError(clientState.error) : void 0, ssrCatchBeforeRoutesRendered = clientState.catch && clientState.catchBoundaryRouteId === null ? clientState.catch : void 0;
  return /* @__PURE__ */ React2.createElement(RemixEntryContext.Provider, {
    value: {
      matches,
      manifest,
      appState: clientState,
      routeModules,
      serverHandoffString,
      clientRoutes,
      routeData: loaderData,
      actionData,
      transitionManager
    }
  }, /* @__PURE__ */ React2.createElement(RemixErrorBoundary, {
    location,
    component: RemixRootDefaultErrorBoundary,
    error: ssrErrorBeforeRoutesRendered
  }, /* @__PURE__ */ React2.createElement(RemixCatchBoundary, {
    location,
    component: RemixRootDefaultCatchBoundary,
    catch: ssrCatchBeforeRoutesRendered
  }, /* @__PURE__ */ React2.createElement(Router, {
    navigationType: action,
    location,
    navigator: navigator2,
    static: staticProp
  }, /* @__PURE__ */ React2.createElement(Routes2, null)))));
}
function deserializeError(data) {
  let error = new Error(data.message);
  return error.stack = data.stack, error;
}
function Routes2() {
  let {
    clientRoutes
  } = useRemixEntryContext();
  return useRoutes(clientRoutes) || clientRoutes[0].element;
}
var RemixRouteContext = /* @__PURE__ */ React2.createContext(void 0);
function useRemixRouteContext() {
  let context = React2.useContext(RemixRouteContext);
  return invariant2(context, "You must render this element in a remix route element"), context;
}
function DefaultRouteComponent({
  id
}) {
  throw new Error(`Route "${id}" has no component! Please go add a \`default\` export in the route module file.
If you were trying to navigate or submit to a resource route, use \`<a>\` instead of \`<Link>\` or \`<Form reloadDocument>\`.`);
}
function RemixRoute({
  id
}) {
  let location = useLocation(), {
    routeData,
    routeModules,
    appState
  } = useRemixEntryContext();
  invariant2(routeData, `Cannot initialize 'routeData'. This normally occurs when you have server code in your client modules.
Check this link for more details:
https://remix.run/pages/gotchas#server-code-in-client-bundles`), invariant2(routeModules, `Cannot initialize 'routeModules'. This normally occurs when you have server code in your client modules.
Check this link for more details:
https://remix.run/pages/gotchas#server-code-in-client-bundles`);
  let data = routeData[id], {
    default: Component,
    CatchBoundary,
    ErrorBoundary
  } = routeModules[id], element = Component ? /* @__PURE__ */ React2.createElement(Component, null) : /* @__PURE__ */ React2.createElement(DefaultRouteComponent, {
    id
  }), context = {
    data,
    id
  };
  if (CatchBoundary) {
    let maybeServerCaught = appState.catch && appState.catchBoundaryRouteId === id ? appState.catch : void 0;
    appState.trackCatchBoundaries && (appState.catchBoundaryRouteId = id), context = maybeServerCaught ? {
      id,
      get data() {
        console.error("You cannot `useLoaderData` in a catch boundary.");
      }
    } : {
      id,
      data
    }, element = /* @__PURE__ */ React2.createElement(RemixCatchBoundary, {
      location,
      component: CatchBoundary,
      catch: maybeServerCaught
    }, element);
  }
  if (ErrorBoundary) {
    let maybeServerRenderError = appState.error && (appState.renderBoundaryRouteId === id || appState.loaderBoundaryRouteId === id) ? deserializeError(appState.error) : void 0;
    appState.trackBoundaries && (appState.renderBoundaryRouteId = id), context = maybeServerRenderError ? {
      id,
      get data() {
        console.error("You cannot `useLoaderData` in an error boundary.");
      }
    } : {
      id,
      data
    }, element = /* @__PURE__ */ React2.createElement(RemixErrorBoundary, {
      location,
      component: ErrorBoundary,
      error: maybeServerRenderError
    }, element);
  }
  return /* @__PURE__ */ React2.createElement(RemixRouteContext.Provider, {
    value: context
  }, element);
}
function usePrefetchBehavior(prefetch, theirElementProps) {
  let [maybePrefetch, setMaybePrefetch] = React2.useState(!1), [shouldPrefetch, setShouldPrefetch] = React2.useState(!1), {
    onFocus,
    onBlur,
    onMouseEnter,
    onMouseLeave,
    onTouchStart
  } = theirElementProps;
  React2.useEffect(() => {
    prefetch === "render" && setShouldPrefetch(!0);
  }, [prefetch]);
  let setIntent = () => {
    prefetch === "intent" && setMaybePrefetch(!0);
  }, cancelIntent = () => {
    prefetch === "intent" && (setMaybePrefetch(!1), setShouldPrefetch(!1));
  };
  return React2.useEffect(() => {
    if (maybePrefetch) {
      let id = setTimeout(() => {
        setShouldPrefetch(!0);
      }, 100);
      return () => {
        clearTimeout(id);
      };
    }
  }, [maybePrefetch]), [shouldPrefetch, {
    onFocus: composeEventHandlers(onFocus, setIntent),
    onBlur: composeEventHandlers(onBlur, cancelIntent),
    onMouseEnter: composeEventHandlers(onMouseEnter, setIntent),
    onMouseLeave: composeEventHandlers(onMouseLeave, cancelIntent),
    onTouchStart: composeEventHandlers(onTouchStart, setIntent)
  }];
}
var NavLink2 = /* @__PURE__ */ React2.forwardRef(({
  to,
  prefetch = "none",
  ...props
}, forwardedRef) => {
  let href = useHref(to), [shouldPrefetch, prefetchHandlers] = usePrefetchBehavior(prefetch, props);
  return /* @__PURE__ */ React2.createElement(React2.Fragment, null, /* @__PURE__ */ React2.createElement(NavLink, _extends3({
    ref: forwardedRef,
    to
  }, props, prefetchHandlers)), shouldPrefetch ? /* @__PURE__ */ React2.createElement(PrefetchPageLinks, {
    page: href
  }) : null);
});
NavLink2.displayName = "NavLink";
var Link2 = /* @__PURE__ */ React2.forwardRef(({
  to,
  prefetch = "none",
  ...props
}, forwardedRef) => {
  let href = useHref(to), [shouldPrefetch, prefetchHandlers] = usePrefetchBehavior(prefetch, props);
  return /* @__PURE__ */ React2.createElement(React2.Fragment, null, /* @__PURE__ */ React2.createElement(Link, _extends3({
    ref: forwardedRef,
    to
  }, props, prefetchHandlers)), shouldPrefetch ? /* @__PURE__ */ React2.createElement(PrefetchPageLinks, {
    page: href
  }) : null);
});
Link2.displayName = "Link";
function composeEventHandlers(theirHandler, ourHandler) {
  return (event) => {
    theirHandler && theirHandler(event), event.defaultPrevented || ourHandler(event);
  };
}
function Links() {
  let {
    matches,
    routeModules,
    manifest
  } = useRemixEntryContext(), links2 = React2.useMemo(() => getLinksForMatches(matches, routeModules, manifest), [matches, routeModules, manifest]);
  return /* @__PURE__ */ React2.createElement(React2.Fragment, null, links2.map((link) => {
    if (isPageLinkDescriptor(link))
      return /* @__PURE__ */ React2.createElement(PrefetchPageLinks, _extends3({
        key: link.page
      }, link));
    let imageSrcSet = null;
    return "useId" in React2 ? (link.imagesrcset && (link.imageSrcSet = imageSrcSet = link.imagesrcset, delete link.imagesrcset), link.imagesizes && (link.imageSizes = link.imagesizes, delete link.imagesizes)) : (link.imageSrcSet && (link.imagesrcset = imageSrcSet = link.imageSrcSet, delete link.imageSrcSet), link.imageSizes && (link.imagesizes = link.imageSizes, delete link.imageSizes)), /* @__PURE__ */ React2.createElement("link", _extends3({
      key: link.rel + (link.href || "") + (imageSrcSet || "")
    }, link));
  }));
}
function PrefetchPageLinks({
  page,
  ...dataLinkProps
}) {
  let {
    clientRoutes
  } = useRemixEntryContext(), matches = React2.useMemo(() => matchClientRoutes(clientRoutes, page), [clientRoutes, page]);
  return matches ? /* @__PURE__ */ React2.createElement(PrefetchPageLinksImpl, _extends3({
    page,
    matches
  }, dataLinkProps)) : (console.warn(`Tried to prefetch ${page} but no routes matched.`), null);
}
function usePrefetchedStylesheets(matches) {
  let {
    routeModules
  } = useRemixEntryContext(), [styleLinks, setStyleLinks] = React2.useState([]);
  return React2.useEffect(() => {
    let interrupted = !1;
    return getStylesheetPrefetchLinks(matches, routeModules).then((links2) => {
      interrupted || setStyleLinks(links2);
    }), () => {
      interrupted = !0;
    };
  }, [matches, routeModules]), styleLinks;
}
function PrefetchPageLinksImpl({
  page,
  matches: nextMatches,
  ...linkProps
}) {
  let location = useLocation(), {
    matches,
    manifest
  } = useRemixEntryContext(), newMatchesForData = React2.useMemo(() => getNewMatchesForLinks(page, nextMatches, matches, location, "data"), [page, nextMatches, matches, location]), newMatchesForAssets = React2.useMemo(() => getNewMatchesForLinks(page, nextMatches, matches, location, "assets"), [page, nextMatches, matches, location]), dataHrefs = React2.useMemo(() => getDataLinkHrefs(page, newMatchesForData, manifest), [newMatchesForData, page, manifest]), moduleHrefs = React2.useMemo(() => getModuleLinkHrefs(newMatchesForAssets, manifest), [newMatchesForAssets, manifest]), styleLinks = usePrefetchedStylesheets(newMatchesForAssets);
  return /* @__PURE__ */ React2.createElement(React2.Fragment, null, dataHrefs.map((href) => /* @__PURE__ */ React2.createElement("link", _extends3({
    key: href,
    rel: "prefetch",
    as: "fetch",
    href
  }, linkProps))), moduleHrefs.map((href) => /* @__PURE__ */ React2.createElement("link", _extends3({
    key: href,
    rel: "modulepreload",
    href
  }, linkProps))), styleLinks.map((link) => /* @__PURE__ */ React2.createElement("link", _extends3({
    key: link.href
  }, link))));
}
function Meta() {
  let {
    matches,
    routeData,
    routeModules
  } = useRemixEntryContext(), location = useLocation(), meta2 = {}, parentsData = {};
  for (let match of matches) {
    let routeId = match.route.id, data = routeData[routeId], params = match.params, routeModule = routeModules[routeId];
    if (routeModule.meta) {
      let routeMeta = typeof routeModule.meta == "function" ? routeModule.meta({
        data,
        parentsData,
        params,
        location
      }) : routeModule.meta;
      Object.assign(meta2, routeMeta);
    }
    parentsData[routeId] = data;
  }
  return /* @__PURE__ */ React2.createElement(React2.Fragment, null, Object.entries(meta2).map(([name, value]) => {
    if (!value)
      return null;
    if (["charset", "charSet"].includes(name))
      return /* @__PURE__ */ React2.createElement("meta", {
        key: "charset",
        charSet: value
      });
    if (name === "title")
      return /* @__PURE__ */ React2.createElement("title", {
        key: "title"
      }, String(value));
    let isOpenGraphTag = name.startsWith("og:");
    return [value].flat().map((content) => isOpenGraphTag ? /* @__PURE__ */ React2.createElement("meta", {
      property: name,
      content,
      key: name + content
    }) : typeof content == "string" ? /* @__PURE__ */ React2.createElement("meta", {
      name,
      content,
      key: name + content
    }) : /* @__PURE__ */ React2.createElement("meta", _extends3({
      key: name + JSON.stringify(content)
    }, content)));
  }));
}
var isHydrated = !1;
function Scripts(props) {
  let {
    manifest,
    matches,
    pendingLocation,
    clientRoutes,
    serverHandoffString
  } = useRemixEntryContext();
  React2.useEffect(() => {
    isHydrated = !0;
  }, []);
  let initialScripts = React2.useMemo(() => {
    let contextScript = serverHandoffString ? `window.__remixContext = ${serverHandoffString};` : "", routeModulesScript = `${matches.map((match, index) => `import ${JSON.stringify(manifest.url)};
import * as route${index} from ${JSON.stringify(manifest.routes[match.route.id].module)};`).join(`
`)}
window.__remixRouteModules = {${matches.map((match, index) => `${JSON.stringify(match.route.id)}:route${index}`).join(",")}};

import(${JSON.stringify(manifest.entry.module)});`;
    return /* @__PURE__ */ React2.createElement(React2.Fragment, null, /* @__PURE__ */ React2.createElement("script", _extends3({}, props, {
      suppressHydrationWarning: !0,
      dangerouslySetInnerHTML: createHtml(contextScript),
      type: void 0
    })), /* @__PURE__ */ React2.createElement("script", _extends3({}, props, {
      dangerouslySetInnerHTML: createHtml(routeModulesScript),
      type: "module",
      async: !0
    })));
  }, []), nextMatches = React2.useMemo(() => {
    if (pendingLocation) {
      let matches2 = matchClientRoutes(clientRoutes, pendingLocation);
      return invariant2(matches2, `No routes match path "${pendingLocation.pathname}"`), matches2;
    }
    return [];
  }, [pendingLocation, clientRoutes]), routePreloads = matches.concat(nextMatches).map((match) => {
    let route = manifest.routes[match.route.id];
    return (route.imports || []).concat([route.module]);
  }).flat(1), preloads = manifest.entry.imports.concat(routePreloads);
  return /* @__PURE__ */ React2.createElement(React2.Fragment, null, /* @__PURE__ */ React2.createElement("link", {
    rel: "modulepreload",
    href: manifest.entry.module,
    crossOrigin: props.crossOrigin
  }), dedupe2(preloads).map((path) => /* @__PURE__ */ React2.createElement("link", {
    key: path,
    rel: "modulepreload",
    href: path,
    crossOrigin: props.crossOrigin
  })), isHydrated ? null : initialScripts);
}
function dedupe2(array) {
  return [...new Set(array)];
}
var Form = /* @__PURE__ */ React2.forwardRef((props, ref) => /* @__PURE__ */ React2.createElement(FormImpl, _extends3({}, props, {
  ref
})));
Form.displayName = "Form";
var FormImpl = /* @__PURE__ */ React2.forwardRef(({
  reloadDocument = !1,
  replace = !1,
  method = "get",
  action,
  encType = "application/x-www-form-urlencoded",
  fetchKey,
  onSubmit,
  ...props
}, forwardedRef) => {
  let submit = useSubmitImpl(fetchKey), formMethod = method.toLowerCase() === "get" ? "get" : "post", formAction = useFormAction(action);
  return /* @__PURE__ */ React2.createElement("form", _extends3({
    ref: forwardedRef,
    method: formMethod,
    action: formAction,
    encType,
    onSubmit: reloadDocument ? void 0 : (event) => {
      if (onSubmit && onSubmit(event), event.defaultPrevented)
        return;
      event.preventDefault();
      let submitter = event.nativeEvent.submitter;
      submit(submitter || event.currentTarget, {
        method,
        replace
      });
    }
  }, props));
});
FormImpl.displayName = "FormImpl";
function useFormAction(action, method = "get") {
  let {
    id
  } = useRemixRouteContext(), resolvedPath = useResolvedPath(action ?? "."), location = useLocation(), {
    search,
    hash
  } = resolvedPath, isIndexRoute = id.endsWith("/index");
  if (action == null && (search = location.search, hash = location.hash, isIndexRoute)) {
    let params = new URLSearchParams(search);
    params.delete("index"), search = params.toString() ? `?${params.toString()}` : "";
  }
  return (action == null || action === ".") && isIndexRoute && (search = search ? search.replace(/^\?/, "?index&") : "?index"), createPath({
    pathname: resolvedPath.pathname,
    search,
    hash
  });
}
var defaultMethod = "get", defaultEncType = "application/x-www-form-urlencoded";
function useSubmitImpl(key) {
  let navigate = useNavigate(), defaultAction = useFormAction(), {
    transitionManager
  } = useRemixEntryContext();
  return React2.useCallback((target, options = {}) => {
    let method, action, encType, formData;
    if (isFormElement(target)) {
      let submissionTrigger = options.submissionTrigger;
      method = options.method || target.getAttribute("method") || defaultMethod, action = options.action || target.getAttribute("action") || defaultAction, encType = options.encType || target.getAttribute("enctype") || defaultEncType, formData = new FormData(target), submissionTrigger && submissionTrigger.name && formData.append(submissionTrigger.name, submissionTrigger.value);
    } else if (isButtonElement(target) || isInputElement(target) && (target.type === "submit" || target.type === "image")) {
      let form = target.form;
      if (form == null)
        throw new Error("Cannot submit a <button> without a <form>");
      method = options.method || target.getAttribute("formmethod") || form.getAttribute("method") || defaultMethod, action = options.action || target.getAttribute("formaction") || form.getAttribute("action") || defaultAction, encType = options.encType || target.getAttribute("formenctype") || form.getAttribute("enctype") || defaultEncType, formData = new FormData(form), target.name && formData.append(target.name, target.value);
    } else {
      if (isHtmlElement(target))
        throw new Error('Cannot submit element that is not <form>, <button>, or <input type="submit|image">');
      if (method = options.method || "get", action = options.action || defaultAction, encType = options.encType || "application/x-www-form-urlencoded", target instanceof FormData)
        formData = target;
      else if (formData = new FormData(), target instanceof URLSearchParams)
        for (let [name, value] of target)
          formData.append(name, value);
      else if (target != null)
        for (let name of Object.keys(target))
          formData.append(name, target[name]);
    }
    if (typeof document > "u")
      throw new Error("You are calling submit during the server render. Try calling submit within a `useEffect` or callback instead.");
    let {
      protocol,
      host
    } = window.location, url = new URL(action, `${protocol}//${host}`);
    if (method.toLowerCase() === "get")
      for (let [name, value] of formData)
        if (typeof value == "string")
          url.searchParams.append(name, value);
        else
          throw new Error("Cannot submit binary form data using GET");
    let submission = {
      formData,
      action: url.pathname + url.search,
      method: method.toUpperCase(),
      encType,
      key: Math.random().toString(36).substr(2, 8)
    };
    key ? transitionManager.send({
      type: "fetcher",
      href: submission.action,
      submission,
      key
    }) : (setNextNavigationSubmission(submission), navigate(url.pathname + url.search, {
      replace: options.replace
    }));
  }, [defaultAction, key, navigate, transitionManager]);
}
var nextNavigationSubmission;
function setNextNavigationSubmission(submission) {
  nextNavigationSubmission = submission;
}
function consumeNextNavigationSubmission() {
  let submission = nextNavigationSubmission;
  return nextNavigationSubmission = void 0, submission;
}
function isHtmlElement(object) {
  return object != null && typeof object.tagName == "string";
}
function isButtonElement(object) {
  return isHtmlElement(object) && object.tagName.toLowerCase() === "button";
}
function isFormElement(object) {
  return isHtmlElement(object) && object.tagName.toLowerCase() === "form";
}
function isInputElement(object) {
  return isHtmlElement(object) && object.tagName.toLowerCase() === "input";
}
function useBeforeUnload(callback) {
  React2.useEffect(() => (window.addEventListener("beforeunload", callback), () => {
    window.removeEventListener("beforeunload", callback);
  }), [callback]);
}
function useLoaderData() {
  return useRemixRouteContext().data;
}
function useTransition() {
  let {
    transitionManager
  } = useRemixEntryContext();
  return transitionManager.getState().transition;
}
var LiveReload = function({
  port = Number(8002),
  nonce = void 0
}) {
  let js = String.raw;
  return /* @__PURE__ */ React2.createElement("script", {
    nonce,
    suppressHydrationWarning: !0,
    dangerouslySetInnerHTML: {
      __html: js`
                function remixLiveReloadConnect(config) {
                  let protocol = location.protocol === "https:" ? "wss:" : "ws:";
                  let host = location.hostname;
                  let socketPath = protocol + "//" + host + ":" + ${String(port)} + "/socket";

                  let ws = new WebSocket(socketPath);
                  ws.onmessage = (message) => {
                    let event = JSON.parse(message.data);
                    if (event.type === "LOG") {
                      console.log(event.message);
                    }
                    if (event.type === "RELOAD") {
                      console.log(" Reloading window ...");
                      window.location.reload();
                    }
                  };
                  ws.onopen = () => {
                    if (config && typeof config.onOpen === "function") {
                      config.onOpen();
                    }
                  };
                  ws.onclose = (error) => {
                    console.log("Remix dev asset server web socket closed. Reconnecting...");
                    setTimeout(
                      () =>
                        remixLiveReloadConnect({
                          onOpen: () => window.location.reload(),
                        }),
                      1000
                    );
                  };
                  ws.onerror = (error) => {
                    console.log("Remix dev asset server web socket error:");
                    console.error(error);
                  };
                }
                remixLiveReloadConnect();
              `
    }
  });
};

// node_modules/@remix-run/react/dist/esm/index.js
init_react_router_dom();

// node_modules/@remix-run/react/dist/esm/scroll-restoration.js
var React3 = __toESM(require_react());
init_react_router_dom();
var STORAGE_KEY = "positions", positions = {};
if (typeof document < "u") {
  let sessionPositions = sessionStorage.getItem(STORAGE_KEY);
  sessionPositions && (positions = JSON.parse(sessionPositions));
}
function ScrollRestoration({
  nonce = void 0
}) {
  useScrollRestoration(), React3.useEffect(() => {
    window.history.scrollRestoration = "manual";
  }, []), useBeforeUnload(React3.useCallback(() => {
    window.history.scrollRestoration = "auto";
  }, []));
  let restoreScroll = ((STORAGE_KEY2) => {
    if (!window.history.state || !window.history.state.key) {
      let key = Math.random().toString(32).slice(2);
      window.history.replaceState({
        key
      }, "");
    }
    try {
      let storedY = JSON.parse(sessionStorage.getItem(STORAGE_KEY2) || "{}")[window.history.state.key];
      typeof storedY == "number" && window.scrollTo(0, storedY);
    } catch (error) {
      console.error(error), sessionStorage.removeItem(STORAGE_KEY2);
    }
  }).toString();
  return /* @__PURE__ */ React3.createElement("script", {
    nonce,
    suppressHydrationWarning: !0,
    dangerouslySetInnerHTML: {
      __html: `(${restoreScroll})(${JSON.stringify(STORAGE_KEY)})`
    }
  });
}
var hydrated = !1;
function useScrollRestoration() {
  let location = useLocation(), transition = useTransition(), wasSubmissionRef = React3.useRef(!1);
  React3.useEffect(() => {
    transition.submission && (wasSubmissionRef.current = !0);
  }, [transition]), React3.useEffect(() => {
    transition.location && (positions[location.key] = window.scrollY);
  }, [transition, location]), useBeforeUnload(React3.useCallback(() => {
    sessionStorage.setItem(STORAGE_KEY, JSON.stringify(positions));
  }, [])), typeof document < "u" && React3.useLayoutEffect(() => {
    if (!hydrated) {
      hydrated = !0;
      return;
    }
    let y = positions[location.key];
    if (y != null) {
      window.scrollTo(0, y);
      return;
    }
    if (location.hash) {
      let el = document.getElementById(location.hash.slice(1));
      if (el) {
        el.scrollIntoView();
        return;
      }
    }
    if (wasSubmissionRef.current === !0) {
      wasSubmissionRef.current = !1;
      return;
    }
    window.scrollTo(0, 0);
  }, [location]), React3.useEffect(() => {
    transition.submission && (wasSubmissionRef.current = !0);
  }, [transition]);
}

// node_modules/@remix-run/react/dist/esm/server.js
init_history();
var React4 = __toESM(require_react());
function RemixServer({
  context,
  url
}) {
  typeof url == "string" && (url = new URL(url));
  let location = {
    pathname: url.pathname,
    search: url.search,
    hash: "",
    state: null,
    key: "default"
  }, staticNavigator = {
    createHref(to) {
      return typeof to == "string" ? to : createPath(to);
    },
    push(to) {
      throw new Error(`You cannot use navigator.push() on the server because it is a stateless environment. This error was probably triggered when you did a \`navigate(${JSON.stringify(to)})\` somewhere in your app.`);
    },
    replace(to) {
      throw new Error(`You cannot use navigator.replace() on the server because it is a stateless environment. This error was probably triggered when you did a \`navigate(${JSON.stringify(to)}, { replace: true })\` somewhere in your app.`);
    },
    go(delta) {
      throw new Error(`You cannot use navigator.go() on the server because it is a stateless environment. This error was probably triggered when you did a \`navigate(${delta})\` somewhere in your app.`);
    },
    back() {
      throw new Error("You cannot use navigator.back() on the server because it is a stateless environment.");
    },
    forward() {
      throw new Error("You cannot use navigator.forward() on the server because it is a stateless environment.");
    },
    block() {
      throw new Error("You cannot use navigator.block() on the server because it is a stateless environment.");
    }
  };
  return /* @__PURE__ */ React4.createElement(RemixEntry, {
    context,
    action: Action.Pop,
    location,
    navigator: staticNavigator,
    static: !0
  });
}

// app/entry.server.tsx
var import_server3 = __toESM(require_server()), import_jsx_dev_runtime = __toESM(require_jsx_dev_runtime());
function handleRequest(request, responseStatusCode, responseHeaders, remixContext) {
  let markup = (0, import_server3.renderToString)(
    /* @__PURE__ */ (0, import_jsx_dev_runtime.jsxDEV)(RemixServer, {
      context: remixContext,
      url: request.url
    }, void 0, !1, {
      fileName: "app/entry.server.tsx",
      lineNumber: 12,
      columnNumber: 5
    }, this)
  );
  return responseHeaders.set("Content-Type", "text/html"), new Response("<!DOCTYPE html>" + markup, {
    status: responseStatusCode,
    headers: responseHeaders
  });
}

// app/root.tsx
var root_exports = {};
__export(root_exports, {
  default: () => App,
  links: () => links,
  meta: () => meta
});

// app/styles/app.css
var app_default = "/build/_assets/app-YRT4DPKN.css";

// app/root.tsx
var import_jsx_dev_runtime = __toESM(require_jsx_dev_runtime());
function links() {
  return [{ rel: "stylesheet", href: app_default }];
}
var meta = () => ({
  charset: "utf-8",
  title: "Alma",
  viewport: "width=device-width,initial-scale=1"
});
function App() {
  return /* @__PURE__ */ (0, import_jsx_dev_runtime.jsxDEV)("html", {
    lang: "en",
    children: [
      /* @__PURE__ */ (0, import_jsx_dev_runtime.jsxDEV)("head", {
        children: [
          /* @__PURE__ */ (0, import_jsx_dev_runtime.jsxDEV)(Meta, {}, void 0, !1, {
            fileName: "app/root.tsx",
            lineNumber: 26,
            columnNumber: 9
          }, this),
          /* @__PURE__ */ (0, import_jsx_dev_runtime.jsxDEV)(Links, {}, void 0, !1, {
            fileName: "app/root.tsx",
            lineNumber: 27,
            columnNumber: 9
          }, this)
        ]
      }, void 0, !0, {
        fileName: "app/root.tsx",
        lineNumber: 25,
        columnNumber: 7
      }, this),
      /* @__PURE__ */ (0, import_jsx_dev_runtime.jsxDEV)("body", {
        children: [
          /* @__PURE__ */ (0, import_jsx_dev_runtime.jsxDEV)(Outlet, {}, void 0, !1, {
            fileName: "app/root.tsx",
            lineNumber: 30,
            columnNumber: 9
          }, this),
          /* @__PURE__ */ (0, import_jsx_dev_runtime.jsxDEV)(ScrollRestoration, {}, void 0, !1, {
            fileName: "app/root.tsx",
            lineNumber: 31,
            columnNumber: 9
          }, this),
          /* @__PURE__ */ (0, import_jsx_dev_runtime.jsxDEV)(Scripts, {}, void 0, !1, {
            fileName: "app/root.tsx",
            lineNumber: 32,
            columnNumber: 9
          }, this),
          /* @__PURE__ */ (0, import_jsx_dev_runtime.jsxDEV)(LiveReload, {}, void 0, !1, {
            fileName: "app/root.tsx",
            lineNumber: 33,
            columnNumber: 9
          }, this)
        ]
      }, void 0, !0, {
        fileName: "app/root.tsx",
        lineNumber: 29,
        columnNumber: 7
      }, this)
    ]
  }, void 0, !0, {
    fileName: "app/root.tsx",
    lineNumber: 24,
    columnNumber: 5
  }, this);
}

// app/routes/about.tsx
var about_exports = {};
__export(about_exports, {
  default: () => Index
});

// node_modules/@mui/material/esm/Button/Button.js
init_objectWithoutPropertiesLoose();
init_extends();
var React32 = __toESM(require_react()), import_prop_types16 = __toESM(require_prop_types());
init_clsx_m();
init_esm2();
init_base();
init_esm3();
init_styled();
init_useThemeProps3();

// node_modules/@mui/material/esm/ButtonBase/ButtonBase.js
init_extends();
init_objectWithoutPropertiesLoose();
var React30 = __toESM(require_react()), import_prop_types15 = __toESM(require_prop_types());
init_clsx_m();
init_esm2();
init_composeClasses3();
init_styled();
init_useThemeProps3();
init_useForkRef2();
init_useEventCallback2();
init_useIsFocusVisible2();

// node_modules/@mui/material/esm/ButtonBase/TouchRipple.js
init_extends();
init_objectWithoutPropertiesLoose();
var React29 = __toESM(require_react()), import_prop_types14 = __toESM(require_prop_types());

// node_modules/@babel/runtime/helpers/esm/setPrototypeOf.js
function _setPrototypeOf(o, p) {
  return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(o2, p2) {
    return o2.__proto__ = p2, o2;
  }, _setPrototypeOf(o, p);
}

// node_modules/@babel/runtime/helpers/esm/inheritsLoose.js
function _inheritsLoose(subClass, superClass) {
  subClass.prototype = Object.create(superClass.prototype), subClass.prototype.constructor = subClass, _setPrototypeOf(subClass, superClass);
}

// node_modules/react-transition-group/esm/Transition.js
init_objectWithoutPropertiesLoose();
var import_prop_types11 = __toESM(require_prop_types()), import_react10 = __toESM(require_react()), import_react_dom2 = __toESM(require_react_dom());

// node_modules/react-transition-group/esm/config.js
var config_default = {
  disabled: !1
};

// node_modules/react-transition-group/esm/utils/PropTypes.js
var import_prop_types10 = __toESM(require_prop_types()), timeoutsShape = import_prop_types10.default.oneOfType([import_prop_types10.default.number, import_prop_types10.default.shape({
  enter: import_prop_types10.default.number,
  exit: import_prop_types10.default.number,
  appear: import_prop_types10.default.number
}).isRequired]), classNamesShape = import_prop_types10.default.oneOfType([import_prop_types10.default.string, import_prop_types10.default.shape({
  enter: import_prop_types10.default.string,
  exit: import_prop_types10.default.string,
  active: import_prop_types10.default.string
}), import_prop_types10.default.shape({
  enter: import_prop_types10.default.string,
  enterDone: import_prop_types10.default.string,
  enterActive: import_prop_types10.default.string,
  exit: import_prop_types10.default.string,
  exitDone: import_prop_types10.default.string,
  exitActive: import_prop_types10.default.string
})]);

// node_modules/react-transition-group/esm/TransitionGroupContext.js
var import_react9 = __toESM(require_react()), TransitionGroupContext_default = import_react9.default.createContext(null);

// node_modules/react-transition-group/esm/utils/reflow.js
var forceReflow = function(node) {
  return node.scrollTop;
};

// node_modules/react-transition-group/esm/Transition.js
var UNMOUNTED = "unmounted", EXITED = "exited", ENTERING = "entering", ENTERED = "entered", EXITING = "exiting", Transition = /* @__PURE__ */ function(_React$Component) {
  _inheritsLoose(Transition2, _React$Component);
  function Transition2(props, context) {
    var _this;
    _this = _React$Component.call(this, props, context) || this;
    var parentGroup = context, appear = parentGroup && !parentGroup.isMounting ? props.enter : props.appear, initialStatus;
    return _this.appearStatus = null, props.in ? appear ? (initialStatus = EXITED, _this.appearStatus = ENTERING) : initialStatus = ENTERED : props.unmountOnExit || props.mountOnEnter ? initialStatus = UNMOUNTED : initialStatus = EXITED, _this.state = {
      status: initialStatus
    }, _this.nextCallback = null, _this;
  }
  Transition2.getDerivedStateFromProps = function(_ref, prevState) {
    var nextIn = _ref.in;
    return nextIn && prevState.status === UNMOUNTED ? {
      status: EXITED
    } : null;
  };
  var _proto = Transition2.prototype;
  return _proto.componentDidMount = function() {
    this.updateStatus(!0, this.appearStatus);
  }, _proto.componentDidUpdate = function(prevProps) {
    var nextStatus = null;
    if (prevProps !== this.props) {
      var status = this.state.status;
      this.props.in ? status !== ENTERING && status !== ENTERED && (nextStatus = ENTERING) : (status === ENTERING || status === ENTERED) && (nextStatus = EXITING);
    }
    this.updateStatus(!1, nextStatus);
  }, _proto.componentWillUnmount = function() {
    this.cancelNextCallback();
  }, _proto.getTimeouts = function() {
    var timeout2 = this.props.timeout, exit, enter, appear;
    return exit = enter = appear = timeout2, timeout2 != null && typeof timeout2 != "number" && (exit = timeout2.exit, enter = timeout2.enter, appear = timeout2.appear !== void 0 ? timeout2.appear : enter), {
      exit,
      enter,
      appear
    };
  }, _proto.updateStatus = function(mounting, nextStatus) {
    if (mounting === void 0 && (mounting = !1), nextStatus !== null)
      if (this.cancelNextCallback(), nextStatus === ENTERING) {
        if (this.props.unmountOnExit || this.props.mountOnEnter) {
          var node = this.props.nodeRef ? this.props.nodeRef.current : import_react_dom2.default.findDOMNode(this);
          node && forceReflow(node);
        }
        this.performEnter(mounting);
      } else
        this.performExit();
    else
      this.props.unmountOnExit && this.state.status === EXITED && this.setState({
        status: UNMOUNTED
      });
  }, _proto.performEnter = function(mounting) {
    var _this2 = this, enter = this.props.enter, appearing = this.context ? this.context.isMounting : mounting, _ref2 = this.props.nodeRef ? [appearing] : [import_react_dom2.default.findDOMNode(this), appearing], maybeNode = _ref2[0], maybeAppearing = _ref2[1], timeouts = this.getTimeouts(), enterTimeout = appearing ? timeouts.appear : timeouts.enter;
    if (!mounting && !enter || config_default.disabled) {
      this.safeSetState({
        status: ENTERED
      }, function() {
        _this2.props.onEntered(maybeNode);
      });
      return;
    }
    this.props.onEnter(maybeNode, maybeAppearing), this.safeSetState({
      status: ENTERING
    }, function() {
      _this2.props.onEntering(maybeNode, maybeAppearing), _this2.onTransitionEnd(enterTimeout, function() {
        _this2.safeSetState({
          status: ENTERED
        }, function() {
          _this2.props.onEntered(maybeNode, maybeAppearing);
        });
      });
    });
  }, _proto.performExit = function() {
    var _this3 = this, exit = this.props.exit, timeouts = this.getTimeouts(), maybeNode = this.props.nodeRef ? void 0 : import_react_dom2.default.findDOMNode(this);
    if (!exit || config_default.disabled) {
      this.safeSetState({
        status: EXITED
      }, function() {
        _this3.props.onExited(maybeNode);
      });
      return;
    }
    this.props.onExit(maybeNode), this.safeSetState({
      status: EXITING
    }, function() {
      _this3.props.onExiting(maybeNode), _this3.onTransitionEnd(timeouts.exit, function() {
        _this3.safeSetState({
          status: EXITED
        }, function() {
          _this3.props.onExited(maybeNode);
        });
      });
    });
  }, _proto.cancelNextCallback = function() {
    this.nextCallback !== null && (this.nextCallback.cancel(), this.nextCallback = null);
  }, _proto.safeSetState = function(nextState, callback) {
    callback = this.setNextCallback(callback), this.setState(nextState, callback);
  }, _proto.setNextCallback = function(callback) {
    var _this4 = this, active = !0;
    return this.nextCallback = function(event) {
      active && (active = !1, _this4.nextCallback = null, callback(event));
    }, this.nextCallback.cancel = function() {
      active = !1;
    }, this.nextCallback;
  }, _proto.onTransitionEnd = function(timeout2, handler) {
    this.setNextCallback(handler);
    var node = this.props.nodeRef ? this.props.nodeRef.current : import_react_dom2.default.findDOMNode(this), doesNotHaveTimeoutOrListener = timeout2 == null && !this.props.addEndListener;
    if (!node || doesNotHaveTimeoutOrListener) {
      setTimeout(this.nextCallback, 0);
      return;
    }
    if (this.props.addEndListener) {
      var _ref3 = this.props.nodeRef ? [this.nextCallback] : [node, this.nextCallback], maybeNode = _ref3[0], maybeNextCallback = _ref3[1];
      this.props.addEndListener(maybeNode, maybeNextCallback);
    }
    timeout2 != null && setTimeout(this.nextCallback, timeout2);
  }, _proto.render = function() {
    var status = this.state.status;
    if (status === UNMOUNTED)
      return null;
    var _this$props = this.props, children = _this$props.children, _in = _this$props.in, _mountOnEnter = _this$props.mountOnEnter, _unmountOnExit = _this$props.unmountOnExit, _appear = _this$props.appear, _enter = _this$props.enter, _exit = _this$props.exit, _timeout = _this$props.timeout, _addEndListener = _this$props.addEndListener, _onEnter = _this$props.onEnter, _onEntering = _this$props.onEntering, _onEntered = _this$props.onEntered, _onExit = _this$props.onExit, _onExiting = _this$props.onExiting, _onExited = _this$props.onExited, _nodeRef = _this$props.nodeRef, childProps = _objectWithoutPropertiesLoose2(_this$props, ["children", "in", "mountOnEnter", "unmountOnExit", "appear", "enter", "exit", "timeout", "addEndListener", "onEnter", "onEntering", "onEntered", "onExit", "onExiting", "onExited", "nodeRef"]);
    return /* @__PURE__ */ import_react10.default.createElement(TransitionGroupContext_default.Provider, {
      value: null
    }, typeof children == "function" ? children(status, childProps) : import_react10.default.cloneElement(import_react10.default.Children.only(children), childProps));
  }, Transition2;
}(import_react10.default.Component);
Transition.contextType = TransitionGroupContext_default;
Transition.propTypes = {
  nodeRef: import_prop_types11.default.shape({
    current: typeof Element > "u" ? import_prop_types11.default.any : function(propValue, key, componentName, location, propFullName, secret) {
      var value = propValue[key];
      return import_prop_types11.default.instanceOf(value && "ownerDocument" in value ? value.ownerDocument.defaultView.Element : Element)(propValue, key, componentName, location, propFullName, secret);
    }
  }),
  children: import_prop_types11.default.oneOfType([import_prop_types11.default.func.isRequired, import_prop_types11.default.element.isRequired]).isRequired,
  in: import_prop_types11.default.bool,
  mountOnEnter: import_prop_types11.default.bool,
  unmountOnExit: import_prop_types11.default.bool,
  appear: import_prop_types11.default.bool,
  enter: import_prop_types11.default.bool,
  exit: import_prop_types11.default.bool,
  timeout: function(props) {
    var pt = timeoutsShape;
    props.addEndListener || (pt = pt.isRequired);
    for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++)
      args[_key - 1] = arguments[_key];
    return pt.apply(void 0, [props].concat(args));
  },
  addEndListener: import_prop_types11.default.func,
  onEnter: import_prop_types11.default.func,
  onEntering: import_prop_types11.default.func,
  onEntered: import_prop_types11.default.func,
  onExit: import_prop_types11.default.func,
  onExiting: import_prop_types11.default.func,
  onExited: import_prop_types11.default.func
};
function noop2() {
}
Transition.defaultProps = {
  in: !1,
  mountOnEnter: !1,
  unmountOnExit: !1,
  appear: !1,
  enter: !0,
  exit: !0,
  onEnter: noop2,
  onEntering: noop2,
  onEntered: noop2,
  onExit: noop2,
  onExiting: noop2,
  onExited: noop2
};
Transition.UNMOUNTED = UNMOUNTED;
Transition.EXITED = EXITED;
Transition.ENTERING = ENTERING;
Transition.ENTERED = ENTERED;
Transition.EXITING = EXITING;
var Transition_default = Transition;

// node_modules/react-transition-group/esm/TransitionGroup.js
init_objectWithoutPropertiesLoose();
init_extends();

// node_modules/@babel/runtime/helpers/esm/assertThisInitialized.js
function _assertThisInitialized(self2) {
  if (self2 === void 0)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return self2;
}

// node_modules/react-transition-group/esm/TransitionGroup.js
var import_prop_types12 = __toESM(require_prop_types()), import_react12 = __toESM(require_react());

// node_modules/react-transition-group/esm/utils/ChildMapping.js
var import_react11 = __toESM(require_react());
function getChildMapping(children, mapFn) {
  var mapper = function(child) {
    return mapFn && (0, import_react11.isValidElement)(child) ? mapFn(child) : child;
  }, result = /* @__PURE__ */ Object.create(null);
  return children && import_react11.Children.map(children, function(c) {
    return c;
  }).forEach(function(child) {
    result[child.key] = mapper(child);
  }), result;
}
function mergeChildMappings(prev, next) {
  prev = prev || {}, next = next || {};
  function getValueForKey(key) {
    return key in next ? next[key] : prev[key];
  }
  var nextKeysPending = /* @__PURE__ */ Object.create(null), pendingKeys = [];
  for (var prevKey in prev)
    prevKey in next ? pendingKeys.length && (nextKeysPending[prevKey] = pendingKeys, pendingKeys = []) : pendingKeys.push(prevKey);
  var i, childMapping = {};
  for (var nextKey in next) {
    if (nextKeysPending[nextKey])
      for (i = 0; i < nextKeysPending[nextKey].length; i++) {
        var pendingNextKey = nextKeysPending[nextKey][i];
        childMapping[nextKeysPending[nextKey][i]] = getValueForKey(pendingNextKey);
      }
    childMapping[nextKey] = getValueForKey(nextKey);
  }
  for (i = 0; i < pendingKeys.length; i++)
    childMapping[pendingKeys[i]] = getValueForKey(pendingKeys[i]);
  return childMapping;
}
function getProp(child, prop, props) {
  return props[prop] != null ? props[prop] : child.props[prop];
}
function getInitialChildMapping(props, onExited) {
  return getChildMapping(props.children, function(child) {
    return (0, import_react11.cloneElement)(child, {
      onExited: onExited.bind(null, child),
      in: !0,
      appear: getProp(child, "appear", props),
      enter: getProp(child, "enter", props),
      exit: getProp(child, "exit", props)
    });
  });
}
function getNextChildMapping(nextProps, prevChildMapping, onExited) {
  var nextChildMapping = getChildMapping(nextProps.children), children = mergeChildMappings(prevChildMapping, nextChildMapping);
  return Object.keys(children).forEach(function(key) {
    var child = children[key];
    if (!!(0, import_react11.isValidElement)(child)) {
      var hasPrev = key in prevChildMapping, hasNext = key in nextChildMapping, prevChild = prevChildMapping[key], isLeaving = (0, import_react11.isValidElement)(prevChild) && !prevChild.props.in;
      hasNext && (!hasPrev || isLeaving) ? children[key] = (0, import_react11.cloneElement)(child, {
        onExited: onExited.bind(null, child),
        in: !0,
        exit: getProp(child, "exit", nextProps),
        enter: getProp(child, "enter", nextProps)
      }) : !hasNext && hasPrev && !isLeaving ? children[key] = (0, import_react11.cloneElement)(child, {
        in: !1
      }) : hasNext && hasPrev && (0, import_react11.isValidElement)(prevChild) && (children[key] = (0, import_react11.cloneElement)(child, {
        onExited: onExited.bind(null, child),
        in: prevChild.props.in,
        exit: getProp(child, "exit", nextProps),
        enter: getProp(child, "enter", nextProps)
      }));
    }
  }), children;
}

// node_modules/react-transition-group/esm/TransitionGroup.js
var values2 = Object.values || function(obj) {
  return Object.keys(obj).map(function(k) {
    return obj[k];
  });
}, defaultProps = {
  component: "div",
  childFactory: function(child) {
    return child;
  }
}, TransitionGroup = /* @__PURE__ */ function(_React$Component) {
  _inheritsLoose(TransitionGroup2, _React$Component);
  function TransitionGroup2(props, context) {
    var _this;
    _this = _React$Component.call(this, props, context) || this;
    var handleExited = _this.handleExited.bind(_assertThisInitialized(_this));
    return _this.state = {
      contextValue: {
        isMounting: !0
      },
      handleExited,
      firstRender: !0
    }, _this;
  }
  var _proto = TransitionGroup2.prototype;
  return _proto.componentDidMount = function() {
    this.mounted = !0, this.setState({
      contextValue: {
        isMounting: !1
      }
    });
  }, _proto.componentWillUnmount = function() {
    this.mounted = !1;
  }, TransitionGroup2.getDerivedStateFromProps = function(nextProps, _ref) {
    var prevChildMapping = _ref.children, handleExited = _ref.handleExited, firstRender = _ref.firstRender;
    return {
      children: firstRender ? getInitialChildMapping(nextProps, handleExited) : getNextChildMapping(nextProps, prevChildMapping, handleExited),
      firstRender: !1
    };
  }, _proto.handleExited = function(child, node) {
    var currentChildMapping = getChildMapping(this.props.children);
    child.key in currentChildMapping || (child.props.onExited && child.props.onExited(node), this.mounted && this.setState(function(state) {
      var children = _extends({}, state.children);
      return delete children[child.key], {
        children
      };
    }));
  }, _proto.render = function() {
    var _this$props = this.props, Component = _this$props.component, childFactory2 = _this$props.childFactory, props = _objectWithoutPropertiesLoose2(_this$props, ["component", "childFactory"]), contextValue = this.state.contextValue, children = values2(this.state.children).map(childFactory2);
    return delete props.appear, delete props.enter, delete props.exit, Component === null ? /* @__PURE__ */ import_react12.default.createElement(TransitionGroupContext_default.Provider, {
      value: contextValue
    }, children) : /* @__PURE__ */ import_react12.default.createElement(TransitionGroupContext_default.Provider, {
      value: contextValue
    }, /* @__PURE__ */ import_react12.default.createElement(Component, props, children));
  }, TransitionGroup2;
}(import_react12.default.Component);
TransitionGroup.propTypes = {
  component: import_prop_types12.default.any,
  children: import_prop_types12.default.node,
  appear: import_prop_types12.default.bool,
  enter: import_prop_types12.default.bool,
  exit: import_prop_types12.default.bool,
  childFactory: import_prop_types12.default.func
};
TransitionGroup.defaultProps = defaultProps;
var TransitionGroup_default = TransitionGroup;

// node_modules/@mui/material/esm/ButtonBase/TouchRipple.js
init_clsx_m();
init_esm3();
init_styled();
init_useThemeProps3();

// node_modules/@mui/material/esm/ButtonBase/Ripple.js
var React28 = __toESM(require_react()), import_prop_types13 = __toESM(require_prop_types());
init_clsx_m();
var import_jsx_runtime10 = __toESM(require_jsx_runtime());
function Ripple(props) {
  let {
    className,
    classes,
    pulsate = !1,
    rippleX,
    rippleY,
    rippleSize,
    in: inProp,
    onExited,
    timeout: timeout2
  } = props, [leaving, setLeaving] = React28.useState(!1), rippleClassName = clsx_m_default(className, classes.ripple, classes.rippleVisible, pulsate && classes.ripplePulsate), rippleStyles = {
    width: rippleSize,
    height: rippleSize,
    top: -(rippleSize / 2) + rippleY,
    left: -(rippleSize / 2) + rippleX
  }, childClassName = clsx_m_default(classes.child, leaving && classes.childLeaving, pulsate && classes.childPulsate);
  return !inProp && !leaving && setLeaving(!0), React28.useEffect(() => {
    if (!inProp && onExited != null) {
      let timeoutId = setTimeout(onExited, timeout2);
      return () => {
        clearTimeout(timeoutId);
      };
    }
  }, [onExited, inProp, timeout2]), /* @__PURE__ */ (0, import_jsx_runtime10.jsx)("span", {
    className: rippleClassName,
    style: rippleStyles,
    children: /* @__PURE__ */ (0, import_jsx_runtime10.jsx)("span", {
      className: childClassName
    })
  });
}
Ripple.propTypes = {
  classes: import_prop_types13.default.object.isRequired,
  className: import_prop_types13.default.string,
  in: import_prop_types13.default.bool,
  onExited: import_prop_types13.default.func,
  pulsate: import_prop_types13.default.bool,
  rippleSize: import_prop_types13.default.number,
  rippleX: import_prop_types13.default.number,
  rippleY: import_prop_types13.default.number,
  timeout: import_prop_types13.default.number.isRequired
};
var Ripple_default = Ripple;

// node_modules/@mui/material/esm/ButtonBase/touchRippleClasses.js
init_base();
var touchRippleClasses = generateUtilityClasses("MuiTouchRipple", ["root", "ripple", "rippleVisible", "ripplePulsate", "child", "childLeaving", "childPulsate"]), touchRippleClasses_default = touchRippleClasses;

// node_modules/@mui/material/esm/ButtonBase/TouchRipple.js
var import_jsx_runtime11 = __toESM(require_jsx_runtime()), _excluded16 = ["center", "classes", "className"], _ = (t) => t, _t, _t2, _t3, _t4, DURATION = 550, DELAY_RIPPLE = 80, enterKeyframe = (0, import_react8.keyframes)(_t || (_t = _`
  0% {
    transform: scale(0);
    opacity: 0.1;
  }

  100% {
    transform: scale(1);
    opacity: 0.3;
  }
`)), exitKeyframe = (0, import_react8.keyframes)(_t2 || (_t2 = _`
  0% {
    opacity: 1;
  }

  100% {
    opacity: 0;
  }
`)), pulsateKeyframe = (0, import_react8.keyframes)(_t3 || (_t3 = _`
  0% {
    transform: scale(1);
  }

  50% {
    transform: scale(0.92);
  }

  100% {
    transform: scale(1);
  }
`)), TouchRippleRoot = styled_default("span", {
  name: "MuiTouchRipple",
  slot: "Root"
})({
  overflow: "hidden",
  pointerEvents: "none",
  position: "absolute",
  zIndex: 0,
  top: 0,
  right: 0,
  bottom: 0,
  left: 0,
  borderRadius: "inherit"
}), TouchRippleRipple = styled_default(Ripple_default, {
  name: "MuiTouchRipple",
  slot: "Ripple"
})(_t4 || (_t4 = _`
  opacity: 0;
  position: absolute;

  &.${0} {
    opacity: 0.3;
    transform: scale(1);
    animation-name: ${0};
    animation-duration: ${0}ms;
    animation-timing-function: ${0};
  }

  &.${0} {
    animation-duration: ${0}ms;
  }

  & .${0} {
    opacity: 1;
    display: block;
    width: 100%;
    height: 100%;
    border-radius: 50%;
    background-color: currentColor;
  }

  & .${0} {
    opacity: 0;
    animation-name: ${0};
    animation-duration: ${0}ms;
    animation-timing-function: ${0};
  }

  & .${0} {
    position: absolute;
    /* @noflip */
    left: 0px;
    top: 0;
    animation-name: ${0};
    animation-duration: 2500ms;
    animation-timing-function: ${0};
    animation-iteration-count: infinite;
    animation-delay: 200ms;
  }
`), touchRippleClasses_default.rippleVisible, enterKeyframe, DURATION, ({
  theme
}) => theme.transitions.easing.easeInOut, touchRippleClasses_default.ripplePulsate, ({
  theme
}) => theme.transitions.duration.shorter, touchRippleClasses_default.child, touchRippleClasses_default.childLeaving, exitKeyframe, DURATION, ({
  theme
}) => theme.transitions.easing.easeInOut, touchRippleClasses_default.childPulsate, pulsateKeyframe, ({
  theme
}) => theme.transitions.easing.easeInOut), TouchRipple = /* @__PURE__ */ React29.forwardRef(function(inProps, ref) {
  let props = useThemeProps2({
    props: inProps,
    name: "MuiTouchRipple"
  }), {
    center: centerProp = !1,
    classes = {},
    className
  } = props, other = _objectWithoutPropertiesLoose2(props, _excluded16), [ripples, setRipples] = React29.useState([]), nextKey = React29.useRef(0), rippleCallback = React29.useRef(null);
  React29.useEffect(() => {
    rippleCallback.current && (rippleCallback.current(), rippleCallback.current = null);
  }, [ripples]);
  let ignoringMouseDown = React29.useRef(!1), startTimer = React29.useRef(null), startTimerCommit = React29.useRef(null), container = React29.useRef(null);
  React29.useEffect(() => () => {
    clearTimeout(startTimer.current);
  }, []);
  let startCommit = React29.useCallback((params) => {
    let {
      pulsate: pulsate2,
      rippleX,
      rippleY,
      rippleSize,
      cb
    } = params;
    setRipples((oldRipples) => [...oldRipples, /* @__PURE__ */ (0, import_jsx_runtime11.jsx)(TouchRippleRipple, {
      classes: {
        ripple: clsx_m_default(classes.ripple, touchRippleClasses_default.ripple),
        rippleVisible: clsx_m_default(classes.rippleVisible, touchRippleClasses_default.rippleVisible),
        ripplePulsate: clsx_m_default(classes.ripplePulsate, touchRippleClasses_default.ripplePulsate),
        child: clsx_m_default(classes.child, touchRippleClasses_default.child),
        childLeaving: clsx_m_default(classes.childLeaving, touchRippleClasses_default.childLeaving),
        childPulsate: clsx_m_default(classes.childPulsate, touchRippleClasses_default.childPulsate)
      },
      timeout: DURATION,
      pulsate: pulsate2,
      rippleX,
      rippleY,
      rippleSize
    }, nextKey.current)]), nextKey.current += 1, rippleCallback.current = cb;
  }, [classes]), start = React29.useCallback((event = {}, options = {}, cb) => {
    let {
      pulsate: pulsate2 = !1,
      center = centerProp || options.pulsate,
      fakeElement = !1
    } = options;
    if ((event == null ? void 0 : event.type) === "mousedown" && ignoringMouseDown.current) {
      ignoringMouseDown.current = !1;
      return;
    }
    (event == null ? void 0 : event.type) === "touchstart" && (ignoringMouseDown.current = !0);
    let element = fakeElement ? null : container.current, rect = element ? element.getBoundingClientRect() : {
      width: 0,
      height: 0,
      left: 0,
      top: 0
    }, rippleX, rippleY, rippleSize;
    if (center || event === void 0 || event.clientX === 0 && event.clientY === 0 || !event.clientX && !event.touches)
      rippleX = Math.round(rect.width / 2), rippleY = Math.round(rect.height / 2);
    else {
      let {
        clientX,
        clientY
      } = event.touches && event.touches.length > 0 ? event.touches[0] : event;
      rippleX = Math.round(clientX - rect.left), rippleY = Math.round(clientY - rect.top);
    }
    if (center)
      rippleSize = Math.sqrt((2 * rect.width ** 2 + rect.height ** 2) / 3), rippleSize % 2 === 0 && (rippleSize += 1);
    else {
      let sizeX = Math.max(Math.abs((element ? element.clientWidth : 0) - rippleX), rippleX) * 2 + 2, sizeY = Math.max(Math.abs((element ? element.clientHeight : 0) - rippleY), rippleY) * 2 + 2;
      rippleSize = Math.sqrt(sizeX ** 2 + sizeY ** 2);
    }
    event != null && event.touches ? startTimerCommit.current === null && (startTimerCommit.current = () => {
      startCommit({
        pulsate: pulsate2,
        rippleX,
        rippleY,
        rippleSize,
        cb
      });
    }, startTimer.current = setTimeout(() => {
      startTimerCommit.current && (startTimerCommit.current(), startTimerCommit.current = null);
    }, DELAY_RIPPLE)) : startCommit({
      pulsate: pulsate2,
      rippleX,
      rippleY,
      rippleSize,
      cb
    });
  }, [centerProp, startCommit]), pulsate = React29.useCallback(() => {
    start({}, {
      pulsate: !0
    });
  }, [start]), stop = React29.useCallback((event, cb) => {
    if (clearTimeout(startTimer.current), (event == null ? void 0 : event.type) === "touchend" && startTimerCommit.current) {
      startTimerCommit.current(), startTimerCommit.current = null, startTimer.current = setTimeout(() => {
        stop(event, cb);
      });
      return;
    }
    startTimerCommit.current = null, setRipples((oldRipples) => oldRipples.length > 0 ? oldRipples.slice(1) : oldRipples), rippleCallback.current = cb;
  }, []);
  return React29.useImperativeHandle(ref, () => ({
    pulsate,
    start,
    stop
  }), [pulsate, start, stop]), /* @__PURE__ */ (0, import_jsx_runtime11.jsx)(TouchRippleRoot, _extends({
    className: clsx_m_default(touchRippleClasses_default.root, classes.root, className),
    ref: container
  }, other, {
    children: /* @__PURE__ */ (0, import_jsx_runtime11.jsx)(TransitionGroup_default, {
      component: null,
      exit: !0,
      children: ripples
    })
  }));
});
TouchRipple.propTypes = {
  center: import_prop_types14.default.bool,
  classes: import_prop_types14.default.object,
  className: import_prop_types14.default.string
};
var TouchRipple_default = TouchRipple;

// node_modules/@mui/material/esm/ButtonBase/buttonBaseClasses.js
init_base();
function getButtonBaseUtilityClass(slot) {
  return generateUtilityClass("MuiButtonBase", slot);
}
var buttonBaseClasses = generateUtilityClasses("MuiButtonBase", ["root", "disabled", "focusVisible"]), buttonBaseClasses_default = buttonBaseClasses;

// node_modules/@mui/material/esm/ButtonBase/ButtonBase.js
var import_jsx_runtime12 = __toESM(require_jsx_runtime()), import_jsx_runtime13 = __toESM(require_jsx_runtime()), _excluded17 = ["action", "centerRipple", "children", "className", "component", "disabled", "disableRipple", "disableTouchRipple", "focusRipple", "focusVisibleClassName", "LinkComponent", "onBlur", "onClick", "onContextMenu", "onDragLeave", "onFocus", "onFocusVisible", "onKeyDown", "onKeyUp", "onMouseDown", "onMouseLeave", "onMouseUp", "onTouchEnd", "onTouchMove", "onTouchStart", "tabIndex", "TouchRippleProps", "touchRippleRef", "type"], useUtilityClasses2 = (ownerState) => {
  let {
    disabled,
    focusVisible,
    focusVisibleClassName,
    classes
  } = ownerState, composedClasses = composeClasses({
    root: ["root", disabled && "disabled", focusVisible && "focusVisible"]
  }, getButtonBaseUtilityClass, classes);
  return focusVisible && focusVisibleClassName && (composedClasses.root += ` ${focusVisibleClassName}`), composedClasses;
}, ButtonBaseRoot = styled_default("button", {
  name: "MuiButtonBase",
  slot: "Root",
  overridesResolver: (props, styles4) => styles4.root
})({
  display: "inline-flex",
  alignItems: "center",
  justifyContent: "center",
  position: "relative",
  boxSizing: "border-box",
  WebkitTapHighlightColor: "transparent",
  backgroundColor: "transparent",
  outline: 0,
  border: 0,
  margin: 0,
  borderRadius: 0,
  padding: 0,
  cursor: "pointer",
  userSelect: "none",
  verticalAlign: "middle",
  MozAppearance: "none",
  WebkitAppearance: "none",
  textDecoration: "none",
  color: "inherit",
  "&::-moz-focus-inner": {
    borderStyle: "none"
  },
  [`&.${buttonBaseClasses_default.disabled}`]: {
    pointerEvents: "none",
    cursor: "default"
  },
  "@media print": {
    colorAdjust: "exact"
  }
}), ButtonBase = /* @__PURE__ */ React30.forwardRef(function(inProps, ref) {
  let props = useThemeProps2({
    props: inProps,
    name: "MuiButtonBase"
  }), {
    action,
    centerRipple = !1,
    children,
    className,
    component = "button",
    disabled = !1,
    disableRipple = !1,
    disableTouchRipple = !1,
    focusRipple = !1,
    LinkComponent = "a",
    onBlur,
    onClick,
    onContextMenu,
    onDragLeave,
    onFocus,
    onFocusVisible,
    onKeyDown,
    onKeyUp,
    onMouseDown,
    onMouseLeave,
    onMouseUp,
    onTouchEnd,
    onTouchMove,
    onTouchStart,
    tabIndex = 0,
    TouchRippleProps,
    touchRippleRef,
    type
  } = props, other = _objectWithoutPropertiesLoose2(props, _excluded17), buttonRef = React30.useRef(null), rippleRef = React30.useRef(null), handleRippleRef = useForkRef_default(rippleRef, touchRippleRef), {
    isFocusVisibleRef,
    onFocus: handleFocusVisible,
    onBlur: handleBlurVisible,
    ref: focusVisibleRef
  } = useIsFocusVisible_default(), [focusVisible, setFocusVisible] = React30.useState(!1);
  disabled && focusVisible && setFocusVisible(!1), React30.useImperativeHandle(action, () => ({
    focusVisible: () => {
      setFocusVisible(!0), buttonRef.current.focus();
    }
  }), []);
  let [mountedState, setMountedState] = React30.useState(!1);
  React30.useEffect(() => {
    setMountedState(!0);
  }, []);
  let enableTouchRipple = mountedState && !disableRipple && !disabled;
  React30.useEffect(() => {
    focusVisible && focusRipple && !disableRipple && mountedState && rippleRef.current.pulsate();
  }, [disableRipple, focusRipple, focusVisible, mountedState]);
  function useRippleHandler(rippleAction, eventCallback, skipRippleAction = disableTouchRipple) {
    return useEventCallback_default((event) => (eventCallback && eventCallback(event), !skipRippleAction && rippleRef.current && rippleRef.current[rippleAction](event), !0));
  }
  let handleMouseDown = useRippleHandler("start", onMouseDown), handleContextMenu = useRippleHandler("stop", onContextMenu), handleDragLeave = useRippleHandler("stop", onDragLeave), handleMouseUp = useRippleHandler("stop", onMouseUp), handleMouseLeave = useRippleHandler("stop", (event) => {
    focusVisible && event.preventDefault(), onMouseLeave && onMouseLeave(event);
  }), handleTouchStart = useRippleHandler("start", onTouchStart), handleTouchEnd = useRippleHandler("stop", onTouchEnd), handleTouchMove = useRippleHandler("stop", onTouchMove), handleBlur = useRippleHandler("stop", (event) => {
    handleBlurVisible(event), isFocusVisibleRef.current === !1 && setFocusVisible(!1), onBlur && onBlur(event);
  }, !1), handleFocus = useEventCallback_default((event) => {
    buttonRef.current || (buttonRef.current = event.currentTarget), handleFocusVisible(event), isFocusVisibleRef.current === !0 && (setFocusVisible(!0), onFocusVisible && onFocusVisible(event)), onFocus && onFocus(event);
  }), isNonNativeButton = () => {
    let button = buttonRef.current;
    return component && component !== "button" && !(button.tagName === "A" && button.href);
  }, keydownRef = React30.useRef(!1), handleKeyDown2 = useEventCallback_default((event) => {
    focusRipple && !keydownRef.current && focusVisible && rippleRef.current && event.key === " " && (keydownRef.current = !0, rippleRef.current.stop(event, () => {
      rippleRef.current.start(event);
    })), event.target === event.currentTarget && isNonNativeButton() && event.key === " " && event.preventDefault(), onKeyDown && onKeyDown(event), event.target === event.currentTarget && isNonNativeButton() && event.key === "Enter" && !disabled && (event.preventDefault(), onClick && onClick(event));
  }), handleKeyUp = useEventCallback_default((event) => {
    focusRipple && event.key === " " && rippleRef.current && focusVisible && !event.defaultPrevented && (keydownRef.current = !1, rippleRef.current.stop(event, () => {
      rippleRef.current.pulsate(event);
    })), onKeyUp && onKeyUp(event), onClick && event.target === event.currentTarget && isNonNativeButton() && event.key === " " && !event.defaultPrevented && onClick(event);
  }), ComponentProp = component;
  ComponentProp === "button" && (other.href || other.to) && (ComponentProp = LinkComponent);
  let buttonProps = {};
  ComponentProp === "button" ? (buttonProps.type = type === void 0 ? "button" : type, buttonProps.disabled = disabled) : (!other.href && !other.to && (buttonProps.role = "button"), disabled && (buttonProps["aria-disabled"] = disabled));
  let handleOwnRef = useForkRef_default(focusVisibleRef, buttonRef), handleRef = useForkRef_default(ref, handleOwnRef);
  React30.useEffect(() => {
    enableTouchRipple && !rippleRef.current && console.error(["MUI: The `component` prop provided to ButtonBase is invalid.", "Please make sure the children prop is rendered in this custom component."].join(`
`));
  }, [enableTouchRipple]);
  let ownerState = _extends({}, props, {
    centerRipple,
    component,
    disabled,
    disableRipple,
    disableTouchRipple,
    focusRipple,
    tabIndex,
    focusVisible
  }), classes = useUtilityClasses2(ownerState);
  return /* @__PURE__ */ (0, import_jsx_runtime13.jsxs)(ButtonBaseRoot, _extends({
    as: ComponentProp,
    className: clsx_m_default(classes.root, className),
    ownerState,
    onBlur: handleBlur,
    onClick,
    onContextMenu: handleContextMenu,
    onFocus: handleFocus,
    onKeyDown: handleKeyDown2,
    onKeyUp: handleKeyUp,
    onMouseDown: handleMouseDown,
    onMouseLeave: handleMouseLeave,
    onMouseUp: handleMouseUp,
    onDragLeave: handleDragLeave,
    onTouchEnd: handleTouchEnd,
    onTouchMove: handleTouchMove,
    onTouchStart: handleTouchStart,
    ref: handleRef,
    tabIndex: disabled ? -1 : tabIndex,
    type
  }, buttonProps, other, {
    children: [children, enableTouchRipple ? /* @__PURE__ */ (0, import_jsx_runtime12.jsx)(TouchRipple_default, _extends({
      ref: handleRippleRef,
      center: centerRipple
    }, TouchRippleProps)) : null]
  }));
});
ButtonBase.propTypes = {
  action: refType_default,
  centerRipple: import_prop_types15.default.bool,
  children: import_prop_types15.default.node,
  classes: import_prop_types15.default.object,
  className: import_prop_types15.default.string,
  component: elementTypeAcceptingRef_default,
  disabled: import_prop_types15.default.bool,
  disableRipple: import_prop_types15.default.bool,
  disableTouchRipple: import_prop_types15.default.bool,
  focusRipple: import_prop_types15.default.bool,
  focusVisibleClassName: import_prop_types15.default.string,
  href: import_prop_types15.default.any,
  LinkComponent: import_prop_types15.default.elementType,
  onBlur: import_prop_types15.default.func,
  onClick: import_prop_types15.default.func,
  onContextMenu: import_prop_types15.default.func,
  onDragLeave: import_prop_types15.default.func,
  onFocus: import_prop_types15.default.func,
  onFocusVisible: import_prop_types15.default.func,
  onKeyDown: import_prop_types15.default.func,
  onKeyUp: import_prop_types15.default.func,
  onMouseDown: import_prop_types15.default.func,
  onMouseLeave: import_prop_types15.default.func,
  onMouseUp: import_prop_types15.default.func,
  onTouchEnd: import_prop_types15.default.func,
  onTouchMove: import_prop_types15.default.func,
  onTouchStart: import_prop_types15.default.func,
  sx: import_prop_types15.default.oneOfType([import_prop_types15.default.arrayOf(import_prop_types15.default.oneOfType([import_prop_types15.default.func, import_prop_types15.default.object, import_prop_types15.default.bool])), import_prop_types15.default.func, import_prop_types15.default.object]),
  tabIndex: import_prop_types15.default.number,
  TouchRippleProps: import_prop_types15.default.object,
  touchRippleRef: import_prop_types15.default.oneOfType([import_prop_types15.default.func, import_prop_types15.default.shape({
    current: import_prop_types15.default.shape({
      pulsate: import_prop_types15.default.func.isRequired,
      start: import_prop_types15.default.func.isRequired,
      stop: import_prop_types15.default.func.isRequired
    })
  })]),
  type: import_prop_types15.default.oneOfType([import_prop_types15.default.oneOf(["button", "reset", "submit"]), import_prop_types15.default.string])
};
var ButtonBase_default = ButtonBase;

// node_modules/@mui/material/esm/Button/Button.js
init_capitalize2();

// node_modules/@mui/material/esm/Button/buttonClasses.js
init_base();
function getButtonUtilityClass(slot) {
  return generateUtilityClass("MuiButton", slot);
}
var buttonClasses = generateUtilityClasses("MuiButton", ["root", "text", "textInherit", "textPrimary", "textSecondary", "textSuccess", "textError", "textInfo", "textWarning", "outlined", "outlinedInherit", "outlinedPrimary", "outlinedSecondary", "outlinedSuccess", "outlinedError", "outlinedInfo", "outlinedWarning", "contained", "containedInherit", "containedPrimary", "containedSecondary", "containedSuccess", "containedError", "containedInfo", "containedWarning", "disableElevation", "focusVisible", "disabled", "colorInherit", "textSizeSmall", "textSizeMedium", "textSizeLarge", "outlinedSizeSmall", "outlinedSizeMedium", "outlinedSizeLarge", "containedSizeSmall", "containedSizeMedium", "containedSizeLarge", "sizeMedium", "sizeSmall", "sizeLarge", "fullWidth", "startIcon", "endIcon", "iconSizeSmall", "iconSizeMedium", "iconSizeLarge"]), buttonClasses_default = buttonClasses;

// node_modules/@mui/material/esm/ButtonGroup/ButtonGroupContext.js
var React31 = __toESM(require_react()), ButtonGroupContext = /* @__PURE__ */ React31.createContext({});
ButtonGroupContext.displayName = "ButtonGroupContext";
var ButtonGroupContext_default = ButtonGroupContext;

// node_modules/@mui/material/esm/Button/Button.js
var import_jsx_runtime14 = __toESM(require_jsx_runtime()), import_jsx_runtime15 = __toESM(require_jsx_runtime()), _excluded18 = ["children", "color", "component", "className", "disabled", "disableElevation", "disableFocusRipple", "endIcon", "focusVisibleClassName", "fullWidth", "size", "startIcon", "type", "variant"], _excluded23 = ["root"], useUtilityClasses3 = (ownerState) => {
  let {
    color: color2,
    disableElevation,
    fullWidth,
    size,
    variant,
    classes
  } = ownerState, slots = {
    root: ["root", variant, `${variant}${capitalize_default(color2)}`, `size${capitalize_default(size)}`, `${variant}Size${capitalize_default(size)}`, color2 === "inherit" && "colorInherit", disableElevation && "disableElevation", fullWidth && "fullWidth"],
    label: ["label"],
    startIcon: ["startIcon", `iconSize${capitalize_default(size)}`],
    endIcon: ["endIcon", `iconSize${capitalize_default(size)}`]
  }, composedClasses = composeClasses(slots, getButtonUtilityClass, classes);
  return _extends({}, classes, composedClasses);
}, commonIconStyles = (ownerState) => _extends({}, ownerState.size === "small" && {
  "& > *:nth-of-type(1)": {
    fontSize: 18
  }
}, ownerState.size === "medium" && {
  "& > *:nth-of-type(1)": {
    fontSize: 20
  }
}, ownerState.size === "large" && {
  "& > *:nth-of-type(1)": {
    fontSize: 22
  }
}), ButtonRoot = styled_default(ButtonBase_default, {
  shouldForwardProp: (prop) => rootShouldForwardProp(prop) || prop === "classes",
  name: "MuiButton",
  slot: "Root",
  overridesResolver: (props, styles4) => {
    let {
      ownerState
    } = props;
    return [styles4.root, styles4[ownerState.variant], styles4[`${ownerState.variant}${capitalize_default(ownerState.color)}`], styles4[`size${capitalize_default(ownerState.size)}`], styles4[`${ownerState.variant}Size${capitalize_default(ownerState.size)}`], ownerState.color === "inherit" && styles4.colorInherit, ownerState.disableElevation && styles4.disableElevation, ownerState.fullWidth && styles4.fullWidth];
  }
})(({
  theme,
  ownerState
}) => {
  var _theme$palette$getCon, _theme$palette;
  return _extends({}, theme.typography.button, {
    minWidth: 64,
    padding: "6px 16px",
    borderRadius: (theme.vars || theme).shape.borderRadius,
    transition: theme.transitions.create(["background-color", "box-shadow", "border-color", "color"], {
      duration: theme.transitions.duration.short
    }),
    "&:hover": _extends({
      textDecoration: "none",
      backgroundColor: theme.vars ? `rgba(${theme.vars.palette.text.primaryChannel} / ${theme.vars.palette.action.hoverOpacity})` : alpha(theme.palette.text.primary, theme.palette.action.hoverOpacity),
      "@media (hover: none)": {
        backgroundColor: "transparent"
      }
    }, ownerState.variant === "text" && ownerState.color !== "inherit" && {
      backgroundColor: theme.vars ? `rgba(${theme.vars.palette[ownerState.color].mainChannel} / ${theme.vars.palette.action.hoverOpacity})` : alpha(theme.palette[ownerState.color].main, theme.palette.action.hoverOpacity),
      "@media (hover: none)": {
        backgroundColor: "transparent"
      }
    }, ownerState.variant === "outlined" && ownerState.color !== "inherit" && {
      border: `1px solid ${(theme.vars || theme).palette[ownerState.color].main}`,
      backgroundColor: theme.vars ? `rgba(${theme.vars.palette[ownerState.color].mainChannel} / ${theme.vars.palette.action.hoverOpacity})` : alpha(theme.palette[ownerState.color].main, theme.palette.action.hoverOpacity),
      "@media (hover: none)": {
        backgroundColor: "transparent"
      }
    }, ownerState.variant === "contained" && {
      backgroundColor: (theme.vars || theme).palette.grey.A100,
      boxShadow: (theme.vars || theme).shadows[4],
      "@media (hover: none)": {
        boxShadow: (theme.vars || theme).shadows[2],
        backgroundColor: (theme.vars || theme).palette.grey[300]
      }
    }, ownerState.variant === "contained" && ownerState.color !== "inherit" && {
      backgroundColor: (theme.vars || theme).palette[ownerState.color].dark,
      "@media (hover: none)": {
        backgroundColor: (theme.vars || theme).palette[ownerState.color].main
      }
    }),
    "&:active": _extends({}, ownerState.variant === "contained" && {
      boxShadow: (theme.vars || theme).shadows[8]
    }),
    [`&.${buttonClasses_default.focusVisible}`]: _extends({}, ownerState.variant === "contained" && {
      boxShadow: (theme.vars || theme).shadows[6]
    }),
    [`&.${buttonClasses_default.disabled}`]: _extends({
      color: (theme.vars || theme).palette.action.disabled
    }, ownerState.variant === "outlined" && {
      border: `1px solid ${(theme.vars || theme).palette.action.disabledBackground}`
    }, ownerState.variant === "outlined" && ownerState.color === "secondary" && {
      border: `1px solid ${(theme.vars || theme).palette.action.disabled}`
    }, ownerState.variant === "contained" && {
      color: (theme.vars || theme).palette.action.disabled,
      boxShadow: (theme.vars || theme).shadows[0],
      backgroundColor: (theme.vars || theme).palette.action.disabledBackground
    })
  }, ownerState.variant === "text" && {
    padding: "6px 8px"
  }, ownerState.variant === "text" && ownerState.color !== "inherit" && {
    color: (theme.vars || theme).palette[ownerState.color].main
  }, ownerState.variant === "outlined" && {
    padding: "5px 15px",
    border: "1px solid currentColor"
  }, ownerState.variant === "outlined" && ownerState.color !== "inherit" && {
    color: (theme.vars || theme).palette[ownerState.color].main,
    border: theme.vars ? `1px solid rgba(${theme.vars.palette[ownerState.color].mainChannel} / 0.5)` : `1px solid ${alpha(theme.palette[ownerState.color].main, 0.5)}`
  }, ownerState.variant === "contained" && {
    color: theme.vars ? theme.vars.palette.text.primary : (_theme$palette$getCon = (_theme$palette = theme.palette).getContrastText) == null ? void 0 : _theme$palette$getCon.call(_theme$palette, theme.palette.grey[300]),
    backgroundColor: (theme.vars || theme).palette.grey[300],
    boxShadow: (theme.vars || theme).shadows[2]
  }, ownerState.variant === "contained" && ownerState.color !== "inherit" && {
    color: (theme.vars || theme).palette[ownerState.color].contrastText,
    backgroundColor: (theme.vars || theme).palette[ownerState.color].main
  }, ownerState.color === "inherit" && {
    color: "inherit",
    borderColor: "currentColor"
  }, ownerState.size === "small" && ownerState.variant === "text" && {
    padding: "4px 5px",
    fontSize: theme.typography.pxToRem(13)
  }, ownerState.size === "large" && ownerState.variant === "text" && {
    padding: "8px 11px",
    fontSize: theme.typography.pxToRem(15)
  }, ownerState.size === "small" && ownerState.variant === "outlined" && {
    padding: "3px 9px",
    fontSize: theme.typography.pxToRem(13)
  }, ownerState.size === "large" && ownerState.variant === "outlined" && {
    padding: "7px 21px",
    fontSize: theme.typography.pxToRem(15)
  }, ownerState.size === "small" && ownerState.variant === "contained" && {
    padding: "4px 10px",
    fontSize: theme.typography.pxToRem(13)
  }, ownerState.size === "large" && ownerState.variant === "contained" && {
    padding: "8px 22px",
    fontSize: theme.typography.pxToRem(15)
  }, ownerState.fullWidth && {
    width: "100%"
  });
}, ({
  ownerState
}) => ownerState.disableElevation && {
  boxShadow: "none",
  "&:hover": {
    boxShadow: "none"
  },
  [`&.${buttonClasses_default.focusVisible}`]: {
    boxShadow: "none"
  },
  "&:active": {
    boxShadow: "none"
  },
  [`&.${buttonClasses_default.disabled}`]: {
    boxShadow: "none"
  }
}), ButtonStartIcon = styled_default("span", {
  name: "MuiButton",
  slot: "StartIcon",
  overridesResolver: (props, styles4) => {
    let {
      ownerState
    } = props;
    return [styles4.startIcon, styles4[`iconSize${capitalize_default(ownerState.size)}`]];
  }
})(({
  ownerState
}) => _extends({
  display: "inherit",
  marginRight: 8,
  marginLeft: -4
}, ownerState.size === "small" && {
  marginLeft: -2
}, commonIconStyles(ownerState))), ButtonEndIcon = styled_default("span", {
  name: "MuiButton",
  slot: "EndIcon",
  overridesResolver: (props, styles4) => {
    let {
      ownerState
    } = props;
    return [styles4.endIcon, styles4[`iconSize${capitalize_default(ownerState.size)}`]];
  }
})(({
  ownerState
}) => _extends({
  display: "inherit",
  marginRight: -4,
  marginLeft: 8
}, ownerState.size === "small" && {
  marginRight: -2
}, commonIconStyles(ownerState))), Button = /* @__PURE__ */ React32.forwardRef(function(inProps, ref) {
  let contextProps = React32.useContext(ButtonGroupContext_default), resolvedProps = resolveProps(contextProps, inProps), props = useThemeProps2({
    props: resolvedProps,
    name: "MuiButton"
  }), {
    children,
    color: color2 = "primary",
    component = "button",
    className,
    disabled = !1,
    disableElevation = !1,
    disableFocusRipple = !1,
    endIcon: endIconProp,
    focusVisibleClassName,
    fullWidth = !1,
    size = "medium",
    startIcon: startIconProp,
    type,
    variant = "text"
  } = props, other = _objectWithoutPropertiesLoose2(props, _excluded18), ownerState = _extends({}, props, {
    color: color2,
    component,
    disabled,
    disableElevation,
    disableFocusRipple,
    fullWidth,
    size,
    type,
    variant
  }), _useUtilityClasses = useUtilityClasses3(ownerState), {
    root: classesRoot
  } = _useUtilityClasses, classes = _objectWithoutPropertiesLoose2(_useUtilityClasses, _excluded23), startIcon = startIconProp && /* @__PURE__ */ (0, import_jsx_runtime14.jsx)(ButtonStartIcon, {
    className: classes.startIcon,
    ownerState,
    children: startIconProp
  }), endIcon = endIconProp && /* @__PURE__ */ (0, import_jsx_runtime14.jsx)(ButtonEndIcon, {
    className: classes.endIcon,
    ownerState,
    children: endIconProp
  });
  return /* @__PURE__ */ (0, import_jsx_runtime15.jsxs)(ButtonRoot, _extends({
    ownerState,
    className: clsx_m_default(contextProps.className, classesRoot, className),
    component,
    disabled,
    focusRipple: !disableFocusRipple,
    focusVisibleClassName: clsx_m_default(classes.focusVisible, focusVisibleClassName),
    ref,
    type
  }, other, {
    classes,
    children: [startIcon, children, endIcon]
  }));
});
Button.propTypes = {
  children: import_prop_types16.default.node,
  classes: import_prop_types16.default.object,
  className: import_prop_types16.default.string,
  color: import_prop_types16.default.oneOfType([import_prop_types16.default.oneOf(["inherit", "primary", "secondary", "success", "error", "info", "warning"]), import_prop_types16.default.string]),
  component: import_prop_types16.default.elementType,
  disabled: import_prop_types16.default.bool,
  disableElevation: import_prop_types16.default.bool,
  disableFocusRipple: import_prop_types16.default.bool,
  disableRipple: import_prop_types16.default.bool,
  endIcon: import_prop_types16.default.node,
  focusVisibleClassName: import_prop_types16.default.string,
  fullWidth: import_prop_types16.default.bool,
  href: import_prop_types16.default.string,
  size: import_prop_types16.default.oneOfType([import_prop_types16.default.oneOf(["small", "medium", "large"]), import_prop_types16.default.string]),
  startIcon: import_prop_types16.default.node,
  sx: import_prop_types16.default.oneOfType([import_prop_types16.default.arrayOf(import_prop_types16.default.oneOfType([import_prop_types16.default.func, import_prop_types16.default.object, import_prop_types16.default.bool])), import_prop_types16.default.func, import_prop_types16.default.object]),
  type: import_prop_types16.default.oneOfType([import_prop_types16.default.oneOf(["button", "reset", "submit"]), import_prop_types16.default.string]),
  variant: import_prop_types16.default.oneOfType([import_prop_types16.default.oneOf(["contained", "outlined", "text"]), import_prop_types16.default.string])
};
var Button_default = Button;

// app/routes/about.tsx
var import_jsx_dev_runtime = __toESM(require_jsx_dev_runtime());
function Index() {
  let loaderData = useLoaderData();
  return /* @__PURE__ */ (0, import_jsx_dev_runtime.jsxDEV)("div", {
    style: { fontFamily: "system-ui, sans-serif", lineHeight: "1.4" },
    children: [
      /* @__PURE__ */ (0, import_jsx_dev_runtime.jsxDEV)("h1", {
        children: "Alma"
      }, void 0, !1, {
        fileName: "app/routes/about.tsx",
        lineNumber: 12,
        columnNumber: 7
      }, this),
      /* @__PURE__ */ (0, import_jsx_dev_runtime.jsxDEV)(Button_default, {
        variant: "contained",
        component: Link2,
        to: "/",
        children: "Go to the main page"
      }, void 0, !1, {
        fileName: "app/routes/about.tsx",
        lineNumber: 14,
        columnNumber: 7
      }, this)
    ]
  }, void 0, !0, {
    fileName: "app/routes/about.tsx",
    lineNumber: 11,
    columnNumber: 5
  }, this);
}

// app/routes/index.tsx
var routes_exports = {};
__export(routes_exports, {
  default: () => Index2,
  loader: () => loader
});
var import_Clear = __toESM(require_Clear());

// node_modules/@mui/material/esm/Checkbox/Checkbox.js
init_objectWithoutPropertiesLoose();
init_extends();
var React41 = __toESM(require_react()), import_prop_types19 = __toESM(require_prop_types());
init_esm2();
init_base();
init_esm3();

// node_modules/@mui/material/esm/internal/SwitchBase.js
init_objectWithoutPropertiesLoose();
init_extends();
var React37 = __toESM(require_react()), import_prop_types18 = __toESM(require_prop_types());
init_clsx_m();
init_esm2();
init_base();
init_capitalize2();
init_styled();
init_useControlled2();

// node_modules/@mui/material/esm/FormControl/useFormControl.js
var React36 = __toESM(require_react());

// node_modules/@mui/material/esm/FormControl/FormControlContext.js
var React35 = __toESM(require_react()), FormControlContext = /* @__PURE__ */ React35.createContext();
FormControlContext.displayName = "FormControlContext";
var FormControlContext_default = FormControlContext;

// node_modules/@mui/material/esm/FormControl/useFormControl.js
function useFormControl() {
  return React36.useContext(FormControlContext_default);
}

// node_modules/@mui/material/esm/internal/switchBaseClasses.js
init_base();
function getSwitchBaseUtilityClass(slot) {
  return generateUtilityClass("PrivateSwitchBase", slot);
}
var switchBaseClasses = generateUtilityClasses("PrivateSwitchBase", ["root", "checked", "disabled", "input", "edgeStart", "edgeEnd"]);

// node_modules/@mui/material/esm/internal/SwitchBase.js
var import_jsx_runtime19 = __toESM(require_jsx_runtime()), import_jsx_runtime20 = __toESM(require_jsx_runtime()), _excluded20 = ["autoFocus", "checked", "checkedIcon", "className", "defaultChecked", "disabled", "disableFocusRipple", "edge", "icon", "id", "inputProps", "inputRef", "name", "onBlur", "onChange", "onFocus", "readOnly", "required", "tabIndex", "type", "value"], useUtilityClasses5 = (ownerState) => {
  let {
    classes,
    checked: checked2,
    disabled,
    edge
  } = ownerState, slots = {
    root: ["root", checked2 && "checked", disabled && "disabled", edge && `edge${capitalize_default(edge)}`],
    input: ["input"]
  };
  return composeClasses(slots, getSwitchBaseUtilityClass, classes);
}, SwitchBaseRoot = styled_default(ButtonBase_default)(({
  ownerState
}) => _extends({
  padding: 9,
  borderRadius: "50%"
}, ownerState.edge === "start" && {
  marginLeft: ownerState.size === "small" ? -3 : -12
}, ownerState.edge === "end" && {
  marginRight: ownerState.size === "small" ? -3 : -12
})), SwitchBaseInput = styled_default("input")({
  cursor: "inherit",
  position: "absolute",
  opacity: 0,
  width: "100%",
  height: "100%",
  top: 0,
  left: 0,
  margin: 0,
  padding: 0,
  zIndex: 1
}), SwitchBase = /* @__PURE__ */ React37.forwardRef(function(props, ref) {
  let {
    autoFocus,
    checked: checkedProp,
    checkedIcon,
    className,
    defaultChecked,
    disabled: disabledProp,
    disableFocusRipple = !1,
    edge = !1,
    icon,
    id,
    inputProps,
    inputRef,
    name,
    onBlur,
    onChange,
    onFocus,
    readOnly,
    required,
    tabIndex,
    type,
    value
  } = props, other = _objectWithoutPropertiesLoose2(props, _excluded20), [checked2, setCheckedState] = useControlled_default({
    controlled: checkedProp,
    default: Boolean(defaultChecked),
    name: "SwitchBase",
    state: "checked"
  }), muiFormControl = useFormControl(), handleFocus = (event) => {
    onFocus && onFocus(event), muiFormControl && muiFormControl.onFocus && muiFormControl.onFocus(event);
  }, handleBlur = (event) => {
    onBlur && onBlur(event), muiFormControl && muiFormControl.onBlur && muiFormControl.onBlur(event);
  }, handleInputChange = (event) => {
    if (event.nativeEvent.defaultPrevented)
      return;
    let newChecked = event.target.checked;
    setCheckedState(newChecked), onChange && onChange(event, newChecked);
  }, disabled = disabledProp;
  muiFormControl && typeof disabled > "u" && (disabled = muiFormControl.disabled);
  let hasLabelFor = type === "checkbox" || type === "radio", ownerState = _extends({}, props, {
    checked: checked2,
    disabled,
    disableFocusRipple,
    edge
  }), classes = useUtilityClasses5(ownerState);
  return /* @__PURE__ */ (0, import_jsx_runtime20.jsxs)(SwitchBaseRoot, _extends({
    component: "span",
    className: clsx_m_default(classes.root, className),
    centerRipple: !0,
    focusRipple: !disableFocusRipple,
    disabled,
    tabIndex: null,
    role: void 0,
    onFocus: handleFocus,
    onBlur: handleBlur,
    ownerState,
    ref
  }, other, {
    children: [/* @__PURE__ */ (0, import_jsx_runtime19.jsx)(SwitchBaseInput, _extends({
      autoFocus,
      checked: checkedProp,
      defaultChecked,
      className: classes.input,
      disabled,
      id: hasLabelFor && id,
      name,
      onChange: handleInputChange,
      readOnly,
      ref: inputRef,
      required,
      ownerState,
      tabIndex,
      type
    }, type === "checkbox" && value === void 0 ? {} : {
      value
    }, inputProps)), checked2 ? checkedIcon : icon]
  }));
});
SwitchBase.propTypes = {
  autoFocus: import_prop_types18.default.bool,
  checked: import_prop_types18.default.bool,
  checkedIcon: import_prop_types18.default.node.isRequired,
  classes: import_prop_types18.default.object,
  className: import_prop_types18.default.string,
  defaultChecked: import_prop_types18.default.bool,
  disabled: import_prop_types18.default.bool,
  disableFocusRipple: import_prop_types18.default.bool,
  edge: import_prop_types18.default.oneOf(["end", "start", !1]),
  icon: import_prop_types18.default.node.isRequired,
  id: import_prop_types18.default.string,
  inputProps: import_prop_types18.default.object,
  inputRef: refType_default,
  name: import_prop_types18.default.string,
  onBlur: import_prop_types18.default.func,
  onChange: import_prop_types18.default.func,
  onFocus: import_prop_types18.default.func,
  readOnly: import_prop_types18.default.bool,
  required: import_prop_types18.default.bool,
  sx: import_prop_types18.default.object,
  tabIndex: import_prop_types18.default.oneOfType([import_prop_types18.default.number, import_prop_types18.default.string]),
  type: import_prop_types18.default.string.isRequired,
  value: import_prop_types18.default.any
};
var SwitchBase_default = SwitchBase;

// node_modules/@mui/material/esm/internal/svg-icons/CheckBoxOutlineBlank.js
var React38 = __toESM(require_react());
init_createSvgIcon();
var import_jsx_runtime21 = __toESM(require_jsx_runtime()), CheckBoxOutlineBlank_default = createSvgIcon(/* @__PURE__ */ (0, import_jsx_runtime21.jsx)("path", {
  d: "M19 5v14H5V5h14m0-2H5c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2z"
}), "CheckBoxOutlineBlank");

// node_modules/@mui/material/esm/internal/svg-icons/CheckBox.js
var React39 = __toESM(require_react());
init_createSvgIcon();
var import_jsx_runtime22 = __toESM(require_jsx_runtime()), CheckBox_default = createSvgIcon(/* @__PURE__ */ (0, import_jsx_runtime22.jsx)("path", {
  d: "M19 3H5c-1.11 0-2 .9-2 2v14c0 1.1.89 2 2 2h14c1.11 0 2-.9 2-2V5c0-1.1-.89-2-2-2zm-9 14l-5-5 1.41-1.41L10 14.17l7.59-7.59L19 8l-9 9z"
}), "CheckBox");

// node_modules/@mui/material/esm/internal/svg-icons/IndeterminateCheckBox.js
var React40 = __toESM(require_react());
init_createSvgIcon();
var import_jsx_runtime23 = __toESM(require_jsx_runtime()), IndeterminateCheckBox_default = createSvgIcon(/* @__PURE__ */ (0, import_jsx_runtime23.jsx)("path", {
  d: "M19 3H5c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2zm-2 10H7v-2h10v2z"
}), "IndeterminateCheckBox");

// node_modules/@mui/material/esm/Checkbox/Checkbox.js
init_capitalize2();
init_useThemeProps3();
init_styled();

// node_modules/@mui/material/esm/Checkbox/checkboxClasses.js
init_base();
function getCheckboxUtilityClass(slot) {
  return generateUtilityClass("MuiCheckbox", slot);
}
var checkboxClasses = generateUtilityClasses("MuiCheckbox", ["root", "checked", "disabled", "indeterminate", "colorPrimary", "colorSecondary"]), checkboxClasses_default = checkboxClasses;

// node_modules/@mui/material/esm/Checkbox/Checkbox.js
var import_jsx_runtime24 = __toESM(require_jsx_runtime()), _excluded21 = ["checkedIcon", "color", "icon", "indeterminate", "indeterminateIcon", "inputProps", "size"], useUtilityClasses6 = (ownerState) => {
  let {
    classes,
    indeterminate,
    color: color2
  } = ownerState, slots = {
    root: ["root", indeterminate && "indeterminate", `color${capitalize_default(color2)}`]
  }, composedClasses = composeClasses(slots, getCheckboxUtilityClass, classes);
  return _extends({}, classes, composedClasses);
}, CheckboxRoot = styled_default(SwitchBase_default, {
  shouldForwardProp: (prop) => rootShouldForwardProp(prop) || prop === "classes",
  name: "MuiCheckbox",
  slot: "Root",
  overridesResolver: (props, styles4) => {
    let {
      ownerState
    } = props;
    return [styles4.root, ownerState.indeterminate && styles4.indeterminate, ownerState.color !== "default" && styles4[`color${capitalize_default(ownerState.color)}`]];
  }
})(({
  theme,
  ownerState
}) => _extends({
  color: (theme.vars || theme).palette.text.secondary
}, !ownerState.disableRipple && {
  "&:hover": {
    backgroundColor: theme.vars ? `rgba(${ownerState.color === "default" ? theme.vars.palette.action.activeChannel : theme.vars.palette.primary.mainChannel} / ${theme.vars.palette.action.hoverOpacity})` : alpha(ownerState.color === "default" ? theme.palette.action.active : theme.palette[ownerState.color].main, theme.palette.action.hoverOpacity),
    "@media (hover: none)": {
      backgroundColor: "transparent"
    }
  }
}, ownerState.color !== "default" && {
  [`&.${checkboxClasses_default.checked}, &.${checkboxClasses_default.indeterminate}`]: {
    color: (theme.vars || theme).palette[ownerState.color].main
  },
  [`&.${checkboxClasses_default.disabled}`]: {
    color: (theme.vars || theme).palette.action.disabled
  }
})), defaultCheckedIcon = /* @__PURE__ */ (0, import_jsx_runtime24.jsx)(CheckBox_default, {}), defaultIcon = /* @__PURE__ */ (0, import_jsx_runtime24.jsx)(CheckBoxOutlineBlank_default, {}), defaultIndeterminateIcon = /* @__PURE__ */ (0, import_jsx_runtime24.jsx)(IndeterminateCheckBox_default, {}), Checkbox = /* @__PURE__ */ React41.forwardRef(function(inProps, ref) {
  var _icon$props$fontSize, _indeterminateIcon$pr;
  let props = useThemeProps2({
    props: inProps,
    name: "MuiCheckbox"
  }), {
    checkedIcon = defaultCheckedIcon,
    color: color2 = "primary",
    icon: iconProp = defaultIcon,
    indeterminate = !1,
    indeterminateIcon: indeterminateIconProp = defaultIndeterminateIcon,
    inputProps,
    size = "medium"
  } = props, other = _objectWithoutPropertiesLoose2(props, _excluded21), icon = indeterminate ? indeterminateIconProp : iconProp, indeterminateIcon = indeterminate ? indeterminateIconProp : checkedIcon, ownerState = _extends({}, props, {
    color: color2,
    indeterminate,
    size
  }), classes = useUtilityClasses6(ownerState);
  return /* @__PURE__ */ (0, import_jsx_runtime24.jsx)(CheckboxRoot, _extends({
    type: "checkbox",
    inputProps: _extends({
      "data-indeterminate": indeterminate
    }, inputProps),
    icon: /* @__PURE__ */ React41.cloneElement(icon, {
      fontSize: (_icon$props$fontSize = icon.props.fontSize) != null ? _icon$props$fontSize : size
    }),
    checkedIcon: /* @__PURE__ */ React41.cloneElement(indeterminateIcon, {
      fontSize: (_indeterminateIcon$pr = indeterminateIcon.props.fontSize) != null ? _indeterminateIcon$pr : size
    }),
    ownerState,
    ref
  }, other, {
    classes
  }));
});
Checkbox.propTypes = {
  checked: import_prop_types19.default.bool,
  checkedIcon: import_prop_types19.default.node,
  classes: import_prop_types19.default.object,
  color: import_prop_types19.default.oneOfType([import_prop_types19.default.oneOf(["default", "primary", "secondary", "error", "info", "success", "warning"]), import_prop_types19.default.string]),
  defaultChecked: import_prop_types19.default.bool,
  disabled: import_prop_types19.default.bool,
  disableRipple: import_prop_types19.default.bool,
  icon: import_prop_types19.default.node,
  id: import_prop_types19.default.string,
  indeterminate: import_prop_types19.default.bool,
  indeterminateIcon: import_prop_types19.default.node,
  inputProps: import_prop_types19.default.object,
  inputRef: refType_default,
  onChange: import_prop_types19.default.func,
  required: import_prop_types19.default.bool,
  size: import_prop_types19.default.oneOfType([import_prop_types19.default.oneOf(["medium", "small"]), import_prop_types19.default.string]),
  sx: import_prop_types19.default.oneOfType([import_prop_types19.default.arrayOf(import_prop_types19.default.oneOfType([import_prop_types19.default.func, import_prop_types19.default.object, import_prop_types19.default.bool])), import_prop_types19.default.func, import_prop_types19.default.object]),
  value: import_prop_types19.default.any
};
var Checkbox_default = Checkbox;

// node_modules/@mui/material/esm/FormGroup/FormGroup.js
init_objectWithoutPropertiesLoose();
init_extends();
var React42 = __toESM(require_react()), import_prop_types20 = __toESM(require_prop_types());
init_clsx_m();
init_base();
init_styled();
init_useThemeProps3();

// node_modules/@mui/material/esm/FormGroup/formGroupClasses.js
init_base();
function getFormGroupUtilityClass(slot) {
  return generateUtilityClass("MuiFormGroup", slot);
}
var formGroupClasses = generateUtilityClasses("MuiFormGroup", ["root", "row", "error"]);

// node_modules/@mui/material/esm/FormControl/formControlState.js
function formControlState({
  props,
  states,
  muiFormControl
}) {
  return states.reduce((acc, state) => (acc[state] = props[state], muiFormControl && typeof props[state] > "u" && (acc[state] = muiFormControl[state]), acc), {});
}

// node_modules/@mui/material/esm/FormGroup/FormGroup.js
var import_jsx_runtime25 = __toESM(require_jsx_runtime()), _excluded24 = ["className", "row"], useUtilityClasses7 = (ownerState) => {
  let {
    classes,
    row,
    error
  } = ownerState;
  return composeClasses({
    root: ["root", row && "row", error && "error"]
  }, getFormGroupUtilityClass, classes);
}, FormGroupRoot = styled_default("div", {
  name: "MuiFormGroup",
  slot: "Root",
  overridesResolver: (props, styles4) => {
    let {
      ownerState
    } = props;
    return [styles4.root, ownerState.row && styles4.row];
  }
})(({
  ownerState
}) => _extends({
  display: "flex",
  flexDirection: "column",
  flexWrap: "wrap"
}, ownerState.row && {
  flexDirection: "row"
})), FormGroup = /* @__PURE__ */ React42.forwardRef(function(inProps, ref) {
  let props = useThemeProps2({
    props: inProps,
    name: "MuiFormGroup"
  }), {
    className,
    row = !1
  } = props, other = _objectWithoutPropertiesLoose2(props, _excluded24), muiFormControl = useFormControl(), fcs = formControlState({
    props,
    muiFormControl,
    states: ["error"]
  }), ownerState = _extends({}, props, {
    row,
    error: fcs.error
  }), classes = useUtilityClasses7(ownerState);
  return /* @__PURE__ */ (0, import_jsx_runtime25.jsx)(FormGroupRoot, _extends({
    className: clsx_m_default(classes.root, className),
    ownerState,
    ref
  }, other));
});
FormGroup.propTypes = {
  children: import_prop_types20.default.node,
  classes: import_prop_types20.default.object,
  className: import_prop_types20.default.string,
  row: import_prop_types20.default.bool,
  sx: import_prop_types20.default.oneOfType([import_prop_types20.default.arrayOf(import_prop_types20.default.oneOfType([import_prop_types20.default.func, import_prop_types20.default.object, import_prop_types20.default.bool])), import_prop_types20.default.func, import_prop_types20.default.object])
};
var FormGroup_default = FormGroup;

// node_modules/@mui/material/esm/FormControlLabel/FormControlLabel.js
init_objectWithoutPropertiesLoose();
init_extends();
var React45 = __toESM(require_react()), import_prop_types23 = __toESM(require_prop_types());
init_clsx_m();
init_esm2();
init_base();

// node_modules/@mui/material/esm/FormControl/FormControl.js
init_objectWithoutPropertiesLoose();
init_extends();
var React43 = __toESM(require_react()), import_prop_types21 = __toESM(require_prop_types());
init_clsx_m();
init_base();
init_useThemeProps3();
init_styled();

// node_modules/@mui/material/esm/InputBase/utils.js
function hasValue(value) {
  return value != null && !(Array.isArray(value) && value.length === 0);
}
function isFilled(obj, SSR = !1) {
  return obj && (hasValue(obj.value) && obj.value !== "" || SSR && hasValue(obj.defaultValue) && obj.defaultValue !== "");
}
function isAdornedStart(obj) {
  return obj.startAdornment;
}

// node_modules/@mui/material/esm/FormControl/FormControl.js
init_capitalize2();
init_isMuiElement2();

// node_modules/@mui/material/esm/FormControl/formControlClasses.js
init_base();
function getFormControlUtilityClasses(slot) {
  return generateUtilityClass("MuiFormControl", slot);
}
var formControlClasses = generateUtilityClasses("MuiFormControl", ["root", "marginNone", "marginNormal", "marginDense", "fullWidth", "disabled"]);

// node_modules/@mui/material/esm/FormControl/FormControl.js
var import_jsx_runtime26 = __toESM(require_jsx_runtime()), _excluded25 = ["children", "className", "color", "component", "disabled", "error", "focused", "fullWidth", "hiddenLabel", "margin", "required", "size", "variant"], useUtilityClasses8 = (ownerState) => {
  let {
    classes,
    margin: margin2,
    fullWidth
  } = ownerState, slots = {
    root: ["root", margin2 !== "none" && `margin${capitalize_default(margin2)}`, fullWidth && "fullWidth"]
  };
  return composeClasses(slots, getFormControlUtilityClasses, classes);
}, FormControlRoot = styled_default("div", {
  name: "MuiFormControl",
  slot: "Root",
  overridesResolver: ({
    ownerState
  }, styles4) => _extends({}, styles4.root, styles4[`margin${capitalize_default(ownerState.margin)}`], ownerState.fullWidth && styles4.fullWidth)
})(({
  ownerState
}) => _extends({
  display: "inline-flex",
  flexDirection: "column",
  position: "relative",
  minWidth: 0,
  padding: 0,
  margin: 0,
  border: 0,
  verticalAlign: "top"
}, ownerState.margin === "normal" && {
  marginTop: 16,
  marginBottom: 8
}, ownerState.margin === "dense" && {
  marginTop: 8,
  marginBottom: 4
}, ownerState.fullWidth && {
  width: "100%"
})), FormControl = /* @__PURE__ */ React43.forwardRef(function(inProps, ref) {
  let props = useThemeProps2({
    props: inProps,
    name: "MuiFormControl"
  }), {
    children,
    className,
    color: color2 = "primary",
    component = "div",
    disabled = !1,
    error = !1,
    focused: visuallyFocused,
    fullWidth = !1,
    hiddenLabel = !1,
    margin: margin2 = "none",
    required = !1,
    size = "medium",
    variant = "outlined"
  } = props, other = _objectWithoutPropertiesLoose2(props, _excluded25), ownerState = _extends({}, props, {
    color: color2,
    component,
    disabled,
    error,
    fullWidth,
    hiddenLabel,
    margin: margin2,
    required,
    size,
    variant
  }), classes = useUtilityClasses8(ownerState), [adornedStart, setAdornedStart] = React43.useState(() => {
    let initialAdornedStart = !1;
    return children && React43.Children.forEach(children, (child) => {
      if (!isMuiElement_default(child, ["Input", "Select"]))
        return;
      let input = isMuiElement_default(child, ["Select"]) ? child.props.input : child;
      input && isAdornedStart(input.props) && (initialAdornedStart = !0);
    }), initialAdornedStart;
  }), [filled, setFilled] = React43.useState(() => {
    let initialFilled = !1;
    return children && React43.Children.forEach(children, (child) => {
      !isMuiElement_default(child, ["Input", "Select"]) || isFilled(child.props, !0) && (initialFilled = !0);
    }), initialFilled;
  }), [focusedState, setFocused] = React43.useState(!1);
  disabled && focusedState && setFocused(!1);
  let focused = visuallyFocused !== void 0 && !disabled ? visuallyFocused : focusedState, registerEffect;
  {
    let registeredInput = React43.useRef(!1);
    registerEffect = () => (registeredInput.current && console.error(["MUI: There are multiple `InputBase` components inside a FormControl.", "This creates visual inconsistencies, only use one `InputBase`."].join(`
`)), registeredInput.current = !0, () => {
      registeredInput.current = !1;
    });
  }
  let onFilled = React43.useCallback(() => {
    setFilled(!0);
  }, []), onEmpty = React43.useCallback(() => {
    setFilled(!1);
  }, []), childContext = {
    adornedStart,
    setAdornedStart,
    color: color2,
    disabled,
    error,
    filled,
    focused,
    fullWidth,
    hiddenLabel,
    size,
    onBlur: () => {
      setFocused(!1);
    },
    onEmpty,
    onFilled,
    onFocus: () => {
      setFocused(!0);
    },
    registerEffect,
    required,
    variant
  };
  return /* @__PURE__ */ (0, import_jsx_runtime26.jsx)(FormControlContext_default.Provider, {
    value: childContext,
    children: /* @__PURE__ */ (0, import_jsx_runtime26.jsx)(FormControlRoot, _extends({
      as: component,
      ownerState,
      className: clsx_m_default(classes.root, className),
      ref
    }, other, {
      children
    }))
  });
});
FormControl.propTypes = {
  children: import_prop_types21.default.node,
  classes: import_prop_types21.default.object,
  className: import_prop_types21.default.string,
  color: import_prop_types21.default.oneOfType([import_prop_types21.default.oneOf(["primary", "secondary", "error", "info", "success", "warning"]), import_prop_types21.default.string]),
  component: import_prop_types21.default.elementType,
  disabled: import_prop_types21.default.bool,
  error: import_prop_types21.default.bool,
  focused: import_prop_types21.default.bool,
  fullWidth: import_prop_types21.default.bool,
  hiddenLabel: import_prop_types21.default.bool,
  margin: import_prop_types21.default.oneOf(["dense", "none", "normal"]),
  required: import_prop_types21.default.bool,
  size: import_prop_types21.default.oneOfType([import_prop_types21.default.oneOf(["medium", "small"]), import_prop_types21.default.string]),
  sx: import_prop_types21.default.oneOfType([import_prop_types21.default.arrayOf(import_prop_types21.default.oneOfType([import_prop_types21.default.func, import_prop_types21.default.object, import_prop_types21.default.bool])), import_prop_types21.default.func, import_prop_types21.default.object]),
  variant: import_prop_types21.default.oneOf(["filled", "outlined", "standard"])
};
var FormControl_default = FormControl;

// node_modules/@mui/material/esm/Typography/Typography.js
init_objectWithoutPropertiesLoose();
init_extends();
var React44 = __toESM(require_react()), import_prop_types22 = __toESM(require_prop_types());
init_clsx_m();
init_esm3();
init_base();
init_styled();
init_useThemeProps3();
init_capitalize2();

// node_modules/@mui/material/esm/Typography/typographyClasses.js
init_base();
function getTypographyUtilityClass(slot) {
  return generateUtilityClass("MuiTypography", slot);
}
var typographyClasses = generateUtilityClasses("MuiTypography", ["root", "h1", "h2", "h3", "h4", "h5", "h6", "subtitle1", "subtitle2", "body1", "body2", "inherit", "button", "caption", "overline", "alignLeft", "alignRight", "alignCenter", "alignJustify", "noWrap", "gutterBottom", "paragraph"]);

// node_modules/@mui/material/esm/Typography/Typography.js
var import_jsx_runtime27 = __toESM(require_jsx_runtime()), _excluded26 = ["align", "className", "component", "gutterBottom", "noWrap", "paragraph", "variant", "variantMapping"], useUtilityClasses9 = (ownerState) => {
  let {
    align,
    gutterBottom,
    noWrap,
    paragraph,
    variant,
    classes
  } = ownerState, slots = {
    root: ["root", variant, ownerState.align !== "inherit" && `align${capitalize_default(align)}`, gutterBottom && "gutterBottom", noWrap && "noWrap", paragraph && "paragraph"]
  };
  return composeClasses(slots, getTypographyUtilityClass, classes);
}, TypographyRoot = styled_default("span", {
  name: "MuiTypography",
  slot: "Root",
  overridesResolver: (props, styles4) => {
    let {
      ownerState
    } = props;
    return [styles4.root, ownerState.variant && styles4[ownerState.variant], ownerState.align !== "inherit" && styles4[`align${capitalize_default(ownerState.align)}`], ownerState.noWrap && styles4.noWrap, ownerState.gutterBottom && styles4.gutterBottom, ownerState.paragraph && styles4.paragraph];
  }
})(({
  theme,
  ownerState
}) => _extends({
  margin: 0
}, ownerState.variant && theme.typography[ownerState.variant], ownerState.align !== "inherit" && {
  textAlign: ownerState.align
}, ownerState.noWrap && {
  overflow: "hidden",
  textOverflow: "ellipsis",
  whiteSpace: "nowrap"
}, ownerState.gutterBottom && {
  marginBottom: "0.35em"
}, ownerState.paragraph && {
  marginBottom: 16
})), defaultVariantMapping = {
  h1: "h1",
  h2: "h2",
  h3: "h3",
  h4: "h4",
  h5: "h5",
  h6: "h6",
  subtitle1: "h6",
  subtitle2: "h6",
  body1: "p",
  body2: "p",
  inherit: "p"
}, colorTransformations = {
  primary: "primary.main",
  textPrimary: "text.primary",
  secondary: "secondary.main",
  textSecondary: "text.secondary",
  error: "error.main"
}, transformDeprecatedColors = (color2) => colorTransformations[color2] || color2, Typography = /* @__PURE__ */ React44.forwardRef(function(inProps, ref) {
  let themeProps = useThemeProps2({
    props: inProps,
    name: "MuiTypography"
  }), color2 = transformDeprecatedColors(themeProps.color), props = extendSxProp(_extends({}, themeProps, {
    color: color2
  })), {
    align = "inherit",
    className,
    component,
    gutterBottom = !1,
    noWrap = !1,
    paragraph = !1,
    variant = "body1",
    variantMapping = defaultVariantMapping
  } = props, other = _objectWithoutPropertiesLoose2(props, _excluded26), ownerState = _extends({}, props, {
    align,
    color: color2,
    className,
    component,
    gutterBottom,
    noWrap,
    paragraph,
    variant,
    variantMapping
  }), Component = component || (paragraph ? "p" : variantMapping[variant] || defaultVariantMapping[variant]) || "span", classes = useUtilityClasses9(ownerState);
  return /* @__PURE__ */ (0, import_jsx_runtime27.jsx)(TypographyRoot, _extends({
    as: Component,
    ref,
    ownerState,
    className: clsx_m_default(classes.root, className)
  }, other));
});
Typography.propTypes = {
  align: import_prop_types22.default.oneOf(["center", "inherit", "justify", "left", "right"]),
  children: import_prop_types22.default.node,
  classes: import_prop_types22.default.object,
  className: import_prop_types22.default.string,
  component: import_prop_types22.default.elementType,
  gutterBottom: import_prop_types22.default.bool,
  noWrap: import_prop_types22.default.bool,
  paragraph: import_prop_types22.default.bool,
  sx: import_prop_types22.default.oneOfType([import_prop_types22.default.arrayOf(import_prop_types22.default.oneOfType([import_prop_types22.default.func, import_prop_types22.default.object, import_prop_types22.default.bool])), import_prop_types22.default.func, import_prop_types22.default.object]),
  variant: import_prop_types22.default.oneOfType([import_prop_types22.default.oneOf(["body1", "body2", "button", "caption", "h1", "h2", "h3", "h4", "h5", "h6", "inherit", "overline", "subtitle1", "subtitle2"]), import_prop_types22.default.string]),
  variantMapping: import_prop_types22.default.object
};
var Typography_default = Typography;

// node_modules/@mui/material/esm/FormControlLabel/FormControlLabel.js
init_capitalize2();
init_styled();
init_useThemeProps3();

// node_modules/@mui/material/esm/FormControlLabel/formControlLabelClasses.js
init_base();
function getFormControlLabelUtilityClasses(slot) {
  return generateUtilityClass("MuiFormControlLabel", slot);
}
var formControlLabelClasses = generateUtilityClasses("MuiFormControlLabel", ["root", "labelPlacementStart", "labelPlacementTop", "labelPlacementBottom", "disabled", "label", "error"]), formControlLabelClasses_default = formControlLabelClasses;

// node_modules/@mui/material/esm/FormControlLabel/FormControlLabel.js
var import_jsx_runtime28 = __toESM(require_jsx_runtime()), import_jsx_runtime29 = __toESM(require_jsx_runtime()), _excluded27 = ["checked", "className", "componentsProps", "control", "disabled", "disableTypography", "inputRef", "label", "labelPlacement", "name", "onChange", "value"], useUtilityClasses10 = (ownerState) => {
  let {
    classes,
    disabled,
    labelPlacement,
    error
  } = ownerState, slots = {
    root: ["root", disabled && "disabled", `labelPlacement${capitalize_default(labelPlacement)}`, error && "error"],
    label: ["label", disabled && "disabled"]
  };
  return composeClasses(slots, getFormControlLabelUtilityClasses, classes);
}, FormControlLabelRoot = styled_default("label", {
  name: "MuiFormControlLabel",
  slot: "Root",
  overridesResolver: (props, styles4) => {
    let {
      ownerState
    } = props;
    return [{
      [`& .${formControlLabelClasses_default.label}`]: styles4.label
    }, styles4.root, styles4[`labelPlacement${capitalize_default(ownerState.labelPlacement)}`]];
  }
})(({
  theme,
  ownerState
}) => _extends({
  display: "inline-flex",
  alignItems: "center",
  cursor: "pointer",
  verticalAlign: "middle",
  WebkitTapHighlightColor: "transparent",
  marginLeft: -11,
  marginRight: 16,
  [`&.${formControlLabelClasses_default.disabled}`]: {
    cursor: "default"
  }
}, ownerState.labelPlacement === "start" && {
  flexDirection: "row-reverse",
  marginLeft: 16,
  marginRight: -11
}, ownerState.labelPlacement === "top" && {
  flexDirection: "column-reverse",
  marginLeft: 16
}, ownerState.labelPlacement === "bottom" && {
  flexDirection: "column",
  marginLeft: 16
}, {
  [`& .${formControlLabelClasses_default.label}`]: {
    [`&.${formControlLabelClasses_default.disabled}`]: {
      color: (theme.vars || theme).palette.text.disabled
    }
  }
})), FormControlLabel = /* @__PURE__ */ React45.forwardRef(function(inProps, ref) {
  let props = useThemeProps2({
    props: inProps,
    name: "MuiFormControlLabel"
  }), {
    className,
    componentsProps = {},
    control,
    disabled: disabledProp,
    disableTypography,
    label: labelProp,
    labelPlacement = "end"
  } = props, other = _objectWithoutPropertiesLoose2(props, _excluded27), muiFormControl = useFormControl(), disabled = disabledProp;
  typeof disabled > "u" && typeof control.props.disabled < "u" && (disabled = control.props.disabled), typeof disabled > "u" && muiFormControl && (disabled = muiFormControl.disabled);
  let controlProps = {
    disabled
  };
  ["checked", "name", "onChange", "value", "inputRef"].forEach((key) => {
    typeof control.props[key] > "u" && typeof props[key] < "u" && (controlProps[key] = props[key]);
  });
  let fcs = formControlState({
    props,
    muiFormControl,
    states: ["error"]
  }), ownerState = _extends({}, props, {
    disabled,
    labelPlacement,
    error: fcs.error
  }), classes = useUtilityClasses10(ownerState), label = labelProp;
  return label != null && label.type !== Typography_default && !disableTypography && (label = /* @__PURE__ */ (0, import_jsx_runtime28.jsx)(Typography_default, _extends({
    component: "span",
    className: classes.label
  }, componentsProps.typography, {
    children: label
  }))), /* @__PURE__ */ (0, import_jsx_runtime29.jsxs)(FormControlLabelRoot, _extends({
    className: clsx_m_default(classes.root, className),
    ownerState,
    ref
  }, other, {
    children: [/* @__PURE__ */ React45.cloneElement(control, controlProps), label]
  }));
});
FormControlLabel.propTypes = {
  checked: import_prop_types23.default.bool,
  classes: import_prop_types23.default.object,
  className: import_prop_types23.default.string,
  componentsProps: import_prop_types23.default.shape({
    typography: import_prop_types23.default.object
  }),
  control: import_prop_types23.default.element.isRequired,
  disabled: import_prop_types23.default.bool,
  disableTypography: import_prop_types23.default.bool,
  inputRef: refType_default,
  label: import_prop_types23.default.node,
  labelPlacement: import_prop_types23.default.oneOf(["bottom", "end", "start", "top"]),
  name: import_prop_types23.default.string,
  onChange: import_prop_types23.default.func,
  sx: import_prop_types23.default.oneOfType([import_prop_types23.default.arrayOf(import_prop_types23.default.oneOfType([import_prop_types23.default.func, import_prop_types23.default.object, import_prop_types23.default.bool])), import_prop_types23.default.func, import_prop_types23.default.object]),
  value: import_prop_types23.default.any
};
var FormControlLabel_default = FormControlLabel;

// node_modules/@mui/material/esm/FormLabel/FormLabel.js
init_objectWithoutPropertiesLoose();
init_extends();
var React46 = __toESM(require_react()), import_prop_types24 = __toESM(require_prop_types());
init_clsx_m();
init_base();
init_capitalize2();
init_useThemeProps3();
init_styled();

// node_modules/@mui/material/esm/FormLabel/formLabelClasses.js
init_base();
function getFormLabelUtilityClasses(slot) {
  return generateUtilityClass("MuiFormLabel", slot);
}
var formLabelClasses = generateUtilityClasses("MuiFormLabel", ["root", "colorSecondary", "focused", "disabled", "error", "filled", "required", "asterisk"]), formLabelClasses_default = formLabelClasses;

// node_modules/@mui/material/esm/FormLabel/FormLabel.js
var import_jsx_runtime30 = __toESM(require_jsx_runtime()), _excluded28 = ["children", "className", "color", "component", "disabled", "error", "filled", "focused", "required"], useUtilityClasses11 = (ownerState) => {
  let {
    classes,
    color: color2,
    focused,
    disabled,
    error,
    filled,
    required
  } = ownerState, slots = {
    root: ["root", `color${capitalize_default(color2)}`, disabled && "disabled", error && "error", filled && "filled", focused && "focused", required && "required"],
    asterisk: ["asterisk", error && "error"]
  };
  return composeClasses(slots, getFormLabelUtilityClasses, classes);
}, FormLabelRoot = styled_default("label", {
  name: "MuiFormLabel",
  slot: "Root",
  overridesResolver: ({
    ownerState
  }, styles4) => _extends({}, styles4.root, ownerState.color === "secondary" && styles4.colorSecondary, ownerState.filled && styles4.filled)
})(({
  theme,
  ownerState
}) => _extends({
  color: (theme.vars || theme).palette.text.secondary
}, theme.typography.body1, {
  lineHeight: "1.4375em",
  padding: 0,
  position: "relative",
  [`&.${formLabelClasses_default.focused}`]: {
    color: (theme.vars || theme).palette[ownerState.color].main
  },
  [`&.${formLabelClasses_default.disabled}`]: {
    color: (theme.vars || theme).palette.text.disabled
  },
  [`&.${formLabelClasses_default.error}`]: {
    color: (theme.vars || theme).palette.error.main
  }
})), AsteriskComponent = styled_default("span", {
  name: "MuiFormLabel",
  slot: "Asterisk",
  overridesResolver: (props, styles4) => styles4.asterisk
})(({
  theme
}) => ({
  [`&.${formLabelClasses_default.error}`]: {
    color: (theme.vars || theme).palette.error.main
  }
})), FormLabel = /* @__PURE__ */ React46.forwardRef(function(inProps, ref) {
  let props = useThemeProps2({
    props: inProps,
    name: "MuiFormLabel"
  }), {
    children,
    className,
    component = "label"
  } = props, other = _objectWithoutPropertiesLoose2(props, _excluded28), muiFormControl = useFormControl(), fcs = formControlState({
    props,
    muiFormControl,
    states: ["color", "required", "focused", "disabled", "error", "filled"]
  }), ownerState = _extends({}, props, {
    color: fcs.color || "primary",
    component,
    disabled: fcs.disabled,
    error: fcs.error,
    filled: fcs.filled,
    focused: fcs.focused,
    required: fcs.required
  }), classes = useUtilityClasses11(ownerState);
  return /* @__PURE__ */ (0, import_jsx_runtime30.jsxs)(FormLabelRoot, _extends({
    as: component,
    ownerState,
    className: clsx_m_default(classes.root, className),
    ref
  }, other, {
    children: [children, fcs.required && /* @__PURE__ */ (0, import_jsx_runtime30.jsxs)(AsteriskComponent, {
      ownerState,
      "aria-hidden": !0,
      className: classes.asterisk,
      children: ["\u2009", "*"]
    })]
  }));
});
FormLabel.propTypes = {
  children: import_prop_types24.default.node,
  classes: import_prop_types24.default.object,
  className: import_prop_types24.default.string,
  color: import_prop_types24.default.oneOfType([import_prop_types24.default.oneOf(["error", "info", "primary", "secondary", "success", "warning"]), import_prop_types24.default.string]),
  component: import_prop_types24.default.elementType,
  disabled: import_prop_types24.default.bool,
  error: import_prop_types24.default.bool,
  filled: import_prop_types24.default.bool,
  focused: import_prop_types24.default.bool,
  required: import_prop_types24.default.bool,
  sx: import_prop_types24.default.oneOfType([import_prop_types24.default.arrayOf(import_prop_types24.default.oneOfType([import_prop_types24.default.func, import_prop_types24.default.object, import_prop_types24.default.bool])), import_prop_types24.default.func, import_prop_types24.default.object])
};
var FormLabel_default = FormLabel;

// node_modules/@mui/material/esm/TextField/TextField.js
init_extends();
init_objectWithoutPropertiesLoose();
var React70 = __toESM(require_react()), import_prop_types45 = __toESM(require_prop_types());
init_clsx_m();
init_base();
init_esm2();
init_styled();
init_useThemeProps3();

// node_modules/@mui/material/esm/Input/Input.js
init_objectWithoutPropertiesLoose();
init_extends();
var React49 = __toESM(require_react()), import_prop_types27 = __toESM(require_prop_types());
init_base();
init_esm2();

// node_modules/@mui/material/esm/InputBase/InputBase.js
init_objectWithoutPropertiesLoose();
init_extends();
var React48 = __toESM(require_react()), import_prop_types26 = __toESM(require_prop_types());
init_clsx_m();
init_esm2();
init_base();
init_styled();
init_useThemeProps3();
init_capitalize2();
init_useForkRef2();
init_useEnhancedEffect2();

// node_modules/@mui/material/esm/GlobalStyles/GlobalStyles.js
init_extends();
var React47 = __toESM(require_react()), import_prop_types25 = __toESM(require_prop_types());
init_esm3();
init_defaultTheme();
var import_jsx_runtime31 = __toESM(require_jsx_runtime());
function GlobalStyles2(props) {
  return /* @__PURE__ */ (0, import_jsx_runtime31.jsx)(GlobalStyles, _extends({}, props, {
    defaultTheme: defaultTheme_default
  }));
}
GlobalStyles2.propTypes = {
  styles: import_prop_types25.default.oneOfType([import_prop_types25.default.func, import_prop_types25.default.number, import_prop_types25.default.object, import_prop_types25.default.shape({
    __emotion_styles: import_prop_types25.default.any.isRequired
  }), import_prop_types25.default.string, import_prop_types25.default.bool])
};
var GlobalStyles_default = GlobalStyles2;

// node_modules/@mui/material/esm/InputBase/inputBaseClasses.js
init_base();
function getInputBaseUtilityClass(slot) {
  return generateUtilityClass("MuiInputBase", slot);
}
var inputBaseClasses2 = generateUtilityClasses("MuiInputBase", ["root", "formControl", "focused", "disabled", "adornedStart", "adornedEnd", "error", "sizeSmall", "multiline", "colorSecondary", "fullWidth", "hiddenLabel", "readOnly", "input", "inputSizeSmall", "inputMultiline", "inputTypeSearch", "inputAdornedStart", "inputAdornedEnd", "inputHiddenLabel"]), inputBaseClasses_default = inputBaseClasses2;

// node_modules/@mui/material/esm/InputBase/InputBase.js
var import_jsx_runtime32 = __toESM(require_jsx_runtime()), import_jsx_runtime33 = __toESM(require_jsx_runtime()), _excluded29 = ["aria-describedby", "autoComplete", "autoFocus", "className", "color", "components", "componentsProps", "defaultValue", "disabled", "disableInjectingGlobalStyles", "endAdornment", "error", "fullWidth", "id", "inputComponent", "inputProps", "inputRef", "margin", "maxRows", "minRows", "multiline", "name", "onBlur", "onChange", "onClick", "onFocus", "onKeyDown", "onKeyUp", "placeholder", "readOnly", "renderSuffix", "rows", "size", "startAdornment", "type", "value"], rootOverridesResolver = (props, styles4) => {
  let {
    ownerState
  } = props;
  return [styles4.root, ownerState.formControl && styles4.formControl, ownerState.startAdornment && styles4.adornedStart, ownerState.endAdornment && styles4.adornedEnd, ownerState.error && styles4.error, ownerState.size === "small" && styles4.sizeSmall, ownerState.multiline && styles4.multiline, ownerState.color && styles4[`color${capitalize_default(ownerState.color)}`], ownerState.fullWidth && styles4.fullWidth, ownerState.hiddenLabel && styles4.hiddenLabel];
}, inputOverridesResolver = (props, styles4) => {
  let {
    ownerState
  } = props;
  return [styles4.input, ownerState.size === "small" && styles4.inputSizeSmall, ownerState.multiline && styles4.inputMultiline, ownerState.type === "search" && styles4.inputTypeSearch, ownerState.startAdornment && styles4.inputAdornedStart, ownerState.endAdornment && styles4.inputAdornedEnd, ownerState.hiddenLabel && styles4.inputHiddenLabel];
}, useUtilityClasses12 = (ownerState) => {
  let {
    classes,
    color: color2,
    disabled,
    error,
    endAdornment,
    focused,
    formControl,
    fullWidth,
    hiddenLabel,
    multiline,
    readOnly,
    size,
    startAdornment,
    type
  } = ownerState, slots = {
    root: ["root", `color${capitalize_default(color2)}`, disabled && "disabled", error && "error", fullWidth && "fullWidth", focused && "focused", formControl && "formControl", size === "small" && "sizeSmall", multiline && "multiline", startAdornment && "adornedStart", endAdornment && "adornedEnd", hiddenLabel && "hiddenLabel", readOnly && "readOnly"],
    input: ["input", disabled && "disabled", type === "search" && "inputTypeSearch", multiline && "inputMultiline", size === "small" && "inputSizeSmall", hiddenLabel && "inputHiddenLabel", startAdornment && "inputAdornedStart", endAdornment && "inputAdornedEnd", readOnly && "readOnly"]
  };
  return composeClasses(slots, getInputBaseUtilityClass, classes);
}, InputBaseRoot = styled_default("div", {
  name: "MuiInputBase",
  slot: "Root",
  overridesResolver: rootOverridesResolver
})(({
  theme,
  ownerState
}) => _extends({}, theme.typography.body1, {
  color: (theme.vars || theme).palette.text.primary,
  lineHeight: "1.4375em",
  boxSizing: "border-box",
  position: "relative",
  cursor: "text",
  display: "inline-flex",
  alignItems: "center",
  [`&.${inputBaseClasses_default.disabled}`]: {
    color: (theme.vars || theme).palette.text.disabled,
    cursor: "default"
  }
}, ownerState.multiline && _extends({
  padding: "4px 0 5px"
}, ownerState.size === "small" && {
  paddingTop: 1
}), ownerState.fullWidth && {
  width: "100%"
})), InputBaseComponent = styled_default("input", {
  name: "MuiInputBase",
  slot: "Input",
  overridesResolver: inputOverridesResolver
})(({
  theme,
  ownerState
}) => {
  let light2 = theme.palette.mode === "light", placeholder = _extends({
    color: "currentColor"
  }, theme.vars ? {
    opacity: theme.vars.opacity.inputPlaceholder
  } : {
    opacity: light2 ? 0.42 : 0.5
  }, {
    transition: theme.transitions.create("opacity", {
      duration: theme.transitions.duration.shorter
    })
  }), placeholderHidden = {
    opacity: "0 !important"
  }, placeholderVisible = theme.vars ? {
    opacity: theme.vars.opacity.inputPlaceholder
  } : {
    opacity: light2 ? 0.42 : 0.5
  };
  return _extends({
    font: "inherit",
    letterSpacing: "inherit",
    color: "currentColor",
    padding: "4px 0 5px",
    border: 0,
    boxSizing: "content-box",
    background: "none",
    height: "1.4375em",
    margin: 0,
    WebkitTapHighlightColor: "transparent",
    display: "block",
    minWidth: 0,
    width: "100%",
    animationName: "mui-auto-fill-cancel",
    animationDuration: "10ms",
    "&::-webkit-input-placeholder": placeholder,
    "&::-moz-placeholder": placeholder,
    "&:-ms-input-placeholder": placeholder,
    "&::-ms-input-placeholder": placeholder,
    "&:focus": {
      outline: 0
    },
    "&:invalid": {
      boxShadow: "none"
    },
    "&::-webkit-search-decoration": {
      WebkitAppearance: "none"
    },
    [`label[data-shrink=false] + .${inputBaseClasses_default.formControl} &`]: {
      "&::-webkit-input-placeholder": placeholderHidden,
      "&::-moz-placeholder": placeholderHidden,
      "&:-ms-input-placeholder": placeholderHidden,
      "&::-ms-input-placeholder": placeholderHidden,
      "&:focus::-webkit-input-placeholder": placeholderVisible,
      "&:focus::-moz-placeholder": placeholderVisible,
      "&:focus:-ms-input-placeholder": placeholderVisible,
      "&:focus::-ms-input-placeholder": placeholderVisible
    },
    [`&.${inputBaseClasses_default.disabled}`]: {
      opacity: 1,
      WebkitTextFillColor: (theme.vars || theme).palette.text.disabled
    },
    "&:-webkit-autofill": {
      animationDuration: "5000s",
      animationName: "mui-auto-fill"
    }
  }, ownerState.size === "small" && {
    paddingTop: 1
  }, ownerState.multiline && {
    height: "auto",
    resize: "none",
    padding: 0,
    paddingTop: 0
  }, ownerState.type === "search" && {
    MozAppearance: "textfield"
  });
}), inputGlobalStyles = /* @__PURE__ */ (0, import_jsx_runtime32.jsx)(GlobalStyles_default, {
  styles: {
    "@keyframes mui-auto-fill": {
      from: {
        display: "block"
      }
    },
    "@keyframes mui-auto-fill-cancel": {
      from: {
        display: "block"
      }
    }
  }
}), InputBase = /* @__PURE__ */ React48.forwardRef(function(inProps, ref) {
  let props = useThemeProps2({
    props: inProps,
    name: "MuiInputBase"
  }), {
    "aria-describedby": ariaDescribedby,
    autoComplete,
    autoFocus,
    className,
    components = {},
    componentsProps = {},
    defaultValue,
    disabled,
    disableInjectingGlobalStyles,
    endAdornment,
    fullWidth = !1,
    id,
    inputComponent = "input",
    inputProps: inputPropsProp = {},
    inputRef: inputRefProp,
    maxRows,
    minRows,
    multiline = !1,
    name,
    onBlur,
    onChange,
    onClick,
    onFocus,
    onKeyDown,
    onKeyUp,
    placeholder,
    readOnly,
    renderSuffix,
    rows,
    startAdornment,
    type = "text",
    value: valueProp
  } = props, other = _objectWithoutPropertiesLoose2(props, _excluded29), value = inputPropsProp.value != null ? inputPropsProp.value : valueProp, {
    current: isControlled
  } = React48.useRef(value != null), inputRef = React48.useRef(), handleInputRefWarning = React48.useCallback((instance) => {
    instance && instance.nodeName !== "INPUT" && !instance.focus && console.error(["MUI: You have provided a `inputComponent` to the input component", "that does not correctly handle the `ref` prop.", "Make sure the `ref` prop is called with a HTMLInputElement."].join(`
`));
  }, []), handleInputPropsRefProp = useForkRef_default(inputPropsProp.ref, handleInputRefWarning), handleInputRefProp = useForkRef_default(inputRefProp, handleInputPropsRefProp), handleInputRef = useForkRef_default(inputRef, handleInputRefProp), [focused, setFocused] = React48.useState(!1), muiFormControl = useFormControl();
  React48.useEffect(() => {
    if (muiFormControl)
      return muiFormControl.registerEffect();
  }, [muiFormControl]);
  let fcs = formControlState({
    props,
    muiFormControl,
    states: ["color", "disabled", "error", "hiddenLabel", "size", "required", "filled"]
  });
  fcs.focused = muiFormControl ? muiFormControl.focused : focused, React48.useEffect(() => {
    !muiFormControl && disabled && focused && (setFocused(!1), onBlur && onBlur());
  }, [muiFormControl, disabled, focused, onBlur]);
  let onFilled = muiFormControl && muiFormControl.onFilled, onEmpty = muiFormControl && muiFormControl.onEmpty, checkDirty = React48.useCallback((obj) => {
    isFilled(obj) ? onFilled && onFilled() : onEmpty && onEmpty();
  }, [onFilled, onEmpty]);
  useEnhancedEffect_default2(() => {
    isControlled && checkDirty({
      value
    });
  }, [value, checkDirty, isControlled]);
  let handleFocus = (event) => {
    if (fcs.disabled) {
      event.stopPropagation();
      return;
    }
    onFocus && onFocus(event), inputPropsProp.onFocus && inputPropsProp.onFocus(event), muiFormControl && muiFormControl.onFocus ? muiFormControl.onFocus(event) : setFocused(!0);
  }, handleBlur = (event) => {
    onBlur && onBlur(event), inputPropsProp.onBlur && inputPropsProp.onBlur(event), muiFormControl && muiFormControl.onBlur ? muiFormControl.onBlur(event) : setFocused(!1);
  }, handleChange = (event, ...args) => {
    if (!isControlled) {
      let element = event.target || inputRef.current;
      if (element == null)
        throw new Error("MUI: Expected valid input target. Did you use a custom `inputComponent` and forget to forward refs? See https://mui.com/r/input-component-ref-interface for more info.");
      checkDirty({
        value: element.value
      });
    }
    inputPropsProp.onChange && inputPropsProp.onChange(event, ...args), onChange && onChange(event, ...args);
  };
  React48.useEffect(() => {
    checkDirty(inputRef.current);
  }, []);
  let handleClick = (event) => {
    inputRef.current && event.currentTarget === event.target && inputRef.current.focus(), onClick && onClick(event);
  }, InputComponent = inputComponent, inputProps = inputPropsProp;
  multiline && InputComponent === "input" && (rows ? ((minRows || maxRows) && console.warn("MUI: You can not use the `minRows` or `maxRows` props when the input `rows` prop is set."), inputProps = _extends({
    type: void 0,
    minRows: rows,
    maxRows: rows
  }, inputProps)) : inputProps = _extends({
    type: void 0,
    maxRows,
    minRows
  }, inputProps), InputComponent = TextareaAutosize_default);
  let handleAutoFill = (event) => {
    checkDirty(event.animationName === "mui-auto-fill-cancel" ? inputRef.current : {
      value: "x"
    });
  };
  React48.useEffect(() => {
    muiFormControl && muiFormControl.setAdornedStart(Boolean(startAdornment));
  }, [muiFormControl, startAdornment]);
  let ownerState = _extends({}, props, {
    color: fcs.color || "primary",
    disabled: fcs.disabled,
    endAdornment,
    error: fcs.error,
    focused: fcs.focused,
    formControl: muiFormControl,
    fullWidth,
    hiddenLabel: fcs.hiddenLabel,
    multiline,
    size: fcs.size,
    startAdornment,
    type
  }), classes = useUtilityClasses12(ownerState), Root = components.Root || InputBaseRoot, rootProps = componentsProps.root || {}, Input3 = components.Input || InputBaseComponent;
  return inputProps = _extends({}, inputProps, componentsProps.input), /* @__PURE__ */ (0, import_jsx_runtime33.jsxs)(React48.Fragment, {
    children: [!disableInjectingGlobalStyles && inputGlobalStyles, /* @__PURE__ */ (0, import_jsx_runtime33.jsxs)(Root, _extends({}, rootProps, !isHostComponent_default(Root) && {
      ownerState: _extends({}, ownerState, rootProps.ownerState)
    }, {
      ref,
      onClick: handleClick
    }, other, {
      className: clsx_m_default(classes.root, rootProps.className, className),
      children: [startAdornment, /* @__PURE__ */ (0, import_jsx_runtime32.jsx)(FormControlContext_default.Provider, {
        value: null,
        children: /* @__PURE__ */ (0, import_jsx_runtime32.jsx)(Input3, _extends({
          ownerState,
          "aria-invalid": fcs.error,
          "aria-describedby": ariaDescribedby,
          autoComplete,
          autoFocus,
          defaultValue,
          disabled: fcs.disabled,
          id,
          onAnimationStart: handleAutoFill,
          name,
          placeholder,
          readOnly,
          required: fcs.required,
          rows,
          value,
          onKeyDown,
          onKeyUp,
          type
        }, inputProps, !isHostComponent_default(Input3) && {
          as: InputComponent,
          ownerState: _extends({}, ownerState, inputProps.ownerState)
        }, {
          ref: handleInputRef,
          className: clsx_m_default(classes.input, inputProps.className),
          onBlur: handleBlur,
          onChange: handleChange,
          onFocus: handleFocus
        }))
      }), endAdornment, renderSuffix ? renderSuffix(_extends({}, fcs, {
        startAdornment
      })) : null]
    }))]
  });
});
InputBase.propTypes = {
  "aria-describedby": import_prop_types26.default.string,
  autoComplete: import_prop_types26.default.string,
  autoFocus: import_prop_types26.default.bool,
  classes: import_prop_types26.default.object,
  className: import_prop_types26.default.string,
  color: import_prop_types26.default.oneOfType([import_prop_types26.default.oneOf(["primary", "secondary", "error", "info", "success", "warning"]), import_prop_types26.default.string]),
  components: import_prop_types26.default.shape({
    Input: import_prop_types26.default.elementType,
    Root: import_prop_types26.default.elementType
  }),
  componentsProps: import_prop_types26.default.shape({
    input: import_prop_types26.default.object,
    root: import_prop_types26.default.object
  }),
  defaultValue: import_prop_types26.default.any,
  disabled: import_prop_types26.default.bool,
  disableInjectingGlobalStyles: import_prop_types26.default.bool,
  endAdornment: import_prop_types26.default.node,
  error: import_prop_types26.default.bool,
  fullWidth: import_prop_types26.default.bool,
  id: import_prop_types26.default.string,
  inputComponent: elementTypeAcceptingRef_default,
  inputProps: import_prop_types26.default.object,
  inputRef: refType_default,
  margin: import_prop_types26.default.oneOf(["dense", "none"]),
  maxRows: import_prop_types26.default.oneOfType([import_prop_types26.default.number, import_prop_types26.default.string]),
  minRows: import_prop_types26.default.oneOfType([import_prop_types26.default.number, import_prop_types26.default.string]),
  multiline: import_prop_types26.default.bool,
  name: import_prop_types26.default.string,
  onBlur: import_prop_types26.default.func,
  onChange: import_prop_types26.default.func,
  onClick: import_prop_types26.default.func,
  onFocus: import_prop_types26.default.func,
  onKeyDown: import_prop_types26.default.func,
  onKeyUp: import_prop_types26.default.func,
  placeholder: import_prop_types26.default.string,
  readOnly: import_prop_types26.default.bool,
  renderSuffix: import_prop_types26.default.func,
  required: import_prop_types26.default.bool,
  rows: import_prop_types26.default.oneOfType([import_prop_types26.default.number, import_prop_types26.default.string]),
  size: import_prop_types26.default.oneOfType([import_prop_types26.default.oneOf(["medium", "small"]), import_prop_types26.default.string]),
  startAdornment: import_prop_types26.default.node,
  sx: import_prop_types26.default.oneOfType([import_prop_types26.default.arrayOf(import_prop_types26.default.oneOfType([import_prop_types26.default.func, import_prop_types26.default.object, import_prop_types26.default.bool])), import_prop_types26.default.func, import_prop_types26.default.object]),
  type: import_prop_types26.default.string,
  value: import_prop_types26.default.any
};
var InputBase_default = InputBase;

// node_modules/@mui/material/esm/Input/Input.js
init_styled();
init_useThemeProps3();

// node_modules/@mui/material/esm/Input/inputClasses.js
init_extends();
init_base();
function getInputUtilityClass(slot) {
  return generateUtilityClass("MuiInput", slot);
}
var inputClasses = _extends({}, inputBaseClasses_default, generateUtilityClasses("MuiInput", ["root", "underline", "input"])), inputClasses_default = inputClasses;

// node_modules/@mui/material/esm/Input/Input.js
var import_jsx_runtime34 = __toESM(require_jsx_runtime()), _excluded30 = ["disableUnderline", "components", "componentsProps", "fullWidth", "inputComponent", "multiline", "type"], useUtilityClasses13 = (ownerState) => {
  let {
    classes,
    disableUnderline
  } = ownerState, composedClasses = composeClasses({
    root: ["root", !disableUnderline && "underline"],
    input: ["input"]
  }, getInputUtilityClass, classes);
  return _extends({}, classes, composedClasses);
}, InputRoot = styled_default(InputBaseRoot, {
  shouldForwardProp: (prop) => rootShouldForwardProp(prop) || prop === "classes",
  name: "MuiInput",
  slot: "Root",
  overridesResolver: (props, styles4) => {
    let {
      ownerState
    } = props;
    return [...rootOverridesResolver(props, styles4), !ownerState.disableUnderline && styles4.underline];
  }
})(({
  theme,
  ownerState
}) => {
  let bottomLineColor = theme.palette.mode === "light" ? "rgba(0, 0, 0, 0.42)" : "rgba(255, 255, 255, 0.7)";
  return theme.vars && (bottomLineColor = `rgba(${theme.vars.palette.common.onBackgroundChannel} / ${theme.vars.opacity.inputUnderline})`), _extends({
    position: "relative"
  }, ownerState.formControl && {
    "label + &": {
      marginTop: 16
    }
  }, !ownerState.disableUnderline && {
    "&:after": {
      borderBottom: `2px solid ${(theme.vars || theme).palette[ownerState.color].main}`,
      left: 0,
      bottom: 0,
      content: '""',
      position: "absolute",
      right: 0,
      transform: "scaleX(0)",
      transition: theme.transitions.create("transform", {
        duration: theme.transitions.duration.shorter,
        easing: theme.transitions.easing.easeOut
      }),
      pointerEvents: "none"
    },
    [`&.${inputClasses_default.focused}:after`]: {
      transform: "scaleX(1) translateX(0)"
    },
    [`&.${inputClasses_default.error}:after`]: {
      borderBottomColor: (theme.vars || theme).palette.error.main,
      transform: "scaleX(1)"
    },
    "&:before": {
      borderBottom: `1px solid ${bottomLineColor}`,
      left: 0,
      bottom: 0,
      content: '"\\00a0"',
      position: "absolute",
      right: 0,
      transition: theme.transitions.create("border-bottom-color", {
        duration: theme.transitions.duration.shorter
      }),
      pointerEvents: "none"
    },
    [`&:hover:not(.${inputClasses_default.disabled}):before`]: {
      borderBottom: `2px solid ${(theme.vars || theme).palette.text.primary}`,
      "@media (hover: none)": {
        borderBottom: `1px solid ${bottomLineColor}`
      }
    },
    [`&.${inputClasses_default.disabled}:before`]: {
      borderBottomStyle: "dotted"
    }
  });
}), InputInput = styled_default(InputBaseComponent, {
  name: "MuiInput",
  slot: "Input",
  overridesResolver: inputOverridesResolver
})({}), Input = /* @__PURE__ */ React49.forwardRef(function(inProps, ref) {
  let props = useThemeProps2({
    props: inProps,
    name: "MuiInput"
  }), {
    disableUnderline,
    components = {},
    componentsProps: componentsPropsProp,
    fullWidth = !1,
    inputComponent = "input",
    multiline = !1,
    type = "text"
  } = props, other = _objectWithoutPropertiesLoose2(props, _excluded30), classes = useUtilityClasses13(props), inputComponentsProps = {
    root: {
      ownerState: {
        disableUnderline
      }
    }
  }, componentsProps = componentsPropsProp ? deepmerge(componentsPropsProp, inputComponentsProps) : inputComponentsProps;
  return /* @__PURE__ */ (0, import_jsx_runtime34.jsx)(InputBase_default, _extends({
    components: _extends({
      Root: InputRoot,
      Input: InputInput
    }, components),
    componentsProps,
    fullWidth,
    inputComponent,
    multiline,
    ref,
    type
  }, other, {
    classes
  }));
});
Input.propTypes = {
  autoComplete: import_prop_types27.default.string,
  autoFocus: import_prop_types27.default.bool,
  classes: import_prop_types27.default.object,
  color: import_prop_types27.default.oneOfType([import_prop_types27.default.oneOf(["primary", "secondary"]), import_prop_types27.default.string]),
  components: import_prop_types27.default.shape({
    Input: import_prop_types27.default.elementType,
    Root: import_prop_types27.default.elementType
  }),
  componentsProps: import_prop_types27.default.shape({
    input: import_prop_types27.default.object,
    root: import_prop_types27.default.object
  }),
  defaultValue: import_prop_types27.default.any,
  disabled: import_prop_types27.default.bool,
  disableUnderline: import_prop_types27.default.bool,
  endAdornment: import_prop_types27.default.node,
  error: import_prop_types27.default.bool,
  fullWidth: import_prop_types27.default.bool,
  id: import_prop_types27.default.string,
  inputComponent: import_prop_types27.default.elementType,
  inputProps: import_prop_types27.default.object,
  inputRef: refType_default,
  margin: import_prop_types27.default.oneOf(["dense", "none"]),
  maxRows: import_prop_types27.default.oneOfType([import_prop_types27.default.number, import_prop_types27.default.string]),
  minRows: import_prop_types27.default.oneOfType([import_prop_types27.default.number, import_prop_types27.default.string]),
  multiline: import_prop_types27.default.bool,
  name: import_prop_types27.default.string,
  onChange: import_prop_types27.default.func,
  placeholder: import_prop_types27.default.string,
  readOnly: import_prop_types27.default.bool,
  required: import_prop_types27.default.bool,
  rows: import_prop_types27.default.oneOfType([import_prop_types27.default.number, import_prop_types27.default.string]),
  startAdornment: import_prop_types27.default.node,
  sx: import_prop_types27.default.oneOfType([import_prop_types27.default.arrayOf(import_prop_types27.default.oneOfType([import_prop_types27.default.func, import_prop_types27.default.object, import_prop_types27.default.bool])), import_prop_types27.default.func, import_prop_types27.default.object]),
  type: import_prop_types27.default.string,
  value: import_prop_types27.default.any
};
Input.muiName = "Input";
var Input_default = Input;

// node_modules/@mui/material/esm/FilledInput/FilledInput.js
init_objectWithoutPropertiesLoose();
init_extends();
var React50 = __toESM(require_react());
init_esm2();
var import_prop_types28 = __toESM(require_prop_types());
init_base();
init_styled();
init_useThemeProps3();

// node_modules/@mui/material/esm/FilledInput/filledInputClasses.js
init_extends();
init_base();
function getFilledInputUtilityClass(slot) {
  return generateUtilityClass("MuiFilledInput", slot);
}
var filledInputClasses = _extends({}, inputBaseClasses_default, generateUtilityClasses("MuiFilledInput", ["root", "underline", "input"])), filledInputClasses_default = filledInputClasses;

// node_modules/@mui/material/esm/FilledInput/FilledInput.js
var import_jsx_runtime35 = __toESM(require_jsx_runtime()), _excluded31 = ["disableUnderline", "components", "componentsProps", "fullWidth", "hiddenLabel", "inputComponent", "multiline", "type"], useUtilityClasses14 = (ownerState) => {
  let {
    classes,
    disableUnderline
  } = ownerState, composedClasses = composeClasses({
    root: ["root", !disableUnderline && "underline"],
    input: ["input"]
  }, getFilledInputUtilityClass, classes);
  return _extends({}, classes, composedClasses);
}, FilledInputRoot = styled_default(InputBaseRoot, {
  shouldForwardProp: (prop) => rootShouldForwardProp(prop) || prop === "classes",
  name: "MuiFilledInput",
  slot: "Root",
  overridesResolver: (props, styles4) => {
    let {
      ownerState
    } = props;
    return [...rootOverridesResolver(props, styles4), !ownerState.disableUnderline && styles4.underline];
  }
})(({
  theme,
  ownerState
}) => {
  var _palette;
  let light2 = theme.palette.mode === "light", bottomLineColor = light2 ? "rgba(0, 0, 0, 0.42)" : "rgba(255, 255, 255, 0.7)", backgroundColor2 = light2 ? "rgba(0, 0, 0, 0.06)" : "rgba(255, 255, 255, 0.09)", hoverBackground = light2 ? "rgba(0, 0, 0, 0.09)" : "rgba(255, 255, 255, 0.13)", disabledBackground = light2 ? "rgba(0, 0, 0, 0.12)" : "rgba(255, 255, 255, 0.12)";
  return _extends({
    position: "relative",
    backgroundColor: theme.vars ? theme.vars.palette.FilledInput.bg : backgroundColor2,
    borderTopLeftRadius: (theme.vars || theme).shape.borderRadius,
    borderTopRightRadius: (theme.vars || theme).shape.borderRadius,
    transition: theme.transitions.create("background-color", {
      duration: theme.transitions.duration.shorter,
      easing: theme.transitions.easing.easeOut
    }),
    "&:hover": {
      backgroundColor: theme.vars ? theme.vars.palette.FilledInput.hoverBg : hoverBackground,
      "@media (hover: none)": {
        backgroundColor: theme.vars ? theme.vars.palette.FilledInput.bg : backgroundColor2
      }
    },
    [`&.${filledInputClasses_default.focused}`]: {
      backgroundColor: theme.vars ? theme.vars.palette.FilledInput.bg : backgroundColor2
    },
    [`&.${filledInputClasses_default.disabled}`]: {
      backgroundColor: theme.vars ? theme.vars.palette.FilledInput.disabledBg : disabledBackground
    }
  }, !ownerState.disableUnderline && {
    "&:after": {
      borderBottom: `2px solid ${(_palette = (theme.vars || theme).palette[ownerState.color || "primary"]) == null ? void 0 : _palette.main}`,
      left: 0,
      bottom: 0,
      content: '""',
      position: "absolute",
      right: 0,
      transform: "scaleX(0)",
      transition: theme.transitions.create("transform", {
        duration: theme.transitions.duration.shorter,
        easing: theme.transitions.easing.easeOut
      }),
      pointerEvents: "none"
    },
    [`&.${filledInputClasses_default.focused}:after`]: {
      transform: "scaleX(1) translateX(0)"
    },
    [`&.${filledInputClasses_default.error}:after`]: {
      borderBottomColor: (theme.vars || theme).palette.error.main,
      transform: "scaleX(1)"
    },
    "&:before": {
      borderBottom: `1px solid ${theme.vars ? `rgba(${theme.vars.palette.common.onBackgroundChannel} / ${theme.vars.opacity.inputUnderline})` : bottomLineColor}`,
      left: 0,
      bottom: 0,
      content: '"\\00a0"',
      position: "absolute",
      right: 0,
      transition: theme.transitions.create("border-bottom-color", {
        duration: theme.transitions.duration.shorter
      }),
      pointerEvents: "none"
    },
    [`&:hover:not(.${filledInputClasses_default.disabled}):before`]: {
      borderBottom: `1px solid ${(theme.vars || theme).palette.text.primary}`
    },
    [`&.${filledInputClasses_default.disabled}:before`]: {
      borderBottomStyle: "dotted"
    }
  }, ownerState.startAdornment && {
    paddingLeft: 12
  }, ownerState.endAdornment && {
    paddingRight: 12
  }, ownerState.multiline && _extends({
    padding: "25px 12px 8px"
  }, ownerState.size === "small" && {
    paddingTop: 21,
    paddingBottom: 4
  }, ownerState.hiddenLabel && {
    paddingTop: 16,
    paddingBottom: 17
  }));
}), FilledInputInput = styled_default(InputBaseComponent, {
  name: "MuiFilledInput",
  slot: "Input",
  overridesResolver: inputOverridesResolver
})(({
  theme,
  ownerState
}) => _extends({
  paddingTop: 25,
  paddingRight: 12,
  paddingBottom: 8,
  paddingLeft: 12
}, !theme.vars && {
  "&:-webkit-autofill": {
    WebkitBoxShadow: theme.palette.mode === "light" ? null : "0 0 0 100px #266798 inset",
    WebkitTextFillColor: theme.palette.mode === "light" ? null : "#fff",
    caretColor: theme.palette.mode === "light" ? null : "#fff",
    borderTopLeftRadius: "inherit",
    borderTopRightRadius: "inherit"
  }
}, theme.vars && {
  "&:-webkit-autofill": {
    borderTopLeftRadius: "inherit",
    borderTopRightRadius: "inherit"
  },
  [theme.getColorSchemeSelector("dark")]: {
    "&:-webkit-autofill": {
      WebkitBoxShadow: "0 0 0 100px #266798 inset",
      WebkitTextFillColor: "#fff",
      caretColor: "#fff"
    }
  }
}, ownerState.size === "small" && {
  paddingTop: 21,
  paddingBottom: 4
}, ownerState.hiddenLabel && {
  paddingTop: 16,
  paddingBottom: 17
}, ownerState.multiline && {
  paddingTop: 0,
  paddingBottom: 0,
  paddingLeft: 0,
  paddingRight: 0
}, ownerState.startAdornment && {
  paddingLeft: 0
}, ownerState.endAdornment && {
  paddingRight: 0
}, ownerState.hiddenLabel && ownerState.size === "small" && {
  paddingTop: 8,
  paddingBottom: 9
})), FilledInput = /* @__PURE__ */ React50.forwardRef(function(inProps, ref) {
  let props = useThemeProps2({
    props: inProps,
    name: "MuiFilledInput"
  }), {
    components = {},
    componentsProps: componentsPropsProp,
    fullWidth = !1,
    inputComponent = "input",
    multiline = !1,
    type = "text"
  } = props, other = _objectWithoutPropertiesLoose2(props, _excluded31), ownerState = _extends({}, props, {
    fullWidth,
    inputComponent,
    multiline,
    type
  }), classes = useUtilityClasses14(props), filledInputComponentsProps = {
    root: {
      ownerState
    },
    input: {
      ownerState
    }
  }, componentsProps = componentsPropsProp ? deepmerge(componentsPropsProp, filledInputComponentsProps) : filledInputComponentsProps;
  return /* @__PURE__ */ (0, import_jsx_runtime35.jsx)(InputBase_default, _extends({
    components: _extends({
      Root: FilledInputRoot,
      Input: FilledInputInput
    }, components),
    componentsProps,
    fullWidth,
    inputComponent,
    multiline,
    ref,
    type
  }, other, {
    classes
  }));
});
FilledInput.propTypes = {
  autoComplete: import_prop_types28.default.string,
  autoFocus: import_prop_types28.default.bool,
  classes: import_prop_types28.default.object,
  color: import_prop_types28.default.oneOfType([import_prop_types28.default.oneOf(["primary", "secondary"]), import_prop_types28.default.string]),
  components: import_prop_types28.default.shape({
    Input: import_prop_types28.default.elementType,
    Root: import_prop_types28.default.elementType
  }),
  componentsProps: import_prop_types28.default.shape({
    input: import_prop_types28.default.object,
    root: import_prop_types28.default.object
  }),
  defaultValue: import_prop_types28.default.any,
  disabled: import_prop_types28.default.bool,
  disableUnderline: import_prop_types28.default.bool,
  endAdornment: import_prop_types28.default.node,
  error: import_prop_types28.default.bool,
  fullWidth: import_prop_types28.default.bool,
  hiddenLabel: import_prop_types28.default.bool,
  id: import_prop_types28.default.string,
  inputComponent: import_prop_types28.default.elementType,
  inputProps: import_prop_types28.default.object,
  inputRef: refType_default,
  margin: import_prop_types28.default.oneOf(["dense", "none"]),
  maxRows: import_prop_types28.default.oneOfType([import_prop_types28.default.number, import_prop_types28.default.string]),
  minRows: import_prop_types28.default.oneOfType([import_prop_types28.default.number, import_prop_types28.default.string]),
  multiline: import_prop_types28.default.bool,
  name: import_prop_types28.default.string,
  onChange: import_prop_types28.default.func,
  placeholder: import_prop_types28.default.string,
  readOnly: import_prop_types28.default.bool,
  required: import_prop_types28.default.bool,
  rows: import_prop_types28.default.oneOfType([import_prop_types28.default.number, import_prop_types28.default.string]),
  startAdornment: import_prop_types28.default.node,
  sx: import_prop_types28.default.oneOfType([import_prop_types28.default.arrayOf(import_prop_types28.default.oneOfType([import_prop_types28.default.func, import_prop_types28.default.object, import_prop_types28.default.bool])), import_prop_types28.default.func, import_prop_types28.default.object]),
  type: import_prop_types28.default.string,
  value: import_prop_types28.default.any
};
FilledInput.muiName = "Input";
var FilledInput_default = FilledInput;

// node_modules/@mui/material/esm/OutlinedInput/OutlinedInput.js
init_objectWithoutPropertiesLoose();
init_extends();
var React52 = __toESM(require_react()), import_prop_types30 = __toESM(require_prop_types());
init_esm2();
init_base();

// node_modules/@mui/material/esm/OutlinedInput/NotchedOutline.js
init_objectWithoutPropertiesLoose();
init_extends();
var React51 = __toESM(require_react()), import_prop_types29 = __toESM(require_prop_types());
init_styled();
var import_jsx_runtime36 = __toESM(require_jsx_runtime()), _span, _excluded33 = ["children", "classes", "className", "label", "notched"], NotchedOutlineRoot = styled_default("fieldset")({
  textAlign: "left",
  position: "absolute",
  bottom: 0,
  right: 0,
  top: -5,
  left: 0,
  margin: 0,
  padding: "0 8px",
  pointerEvents: "none",
  borderRadius: "inherit",
  borderStyle: "solid",
  borderWidth: 1,
  overflow: "hidden",
  minWidth: "0%"
}), NotchedOutlineLegend = styled_default("legend")(({
  ownerState,
  theme
}) => _extends({
  float: "unset",
  overflow: "hidden"
}, !ownerState.withLabel && {
  padding: 0,
  lineHeight: "11px",
  transition: theme.transitions.create("width", {
    duration: 150,
    easing: theme.transitions.easing.easeOut
  })
}, ownerState.withLabel && _extends({
  display: "block",
  width: "auto",
  padding: 0,
  height: 11,
  fontSize: "0.75em",
  visibility: "hidden",
  maxWidth: 0.01,
  transition: theme.transitions.create("max-width", {
    duration: 50,
    easing: theme.transitions.easing.easeOut
  }),
  whiteSpace: "nowrap",
  "& > span": {
    paddingLeft: 5,
    paddingRight: 5,
    display: "inline-block",
    opacity: 0,
    visibility: "visible"
  }
}, ownerState.notched && {
  maxWidth: "100%",
  transition: theme.transitions.create("max-width", {
    duration: 100,
    easing: theme.transitions.easing.easeOut,
    delay: 50
  })
})));
function NotchedOutline(props) {
  let {
    className,
    label,
    notched
  } = props, other = _objectWithoutPropertiesLoose2(props, _excluded33), withLabel = label != null && label !== "", ownerState = _extends({}, props, {
    notched,
    withLabel
  });
  return /* @__PURE__ */ (0, import_jsx_runtime36.jsx)(NotchedOutlineRoot, _extends({
    "aria-hidden": !0,
    className,
    ownerState
  }, other, {
    children: /* @__PURE__ */ (0, import_jsx_runtime36.jsx)(NotchedOutlineLegend, {
      ownerState,
      children: withLabel ? /* @__PURE__ */ (0, import_jsx_runtime36.jsx)("span", {
        children: label
      }) : _span || (_span = /* @__PURE__ */ (0, import_jsx_runtime36.jsx)("span", {
        className: "notranslate",
        children: "\u200B"
      }))
    })
  }));
}
NotchedOutline.propTypes = {
  children: import_prop_types29.default.node,
  classes: import_prop_types29.default.object,
  className: import_prop_types29.default.string,
  label: import_prop_types29.default.node,
  notched: import_prop_types29.default.bool.isRequired,
  style: import_prop_types29.default.object
};

// node_modules/@mui/material/esm/OutlinedInput/OutlinedInput.js
init_styled();

// node_modules/@mui/material/esm/OutlinedInput/outlinedInputClasses.js
init_extends();
init_base();
function getOutlinedInputUtilityClass(slot) {
  return generateUtilityClass("MuiOutlinedInput", slot);
}
var outlinedInputClasses = _extends({}, inputBaseClasses_default, generateUtilityClasses("MuiOutlinedInput", ["root", "notchedOutline", "input"])), outlinedInputClasses_default = outlinedInputClasses;

// node_modules/@mui/material/esm/OutlinedInput/OutlinedInput.js
init_useThemeProps3();
var import_jsx_runtime37 = __toESM(require_jsx_runtime()), import_jsx_runtime38 = __toESM(require_jsx_runtime()), _excluded34 = ["components", "fullWidth", "inputComponent", "label", "multiline", "notched", "type"], useUtilityClasses15 = (ownerState) => {
  let {
    classes
  } = ownerState, composedClasses = composeClasses({
    root: ["root"],
    notchedOutline: ["notchedOutline"],
    input: ["input"]
  }, getOutlinedInputUtilityClass, classes);
  return _extends({}, classes, composedClasses);
}, OutlinedInputRoot = styled_default(InputBaseRoot, {
  shouldForwardProp: (prop) => rootShouldForwardProp(prop) || prop === "classes",
  name: "MuiOutlinedInput",
  slot: "Root",
  overridesResolver: rootOverridesResolver
})(({
  theme,
  ownerState
}) => {
  let borderColor2 = theme.palette.mode === "light" ? "rgba(0, 0, 0, 0.23)" : "rgba(255, 255, 255, 0.23)";
  return _extends({
    position: "relative",
    borderRadius: (theme.vars || theme).shape.borderRadius,
    [`&:hover .${outlinedInputClasses_default.notchedOutline}`]: {
      borderColor: (theme.vars || theme).palette.text.primary
    },
    "@media (hover: none)": {
      [`&:hover .${outlinedInputClasses_default.notchedOutline}`]: {
        borderColor: theme.vars ? `rgba(${theme.vars.palette.common.onBackgroundChannel} / 0.23)` : borderColor2
      }
    },
    [`&.${outlinedInputClasses_default.focused} .${outlinedInputClasses_default.notchedOutline}`]: {
      borderColor: (theme.vars || theme).palette[ownerState.color].main,
      borderWidth: 2
    },
    [`&.${outlinedInputClasses_default.error} .${outlinedInputClasses_default.notchedOutline}`]: {
      borderColor: (theme.vars || theme).palette.error.main
    },
    [`&.${outlinedInputClasses_default.disabled} .${outlinedInputClasses_default.notchedOutline}`]: {
      borderColor: (theme.vars || theme).palette.action.disabled
    }
  }, ownerState.startAdornment && {
    paddingLeft: 14
  }, ownerState.endAdornment && {
    paddingRight: 14
  }, ownerState.multiline && _extends({
    padding: "16.5px 14px"
  }, ownerState.size === "small" && {
    padding: "8.5px 14px"
  }));
}), NotchedOutlineRoot2 = styled_default(NotchedOutline, {
  name: "MuiOutlinedInput",
  slot: "NotchedOutline",
  overridesResolver: (props, styles4) => styles4.notchedOutline
})(({
  theme
}) => {
  let borderColor2 = theme.palette.mode === "light" ? "rgba(0, 0, 0, 0.23)" : "rgba(255, 255, 255, 0.23)";
  return {
    borderColor: theme.vars ? `rgba(${theme.vars.palette.common.onBackgroundChannel} / 0.23)` : borderColor2
  };
}), OutlinedInputInput = styled_default(InputBaseComponent, {
  name: "MuiOutlinedInput",
  slot: "Input",
  overridesResolver: inputOverridesResolver
})(({
  theme,
  ownerState
}) => _extends({
  padding: "16.5px 14px"
}, !theme.vars && {
  "&:-webkit-autofill": {
    WebkitBoxShadow: theme.palette.mode === "light" ? null : "0 0 0 100px #266798 inset",
    WebkitTextFillColor: theme.palette.mode === "light" ? null : "#fff",
    caretColor: theme.palette.mode === "light" ? null : "#fff",
    borderRadius: "inherit"
  }
}, theme.vars && {
  "&:-webkit-autofill": {
    borderRadius: "inherit"
  },
  [theme.getColorSchemeSelector("dark")]: {
    "&:-webkit-autofill": {
      WebkitBoxShadow: "0 0 0 100px #266798 inset",
      WebkitTextFillColor: "#fff",
      caretColor: "#fff"
    }
  }
}, ownerState.size === "small" && {
  padding: "8.5px 14px"
}, ownerState.multiline && {
  padding: 0
}, ownerState.startAdornment && {
  paddingLeft: 0
}, ownerState.endAdornment && {
  paddingRight: 0
})), OutlinedInput = /* @__PURE__ */ React52.forwardRef(function(inProps, ref) {
  var _React$Fragment;
  let props = useThemeProps2({
    props: inProps,
    name: "MuiOutlinedInput"
  }), {
    components = {},
    fullWidth = !1,
    inputComponent = "input",
    label,
    multiline = !1,
    notched,
    type = "text"
  } = props, other = _objectWithoutPropertiesLoose2(props, _excluded34), classes = useUtilityClasses15(props), muiFormControl = useFormControl(), fcs = formControlState({
    props,
    muiFormControl,
    states: ["required"]
  }), ownerState = _extends({}, props, {
    color: fcs.color || "primary",
    disabled: fcs.disabled,
    error: fcs.error,
    focused: fcs.focused,
    formControl: muiFormControl,
    fullWidth,
    hiddenLabel: fcs.hiddenLabel,
    multiline,
    size: fcs.size,
    type
  });
  return /* @__PURE__ */ (0, import_jsx_runtime38.jsx)(InputBase_default, _extends({
    components: _extends({
      Root: OutlinedInputRoot,
      Input: OutlinedInputInput
    }, components),
    renderSuffix: (state) => /* @__PURE__ */ (0, import_jsx_runtime38.jsx)(NotchedOutlineRoot2, {
      ownerState,
      className: classes.notchedOutline,
      label: label != null && label !== "" && fcs.required ? _React$Fragment || (_React$Fragment = /* @__PURE__ */ (0, import_jsx_runtime37.jsxs)(React52.Fragment, {
        children: [label, "\xA0", "*"]
      })) : label,
      notched: typeof notched < "u" ? notched : Boolean(state.startAdornment || state.filled || state.focused)
    }),
    fullWidth,
    inputComponent,
    multiline,
    ref,
    type
  }, other, {
    classes: _extends({}, classes, {
      notchedOutline: null
    })
  }));
});
OutlinedInput.propTypes = {
  autoComplete: import_prop_types30.default.string,
  autoFocus: import_prop_types30.default.bool,
  classes: import_prop_types30.default.object,
  color: import_prop_types30.default.oneOfType([import_prop_types30.default.oneOf(["primary", "secondary"]), import_prop_types30.default.string]),
  components: import_prop_types30.default.shape({
    Input: import_prop_types30.default.elementType,
    Root: import_prop_types30.default.elementType
  }),
  defaultValue: import_prop_types30.default.any,
  disabled: import_prop_types30.default.bool,
  endAdornment: import_prop_types30.default.node,
  error: import_prop_types30.default.bool,
  fullWidth: import_prop_types30.default.bool,
  id: import_prop_types30.default.string,
  inputComponent: import_prop_types30.default.elementType,
  inputProps: import_prop_types30.default.object,
  inputRef: refType_default,
  label: import_prop_types30.default.node,
  margin: import_prop_types30.default.oneOf(["dense", "none"]),
  maxRows: import_prop_types30.default.oneOfType([import_prop_types30.default.number, import_prop_types30.default.string]),
  minRows: import_prop_types30.default.oneOfType([import_prop_types30.default.number, import_prop_types30.default.string]),
  multiline: import_prop_types30.default.bool,
  name: import_prop_types30.default.string,
  notched: import_prop_types30.default.bool,
  onChange: import_prop_types30.default.func,
  placeholder: import_prop_types30.default.string,
  readOnly: import_prop_types30.default.bool,
  required: import_prop_types30.default.bool,
  rows: import_prop_types30.default.oneOfType([import_prop_types30.default.number, import_prop_types30.default.string]),
  startAdornment: import_prop_types30.default.node,
  sx: import_prop_types30.default.oneOfType([import_prop_types30.default.arrayOf(import_prop_types30.default.oneOfType([import_prop_types30.default.func, import_prop_types30.default.object, import_prop_types30.default.bool])), import_prop_types30.default.func, import_prop_types30.default.object]),
  type: import_prop_types30.default.string,
  value: import_prop_types30.default.any
};
OutlinedInput.muiName = "Input";
var OutlinedInput_default = OutlinedInput;

// node_modules/@mui/material/esm/InputLabel/InputLabel.js
init_objectWithoutPropertiesLoose();
init_extends();
var React53 = __toESM(require_react()), import_prop_types31 = __toESM(require_prop_types());
init_base();
init_useThemeProps3();
init_styled();

// node_modules/@mui/material/esm/InputLabel/inputLabelClasses.js
init_base();
function getInputLabelUtilityClasses(slot) {
  return generateUtilityClass("MuiInputLabel", slot);
}
var inputLabelClasses = generateUtilityClasses("MuiInputLabel", ["root", "focused", "disabled", "error", "required", "asterisk", "formControl", "sizeSmall", "shrink", "animated", "standard", "filled", "outlined"]);

// node_modules/@mui/material/esm/InputLabel/InputLabel.js
var import_jsx_runtime39 = __toESM(require_jsx_runtime()), _excluded35 = ["disableAnimation", "margin", "shrink", "variant"], useUtilityClasses16 = (ownerState) => {
  let {
    classes,
    formControl,
    size,
    shrink,
    disableAnimation,
    variant,
    required
  } = ownerState, composedClasses = composeClasses({
    root: ["root", formControl && "formControl", !disableAnimation && "animated", shrink && "shrink", size === "small" && "sizeSmall", variant],
    asterisk: [required && "asterisk"]
  }, getInputLabelUtilityClasses, classes);
  return _extends({}, classes, composedClasses);
}, InputLabelRoot = styled_default(FormLabel_default, {
  shouldForwardProp: (prop) => rootShouldForwardProp(prop) || prop === "classes",
  name: "MuiInputLabel",
  slot: "Root",
  overridesResolver: (props, styles4) => {
    let {
      ownerState
    } = props;
    return [{
      [`& .${formLabelClasses_default.asterisk}`]: styles4.asterisk
    }, styles4.root, ownerState.formControl && styles4.formControl, ownerState.size === "small" && styles4.sizeSmall, ownerState.shrink && styles4.shrink, !ownerState.disableAnimation && styles4.animated, styles4[ownerState.variant]];
  }
})(({
  theme,
  ownerState
}) => _extends({
  display: "block",
  transformOrigin: "top left",
  whiteSpace: "nowrap",
  overflow: "hidden",
  textOverflow: "ellipsis",
  maxWidth: "100%"
}, ownerState.formControl && {
  position: "absolute",
  left: 0,
  top: 0,
  transform: "translate(0, 20px) scale(1)"
}, ownerState.size === "small" && {
  transform: "translate(0, 17px) scale(1)"
}, ownerState.shrink && {
  transform: "translate(0, -1.5px) scale(0.75)",
  transformOrigin: "top left",
  maxWidth: "133%"
}, !ownerState.disableAnimation && {
  transition: theme.transitions.create(["color", "transform", "max-width"], {
    duration: theme.transitions.duration.shorter,
    easing: theme.transitions.easing.easeOut
  })
}, ownerState.variant === "filled" && _extends({
  zIndex: 1,
  pointerEvents: "none",
  transform: "translate(12px, 16px) scale(1)",
  maxWidth: "calc(100% - 24px)"
}, ownerState.size === "small" && {
  transform: "translate(12px, 13px) scale(1)"
}, ownerState.shrink && _extends({
  userSelect: "none",
  pointerEvents: "auto",
  transform: "translate(12px, 7px) scale(0.75)",
  maxWidth: "calc(133% - 24px)"
}, ownerState.size === "small" && {
  transform: "translate(12px, 4px) scale(0.75)"
})), ownerState.variant === "outlined" && _extends({
  zIndex: 1,
  pointerEvents: "none",
  transform: "translate(14px, 16px) scale(1)",
  maxWidth: "calc(100% - 24px)"
}, ownerState.size === "small" && {
  transform: "translate(14px, 9px) scale(1)"
}, ownerState.shrink && {
  userSelect: "none",
  pointerEvents: "auto",
  maxWidth: "calc(133% - 24px)",
  transform: "translate(14px, -9px) scale(0.75)"
}))), InputLabel = /* @__PURE__ */ React53.forwardRef(function(inProps, ref) {
  let props = useThemeProps2({
    name: "MuiInputLabel",
    props: inProps
  }), {
    disableAnimation = !1,
    shrink: shrinkProp
  } = props, other = _objectWithoutPropertiesLoose2(props, _excluded35), muiFormControl = useFormControl(), shrink = shrinkProp;
  typeof shrink > "u" && muiFormControl && (shrink = muiFormControl.filled || muiFormControl.focused || muiFormControl.adornedStart);
  let fcs = formControlState({
    props,
    muiFormControl,
    states: ["size", "variant", "required"]
  }), ownerState = _extends({}, props, {
    disableAnimation,
    formControl: muiFormControl,
    shrink,
    size: fcs.size,
    variant: fcs.variant,
    required: fcs.required
  }), classes = useUtilityClasses16(ownerState);
  return /* @__PURE__ */ (0, import_jsx_runtime39.jsx)(InputLabelRoot, _extends({
    "data-shrink": shrink,
    ownerState,
    ref
  }, other, {
    classes
  }));
});
InputLabel.propTypes = {
  children: import_prop_types31.default.node,
  classes: import_prop_types31.default.object,
  color: import_prop_types31.default.oneOfType([import_prop_types31.default.oneOf(["error", "info", "primary", "secondary", "success", "warning"]), import_prop_types31.default.string]),
  disableAnimation: import_prop_types31.default.bool,
  disabled: import_prop_types31.default.bool,
  error: import_prop_types31.default.bool,
  focused: import_prop_types31.default.bool,
  margin: import_prop_types31.default.oneOf(["dense"]),
  required: import_prop_types31.default.bool,
  shrink: import_prop_types31.default.bool,
  size: import_prop_types31.default.oneOf(["normal", "small"]),
  sx: import_prop_types31.default.oneOfType([import_prop_types31.default.arrayOf(import_prop_types31.default.oneOfType([import_prop_types31.default.func, import_prop_types31.default.object, import_prop_types31.default.bool])), import_prop_types31.default.func, import_prop_types31.default.object]),
  variant: import_prop_types31.default.oneOf(["filled", "outlined", "standard"])
};
var InputLabel_default = InputLabel;

// node_modules/@mui/material/esm/FormHelperText/FormHelperText.js
init_objectWithoutPropertiesLoose();
init_extends();
var React54 = __toESM(require_react()), import_prop_types32 = __toESM(require_prop_types());
init_clsx_m();
init_base();
init_styled();
init_capitalize2();

// node_modules/@mui/material/esm/FormHelperText/formHelperTextClasses.js
init_base();
function getFormHelperTextUtilityClasses(slot) {
  return generateUtilityClass("MuiFormHelperText", slot);
}
var formHelperTextClasses = generateUtilityClasses("MuiFormHelperText", ["root", "error", "disabled", "sizeSmall", "sizeMedium", "contained", "focused", "filled", "required"]), formHelperTextClasses_default = formHelperTextClasses;

// node_modules/@mui/material/esm/FormHelperText/FormHelperText.js
init_useThemeProps3();
var import_jsx_runtime40 = __toESM(require_jsx_runtime()), _span2, _excluded36 = ["children", "className", "component", "disabled", "error", "filled", "focused", "margin", "required", "variant"], useUtilityClasses17 = (ownerState) => {
  let {
    classes,
    contained,
    size,
    disabled,
    error,
    filled,
    focused,
    required
  } = ownerState, slots = {
    root: ["root", disabled && "disabled", error && "error", size && `size${capitalize_default(size)}`, contained && "contained", focused && "focused", filled && "filled", required && "required"]
  };
  return composeClasses(slots, getFormHelperTextUtilityClasses, classes);
}, FormHelperTextRoot = styled_default("p", {
  name: "MuiFormHelperText",
  slot: "Root",
  overridesResolver: (props, styles4) => {
    let {
      ownerState
    } = props;
    return [styles4.root, ownerState.size && styles4[`size${capitalize_default(ownerState.size)}`], ownerState.contained && styles4.contained, ownerState.filled && styles4.filled];
  }
})(({
  theme,
  ownerState
}) => _extends({
  color: (theme.vars || theme).palette.text.secondary
}, theme.typography.caption, {
  textAlign: "left",
  marginTop: 3,
  marginRight: 0,
  marginBottom: 0,
  marginLeft: 0,
  [`&.${formHelperTextClasses_default.disabled}`]: {
    color: (theme.vars || theme).palette.text.disabled
  },
  [`&.${formHelperTextClasses_default.error}`]: {
    color: (theme.vars || theme).palette.error.main
  }
}, ownerState.size === "small" && {
  marginTop: 4
}, ownerState.contained && {
  marginLeft: 14,
  marginRight: 14
})), FormHelperText = /* @__PURE__ */ React54.forwardRef(function(inProps, ref) {
  let props = useThemeProps2({
    props: inProps,
    name: "MuiFormHelperText"
  }), {
    children,
    className,
    component = "p"
  } = props, other = _objectWithoutPropertiesLoose2(props, _excluded36), muiFormControl = useFormControl(), fcs = formControlState({
    props,
    muiFormControl,
    states: ["variant", "size", "disabled", "error", "filled", "focused", "required"]
  }), ownerState = _extends({}, props, {
    component,
    contained: fcs.variant === "filled" || fcs.variant === "outlined",
    variant: fcs.variant,
    size: fcs.size,
    disabled: fcs.disabled,
    error: fcs.error,
    filled: fcs.filled,
    focused: fcs.focused,
    required: fcs.required
  }), classes = useUtilityClasses17(ownerState);
  return /* @__PURE__ */ (0, import_jsx_runtime40.jsx)(FormHelperTextRoot, _extends({
    as: component,
    ownerState,
    className: clsx_m_default(classes.root, className),
    ref
  }, other, {
    children: children === " " ? _span2 || (_span2 = /* @__PURE__ */ (0, import_jsx_runtime40.jsx)("span", {
      className: "notranslate",
      children: "\u200B"
    })) : children
  }));
});
FormHelperText.propTypes = {
  children: import_prop_types32.default.node,
  classes: import_prop_types32.default.object,
  className: import_prop_types32.default.string,
  component: import_prop_types32.default.elementType,
  disabled: import_prop_types32.default.bool,
  error: import_prop_types32.default.bool,
  filled: import_prop_types32.default.bool,
  focused: import_prop_types32.default.bool,
  margin: import_prop_types32.default.oneOf(["dense"]),
  required: import_prop_types32.default.bool,
  sx: import_prop_types32.default.oneOfType([import_prop_types32.default.arrayOf(import_prop_types32.default.oneOfType([import_prop_types32.default.func, import_prop_types32.default.object, import_prop_types32.default.bool])), import_prop_types32.default.func, import_prop_types32.default.object]),
  variant: import_prop_types32.default.oneOfType([import_prop_types32.default.oneOf(["filled", "outlined", "standard"]), import_prop_types32.default.string])
};
var FormHelperText_default = FormHelperText;

// node_modules/@mui/material/esm/Select/Select.js
init_extends();
init_objectWithoutPropertiesLoose();
var React69 = __toESM(require_react()), import_prop_types44 = __toESM(require_prop_types());
init_clsx_m();
init_esm2();

// node_modules/@mui/material/esm/Select/SelectInput.js
init_extends();
init_objectWithoutPropertiesLoose();
var React67 = __toESM(require_react()), import_react_is4 = __toESM(require_react_is2()), import_prop_types43 = __toESM(require_prop_types());
init_clsx_m();
init_base();
init_esm2();
init_ownerDocument2();
init_capitalize2();

// node_modules/@mui/material/esm/Menu/Menu.js
init_extends();
init_objectWithoutPropertiesLoose();
var React65 = __toESM(require_react()), import_react_is3 = __toESM(require_react_is2()), import_prop_types41 = __toESM(require_prop_types());
init_clsx_m();
init_base();
init_esm2();

// node_modules/@mui/material/esm/MenuList/MenuList.js
init_extends();
init_objectWithoutPropertiesLoose();
var React57 = __toESM(require_react()), import_react_is2 = __toESM(require_react_is2()), import_prop_types34 = __toESM(require_prop_types());
init_ownerDocument2();

// node_modules/@mui/material/esm/List/List.js
init_objectWithoutPropertiesLoose();
init_extends();
var React56 = __toESM(require_react()), import_prop_types33 = __toESM(require_prop_types());
init_clsx_m();
init_base();
init_styled();
init_useThemeProps3();

// node_modules/@mui/material/esm/List/ListContext.js
var React55 = __toESM(require_react()), ListContext = /* @__PURE__ */ React55.createContext({});
ListContext.displayName = "ListContext";
var ListContext_default = ListContext;

// node_modules/@mui/material/esm/List/listClasses.js
init_base();
function getListUtilityClass(slot) {
  return generateUtilityClass("MuiList", slot);
}
var listClasses = generateUtilityClasses("MuiList", ["root", "padding", "dense", "subheader"]);

// node_modules/@mui/material/esm/List/List.js
var import_jsx_runtime41 = __toESM(require_jsx_runtime()), import_jsx_runtime42 = __toESM(require_jsx_runtime()), _excluded37 = ["children", "className", "component", "dense", "disablePadding", "subheader"], useUtilityClasses18 = (ownerState) => {
  let {
    classes,
    disablePadding,
    dense,
    subheader
  } = ownerState;
  return composeClasses({
    root: ["root", !disablePadding && "padding", dense && "dense", subheader && "subheader"]
  }, getListUtilityClass, classes);
}, ListRoot = styled_default("ul", {
  name: "MuiList",
  slot: "Root",
  overridesResolver: (props, styles4) => {
    let {
      ownerState
    } = props;
    return [styles4.root, !ownerState.disablePadding && styles4.padding, ownerState.dense && styles4.dense, ownerState.subheader && styles4.subheader];
  }
})(({
  ownerState
}) => _extends({
  listStyle: "none",
  margin: 0,
  padding: 0,
  position: "relative"
}, !ownerState.disablePadding && {
  paddingTop: 8,
  paddingBottom: 8
}, ownerState.subheader && {
  paddingTop: 0
})), List = /* @__PURE__ */ React56.forwardRef(function(inProps, ref) {
  let props = useThemeProps2({
    props: inProps,
    name: "MuiList"
  }), {
    children,
    className,
    component = "ul",
    dense = !1,
    disablePadding = !1,
    subheader
  } = props, other = _objectWithoutPropertiesLoose2(props, _excluded37), context = React56.useMemo(() => ({
    dense
  }), [dense]), ownerState = _extends({}, props, {
    component,
    dense,
    disablePadding
  }), classes = useUtilityClasses18(ownerState);
  return /* @__PURE__ */ (0, import_jsx_runtime42.jsx)(ListContext_default.Provider, {
    value: context,
    children: /* @__PURE__ */ (0, import_jsx_runtime41.jsxs)(ListRoot, _extends({
      as: component,
      className: clsx_m_default(classes.root, className),
      ref,
      ownerState
    }, other, {
      children: [subheader, children]
    }))
  });
});
List.propTypes = {
  children: import_prop_types33.default.node,
  classes: import_prop_types33.default.object,
  className: import_prop_types33.default.string,
  component: import_prop_types33.default.elementType,
  dense: import_prop_types33.default.bool,
  disablePadding: import_prop_types33.default.bool,
  subheader: import_prop_types33.default.node,
  sx: import_prop_types33.default.oneOfType([import_prop_types33.default.arrayOf(import_prop_types33.default.oneOfType([import_prop_types33.default.func, import_prop_types33.default.object, import_prop_types33.default.bool])), import_prop_types33.default.func, import_prop_types33.default.object])
};
var List_default = List;

// node_modules/@mui/material/esm/utils/getScrollbarSize.js
init_esm2();
var getScrollbarSize_default = getScrollbarSize;

// node_modules/@mui/material/esm/MenuList/MenuList.js
init_useForkRef2();
init_useEnhancedEffect2();
var import_jsx_runtime43 = __toESM(require_jsx_runtime()), _excluded38 = ["actions", "autoFocus", "autoFocusItem", "children", "className", "disabledItemsFocusable", "disableListWrap", "onKeyDown", "variant"];
function nextItem(list, item, disableListWrap) {
  return list === item ? list.firstChild : item && item.nextElementSibling ? item.nextElementSibling : disableListWrap ? null : list.firstChild;
}
function previousItem(list, item, disableListWrap) {
  return list === item ? disableListWrap ? list.firstChild : list.lastChild : item && item.previousElementSibling ? item.previousElementSibling : disableListWrap ? null : list.lastChild;
}
function textCriteriaMatches(nextFocus, textCriteria) {
  if (textCriteria === void 0)
    return !0;
  let text = nextFocus.innerText;
  return text === void 0 && (text = nextFocus.textContent), text = text.trim().toLowerCase(), text.length === 0 ? !1 : textCriteria.repeating ? text[0] === textCriteria.keys[0] : text.indexOf(textCriteria.keys.join("")) === 0;
}
function moveFocus(list, currentFocus, disableListWrap, disabledItemsFocusable, traversalFunction, textCriteria) {
  let wrappedOnce = !1, nextFocus = traversalFunction(list, currentFocus, currentFocus ? disableListWrap : !1);
  for (; nextFocus; ) {
    if (nextFocus === list.firstChild) {
      if (wrappedOnce)
        return !1;
      wrappedOnce = !0;
    }
    let nextFocusDisabled = disabledItemsFocusable ? !1 : nextFocus.disabled || nextFocus.getAttribute("aria-disabled") === "true";
    if (!nextFocus.hasAttribute("tabindex") || !textCriteriaMatches(nextFocus, textCriteria) || nextFocusDisabled)
      nextFocus = traversalFunction(list, nextFocus, disableListWrap);
    else
      return nextFocus.focus(), !0;
  }
  return !1;
}
var MenuList = /* @__PURE__ */ React57.forwardRef(function(props, ref) {
  let {
    actions,
    autoFocus = !1,
    autoFocusItem = !1,
    children,
    className,
    disabledItemsFocusable = !1,
    disableListWrap = !1,
    onKeyDown,
    variant = "selectedMenu"
  } = props, other = _objectWithoutPropertiesLoose2(props, _excluded38), listRef = React57.useRef(null), textCriteriaRef = React57.useRef({
    keys: [],
    repeating: !0,
    previousKeyMatched: !0,
    lastTime: null
  });
  useEnhancedEffect_default2(() => {
    autoFocus && listRef.current.focus();
  }, [autoFocus]), React57.useImperativeHandle(actions, () => ({
    adjustStyleForScrollbar: (containerElement, theme) => {
      let noExplicitWidth = !listRef.current.style.width;
      if (containerElement.clientHeight < listRef.current.clientHeight && noExplicitWidth) {
        let scrollbarSize = `${getScrollbarSize_default(ownerDocument_default(containerElement))}px`;
        listRef.current.style[theme.direction === "rtl" ? "paddingLeft" : "paddingRight"] = scrollbarSize, listRef.current.style.width = `calc(100% + ${scrollbarSize})`;
      }
      return listRef.current;
    }
  }), []);
  let handleKeyDown2 = (event) => {
    let list = listRef.current, key = event.key, currentFocus = ownerDocument_default(list).activeElement;
    if (key === "ArrowDown")
      event.preventDefault(), moveFocus(list, currentFocus, disableListWrap, disabledItemsFocusable, nextItem);
    else if (key === "ArrowUp")
      event.preventDefault(), moveFocus(list, currentFocus, disableListWrap, disabledItemsFocusable, previousItem);
    else if (key === "Home")
      event.preventDefault(), moveFocus(list, null, disableListWrap, disabledItemsFocusable, nextItem);
    else if (key === "End")
      event.preventDefault(), moveFocus(list, null, disableListWrap, disabledItemsFocusable, previousItem);
    else if (key.length === 1) {
      let criteria = textCriteriaRef.current, lowerKey = key.toLowerCase(), currTime = performance.now();
      criteria.keys.length > 0 && (currTime - criteria.lastTime > 500 ? (criteria.keys = [], criteria.repeating = !0, criteria.previousKeyMatched = !0) : criteria.repeating && lowerKey !== criteria.keys[0] && (criteria.repeating = !1)), criteria.lastTime = currTime, criteria.keys.push(lowerKey);
      let keepFocusOnCurrent = currentFocus && !criteria.repeating && textCriteriaMatches(currentFocus, criteria);
      criteria.previousKeyMatched && (keepFocusOnCurrent || moveFocus(list, currentFocus, !1, disabledItemsFocusable, nextItem, criteria)) ? event.preventDefault() : criteria.previousKeyMatched = !1;
    }
    onKeyDown && onKeyDown(event);
  }, handleRef = useForkRef_default(listRef, ref), activeItemIndex = -1;
  React57.Children.forEach(children, (child, index) => {
    !/* @__PURE__ */ React57.isValidElement(child) || ((0, import_react_is2.isFragment)(child) && console.error(["MUI: The Menu component doesn't accept a Fragment as a child.", "Consider providing an array instead."].join(`
`)), child.props.disabled || (variant === "selectedMenu" && child.props.selected || activeItemIndex === -1) && (activeItemIndex = index));
  });
  let items = React57.Children.map(children, (child, index) => {
    if (index === activeItemIndex) {
      let newChildProps = {};
      return autoFocusItem && (newChildProps.autoFocus = !0), child.props.tabIndex === void 0 && variant === "selectedMenu" && (newChildProps.tabIndex = 0), /* @__PURE__ */ React57.cloneElement(child, newChildProps);
    }
    return child;
  });
  return /* @__PURE__ */ (0, import_jsx_runtime43.jsx)(List_default, _extends({
    role: "menu",
    ref: handleRef,
    className,
    onKeyDown: handleKeyDown2,
    tabIndex: autoFocus ? 0 : -1
  }, other, {
    children: items
  }));
});
MenuList.propTypes = {
  autoFocus: import_prop_types34.default.bool,
  autoFocusItem: import_prop_types34.default.bool,
  children: import_prop_types34.default.node,
  className: import_prop_types34.default.string,
  disabledItemsFocusable: import_prop_types34.default.bool,
  disableListWrap: import_prop_types34.default.bool,
  onKeyDown: import_prop_types34.default.func,
  variant: import_prop_types34.default.oneOf(["menu", "selectedMenu"])
};
var MenuList_default = MenuList;

// node_modules/@mui/material/esm/Paper/Paper.js
init_objectWithoutPropertiesLoose();
init_extends();
var React59 = __toESM(require_react()), import_prop_types35 = __toESM(require_prop_types());
init_clsx_m();
init_esm2();
init_base();
init_esm3();
init_styled();
init_useThemeProps3();

// node_modules/@mui/material/esm/styles/useTheme.js
var React58 = __toESM(require_react());
init_esm3();
init_defaultTheme();
function useTheme4() {
  let theme = useTheme_default(defaultTheme_default);
  return React58.useDebugValue(theme), theme;
}

// node_modules/@mui/material/esm/Paper/paperClasses.js
init_base();
function getPaperUtilityClass(slot) {
  return generateUtilityClass("MuiPaper", slot);
}
var paperClasses = generateUtilityClasses("MuiPaper", ["root", "rounded", "outlined", "elevation", "elevation0", "elevation1", "elevation2", "elevation3", "elevation4", "elevation5", "elevation6", "elevation7", "elevation8", "elevation9", "elevation10", "elevation11", "elevation12", "elevation13", "elevation14", "elevation15", "elevation16", "elevation17", "elevation18", "elevation19", "elevation20", "elevation21", "elevation22", "elevation23", "elevation24"]);

// node_modules/@mui/material/esm/Paper/Paper.js
var import_jsx_runtime44 = __toESM(require_jsx_runtime()), _excluded39 = ["className", "component", "elevation", "square", "variant"], getOverlayAlpha = (elevation) => {
  let alphaValue;
  return elevation < 1 ? alphaValue = 5.11916 * elevation ** 2 : alphaValue = 4.5 * Math.log(elevation + 1) + 2, (alphaValue / 100).toFixed(2);
}, useUtilityClasses19 = (ownerState) => {
  let {
    square,
    elevation,
    variant,
    classes
  } = ownerState, slots = {
    root: ["root", variant, !square && "rounded", variant === "elevation" && `elevation${elevation}`]
  };
  return composeClasses(slots, getPaperUtilityClass, classes);
}, PaperRoot = styled_default("div", {
  name: "MuiPaper",
  slot: "Root",
  overridesResolver: (props, styles4) => {
    let {
      ownerState
    } = props;
    return [styles4.root, styles4[ownerState.variant], !ownerState.square && styles4.rounded, ownerState.variant === "elevation" && styles4[`elevation${ownerState.elevation}`]];
  }
})(({
  theme,
  ownerState
}) => {
  var _theme$vars$overlays;
  return _extends({
    backgroundColor: (theme.vars || theme).palette.background.paper,
    color: (theme.vars || theme).palette.text.primary,
    transition: theme.transitions.create("box-shadow")
  }, !ownerState.square && {
    borderRadius: theme.shape.borderRadius
  }, ownerState.variant === "outlined" && {
    border: `1px solid ${(theme.vars || theme).palette.divider}`
  }, ownerState.variant === "elevation" && _extends({
    boxShadow: (theme.vars || theme).shadows[ownerState.elevation]
  }, !theme.vars && theme.palette.mode === "dark" && {
    backgroundImage: `linear-gradient(${alpha("#fff", getOverlayAlpha(ownerState.elevation))}, ${alpha("#fff", getOverlayAlpha(ownerState.elevation))})`
  }, theme.vars && {
    backgroundImage: (_theme$vars$overlays = theme.vars.overlays) == null ? void 0 : _theme$vars$overlays[ownerState.elevation]
  }));
}), Paper = /* @__PURE__ */ React59.forwardRef(function(inProps, ref) {
  let props = useThemeProps2({
    props: inProps,
    name: "MuiPaper"
  }), {
    className,
    component = "div",
    elevation = 1,
    square = !1,
    variant = "elevation"
  } = props, other = _objectWithoutPropertiesLoose2(props, _excluded39), ownerState = _extends({}, props, {
    component,
    elevation,
    square,
    variant
  }), classes = useUtilityClasses19(ownerState);
  return useTheme4().shadows[elevation] === void 0 && console.error([`MUI: The elevation provided <Paper elevation={${elevation}}> is not available in the theme.`, `Please make sure that \`theme.shadows[${elevation}]\` is defined.`].join(`
`)), /* @__PURE__ */ (0, import_jsx_runtime44.jsx)(PaperRoot, _extends({
    as: component,
    ownerState,
    className: clsx_m_default(classes.root, className),
    ref
  }, other));
});
Paper.propTypes = {
  children: import_prop_types35.default.node,
  classes: import_prop_types35.default.object,
  className: import_prop_types35.default.string,
  component: import_prop_types35.default.elementType,
  elevation: chainPropTypes(integerPropType_default, (props) => {
    let {
      elevation,
      variant
    } = props;
    return elevation > 0 && variant === "outlined" ? new Error(`MUI: Combining \`elevation={${elevation}}\` with \`variant="${variant}"\` has no effect. Either use \`elevation={0}\` or use a different \`variant\`.`) : null;
  }),
  square: import_prop_types35.default.bool,
  sx: import_prop_types35.default.oneOfType([import_prop_types35.default.arrayOf(import_prop_types35.default.oneOfType([import_prop_types35.default.func, import_prop_types35.default.object, import_prop_types35.default.bool])), import_prop_types35.default.func, import_prop_types35.default.object]),
  variant: import_prop_types35.default.oneOfType([import_prop_types35.default.oneOf(["elevation", "outlined"]), import_prop_types35.default.string])
};
var Paper_default = Paper;

// node_modules/@mui/material/esm/Popover/Popover.js
init_extends();
init_objectWithoutPropertiesLoose();
var React64 = __toESM(require_react()), import_prop_types40 = __toESM(require_prop_types());
init_clsx_m();
init_base();
init_esm2();
init_styled();
init_useThemeProps3();
init_debounce2();
init_ownerDocument2();
init_ownerWindow2();
init_useForkRef2();

// node_modules/@mui/material/esm/Grow/Grow.js
init_extends();
init_objectWithoutPropertiesLoose();
var React60 = __toESM(require_react()), import_prop_types36 = __toESM(require_prop_types());
init_esm2();

// node_modules/@mui/material/esm/transitions/utils.js
var reflow = (node) => node.scrollTop;
function getTransitionProps(props, options) {
  var _style$transitionDura, _style$transitionTimi;
  let {
    timeout: timeout2,
    easing: easing2,
    style: style3 = {}
  } = props;
  return {
    duration: (_style$transitionDura = style3.transitionDuration) != null ? _style$transitionDura : typeof timeout2 == "number" ? timeout2 : timeout2[options.mode] || 0,
    easing: (_style$transitionTimi = style3.transitionTimingFunction) != null ? _style$transitionTimi : typeof easing2 == "object" ? easing2[options.mode] : easing2,
    delay: style3.transitionDelay
  };
}

// node_modules/@mui/material/esm/Grow/Grow.js
init_useForkRef2();
var import_jsx_runtime45 = __toESM(require_jsx_runtime()), _excluded40 = ["addEndListener", "appear", "children", "easing", "in", "onEnter", "onEntered", "onEntering", "onExit", "onExited", "onExiting", "style", "timeout", "TransitionComponent"];
function getScale(value) {
  return `scale(${value}, ${value ** 2})`;
}
var styles2 = {
  entering: {
    opacity: 1,
    transform: getScale(1)
  },
  entered: {
    opacity: 1,
    transform: "none"
  }
}, isWebKit154 = typeof navigator < "u" && /^((?!chrome|android).)*(safari|mobile)/i.test(navigator.userAgent) && /(os |version\/)15(.|_)4/i.test(navigator.userAgent), Grow = /* @__PURE__ */ React60.forwardRef(function(props, ref) {
  let {
    addEndListener,
    appear = !0,
    children,
    easing: easing2,
    in: inProp,
    onEnter,
    onEntered,
    onEntering,
    onExit,
    onExited,
    onExiting,
    style: style3,
    timeout: timeout2 = "auto",
    TransitionComponent = Transition_default
  } = props, other = _objectWithoutPropertiesLoose2(props, _excluded40), timer = React60.useRef(), autoTimeout = React60.useRef(), theme = useTheme4(), nodeRef = React60.useRef(null), foreignRef = useForkRef_default(children.ref, ref), handleRef = useForkRef_default(nodeRef, foreignRef), normalizedTransitionCallback = (callback) => (maybeIsAppearing) => {
    if (callback) {
      let node = nodeRef.current;
      maybeIsAppearing === void 0 ? callback(node) : callback(node, maybeIsAppearing);
    }
  }, handleEntering = normalizedTransitionCallback(onEntering), handleEnter = normalizedTransitionCallback((node, isAppearing) => {
    reflow(node);
    let {
      duration: transitionDuration,
      delay,
      easing: transitionTimingFunction
    } = getTransitionProps({
      style: style3,
      timeout: timeout2,
      easing: easing2
    }, {
      mode: "enter"
    }), duration2;
    timeout2 === "auto" ? (duration2 = theme.transitions.getAutoHeightDuration(node.clientHeight), autoTimeout.current = duration2) : duration2 = transitionDuration, node.style.transition = [theme.transitions.create("opacity", {
      duration: duration2,
      delay
    }), theme.transitions.create("transform", {
      duration: isWebKit154 ? duration2 : duration2 * 0.666,
      delay,
      easing: transitionTimingFunction
    })].join(","), onEnter && onEnter(node, isAppearing);
  }), handleEntered = normalizedTransitionCallback(onEntered), handleExiting = normalizedTransitionCallback(onExiting), handleExit = normalizedTransitionCallback((node) => {
    let {
      duration: transitionDuration,
      delay,
      easing: transitionTimingFunction
    } = getTransitionProps({
      style: style3,
      timeout: timeout2,
      easing: easing2
    }, {
      mode: "exit"
    }), duration2;
    timeout2 === "auto" ? (duration2 = theme.transitions.getAutoHeightDuration(node.clientHeight), autoTimeout.current = duration2) : duration2 = transitionDuration, node.style.transition = [theme.transitions.create("opacity", {
      duration: duration2,
      delay
    }), theme.transitions.create("transform", {
      duration: isWebKit154 ? duration2 : duration2 * 0.666,
      delay: isWebKit154 ? delay : delay || duration2 * 0.333,
      easing: transitionTimingFunction
    })].join(","), node.style.opacity = 0, node.style.transform = getScale(0.75), onExit && onExit(node);
  }), handleExited = normalizedTransitionCallback(onExited), handleAddEndListener = (next) => {
    timeout2 === "auto" && (timer.current = setTimeout(next, autoTimeout.current || 0)), addEndListener && addEndListener(nodeRef.current, next);
  };
  return React60.useEffect(() => () => {
    clearTimeout(timer.current);
  }, []), /* @__PURE__ */ (0, import_jsx_runtime45.jsx)(TransitionComponent, _extends({
    appear,
    in: inProp,
    nodeRef,
    onEnter: handleEnter,
    onEntered: handleEntered,
    onEntering: handleEntering,
    onExit: handleExit,
    onExited: handleExited,
    onExiting: handleExiting,
    addEndListener: handleAddEndListener,
    timeout: timeout2 === "auto" ? null : timeout2
  }, other, {
    children: (state, childProps) => /* @__PURE__ */ React60.cloneElement(children, _extends({
      style: _extends({
        opacity: 0,
        transform: getScale(0.75),
        visibility: state === "exited" && !inProp ? "hidden" : void 0
      }, styles2[state], style3, children.props.style),
      ref: handleRef
    }, childProps))
  }));
});
Grow.propTypes = {
  addEndListener: import_prop_types36.default.func,
  appear: import_prop_types36.default.bool,
  children: elementAcceptingRef_default.isRequired,
  easing: import_prop_types36.default.oneOfType([import_prop_types36.default.shape({
    enter: import_prop_types36.default.string,
    exit: import_prop_types36.default.string
  }), import_prop_types36.default.string]),
  in: import_prop_types36.default.bool,
  onEnter: import_prop_types36.default.func,
  onEntered: import_prop_types36.default.func,
  onEntering: import_prop_types36.default.func,
  onExit: import_prop_types36.default.func,
  onExited: import_prop_types36.default.func,
  onExiting: import_prop_types36.default.func,
  style: import_prop_types36.default.object,
  timeout: import_prop_types36.default.oneOfType([import_prop_types36.default.oneOf(["auto"]), import_prop_types36.default.number, import_prop_types36.default.shape({
    appear: import_prop_types36.default.number,
    enter: import_prop_types36.default.number,
    exit: import_prop_types36.default.number
  })])
};
Grow.muiSupportAuto = !0;
var Grow_default = Grow;

// node_modules/@mui/material/esm/Modal/index.js
init_ModalUnstyled2();

// node_modules/@mui/material/esm/Modal/Modal.js
init_objectWithoutPropertiesLoose();
init_extends();
var React63 = __toESM(require_react()), import_prop_types39 = __toESM(require_prop_types());
init_ModalUnstyled2();
init_utils2();
init_esm2();
init_styled();
init_useThemeProps3();

// node_modules/@mui/material/esm/Backdrop/Backdrop.js
init_objectWithoutPropertiesLoose();
init_extends();
var React62 = __toESM(require_react()), import_prop_types38 = __toESM(require_prop_types());
init_clsx_m();
init_base();
init_styled();
init_useThemeProps3();

// node_modules/@mui/material/esm/Fade/Fade.js
init_extends();
init_objectWithoutPropertiesLoose();
var React61 = __toESM(require_react()), import_prop_types37 = __toESM(require_prop_types());
init_esm2();
init_useForkRef2();
var import_jsx_runtime46 = __toESM(require_jsx_runtime()), _excluded41 = ["addEndListener", "appear", "children", "easing", "in", "onEnter", "onEntered", "onEntering", "onExit", "onExited", "onExiting", "style", "timeout", "TransitionComponent"], styles3 = {
  entering: {
    opacity: 1
  },
  entered: {
    opacity: 1
  }
}, Fade = /* @__PURE__ */ React61.forwardRef(function(props, ref) {
  let theme = useTheme4(), defaultTimeout = {
    enter: theme.transitions.duration.enteringScreen,
    exit: theme.transitions.duration.leavingScreen
  }, {
    addEndListener,
    appear = !0,
    children,
    easing: easing2,
    in: inProp,
    onEnter,
    onEntered,
    onEntering,
    onExit,
    onExited,
    onExiting,
    style: style3,
    timeout: timeout2 = defaultTimeout,
    TransitionComponent = Transition_default
  } = props, other = _objectWithoutPropertiesLoose2(props, _excluded41), enableStrictModeCompat = !0, nodeRef = React61.useRef(null), foreignRef = useForkRef_default(children.ref, ref), handleRef = useForkRef_default(nodeRef, foreignRef), normalizedTransitionCallback = (callback) => (maybeIsAppearing) => {
    if (callback) {
      let node = nodeRef.current;
      maybeIsAppearing === void 0 ? callback(node) : callback(node, maybeIsAppearing);
    }
  }, handleEntering = normalizedTransitionCallback(onEntering), handleEnter = normalizedTransitionCallback((node, isAppearing) => {
    reflow(node);
    let transitionProps = getTransitionProps({
      style: style3,
      timeout: timeout2,
      easing: easing2
    }, {
      mode: "enter"
    });
    node.style.webkitTransition = theme.transitions.create("opacity", transitionProps), node.style.transition = theme.transitions.create("opacity", transitionProps), onEnter && onEnter(node, isAppearing);
  }), handleEntered = normalizedTransitionCallback(onEntered), handleExiting = normalizedTransitionCallback(onExiting), handleExit = normalizedTransitionCallback((node) => {
    let transitionProps = getTransitionProps({
      style: style3,
      timeout: timeout2,
      easing: easing2
    }, {
      mode: "exit"
    });
    node.style.webkitTransition = theme.transitions.create("opacity", transitionProps), node.style.transition = theme.transitions.create("opacity", transitionProps), onExit && onExit(node);
  }), handleExited = normalizedTransitionCallback(onExited);
  return /* @__PURE__ */ (0, import_jsx_runtime46.jsx)(TransitionComponent, _extends({
    appear,
    in: inProp,
    nodeRef: enableStrictModeCompat ? nodeRef : void 0,
    onEnter: handleEnter,
    onEntered: handleEntered,
    onEntering: handleEntering,
    onExit: handleExit,
    onExited: handleExited,
    onExiting: handleExiting,
    addEndListener: (next) => {
      addEndListener && addEndListener(nodeRef.current, next);
    },
    timeout: timeout2
  }, other, {
    children: (state, childProps) => /* @__PURE__ */ React61.cloneElement(children, _extends({
      style: _extends({
        opacity: 0,
        visibility: state === "exited" && !inProp ? "hidden" : void 0
      }, styles3[state], style3, children.props.style),
      ref: handleRef
    }, childProps))
  }));
});
Fade.propTypes = {
  addEndListener: import_prop_types37.default.func,
  appear: import_prop_types37.default.bool,
  children: elementAcceptingRef_default.isRequired,
  easing: import_prop_types37.default.oneOfType([import_prop_types37.default.shape({
    enter: import_prop_types37.default.string,
    exit: import_prop_types37.default.string
  }), import_prop_types37.default.string]),
  in: import_prop_types37.default.bool,
  onEnter: import_prop_types37.default.func,
  onEntered: import_prop_types37.default.func,
  onEntering: import_prop_types37.default.func,
  onExit: import_prop_types37.default.func,
  onExited: import_prop_types37.default.func,
  onExiting: import_prop_types37.default.func,
  style: import_prop_types37.default.object,
  timeout: import_prop_types37.default.oneOfType([import_prop_types37.default.number, import_prop_types37.default.shape({
    appear: import_prop_types37.default.number,
    enter: import_prop_types37.default.number,
    exit: import_prop_types37.default.number
  })])
};
var Fade_default = Fade;

// node_modules/@mui/material/esm/Backdrop/backdropClasses.js
init_base();
function getBackdropUtilityClass(slot) {
  return generateUtilityClass("MuiBackdrop", slot);
}
var backdropClasses = generateUtilityClasses("MuiBackdrop", ["root", "invisible"]);

// node_modules/@mui/material/esm/Backdrop/Backdrop.js
var import_jsx_runtime47 = __toESM(require_jsx_runtime()), _excluded42 = ["children", "component", "components", "componentsProps", "className", "invisible", "open", "transitionDuration", "TransitionComponent"], useUtilityClasses20 = (ownerState) => {
  let {
    classes,
    invisible
  } = ownerState;
  return composeClasses({
    root: ["root", invisible && "invisible"]
  }, getBackdropUtilityClass, classes);
}, BackdropRoot = styled_default("div", {
  name: "MuiBackdrop",
  slot: "Root",
  overridesResolver: (props, styles4) => {
    let {
      ownerState
    } = props;
    return [styles4.root, ownerState.invisible && styles4.invisible];
  }
})(({
  ownerState
}) => _extends({
  position: "fixed",
  display: "flex",
  alignItems: "center",
  justifyContent: "center",
  right: 0,
  bottom: 0,
  top: 0,
  left: 0,
  backgroundColor: "rgba(0, 0, 0, 0.5)",
  WebkitTapHighlightColor: "transparent"
}, ownerState.invisible && {
  backgroundColor: "transparent"
})), Backdrop = /* @__PURE__ */ React62.forwardRef(function(inProps, ref) {
  var _components$Root, _componentsProps$root;
  let props = useThemeProps2({
    props: inProps,
    name: "MuiBackdrop"
  }), {
    children,
    component = "div",
    components = {},
    componentsProps = {},
    className,
    invisible = !1,
    open,
    transitionDuration,
    TransitionComponent = Fade_default
  } = props, other = _objectWithoutPropertiesLoose2(props, _excluded42), ownerState = _extends({}, props, {
    component,
    invisible
  }), classes = useUtilityClasses20(ownerState);
  return /* @__PURE__ */ (0, import_jsx_runtime47.jsx)(TransitionComponent, _extends({
    in: open,
    timeout: transitionDuration
  }, other, {
    children: /* @__PURE__ */ (0, import_jsx_runtime47.jsx)(BackdropRoot, {
      "aria-hidden": !0,
      as: (_components$Root = components.Root) != null ? _components$Root : component,
      className: clsx_m_default(classes.root, className),
      ownerState: _extends({}, ownerState, (_componentsProps$root = componentsProps.root) == null ? void 0 : _componentsProps$root.ownerState),
      classes,
      ref,
      children
    })
  }));
});
Backdrop.propTypes = {
  children: import_prop_types38.default.node,
  classes: import_prop_types38.default.object,
  className: import_prop_types38.default.string,
  component: import_prop_types38.default.elementType,
  components: import_prop_types38.default.shape({
    Root: import_prop_types38.default.elementType
  }),
  componentsProps: import_prop_types38.default.shape({
    root: import_prop_types38.default.object
  }),
  invisible: import_prop_types38.default.bool,
  open: import_prop_types38.default.bool.isRequired,
  sx: import_prop_types38.default.oneOfType([import_prop_types38.default.arrayOf(import_prop_types38.default.oneOfType([import_prop_types38.default.func, import_prop_types38.default.object, import_prop_types38.default.bool])), import_prop_types38.default.func, import_prop_types38.default.object]),
  transitionDuration: import_prop_types38.default.oneOfType([import_prop_types38.default.number, import_prop_types38.default.shape({
    appear: import_prop_types38.default.number,
    enter: import_prop_types38.default.number,
    exit: import_prop_types38.default.number
  })])
};
var Backdrop_default = Backdrop;

// node_modules/@mui/material/esm/Modal/Modal.js
var import_jsx_runtime48 = __toESM(require_jsx_runtime()), _excluded43 = ["BackdropComponent", "BackdropProps", "closeAfterTransition", "children", "component", "components", "componentsProps", "disableAutoFocus", "disableEnforceFocus", "disableEscapeKeyDown", "disablePortal", "disableRestoreFocus", "disableScrollLock", "hideBackdrop", "keepMounted", "theme"];
var extendUtilityClasses = (ownerState) => ownerState.classes, ModalRoot = styled_default("div", {
  name: "MuiModal",
  slot: "Root",
  overridesResolver: (props, styles4) => {
    let {
      ownerState
    } = props;
    return [styles4.root, !ownerState.open && ownerState.exited && styles4.hidden];
  }
})(({
  theme,
  ownerState
}) => _extends({
  position: "fixed",
  zIndex: (theme.vars || theme).zIndex.modal,
  right: 0,
  bottom: 0,
  top: 0,
  left: 0
}, !ownerState.open && ownerState.exited && {
  visibility: "hidden"
})), ModalBackdrop = styled_default(Backdrop_default, {
  name: "MuiModal",
  slot: "Backdrop",
  overridesResolver: (props, styles4) => styles4.backdrop
})({
  zIndex: -1
}), Modal = /* @__PURE__ */ React63.forwardRef(function(inProps, ref) {
  var _ref, _components$Root;
  let props = useThemeProps2({
    name: "MuiModal",
    props: inProps
  }), {
    BackdropComponent = ModalBackdrop,
    BackdropProps,
    closeAfterTransition = !1,
    children,
    component,
    components = {},
    componentsProps = {},
    disableAutoFocus = !1,
    disableEnforceFocus = !1,
    disableEscapeKeyDown = !1,
    disablePortal = !1,
    disableRestoreFocus = !1,
    disableScrollLock = !1,
    hideBackdrop = !1,
    keepMounted = !1,
    theme
  } = props, other = _objectWithoutPropertiesLoose2(props, _excluded43), [exited, setExited] = React63.useState(!0), commonProps = {
    closeAfterTransition,
    disableAutoFocus,
    disableEnforceFocus,
    disableEscapeKeyDown,
    disablePortal,
    disableRestoreFocus,
    disableScrollLock,
    hideBackdrop,
    keepMounted
  }, ownerState = _extends({}, props, commonProps, {
    exited
  }), classes = extendUtilityClasses(ownerState), Root = (_ref = (_components$Root = components.Root) != null ? _components$Root : component) != null ? _ref : ModalRoot;
  return /* @__PURE__ */ (0, import_jsx_runtime48.jsx)(ModalUnstyled_default, _extends({
    components: _extends({
      Root,
      Backdrop: BackdropComponent
    }, components),
    componentsProps: {
      root: () => _extends({}, resolveComponentProps(componentsProps.root, ownerState), !isHostComponent_default(Root) && {
        as: component,
        theme
      }),
      backdrop: () => _extends({}, BackdropProps, resolveComponentProps(componentsProps.backdrop, ownerState))
    },
    onTransitionEnter: () => setExited(!1),
    onTransitionExited: () => setExited(!0),
    ref
  }, other, {
    classes
  }, commonProps, {
    children
  }));
});
Modal.propTypes = {
  BackdropComponent: import_prop_types39.default.elementType,
  BackdropProps: import_prop_types39.default.object,
  children: elementAcceptingRef_default.isRequired,
  classes: import_prop_types39.default.object,
  closeAfterTransition: import_prop_types39.default.bool,
  component: import_prop_types39.default.elementType,
  components: import_prop_types39.default.shape({
    Backdrop: import_prop_types39.default.elementType,
    Root: import_prop_types39.default.elementType
  }),
  componentsProps: import_prop_types39.default.shape({
    backdrop: import_prop_types39.default.oneOfType([import_prop_types39.default.func, import_prop_types39.default.object]),
    root: import_prop_types39.default.oneOfType([import_prop_types39.default.func, import_prop_types39.default.object])
  }),
  container: import_prop_types39.default.oneOfType([HTMLElementType, import_prop_types39.default.func]),
  disableAutoFocus: import_prop_types39.default.bool,
  disableEnforceFocus: import_prop_types39.default.bool,
  disableEscapeKeyDown: import_prop_types39.default.bool,
  disablePortal: import_prop_types39.default.bool,
  disableRestoreFocus: import_prop_types39.default.bool,
  disableScrollLock: import_prop_types39.default.bool,
  hideBackdrop: import_prop_types39.default.bool,
  keepMounted: import_prop_types39.default.bool,
  onBackdropClick: import_prop_types39.default.func,
  onClose: import_prop_types39.default.func,
  open: import_prop_types39.default.bool.isRequired,
  sx: import_prop_types39.default.oneOfType([import_prop_types39.default.arrayOf(import_prop_types39.default.oneOfType([import_prop_types39.default.func, import_prop_types39.default.object, import_prop_types39.default.bool])), import_prop_types39.default.func, import_prop_types39.default.object])
};
var Modal_default = Modal;

// node_modules/@mui/material/esm/Popover/popoverClasses.js
init_base();
function getPopoverUtilityClass(slot) {
  return generateUtilityClass("MuiPopover", slot);
}
var popoverClasses = generateUtilityClasses("MuiPopover", ["root", "paper"]);

// node_modules/@mui/material/esm/Popover/Popover.js
var import_jsx_runtime49 = __toESM(require_jsx_runtime()), _excluded44 = ["onEntering"], _excluded210 = ["action", "anchorEl", "anchorOrigin", "anchorPosition", "anchorReference", "children", "className", "container", "elevation", "marginThreshold", "open", "PaperProps", "transformOrigin", "TransitionComponent", "transitionDuration", "TransitionProps"];
function getOffsetTop(rect, vertical) {
  let offset = 0;
  return typeof vertical == "number" ? offset = vertical : vertical === "center" ? offset = rect.height / 2 : vertical === "bottom" && (offset = rect.height), offset;
}
function getOffsetLeft(rect, horizontal) {
  let offset = 0;
  return typeof horizontal == "number" ? offset = horizontal : horizontal === "center" ? offset = rect.width / 2 : horizontal === "right" && (offset = rect.width), offset;
}
function getTransformOriginValue(transformOrigin) {
  return [transformOrigin.horizontal, transformOrigin.vertical].map((n) => typeof n == "number" ? `${n}px` : n).join(" ");
}
function resolveAnchorEl(anchorEl) {
  return typeof anchorEl == "function" ? anchorEl() : anchorEl;
}
var useUtilityClasses21 = (ownerState) => {
  let {
    classes
  } = ownerState;
  return composeClasses({
    root: ["root"],
    paper: ["paper"]
  }, getPopoverUtilityClass, classes);
}, PopoverRoot = styled_default(Modal_default, {
  name: "MuiPopover",
  slot: "Root",
  overridesResolver: (props, styles4) => styles4.root
})({}), PopoverPaper = styled_default(Paper_default, {
  name: "MuiPopover",
  slot: "Paper",
  overridesResolver: (props, styles4) => styles4.paper
})({
  position: "absolute",
  overflowY: "auto",
  overflowX: "hidden",
  minWidth: 16,
  minHeight: 16,
  maxWidth: "calc(100% - 32px)",
  maxHeight: "calc(100% - 32px)",
  outline: 0
}), Popover = /* @__PURE__ */ React64.forwardRef(function(inProps, ref) {
  let props = useThemeProps2({
    props: inProps,
    name: "MuiPopover"
  }), {
    action,
    anchorEl,
    anchorOrigin = {
      vertical: "top",
      horizontal: "left"
    },
    anchorPosition,
    anchorReference = "anchorEl",
    children,
    className,
    container: containerProp,
    elevation = 8,
    marginThreshold = 16,
    open,
    PaperProps = {},
    transformOrigin = {
      vertical: "top",
      horizontal: "left"
    },
    TransitionComponent = Grow_default,
    transitionDuration: transitionDurationProp = "auto",
    TransitionProps: {
      onEntering
    } = {}
  } = props, TransitionProps = _objectWithoutPropertiesLoose2(props.TransitionProps, _excluded44), other = _objectWithoutPropertiesLoose2(props, _excluded210), paperRef = React64.useRef(), handlePaperRef = useForkRef_default(paperRef, PaperProps.ref), ownerState = _extends({}, props, {
    anchorOrigin,
    anchorReference,
    elevation,
    marginThreshold,
    PaperProps,
    transformOrigin,
    TransitionComponent,
    transitionDuration: transitionDurationProp,
    TransitionProps
  }), classes = useUtilityClasses21(ownerState), getAnchorOffset = React64.useCallback(() => {
    if (anchorReference === "anchorPosition")
      return anchorPosition || console.error('MUI: You need to provide a `anchorPosition` prop when using <Popover anchorReference="anchorPosition" />.'), anchorPosition;
    let resolvedAnchorEl = resolveAnchorEl(anchorEl), anchorElement = resolvedAnchorEl && resolvedAnchorEl.nodeType === 1 ? resolvedAnchorEl : ownerDocument_default(paperRef.current).body, anchorRect = anchorElement.getBoundingClientRect();
    {
      let box = anchorElement.getBoundingClientRect();
      box.top === 0 && box.left === 0 && box.right === 0 && box.bottom === 0 && console.warn(["MUI: The `anchorEl` prop provided to the component is invalid.", "The anchor element should be part of the document layout.", "Make sure the element is present in the document or that it's not display none."].join(`
`));
    }
    return {
      top: anchorRect.top + getOffsetTop(anchorRect, anchorOrigin.vertical),
      left: anchorRect.left + getOffsetLeft(anchorRect, anchorOrigin.horizontal)
    };
  }, [anchorEl, anchorOrigin.horizontal, anchorOrigin.vertical, anchorPosition, anchorReference]), getTransformOrigin = React64.useCallback((elemRect) => ({
    vertical: getOffsetTop(elemRect, transformOrigin.vertical),
    horizontal: getOffsetLeft(elemRect, transformOrigin.horizontal)
  }), [transformOrigin.horizontal, transformOrigin.vertical]), getPositioningStyle = React64.useCallback((element) => {
    let elemRect = {
      width: element.offsetWidth,
      height: element.offsetHeight
    }, elemTransformOrigin = getTransformOrigin(elemRect);
    if (anchorReference === "none")
      return {
        top: null,
        left: null,
        transformOrigin: getTransformOriginValue(elemTransformOrigin)
      };
    let anchorOffset = getAnchorOffset(), top2 = anchorOffset.top - elemTransformOrigin.vertical, left2 = anchorOffset.left - elemTransformOrigin.horizontal, bottom2 = top2 + elemRect.height, right2 = left2 + elemRect.width, containerWindow = ownerWindow_default(resolveAnchorEl(anchorEl)), heightThreshold = containerWindow.innerHeight - marginThreshold, widthThreshold = containerWindow.innerWidth - marginThreshold;
    if (top2 < marginThreshold) {
      let diff = top2 - marginThreshold;
      top2 -= diff, elemTransformOrigin.vertical += diff;
    } else if (bottom2 > heightThreshold) {
      let diff = bottom2 - heightThreshold;
      top2 -= diff, elemTransformOrigin.vertical += diff;
    }
    if (elemRect.height > heightThreshold && elemRect.height && heightThreshold && console.error(["MUI: The popover component is too tall.", `Some part of it can not be seen on the screen (${elemRect.height - heightThreshold}px).`, "Please consider adding a `max-height` to improve the user-experience."].join(`
`)), left2 < marginThreshold) {
      let diff = left2 - marginThreshold;
      left2 -= diff, elemTransformOrigin.horizontal += diff;
    } else if (right2 > widthThreshold) {
      let diff = right2 - widthThreshold;
      left2 -= diff, elemTransformOrigin.horizontal += diff;
    }
    return {
      top: `${Math.round(top2)}px`,
      left: `${Math.round(left2)}px`,
      transformOrigin: getTransformOriginValue(elemTransformOrigin)
    };
  }, [anchorEl, anchorReference, getAnchorOffset, getTransformOrigin, marginThreshold]), setPositioningStyles = React64.useCallback(() => {
    let element = paperRef.current;
    if (!element)
      return;
    let positioning = getPositioningStyle(element);
    positioning.top !== null && (element.style.top = positioning.top), positioning.left !== null && (element.style.left = positioning.left), element.style.transformOrigin = positioning.transformOrigin;
  }, [getPositioningStyle]), handleEntering = (element, isAppearing) => {
    onEntering && onEntering(element, isAppearing), setPositioningStyles();
  };
  React64.useEffect(() => {
    open && setPositioningStyles();
  }), React64.useImperativeHandle(action, () => open ? {
    updatePosition: () => {
      setPositioningStyles();
    }
  } : null, [open, setPositioningStyles]), React64.useEffect(() => {
    if (!open)
      return;
    let handleResize = debounce_default(() => {
      setPositioningStyles();
    }), containerWindow = ownerWindow_default(anchorEl);
    return containerWindow.addEventListener("resize", handleResize), () => {
      handleResize.clear(), containerWindow.removeEventListener("resize", handleResize);
    };
  }, [anchorEl, open, setPositioningStyles]);
  let transitionDuration = transitionDurationProp;
  transitionDurationProp === "auto" && !TransitionComponent.muiSupportAuto && (transitionDuration = void 0);
  let container = containerProp || (anchorEl ? ownerDocument_default(resolveAnchorEl(anchorEl)).body : void 0);
  return /* @__PURE__ */ (0, import_jsx_runtime49.jsx)(PopoverRoot, _extends({
    BackdropProps: {
      invisible: !0
    },
    className: clsx_m_default(classes.root, className),
    container,
    open,
    ref,
    ownerState
  }, other, {
    children: /* @__PURE__ */ (0, import_jsx_runtime49.jsx)(TransitionComponent, _extends({
      appear: !0,
      in: open,
      onEntering: handleEntering,
      timeout: transitionDuration
    }, TransitionProps, {
      children: /* @__PURE__ */ (0, import_jsx_runtime49.jsx)(PopoverPaper, _extends({
        elevation
      }, PaperProps, {
        ref: handlePaperRef,
        className: clsx_m_default(classes.paper, PaperProps.className),
        children
      }))
    }))
  }));
});
Popover.propTypes = {
  action: refType_default,
  anchorEl: chainPropTypes(import_prop_types40.default.oneOfType([HTMLElementType, import_prop_types40.default.func]), (props) => {
    if (props.open && (!props.anchorReference || props.anchorReference === "anchorEl")) {
      let resolvedAnchorEl = resolveAnchorEl(props.anchorEl);
      if (resolvedAnchorEl && resolvedAnchorEl.nodeType === 1) {
        let box = resolvedAnchorEl.getBoundingClientRect();
        if (box.top === 0 && box.left === 0 && box.right === 0 && box.bottom === 0)
          return new Error(["MUI: The `anchorEl` prop provided to the component is invalid.", "The anchor element should be part of the document layout.", "Make sure the element is present in the document or that it's not display none."].join(`
`));
      } else
        return new Error(["MUI: The `anchorEl` prop provided to the component is invalid.", `It should be an Element instance but it's \`${resolvedAnchorEl}\` instead.`].join(`
`));
    }
    return null;
  }),
  anchorOrigin: import_prop_types40.default.shape({
    horizontal: import_prop_types40.default.oneOfType([import_prop_types40.default.oneOf(["center", "left", "right"]), import_prop_types40.default.number]).isRequired,
    vertical: import_prop_types40.default.oneOfType([import_prop_types40.default.oneOf(["bottom", "center", "top"]), import_prop_types40.default.number]).isRequired
  }),
  anchorPosition: import_prop_types40.default.shape({
    left: import_prop_types40.default.number.isRequired,
    top: import_prop_types40.default.number.isRequired
  }),
  anchorReference: import_prop_types40.default.oneOf(["anchorEl", "anchorPosition", "none"]),
  children: import_prop_types40.default.node,
  classes: import_prop_types40.default.object,
  className: import_prop_types40.default.string,
  container: import_prop_types40.default.oneOfType([HTMLElementType, import_prop_types40.default.func]),
  elevation: integerPropType_default,
  marginThreshold: import_prop_types40.default.number,
  onClose: import_prop_types40.default.func,
  open: import_prop_types40.default.bool.isRequired,
  PaperProps: import_prop_types40.default.shape({
    component: elementTypeAcceptingRef_default
  }),
  sx: import_prop_types40.default.oneOfType([import_prop_types40.default.arrayOf(import_prop_types40.default.oneOfType([import_prop_types40.default.func, import_prop_types40.default.object, import_prop_types40.default.bool])), import_prop_types40.default.func, import_prop_types40.default.object]),
  transformOrigin: import_prop_types40.default.shape({
    horizontal: import_prop_types40.default.oneOfType([import_prop_types40.default.oneOf(["center", "left", "right"]), import_prop_types40.default.number]).isRequired,
    vertical: import_prop_types40.default.oneOfType([import_prop_types40.default.oneOf(["bottom", "center", "top"]), import_prop_types40.default.number]).isRequired
  }),
  TransitionComponent: import_prop_types40.default.elementType,
  transitionDuration: import_prop_types40.default.oneOfType([import_prop_types40.default.oneOf(["auto"]), import_prop_types40.default.number, import_prop_types40.default.shape({
    appear: import_prop_types40.default.number,
    enter: import_prop_types40.default.number,
    exit: import_prop_types40.default.number
  })]),
  TransitionProps: import_prop_types40.default.object
};
var Popover_default = Popover;

// node_modules/@mui/material/esm/Menu/Menu.js
init_styled();
init_useThemeProps3();

// node_modules/@mui/material/esm/Menu/menuClasses.js
init_base();
function getMenuUtilityClass(slot) {
  return generateUtilityClass("MuiMenu", slot);
}
var menuClasses = generateUtilityClasses("MuiMenu", ["root", "paper", "list"]);

// node_modules/@mui/material/esm/Menu/Menu.js
var import_jsx_runtime50 = __toESM(require_jsx_runtime()), _excluded45 = ["onEntering"], _excluded211 = ["autoFocus", "children", "disableAutoFocusItem", "MenuListProps", "onClose", "open", "PaperProps", "PopoverClasses", "transitionDuration", "TransitionProps", "variant"], RTL_ORIGIN = {
  vertical: "top",
  horizontal: "right"
}, LTR_ORIGIN = {
  vertical: "top",
  horizontal: "left"
}, useUtilityClasses22 = (ownerState) => {
  let {
    classes
  } = ownerState;
  return composeClasses({
    root: ["root"],
    paper: ["paper"],
    list: ["list"]
  }, getMenuUtilityClass, classes);
}, MenuRoot = styled_default(Popover_default, {
  shouldForwardProp: (prop) => rootShouldForwardProp(prop) || prop === "classes",
  name: "MuiMenu",
  slot: "Root",
  overridesResolver: (props, styles4) => styles4.root
})({}), MenuPaper = styled_default(Paper_default, {
  name: "MuiMenu",
  slot: "Paper",
  overridesResolver: (props, styles4) => styles4.paper
})({
  maxHeight: "calc(100% - 96px)",
  WebkitOverflowScrolling: "touch"
}), MenuMenuList = styled_default(MenuList_default, {
  name: "MuiMenu",
  slot: "List",
  overridesResolver: (props, styles4) => styles4.list
})({
  outline: 0
}), Menu = /* @__PURE__ */ React65.forwardRef(function(inProps, ref) {
  let props = useThemeProps2({
    props: inProps,
    name: "MuiMenu"
  }), {
    autoFocus = !0,
    children,
    disableAutoFocusItem = !1,
    MenuListProps = {},
    onClose,
    open,
    PaperProps = {},
    PopoverClasses,
    transitionDuration = "auto",
    TransitionProps: {
      onEntering
    } = {},
    variant = "selectedMenu"
  } = props, TransitionProps = _objectWithoutPropertiesLoose2(props.TransitionProps, _excluded45), other = _objectWithoutPropertiesLoose2(props, _excluded211), theme = useTheme4(), isRtl = theme.direction === "rtl", ownerState = _extends({}, props, {
    autoFocus,
    disableAutoFocusItem,
    MenuListProps,
    onEntering,
    PaperProps,
    transitionDuration,
    TransitionProps,
    variant
  }), classes = useUtilityClasses22(ownerState), autoFocusItem = autoFocus && !disableAutoFocusItem && open, menuListActionsRef = React65.useRef(null), handleEntering = (element, isAppearing) => {
    menuListActionsRef.current && menuListActionsRef.current.adjustStyleForScrollbar(element, theme), onEntering && onEntering(element, isAppearing);
  }, handleListKeyDown = (event) => {
    event.key === "Tab" && (event.preventDefault(), onClose && onClose(event, "tabKeyDown"));
  }, activeItemIndex = -1;
  return React65.Children.map(children, (child, index) => {
    !/* @__PURE__ */ React65.isValidElement(child) || ((0, import_react_is3.isFragment)(child) && console.error(["MUI: The Menu component doesn't accept a Fragment as a child.", "Consider providing an array instead."].join(`
`)), child.props.disabled || (variant === "selectedMenu" && child.props.selected || activeItemIndex === -1) && (activeItemIndex = index));
  }), /* @__PURE__ */ (0, import_jsx_runtime50.jsx)(MenuRoot, _extends({
    classes: PopoverClasses,
    onClose,
    anchorOrigin: {
      vertical: "bottom",
      horizontal: isRtl ? "right" : "left"
    },
    transformOrigin: isRtl ? RTL_ORIGIN : LTR_ORIGIN,
    PaperProps: _extends({
      component: MenuPaper
    }, PaperProps, {
      classes: _extends({}, PaperProps.classes, {
        root: classes.paper
      })
    }),
    className: classes.root,
    open,
    ref,
    transitionDuration,
    TransitionProps: _extends({
      onEntering: handleEntering
    }, TransitionProps),
    ownerState
  }, other, {
    children: /* @__PURE__ */ (0, import_jsx_runtime50.jsx)(MenuMenuList, _extends({
      onKeyDown: handleListKeyDown,
      actions: menuListActionsRef,
      autoFocus: autoFocus && (activeItemIndex === -1 || disableAutoFocusItem),
      autoFocusItem,
      variant
    }, MenuListProps, {
      className: clsx_m_default(classes.list, MenuListProps.className),
      children
    }))
  }));
});
Menu.propTypes = {
  anchorEl: import_prop_types41.default.oneOfType([HTMLElementType, import_prop_types41.default.func]),
  autoFocus: import_prop_types41.default.bool,
  children: import_prop_types41.default.node,
  classes: import_prop_types41.default.object,
  disableAutoFocusItem: import_prop_types41.default.bool,
  MenuListProps: import_prop_types41.default.object,
  onClose: import_prop_types41.default.func,
  open: import_prop_types41.default.bool.isRequired,
  PaperProps: import_prop_types41.default.object,
  PopoverClasses: import_prop_types41.default.object,
  sx: import_prop_types41.default.oneOfType([import_prop_types41.default.arrayOf(import_prop_types41.default.oneOfType([import_prop_types41.default.func, import_prop_types41.default.object, import_prop_types41.default.bool])), import_prop_types41.default.func, import_prop_types41.default.object]),
  transitionDuration: import_prop_types41.default.oneOfType([import_prop_types41.default.oneOf(["auto"]), import_prop_types41.default.number, import_prop_types41.default.shape({
    appear: import_prop_types41.default.number,
    enter: import_prop_types41.default.number,
    exit: import_prop_types41.default.number
  })]),
  TransitionProps: import_prop_types41.default.object,
  variant: import_prop_types41.default.oneOf(["menu", "selectedMenu"])
};
var Menu_default = Menu;

// node_modules/@mui/material/esm/NativeSelect/NativeSelectInput.js
init_objectWithoutPropertiesLoose();
init_extends();
var React66 = __toESM(require_react()), import_prop_types42 = __toESM(require_prop_types());
init_clsx_m();
init_esm2();
init_base();
init_capitalize2();

// node_modules/@mui/material/esm/NativeSelect/nativeSelectClasses.js
init_base();
function getNativeSelectUtilityClasses(slot) {
  return generateUtilityClass("MuiNativeSelect", slot);
}
var nativeSelectClasses = generateUtilityClasses("MuiNativeSelect", ["root", "select", "multiple", "filled", "outlined", "standard", "disabled", "icon", "iconOpen", "iconFilled", "iconOutlined", "iconStandard", "nativeInput"]), nativeSelectClasses_default = nativeSelectClasses;

// node_modules/@mui/material/esm/NativeSelect/NativeSelectInput.js
init_styled();
var import_jsx_runtime51 = __toESM(require_jsx_runtime()), import_jsx_runtime52 = __toESM(require_jsx_runtime()), _excluded46 = ["className", "disabled", "IconComponent", "inputRef", "variant"], useUtilityClasses23 = (ownerState) => {
  let {
    classes,
    variant,
    disabled,
    multiple,
    open
  } = ownerState, slots = {
    select: ["select", variant, disabled && "disabled", multiple && "multiple"],
    icon: ["icon", `icon${capitalize_default(variant)}`, open && "iconOpen", disabled && "disabled"]
  };
  return composeClasses(slots, getNativeSelectUtilityClasses, classes);
}, nativeSelectSelectStyles = ({
  ownerState,
  theme
}) => _extends({
  MozAppearance: "none",
  WebkitAppearance: "none",
  userSelect: "none",
  borderRadius: 0,
  cursor: "pointer",
  "&:focus": {
    backgroundColor: theme.palette.mode === "light" ? "rgba(0, 0, 0, 0.05)" : "rgba(255, 255, 255, 0.05)",
    borderRadius: 0
  },
  "&::-ms-expand": {
    display: "none"
  },
  [`&.${nativeSelectClasses_default.disabled}`]: {
    cursor: "default"
  },
  "&[multiple]": {
    height: "auto"
  },
  "&:not([multiple]) option, &:not([multiple]) optgroup": {
    backgroundColor: theme.palette.background.paper
  },
  "&&&": {
    paddingRight: 24,
    minWidth: 16
  }
}, ownerState.variant === "filled" && {
  "&&&": {
    paddingRight: 32
  }
}, ownerState.variant === "outlined" && {
  borderRadius: theme.shape.borderRadius,
  "&:focus": {
    borderRadius: theme.shape.borderRadius
  },
  "&&&": {
    paddingRight: 32
  }
}), NativeSelectSelect = styled_default("select", {
  name: "MuiNativeSelect",
  slot: "Select",
  shouldForwardProp: rootShouldForwardProp,
  overridesResolver: (props, styles4) => {
    let {
      ownerState
    } = props;
    return [styles4.select, styles4[ownerState.variant], {
      [`&.${nativeSelectClasses_default.multiple}`]: styles4.multiple
    }];
  }
})(nativeSelectSelectStyles), nativeSelectIconStyles = ({
  ownerState,
  theme
}) => _extends({
  position: "absolute",
  right: 0,
  top: "calc(50% - .5em)",
  pointerEvents: "none",
  color: theme.palette.action.active,
  [`&.${nativeSelectClasses_default.disabled}`]: {
    color: theme.palette.action.disabled
  }
}, ownerState.open && {
  transform: "rotate(180deg)"
}, ownerState.variant === "filled" && {
  right: 7
}, ownerState.variant === "outlined" && {
  right: 7
}), NativeSelectIcon = styled_default("svg", {
  name: "MuiNativeSelect",
  slot: "Icon",
  overridesResolver: (props, styles4) => {
    let {
      ownerState
    } = props;
    return [styles4.icon, ownerState.variant && styles4[`icon${capitalize_default(ownerState.variant)}`], ownerState.open && styles4.iconOpen];
  }
})(nativeSelectIconStyles), NativeSelectInput = /* @__PURE__ */ React66.forwardRef(function(props, ref) {
  let {
    className,
    disabled,
    IconComponent,
    inputRef,
    variant = "standard"
  } = props, other = _objectWithoutPropertiesLoose2(props, _excluded46), ownerState = _extends({}, props, {
    disabled,
    variant
  }), classes = useUtilityClasses23(ownerState);
  return /* @__PURE__ */ (0, import_jsx_runtime52.jsxs)(React66.Fragment, {
    children: [/* @__PURE__ */ (0, import_jsx_runtime51.jsx)(NativeSelectSelect, _extends({
      ownerState,
      className: clsx_m_default(classes.select, className),
      disabled,
      ref: inputRef || ref
    }, other)), props.multiple ? null : /* @__PURE__ */ (0, import_jsx_runtime51.jsx)(NativeSelectIcon, {
      as: IconComponent,
      ownerState,
      className: classes.icon
    })]
  });
});
NativeSelectInput.propTypes = {
  children: import_prop_types42.default.node,
  classes: import_prop_types42.default.object,
  className: import_prop_types42.default.string,
  disabled: import_prop_types42.default.bool,
  IconComponent: import_prop_types42.default.elementType.isRequired,
  inputRef: refType_default,
  multiple: import_prop_types42.default.bool,
  name: import_prop_types42.default.string,
  onChange: import_prop_types42.default.func,
  value: import_prop_types42.default.any,
  variant: import_prop_types42.default.oneOf(["standard", "outlined", "filled"])
};
var NativeSelectInput_default = NativeSelectInput;

// node_modules/@mui/material/esm/Select/SelectInput.js
init_styled();
init_useForkRef2();
init_useControlled2();

// node_modules/@mui/material/esm/Select/selectClasses.js
init_base();
function getSelectUtilityClasses(slot) {
  return generateUtilityClass("MuiSelect", slot);
}
var selectClasses = generateUtilityClasses("MuiSelect", ["select", "multiple", "filled", "outlined", "standard", "disabled", "focused", "icon", "iconOpen", "iconFilled", "iconOutlined", "iconStandard", "nativeInput"]), selectClasses_default = selectClasses;

// node_modules/@mui/material/esm/Select/SelectInput.js
var import_jsx_runtime53 = __toESM(require_jsx_runtime()), import_jsx_runtime54 = __toESM(require_jsx_runtime()), _span3, _excluded47 = ["aria-describedby", "aria-label", "autoFocus", "autoWidth", "children", "className", "defaultOpen", "defaultValue", "disabled", "displayEmpty", "IconComponent", "inputRef", "labelId", "MenuProps", "multiple", "name", "onBlur", "onChange", "onClose", "onFocus", "onOpen", "open", "readOnly", "renderValue", "SelectDisplayProps", "tabIndex", "type", "value", "variant"], SelectSelect = styled_default("div", {
  name: "MuiSelect",
  slot: "Select",
  overridesResolver: (props, styles4) => {
    let {
      ownerState
    } = props;
    return [
      {
        [`&.${selectClasses_default.select}`]: styles4.select
      },
      {
        [`&.${selectClasses_default.select}`]: styles4[ownerState.variant]
      },
      {
        [`&.${selectClasses_default.multiple}`]: styles4.multiple
      }
    ];
  }
})(nativeSelectSelectStyles, {
  [`&.${selectClasses_default.select}`]: {
    height: "auto",
    minHeight: "1.4375em",
    textOverflow: "ellipsis",
    whiteSpace: "nowrap",
    overflow: "hidden"
  }
}), SelectIcon = styled_default("svg", {
  name: "MuiSelect",
  slot: "Icon",
  overridesResolver: (props, styles4) => {
    let {
      ownerState
    } = props;
    return [styles4.icon, ownerState.variant && styles4[`icon${capitalize_default(ownerState.variant)}`], ownerState.open && styles4.iconOpen];
  }
})(nativeSelectIconStyles), SelectNativeInput = styled_default("input", {
  shouldForwardProp: (prop) => slotShouldForwardProp(prop) && prop !== "classes",
  name: "MuiSelect",
  slot: "NativeInput",
  overridesResolver: (props, styles4) => styles4.nativeInput
})({
  bottom: 0,
  left: 0,
  position: "absolute",
  opacity: 0,
  pointerEvents: "none",
  width: "100%",
  boxSizing: "border-box"
});
function areEqualValues(a, b) {
  return typeof b == "object" && b !== null ? a === b : String(a) === String(b);
}
function isEmpty5(display) {
  return display == null || typeof display == "string" && !display.trim();
}
var useUtilityClasses24 = (ownerState) => {
  let {
    classes,
    variant,
    disabled,
    multiple,
    open
  } = ownerState, slots = {
    select: ["select", variant, disabled && "disabled", multiple && "multiple"],
    icon: ["icon", `icon${capitalize_default(variant)}`, open && "iconOpen", disabled && "disabled"],
    nativeInput: ["nativeInput"]
  };
  return composeClasses(slots, getSelectUtilityClasses, classes);
}, SelectInput = /* @__PURE__ */ React67.forwardRef(function(props, ref) {
  let {
    "aria-describedby": ariaDescribedby,
    "aria-label": ariaLabel,
    autoFocus,
    autoWidth,
    children,
    className,
    defaultOpen,
    defaultValue,
    disabled,
    displayEmpty,
    IconComponent,
    inputRef: inputRefProp,
    labelId,
    MenuProps = {},
    multiple,
    name,
    onBlur,
    onChange,
    onClose,
    onFocus,
    onOpen,
    open: openProp,
    readOnly,
    renderValue,
    SelectDisplayProps = {},
    tabIndex: tabIndexProp,
    value: valueProp,
    variant = "standard"
  } = props, other = _objectWithoutPropertiesLoose2(props, _excluded47), [value, setValueState] = useControlled_default({
    controlled: valueProp,
    default: defaultValue,
    name: "Select"
  }), [openState, setOpenState] = useControlled_default({
    controlled: openProp,
    default: defaultOpen,
    name: "Select"
  }), inputRef = React67.useRef(null), displayRef = React67.useRef(null), [displayNode, setDisplayNode] = React67.useState(null), {
    current: isOpenControlled
  } = React67.useRef(openProp != null), [menuMinWidthState, setMenuMinWidthState] = React67.useState(), handleRef = useForkRef_default(ref, inputRefProp), handleDisplayRef = React67.useCallback((node) => {
    displayRef.current = node, node && setDisplayNode(node);
  }, []);
  React67.useImperativeHandle(handleRef, () => ({
    focus: () => {
      displayRef.current.focus();
    },
    node: inputRef.current,
    value
  }), [value]), React67.useEffect(() => {
    defaultOpen && openState && displayNode && !isOpenControlled && (setMenuMinWidthState(autoWidth ? null : displayNode.clientWidth), displayRef.current.focus());
  }, [displayNode, autoWidth]), React67.useEffect(() => {
    autoFocus && displayRef.current.focus();
  }, [autoFocus]), React67.useEffect(() => {
    if (!labelId)
      return;
    let label = ownerDocument_default(displayRef.current).getElementById(labelId);
    if (label) {
      let handler = () => {
        getSelection().isCollapsed && displayRef.current.focus();
      };
      return label.addEventListener("click", handler), () => {
        label.removeEventListener("click", handler);
      };
    }
  }, [labelId]);
  let update = (open2, event) => {
    open2 ? onOpen && onOpen(event) : onClose && onClose(event), isOpenControlled || (setMenuMinWidthState(autoWidth ? null : displayNode.clientWidth), setOpenState(open2));
  }, handleMouseDown = (event) => {
    event.button === 0 && (event.preventDefault(), displayRef.current.focus(), update(!0, event));
  }, handleClose = (event) => {
    update(!1, event);
  }, childrenArray = React67.Children.toArray(children), handleChange = (event) => {
    let index = childrenArray.map((child2) => child2.props.value).indexOf(event.target.value);
    if (index === -1)
      return;
    let child = childrenArray[index];
    setValueState(child.props.value), onChange && onChange(event, child);
  }, handleItemClick = (child) => (event) => {
    let newValue;
    if (!!event.currentTarget.hasAttribute("tabindex")) {
      if (multiple) {
        newValue = Array.isArray(value) ? value.slice() : [];
        let itemIndex = value.indexOf(child.props.value);
        itemIndex === -1 ? newValue.push(child.props.value) : newValue.splice(itemIndex, 1);
      } else
        newValue = child.props.value;
      if (child.props.onClick && child.props.onClick(event), value !== newValue && (setValueState(newValue), onChange)) {
        let nativeEvent = event.nativeEvent || event, clonedEvent = new nativeEvent.constructor(nativeEvent.type, nativeEvent);
        Object.defineProperty(clonedEvent, "target", {
          writable: !0,
          value: {
            value: newValue,
            name
          }
        }), onChange(clonedEvent, child);
      }
      multiple || update(!1, event);
    }
  }, handleKeyDown2 = (event) => {
    readOnly || [
      " ",
      "ArrowUp",
      "ArrowDown",
      "Enter"
    ].indexOf(event.key) !== -1 && (event.preventDefault(), update(!0, event));
  }, open = displayNode !== null && openState, handleBlur = (event) => {
    !open && onBlur && (Object.defineProperty(event, "target", {
      writable: !0,
      value: {
        value,
        name
      }
    }), onBlur(event));
  };
  delete other["aria-invalid"];
  let display, displaySingle, displayMultiple = [], computeDisplay = !1, foundMatch = !1;
  (isFilled({
    value
  }) || displayEmpty) && (renderValue ? display = renderValue(value) : computeDisplay = !0);
  let items = childrenArray.map((child, index, arr) => {
    if (!/* @__PURE__ */ React67.isValidElement(child))
      return null;
    (0, import_react_is4.isFragment)(child) && console.error(["MUI: The Select component doesn't accept a Fragment as a child.", "Consider providing an array instead."].join(`
`));
    let selected;
    if (multiple) {
      if (!Array.isArray(value))
        throw new Error("MUI: The `value` prop must be an array when using the `Select` component with `multiple`.");
      selected = value.some((v) => areEqualValues(v, child.props.value)), selected && computeDisplay && displayMultiple.push(child.props.children);
    } else
      selected = areEqualValues(value, child.props.value), selected && computeDisplay && (displaySingle = child.props.children);
    if (selected && (foundMatch = !0), child.props.value === void 0)
      return /* @__PURE__ */ React67.cloneElement(child, {
        "aria-readonly": !0,
        role: "option"
      });
    let isFirstSelectableElement = () => {
      if (value)
        return selected;
      let firstSelectableElement = arr.find((item) => item.props.value !== void 0 && item.props.disabled !== !0);
      return child === firstSelectableElement ? !0 : selected;
    };
    return /* @__PURE__ */ React67.cloneElement(child, {
      "aria-selected": selected ? "true" : "false",
      onClick: handleItemClick(child),
      onKeyUp: (event) => {
        event.key === " " && event.preventDefault(), child.props.onKeyUp && child.props.onKeyUp(event);
      },
      role: "option",
      selected: arr[0].props.value === void 0 || arr[0].props.disabled === !0 ? isFirstSelectableElement() : selected,
      value: void 0,
      "data-value": child.props.value
    });
  });
  React67.useEffect(() => {
    if (!foundMatch && !multiple && value !== "") {
      let values3 = childrenArray.map((child) => child.props.value);
      console.warn([`MUI: You have provided an out-of-range value \`${value}\` for the select ${name ? `(name="${name}") ` : ""}component.`, "Consider providing a value that matches one of the available options or ''.", `The available values are ${values3.filter((x) => x != null).map((x) => `\`${x}\``).join(", ") || '""'}.`].join(`
`));
    }
  }, [foundMatch, childrenArray, multiple, name, value]), computeDisplay && (multiple ? displayMultiple.length === 0 ? display = null : display = displayMultiple.reduce((output, child, index) => (output.push(child), index < displayMultiple.length - 1 && output.push(", "), output), []) : display = displaySingle);
  let menuMinWidth = menuMinWidthState;
  !autoWidth && isOpenControlled && displayNode && (menuMinWidth = displayNode.clientWidth);
  let tabIndex;
  typeof tabIndexProp < "u" ? tabIndex = tabIndexProp : tabIndex = disabled ? null : 0;
  let buttonId = SelectDisplayProps.id || (name ? `mui-component-select-${name}` : void 0), ownerState = _extends({}, props, {
    variant,
    value,
    open
  }), classes = useUtilityClasses24(ownerState);
  return /* @__PURE__ */ (0, import_jsx_runtime54.jsxs)(React67.Fragment, {
    children: [/* @__PURE__ */ (0, import_jsx_runtime53.jsx)(SelectSelect, _extends({
      ref: handleDisplayRef,
      tabIndex,
      role: "button",
      "aria-disabled": disabled ? "true" : void 0,
      "aria-expanded": open ? "true" : "false",
      "aria-haspopup": "listbox",
      "aria-label": ariaLabel,
      "aria-labelledby": [labelId, buttonId].filter(Boolean).join(" ") || void 0,
      "aria-describedby": ariaDescribedby,
      onKeyDown: handleKeyDown2,
      onMouseDown: disabled || readOnly ? null : handleMouseDown,
      onBlur: handleBlur,
      onFocus
    }, SelectDisplayProps, {
      ownerState,
      className: clsx_m_default(SelectDisplayProps.className, classes.select, className),
      id: buttonId,
      children: isEmpty5(display) ? _span3 || (_span3 = /* @__PURE__ */ (0, import_jsx_runtime53.jsx)("span", {
        className: "notranslate",
        children: "\u200B"
      })) : display
    })), /* @__PURE__ */ (0, import_jsx_runtime53.jsx)(SelectNativeInput, _extends({
      value: Array.isArray(value) ? value.join(",") : value,
      name,
      ref: inputRef,
      "aria-hidden": !0,
      onChange: handleChange,
      tabIndex: -1,
      disabled,
      className: classes.nativeInput,
      autoFocus,
      ownerState
    }, other)), /* @__PURE__ */ (0, import_jsx_runtime53.jsx)(SelectIcon, {
      as: IconComponent,
      className: classes.icon,
      ownerState
    }), /* @__PURE__ */ (0, import_jsx_runtime53.jsx)(Menu_default, _extends({
      id: `menu-${name || ""}`,
      anchorEl: displayNode,
      open,
      onClose: handleClose,
      anchorOrigin: {
        vertical: "bottom",
        horizontal: "center"
      },
      transformOrigin: {
        vertical: "top",
        horizontal: "center"
      }
    }, MenuProps, {
      MenuListProps: _extends({
        "aria-labelledby": labelId,
        role: "listbox",
        disableListWrap: !0
      }, MenuProps.MenuListProps),
      PaperProps: _extends({}, MenuProps.PaperProps, {
        style: _extends({
          minWidth: menuMinWidth
        }, MenuProps.PaperProps != null ? MenuProps.PaperProps.style : null)
      }),
      children: items
    }))]
  });
});
SelectInput.propTypes = {
  "aria-describedby": import_prop_types43.default.string,
  "aria-label": import_prop_types43.default.string,
  autoFocus: import_prop_types43.default.bool,
  autoWidth: import_prop_types43.default.bool,
  children: import_prop_types43.default.node,
  classes: import_prop_types43.default.object,
  className: import_prop_types43.default.string,
  defaultOpen: import_prop_types43.default.bool,
  defaultValue: import_prop_types43.default.any,
  disabled: import_prop_types43.default.bool,
  displayEmpty: import_prop_types43.default.bool,
  IconComponent: import_prop_types43.default.elementType.isRequired,
  inputRef: refType_default,
  labelId: import_prop_types43.default.string,
  MenuProps: import_prop_types43.default.object,
  multiple: import_prop_types43.default.bool,
  name: import_prop_types43.default.string,
  onBlur: import_prop_types43.default.func,
  onChange: import_prop_types43.default.func,
  onClose: import_prop_types43.default.func,
  onFocus: import_prop_types43.default.func,
  onOpen: import_prop_types43.default.func,
  open: import_prop_types43.default.bool,
  readOnly: import_prop_types43.default.bool,
  renderValue: import_prop_types43.default.func,
  SelectDisplayProps: import_prop_types43.default.object,
  tabIndex: import_prop_types43.default.oneOfType([import_prop_types43.default.number, import_prop_types43.default.string]),
  type: import_prop_types43.default.any,
  value: import_prop_types43.default.any,
  variant: import_prop_types43.default.oneOf(["standard", "outlined", "filled"])
};
var SelectInput_default = SelectInput;

// node_modules/@mui/material/esm/internal/svg-icons/ArrowDropDown.js
var React68 = __toESM(require_react());
init_createSvgIcon();
var import_jsx_runtime55 = __toESM(require_jsx_runtime()), ArrowDropDown_default = createSvgIcon(/* @__PURE__ */ (0, import_jsx_runtime55.jsx)("path", {
  d: "M7 10l5 5 5-5z"
}), "ArrowDropDown");

// node_modules/@mui/material/esm/Select/Select.js
init_useThemeProps3();
init_useForkRef2();
init_styled();
var import_jsx_runtime56 = __toESM(require_jsx_runtime()), _StyledInput, _StyledFilledInput, _excluded48 = ["autoWidth", "children", "classes", "className", "defaultOpen", "displayEmpty", "IconComponent", "id", "input", "inputProps", "label", "labelId", "MenuProps", "multiple", "native", "onClose", "onOpen", "open", "renderValue", "SelectDisplayProps", "variant"], useUtilityClasses25 = (ownerState) => {
  let {
    classes
  } = ownerState;
  return classes;
}, styledRootConfig = {
  name: "MuiSelect",
  overridesResolver: (props, styles4) => styles4.root,
  shouldForwardProp: (prop) => rootShouldForwardProp(prop) && prop !== "variant",
  slot: "Root"
}, StyledInput = styled_default(Input_default, styledRootConfig)(""), StyledOutlinedInput = styled_default(OutlinedInput_default, styledRootConfig)(""), StyledFilledInput = styled_default(FilledInput_default, styledRootConfig)(""), Select = /* @__PURE__ */ React69.forwardRef(function(inProps, ref) {
  let props = useThemeProps2({
    name: "MuiSelect",
    props: inProps
  }), {
    autoWidth = !1,
    children,
    classes: classesProp = {},
    className,
    defaultOpen = !1,
    displayEmpty = !1,
    IconComponent = ArrowDropDown_default,
    id,
    input,
    inputProps,
    label,
    labelId,
    MenuProps,
    multiple = !1,
    native = !1,
    onClose,
    onOpen,
    open,
    renderValue,
    SelectDisplayProps,
    variant: variantProp = "outlined"
  } = props, other = _objectWithoutPropertiesLoose2(props, _excluded48), inputComponent = native ? NativeSelectInput_default : SelectInput_default, muiFormControl = useFormControl(), variant = formControlState({
    props,
    muiFormControl,
    states: ["variant"]
  }).variant || variantProp, InputComponent = input || {
    standard: _StyledInput || (_StyledInput = /* @__PURE__ */ (0, import_jsx_runtime56.jsx)(StyledInput, {})),
    outlined: /* @__PURE__ */ (0, import_jsx_runtime56.jsx)(StyledOutlinedInput, {
      label
    }),
    filled: _StyledFilledInput || (_StyledFilledInput = /* @__PURE__ */ (0, import_jsx_runtime56.jsx)(StyledFilledInput, {}))
  }[variant], ownerState = _extends({}, props, {
    variant,
    classes: classesProp
  }), classes = useUtilityClasses25(ownerState), inputComponentRef = useForkRef_default(ref, InputComponent.ref);
  return /* @__PURE__ */ (0, import_jsx_runtime56.jsx)(React69.Fragment, {
    children: /* @__PURE__ */ React69.cloneElement(InputComponent, _extends({
      inputComponent,
      inputProps: _extends({
        children,
        IconComponent,
        variant,
        type: void 0,
        multiple
      }, native ? {
        id
      } : {
        autoWidth,
        defaultOpen,
        displayEmpty,
        labelId,
        MenuProps,
        onClose,
        onOpen,
        open,
        renderValue,
        SelectDisplayProps: _extends({
          id
        }, SelectDisplayProps)
      }, inputProps, {
        classes: inputProps ? deepmerge(classes, inputProps.classes) : classes
      }, input ? input.props.inputProps : {})
    }, multiple && native && variant === "outlined" ? {
      notched: !0
    } : {}, {
      ref: inputComponentRef,
      className: clsx_m_default(InputComponent.props.className, className)
    }, !input && {
      variant
    }, other))
  });
});
Select.propTypes = {
  autoWidth: import_prop_types44.default.bool,
  children: import_prop_types44.default.node,
  classes: import_prop_types44.default.object,
  className: import_prop_types44.default.string,
  defaultOpen: import_prop_types44.default.bool,
  defaultValue: import_prop_types44.default.any,
  displayEmpty: import_prop_types44.default.bool,
  IconComponent: import_prop_types44.default.elementType,
  id: import_prop_types44.default.string,
  input: import_prop_types44.default.element,
  inputProps: import_prop_types44.default.object,
  label: import_prop_types44.default.node,
  labelId: import_prop_types44.default.string,
  MenuProps: import_prop_types44.default.object,
  multiple: import_prop_types44.default.bool,
  native: import_prop_types44.default.bool,
  onChange: import_prop_types44.default.func,
  onClose: import_prop_types44.default.func,
  onOpen: import_prop_types44.default.func,
  open: import_prop_types44.default.bool,
  renderValue: import_prop_types44.default.func,
  SelectDisplayProps: import_prop_types44.default.object,
  sx: import_prop_types44.default.oneOfType([import_prop_types44.default.arrayOf(import_prop_types44.default.oneOfType([import_prop_types44.default.func, import_prop_types44.default.object, import_prop_types44.default.bool])), import_prop_types44.default.func, import_prop_types44.default.object]),
  value: import_prop_types44.default.oneOfType([import_prop_types44.default.oneOf([""]), import_prop_types44.default.any]),
  variant: import_prop_types44.default.oneOf(["filled", "outlined", "standard"])
};
Select.muiName = "Select";
var Select_default = Select;

// node_modules/@mui/material/esm/TextField/textFieldClasses.js
init_base();
function getTextFieldUtilityClass(slot) {
  return generateUtilityClass("MuiTextField", slot);
}
var textFieldClasses = generateUtilityClasses("MuiTextField", ["root"]);

// node_modules/@mui/material/esm/TextField/TextField.js
var import_jsx_runtime57 = __toESM(require_jsx_runtime()), import_jsx_runtime58 = __toESM(require_jsx_runtime()), _excluded49 = ["autoComplete", "autoFocus", "children", "className", "color", "defaultValue", "disabled", "error", "FormHelperTextProps", "fullWidth", "helperText", "id", "InputLabelProps", "inputProps", "InputProps", "inputRef", "label", "maxRows", "minRows", "multiline", "name", "onBlur", "onChange", "onFocus", "placeholder", "required", "rows", "select", "SelectProps", "type", "value", "variant"], variantComponent = {
  standard: Input_default,
  filled: FilledInput_default,
  outlined: OutlinedInput_default
}, useUtilityClasses26 = (ownerState) => {
  let {
    classes
  } = ownerState;
  return composeClasses({
    root: ["root"]
  }, getTextFieldUtilityClass, classes);
}, TextFieldRoot = styled_default(FormControl_default, {
  name: "MuiTextField",
  slot: "Root",
  overridesResolver: (props, styles4) => styles4.root
})({}), TextField = /* @__PURE__ */ React70.forwardRef(function(inProps, ref) {
  let props = useThemeProps2({
    props: inProps,
    name: "MuiTextField"
  }), {
    autoComplete,
    autoFocus = !1,
    children,
    className,
    color: color2 = "primary",
    defaultValue,
    disabled = !1,
    error = !1,
    FormHelperTextProps,
    fullWidth = !1,
    helperText,
    id: idOverride,
    InputLabelProps,
    inputProps,
    InputProps,
    inputRef,
    label,
    maxRows,
    minRows,
    multiline = !1,
    name,
    onBlur,
    onChange,
    onFocus,
    placeholder,
    required = !1,
    rows,
    select = !1,
    SelectProps,
    type,
    value,
    variant = "outlined"
  } = props, other = _objectWithoutPropertiesLoose2(props, _excluded49), ownerState = _extends({}, props, {
    autoFocus,
    color: color2,
    disabled,
    error,
    fullWidth,
    multiline,
    required,
    select,
    variant
  }), classes = useUtilityClasses26(ownerState);
  select && !children && console.error("MUI: `children` must be passed when using the `TextField` component with `select`.");
  let InputMore = {};
  variant === "outlined" && (InputLabelProps && typeof InputLabelProps.shrink < "u" && (InputMore.notched = InputLabelProps.shrink), InputMore.label = label), select && ((!SelectProps || !SelectProps.native) && (InputMore.id = void 0), InputMore["aria-describedby"] = void 0);
  let id = useId2(idOverride), helperTextId = helperText && id ? `${id}-helper-text` : void 0, inputLabelId = label && id ? `${id}-label` : void 0, InputComponent = variantComponent[variant], InputElement = /* @__PURE__ */ (0, import_jsx_runtime57.jsx)(InputComponent, _extends({
    "aria-describedby": helperTextId,
    autoComplete,
    autoFocus,
    defaultValue,
    fullWidth,
    multiline,
    name,
    rows,
    maxRows,
    minRows,
    type,
    value,
    id,
    inputRef,
    onBlur,
    onChange,
    onFocus,
    placeholder,
    inputProps
  }, InputMore, InputProps));
  return /* @__PURE__ */ (0, import_jsx_runtime58.jsxs)(TextFieldRoot, _extends({
    className: clsx_m_default(classes.root, className),
    disabled,
    error,
    fullWidth,
    ref,
    required,
    color: color2,
    variant,
    ownerState
  }, other, {
    children: [label != null && label !== "" && /* @__PURE__ */ (0, import_jsx_runtime57.jsx)(InputLabel_default, _extends({
      htmlFor: id,
      id: inputLabelId
    }, InputLabelProps, {
      children: label
    })), select ? /* @__PURE__ */ (0, import_jsx_runtime57.jsx)(Select_default, _extends({
      "aria-describedby": helperTextId,
      id,
      labelId: inputLabelId,
      value,
      input: InputElement
    }, SelectProps, {
      children
    })) : InputElement, helperText && /* @__PURE__ */ (0, import_jsx_runtime57.jsx)(FormHelperText_default, _extends({
      id: helperTextId
    }, FormHelperTextProps, {
      children: helperText
    }))]
  }));
});
TextField.propTypes = {
  autoComplete: import_prop_types45.default.string,
  autoFocus: import_prop_types45.default.bool,
  children: import_prop_types45.default.node,
  classes: import_prop_types45.default.object,
  className: import_prop_types45.default.string,
  color: import_prop_types45.default.oneOfType([import_prop_types45.default.oneOf(["primary", "secondary", "error", "info", "success", "warning"]), import_prop_types45.default.string]),
  defaultValue: import_prop_types45.default.any,
  disabled: import_prop_types45.default.bool,
  error: import_prop_types45.default.bool,
  FormHelperTextProps: import_prop_types45.default.object,
  fullWidth: import_prop_types45.default.bool,
  helperText: import_prop_types45.default.node,
  id: import_prop_types45.default.string,
  InputLabelProps: import_prop_types45.default.object,
  inputProps: import_prop_types45.default.object,
  InputProps: import_prop_types45.default.object,
  inputRef: refType_default,
  label: import_prop_types45.default.node,
  margin: import_prop_types45.default.oneOf(["dense", "none", "normal"]),
  maxRows: import_prop_types45.default.oneOfType([import_prop_types45.default.number, import_prop_types45.default.string]),
  minRows: import_prop_types45.default.oneOfType([import_prop_types45.default.number, import_prop_types45.default.string]),
  multiline: import_prop_types45.default.bool,
  name: import_prop_types45.default.string,
  onBlur: import_prop_types45.default.func,
  onChange: import_prop_types45.default.func,
  onFocus: import_prop_types45.default.func,
  placeholder: import_prop_types45.default.string,
  required: import_prop_types45.default.bool,
  rows: import_prop_types45.default.oneOfType([import_prop_types45.default.number, import_prop_types45.default.string]),
  select: import_prop_types45.default.bool,
  SelectProps: import_prop_types45.default.object,
  size: import_prop_types45.default.oneOfType([import_prop_types45.default.oneOf(["medium", "small"]), import_prop_types45.default.string]),
  sx: import_prop_types45.default.oneOfType([import_prop_types45.default.arrayOf(import_prop_types45.default.oneOfType([import_prop_types45.default.func, import_prop_types45.default.object, import_prop_types45.default.bool])), import_prop_types45.default.func, import_prop_types45.default.object]),
  type: import_prop_types45.default.string,
  value: import_prop_types45.default.any,
  variant: import_prop_types45.default.oneOf(["filled", "outlined", "standard"])
};
var TextField_default = TextField;

// app/components/table.tsx
var React89 = __toESM(require_react());

// node_modules/@mui/material/esm/styles/index.js
init_createTheme3();
init_styled();

// node_modules/@mui/material/esm/Box/Box.js
init_esm3();
var import_prop_types46 = __toESM(require_prop_types());

// node_modules/@mui/material/esm/className/index.js
init_esm2();

// node_modules/@mui/material/esm/Box/Box.js
var defaultTheme2 = createTheme_default2(), Box = createBox({
  defaultTheme: defaultTheme2,
  defaultClassName: "MuiBox-root",
  generateClassName: ClassNameGenerator_default.generate
});
Box.propTypes = {
  children: import_prop_types46.default.node,
  component: import_prop_types46.default.elementType,
  sx: import_prop_types46.default.oneOfType([import_prop_types46.default.arrayOf(import_prop_types46.default.oneOfType([import_prop_types46.default.func, import_prop_types46.default.object, import_prop_types46.default.bool])), import_prop_types46.default.func, import_prop_types46.default.object])
};
var Box_default = Box;

// node_modules/@mui/material/esm/Table/Table.js
init_objectWithoutPropertiesLoose();
init_extends();
var React72 = __toESM(require_react()), import_prop_types47 = __toESM(require_prop_types());
init_clsx_m();
init_base();

// node_modules/@mui/material/esm/Table/TableContext.js
var React71 = __toESM(require_react()), TableContext = /* @__PURE__ */ React71.createContext();
TableContext.displayName = "TableContext";
var TableContext_default = TableContext;

// node_modules/@mui/material/esm/Table/Table.js
init_useThemeProps3();
init_styled();

// node_modules/@mui/material/esm/Table/tableClasses.js
init_base();
function getTableUtilityClass(slot) {
  return generateUtilityClass("MuiTable", slot);
}
var tableClasses = generateUtilityClasses("MuiTable", ["root", "stickyHeader"]);

// node_modules/@mui/material/esm/Table/Table.js
var import_jsx_runtime59 = __toESM(require_jsx_runtime()), _excluded50 = ["className", "component", "padding", "size", "stickyHeader"], useUtilityClasses27 = (ownerState) => {
  let {
    classes,
    stickyHeader
  } = ownerState;
  return composeClasses({
    root: ["root", stickyHeader && "stickyHeader"]
  }, getTableUtilityClass, classes);
}, TableRoot = styled_default("table", {
  name: "MuiTable",
  slot: "Root",
  overridesResolver: (props, styles4) => {
    let {
      ownerState
    } = props;
    return [styles4.root, ownerState.stickyHeader && styles4.stickyHeader];
  }
})(({
  theme,
  ownerState
}) => _extends({
  display: "table",
  width: "100%",
  borderCollapse: "collapse",
  borderSpacing: 0,
  "& caption": _extends({}, theme.typography.body2, {
    padding: theme.spacing(2),
    color: (theme.vars || theme).palette.text.secondary,
    textAlign: "left",
    captionSide: "bottom"
  })
}, ownerState.stickyHeader && {
  borderCollapse: "separate"
})), defaultComponent = "table", Table = /* @__PURE__ */ React72.forwardRef(function(inProps, ref) {
  let props = useThemeProps2({
    props: inProps,
    name: "MuiTable"
  }), {
    className,
    component = defaultComponent,
    padding: padding2 = "normal",
    size = "medium",
    stickyHeader = !1
  } = props, other = _objectWithoutPropertiesLoose2(props, _excluded50), ownerState = _extends({}, props, {
    component,
    padding: padding2,
    size,
    stickyHeader
  }), classes = useUtilityClasses27(ownerState), table = React72.useMemo(() => ({
    padding: padding2,
    size,
    stickyHeader
  }), [padding2, size, stickyHeader]);
  return /* @__PURE__ */ (0, import_jsx_runtime59.jsx)(TableContext_default.Provider, {
    value: table,
    children: /* @__PURE__ */ (0, import_jsx_runtime59.jsx)(TableRoot, _extends({
      as: component,
      role: component === defaultComponent ? null : "table",
      ref,
      className: clsx_m_default(classes.root, className),
      ownerState
    }, other))
  });
});
Table.propTypes = {
  children: import_prop_types47.default.node,
  classes: import_prop_types47.default.object,
  className: import_prop_types47.default.string,
  component: import_prop_types47.default.elementType,
  padding: import_prop_types47.default.oneOf(["checkbox", "none", "normal"]),
  size: import_prop_types47.default.oneOfType([import_prop_types47.default.oneOf(["medium", "small"]), import_prop_types47.default.string]),
  stickyHeader: import_prop_types47.default.bool,
  sx: import_prop_types47.default.oneOfType([import_prop_types47.default.arrayOf(import_prop_types47.default.oneOfType([import_prop_types47.default.func, import_prop_types47.default.object, import_prop_types47.default.bool])), import_prop_types47.default.func, import_prop_types47.default.object])
};
var Table_default = Table;

// node_modules/@mui/material/esm/TableBody/TableBody.js
init_extends();
init_objectWithoutPropertiesLoose();
var React74 = __toESM(require_react()), import_prop_types48 = __toESM(require_prop_types());
init_clsx_m();
init_base();

// node_modules/@mui/material/esm/Table/Tablelvl2Context.js
var React73 = __toESM(require_react()), Tablelvl2Context = /* @__PURE__ */ React73.createContext();
Tablelvl2Context.displayName = "Tablelvl2Context";
var Tablelvl2Context_default = Tablelvl2Context;

// node_modules/@mui/material/esm/TableBody/TableBody.js
init_useThemeProps3();
init_styled();

// node_modules/@mui/material/esm/TableBody/tableBodyClasses.js
init_base();
function getTableBodyUtilityClass(slot) {
  return generateUtilityClass("MuiTableBody", slot);
}
var tableBodyClasses = generateUtilityClasses("MuiTableBody", ["root"]);

// node_modules/@mui/material/esm/TableBody/TableBody.js
var import_jsx_runtime60 = __toESM(require_jsx_runtime()), _excluded51 = ["className", "component"], useUtilityClasses28 = (ownerState) => {
  let {
    classes
  } = ownerState;
  return composeClasses({
    root: ["root"]
  }, getTableBodyUtilityClass, classes);
}, TableBodyRoot = styled_default("tbody", {
  name: "MuiTableBody",
  slot: "Root",
  overridesResolver: (props, styles4) => styles4.root
})({
  display: "table-row-group"
}), tablelvl2 = {
  variant: "body"
}, defaultComponent2 = "tbody", TableBody = /* @__PURE__ */ React74.forwardRef(function(inProps, ref) {
  let props = useThemeProps2({
    props: inProps,
    name: "MuiTableBody"
  }), {
    className,
    component = defaultComponent2
  } = props, other = _objectWithoutPropertiesLoose2(props, _excluded51), ownerState = _extends({}, props, {
    component
  }), classes = useUtilityClasses28(ownerState);
  return /* @__PURE__ */ (0, import_jsx_runtime60.jsx)(Tablelvl2Context_default.Provider, {
    value: tablelvl2,
    children: /* @__PURE__ */ (0, import_jsx_runtime60.jsx)(TableBodyRoot, _extends({
      className: clsx_m_default(classes.root, className),
      as: component,
      ref,
      role: component === defaultComponent2 ? null : "rowgroup",
      ownerState
    }, other))
  });
});
TableBody.propTypes = {
  children: import_prop_types48.default.node,
  classes: import_prop_types48.default.object,
  className: import_prop_types48.default.string,
  component: import_prop_types48.default.elementType,
  sx: import_prop_types48.default.oneOfType([import_prop_types48.default.arrayOf(import_prop_types48.default.oneOfType([import_prop_types48.default.func, import_prop_types48.default.object, import_prop_types48.default.bool])), import_prop_types48.default.func, import_prop_types48.default.object])
};
var TableBody_default = TableBody;

// node_modules/@mui/material/esm/TableCell/TableCell.js
init_objectWithoutPropertiesLoose();
init_extends();
var React75 = __toESM(require_react()), import_prop_types49 = __toESM(require_prop_types());
init_clsx_m();
init_base();
init_esm3();
init_capitalize2();
init_useThemeProps3();
init_styled();

// node_modules/@mui/material/esm/TableCell/tableCellClasses.js
init_base();
function getTableCellUtilityClass(slot) {
  return generateUtilityClass("MuiTableCell", slot);
}
var tableCellClasses = generateUtilityClasses("MuiTableCell", ["root", "head", "body", "footer", "sizeSmall", "sizeMedium", "paddingCheckbox", "paddingNone", "alignLeft", "alignCenter", "alignRight", "alignJustify", "stickyHeader"]), tableCellClasses_default = tableCellClasses;

// node_modules/@mui/material/esm/TableCell/TableCell.js
var import_jsx_runtime61 = __toESM(require_jsx_runtime()), _excluded52 = ["align", "className", "component", "padding", "scope", "size", "sortDirection", "variant"], useUtilityClasses29 = (ownerState) => {
  let {
    classes,
    variant,
    align,
    padding: padding2,
    size,
    stickyHeader
  } = ownerState, slots = {
    root: ["root", variant, stickyHeader && "stickyHeader", align !== "inherit" && `align${capitalize_default(align)}`, padding2 !== "normal" && `padding${capitalize_default(padding2)}`, `size${capitalize_default(size)}`]
  };
  return composeClasses(slots, getTableCellUtilityClass, classes);
}, TableCellRoot = styled_default("td", {
  name: "MuiTableCell",
  slot: "Root",
  overridesResolver: (props, styles4) => {
    let {
      ownerState
    } = props;
    return [styles4.root, styles4[ownerState.variant], styles4[`size${capitalize_default(ownerState.size)}`], ownerState.padding !== "normal" && styles4[`padding${capitalize_default(ownerState.padding)}`], ownerState.align !== "inherit" && styles4[`align${capitalize_default(ownerState.align)}`], ownerState.stickyHeader && styles4.stickyHeader];
  }
})(({
  theme,
  ownerState
}) => _extends({}, theme.typography.body2, {
  display: "table-cell",
  verticalAlign: "inherit",
  borderBottom: theme.vars ? `1px solid ${theme.vars.palette.TableCell.border}` : `1px solid
    ${theme.palette.mode === "light" ? lighten(alpha(theme.palette.divider, 1), 0.88) : darken(alpha(theme.palette.divider, 1), 0.68)}`,
  textAlign: "left",
  padding: 16
}, ownerState.variant === "head" && {
  color: (theme.vars || theme).palette.text.primary,
  lineHeight: theme.typography.pxToRem(24),
  fontWeight: theme.typography.fontWeightMedium
}, ownerState.variant === "body" && {
  color: (theme.vars || theme).palette.text.primary
}, ownerState.variant === "footer" && {
  color: (theme.vars || theme).palette.text.secondary,
  lineHeight: theme.typography.pxToRem(21),
  fontSize: theme.typography.pxToRem(12)
}, ownerState.size === "small" && {
  padding: "6px 16px",
  [`&.${tableCellClasses_default.paddingCheckbox}`]: {
    width: 24,
    padding: "0 12px 0 16px",
    "& > *": {
      padding: 0
    }
  }
}, ownerState.padding === "checkbox" && {
  width: 48,
  padding: "0 0 0 4px"
}, ownerState.padding === "none" && {
  padding: 0
}, ownerState.align === "left" && {
  textAlign: "left"
}, ownerState.align === "center" && {
  textAlign: "center"
}, ownerState.align === "right" && {
  textAlign: "right",
  flexDirection: "row-reverse"
}, ownerState.align === "justify" && {
  textAlign: "justify"
}, ownerState.stickyHeader && {
  position: "sticky",
  top: 0,
  zIndex: 2,
  backgroundColor: (theme.vars || theme).palette.background.default
})), TableCell = /* @__PURE__ */ React75.forwardRef(function(inProps, ref) {
  let props = useThemeProps2({
    props: inProps,
    name: "MuiTableCell"
  }), {
    align = "inherit",
    className,
    component: componentProp,
    padding: paddingProp,
    scope: scopeProp,
    size: sizeProp,
    sortDirection,
    variant: variantProp
  } = props, other = _objectWithoutPropertiesLoose2(props, _excluded52), table = React75.useContext(TableContext_default), tablelvl24 = React75.useContext(Tablelvl2Context_default), isHeadCell = tablelvl24 && tablelvl24.variant === "head", component;
  componentProp ? component = componentProp : component = isHeadCell ? "th" : "td";
  let scope = scopeProp;
  !scope && isHeadCell && (scope = "col");
  let variant = variantProp || tablelvl24 && tablelvl24.variant, ownerState = _extends({}, props, {
    align,
    component,
    padding: paddingProp || (table && table.padding ? table.padding : "normal"),
    size: sizeProp || (table && table.size ? table.size : "medium"),
    sortDirection,
    stickyHeader: variant === "head" && table && table.stickyHeader,
    variant
  }), classes = useUtilityClasses29(ownerState), ariaSort = null;
  return sortDirection && (ariaSort = sortDirection === "asc" ? "ascending" : "descending"), /* @__PURE__ */ (0, import_jsx_runtime61.jsx)(TableCellRoot, _extends({
    as: component,
    ref,
    className: clsx_m_default(classes.root, className),
    "aria-sort": ariaSort,
    scope,
    ownerState
  }, other));
});
TableCell.propTypes = {
  align: import_prop_types49.default.oneOf(["center", "inherit", "justify", "left", "right"]),
  children: import_prop_types49.default.node,
  classes: import_prop_types49.default.object,
  className: import_prop_types49.default.string,
  component: import_prop_types49.default.elementType,
  padding: import_prop_types49.default.oneOf(["checkbox", "none", "normal"]),
  scope: import_prop_types49.default.string,
  size: import_prop_types49.default.oneOfType([import_prop_types49.default.oneOf(["medium", "small"]), import_prop_types49.default.string]),
  sortDirection: import_prop_types49.default.oneOf(["asc", "desc", !1]),
  sx: import_prop_types49.default.oneOfType([import_prop_types49.default.arrayOf(import_prop_types49.default.oneOfType([import_prop_types49.default.func, import_prop_types49.default.object, import_prop_types49.default.bool])), import_prop_types49.default.func, import_prop_types49.default.object]),
  variant: import_prop_types49.default.oneOfType([import_prop_types49.default.oneOf(["body", "footer", "head"]), import_prop_types49.default.string])
};
var TableCell_default = TableCell;

// node_modules/@mui/material/esm/TableContainer/TableContainer.js
init_extends();
init_objectWithoutPropertiesLoose();
var React76 = __toESM(require_react()), import_prop_types50 = __toESM(require_prop_types());
init_clsx_m();
init_base();
init_useThemeProps3();
init_styled();

// node_modules/@mui/material/esm/TableContainer/tableContainerClasses.js
init_base();
function getTableContainerUtilityClass(slot) {
  return generateUtilityClass("MuiTableContainer", slot);
}
var tableContainerClasses = generateUtilityClasses("MuiTableContainer", ["root"]);

// node_modules/@mui/material/esm/TableContainer/TableContainer.js
var import_jsx_runtime62 = __toESM(require_jsx_runtime()), _excluded53 = ["className", "component"], useUtilityClasses30 = (ownerState) => {
  let {
    classes
  } = ownerState;
  return composeClasses({
    root: ["root"]
  }, getTableContainerUtilityClass, classes);
}, TableContainerRoot = styled_default("div", {
  name: "MuiTableContainer",
  slot: "Root",
  overridesResolver: (props, styles4) => styles4.root
})({
  width: "100%",
  overflowX: "auto"
}), TableContainer = /* @__PURE__ */ React76.forwardRef(function(inProps, ref) {
  let props = useThemeProps2({
    props: inProps,
    name: "MuiTableContainer"
  }), {
    className,
    component = "div"
  } = props, other = _objectWithoutPropertiesLoose2(props, _excluded53), ownerState = _extends({}, props, {
    component
  }), classes = useUtilityClasses30(ownerState);
  return /* @__PURE__ */ (0, import_jsx_runtime62.jsx)(TableContainerRoot, _extends({
    ref,
    as: component,
    className: clsx_m_default(classes.root, className),
    ownerState
  }, other));
});
TableContainer.propTypes = {
  children: import_prop_types50.default.node,
  classes: import_prop_types50.default.object,
  className: import_prop_types50.default.string,
  component: import_prop_types50.default.elementType,
  sx: import_prop_types50.default.oneOfType([import_prop_types50.default.arrayOf(import_prop_types50.default.oneOfType([import_prop_types50.default.func, import_prop_types50.default.object, import_prop_types50.default.bool])), import_prop_types50.default.func, import_prop_types50.default.object])
};
var TableContainer_default = TableContainer;

// node_modules/@mui/material/esm/TableFooter/TableFooter.js
init_extends();
init_objectWithoutPropertiesLoose();
var React77 = __toESM(require_react()), import_prop_types51 = __toESM(require_prop_types());
init_clsx_m();
init_base();
init_useThemeProps3();
init_styled();

// node_modules/@mui/material/esm/TableFooter/tableFooterClasses.js
init_base();
function getTableFooterUtilityClass(slot) {
  return generateUtilityClass("MuiTableFooter", slot);
}
var tableFooterClasses = generateUtilityClasses("MuiTableFooter", ["root"]);

// node_modules/@mui/material/esm/TableFooter/TableFooter.js
var import_jsx_runtime63 = __toESM(require_jsx_runtime()), _excluded54 = ["className", "component"], useUtilityClasses31 = (ownerState) => {
  let {
    classes
  } = ownerState;
  return composeClasses({
    root: ["root"]
  }, getTableFooterUtilityClass, classes);
}, TableFooterRoot = styled_default("tfoot", {
  name: "MuiTableFooter",
  slot: "Root",
  overridesResolver: (props, styles4) => styles4.root
})({
  display: "table-footer-group"
}), tablelvl22 = {
  variant: "footer"
}, defaultComponent3 = "tfoot", TableFooter = /* @__PURE__ */ React77.forwardRef(function(inProps, ref) {
  let props = useThemeProps2({
    props: inProps,
    name: "MuiTableFooter"
  }), {
    className,
    component = defaultComponent3
  } = props, other = _objectWithoutPropertiesLoose2(props, _excluded54), ownerState = _extends({}, props, {
    component
  }), classes = useUtilityClasses31(ownerState);
  return /* @__PURE__ */ (0, import_jsx_runtime63.jsx)(Tablelvl2Context_default.Provider, {
    value: tablelvl22,
    children: /* @__PURE__ */ (0, import_jsx_runtime63.jsx)(TableFooterRoot, _extends({
      as: component,
      className: clsx_m_default(classes.root, className),
      ref,
      role: component === defaultComponent3 ? null : "rowgroup",
      ownerState
    }, other))
  });
});
TableFooter.propTypes = {
  children: import_prop_types51.default.node,
  classes: import_prop_types51.default.object,
  className: import_prop_types51.default.string,
  component: import_prop_types51.default.elementType,
  sx: import_prop_types51.default.oneOfType([import_prop_types51.default.arrayOf(import_prop_types51.default.oneOfType([import_prop_types51.default.func, import_prop_types51.default.object, import_prop_types51.default.bool])), import_prop_types51.default.func, import_prop_types51.default.object])
};
var TableFooter_default = TableFooter;

// node_modules/@mui/material/esm/TablePagination/TablePagination.js
init_objectWithoutPropertiesLoose();
init_extends();
var React86 = __toESM(require_react()), import_prop_types56 = __toESM(require_prop_types());
init_clsx_m();
init_esm2();
init_base();
init_styled();
init_useThemeProps3();

// node_modules/@mui/material/esm/MenuItem/MenuItem.js
init_objectWithoutPropertiesLoose();
init_extends();
var React78 = __toESM(require_react()), import_prop_types52 = __toESM(require_prop_types());
init_clsx_m();
init_base();
init_esm3();
init_styled();
init_useThemeProps3();
init_useEnhancedEffect2();
init_useForkRef2();

// node_modules/@mui/material/esm/Divider/dividerClasses.js
init_base();
var dividerClasses = generateUtilityClasses("MuiDivider", ["root", "absolute", "fullWidth", "inset", "middle", "flexItem", "light", "vertical", "withChildren", "withChildrenVertical", "textAlignRight", "textAlignLeft", "wrapper", "wrapperVertical"]), dividerClasses_default = dividerClasses;

// node_modules/@mui/material/esm/ListItemIcon/listItemIconClasses.js
init_base();
var listItemIconClasses = generateUtilityClasses("MuiListItemIcon", ["root", "alignItemsFlexStart"]), listItemIconClasses_default = listItemIconClasses;

// node_modules/@mui/material/esm/ListItemText/listItemTextClasses.js
init_base();
var listItemTextClasses = generateUtilityClasses("MuiListItemText", ["root", "multiline", "dense", "inset", "primary", "secondary"]), listItemTextClasses_default = listItemTextClasses;

// node_modules/@mui/material/esm/MenuItem/menuItemClasses.js
init_base();
function getMenuItemUtilityClass(slot) {
  return generateUtilityClass("MuiMenuItem", slot);
}
var menuItemClasses = generateUtilityClasses("MuiMenuItem", ["root", "focusVisible", "dense", "disabled", "divider", "gutters", "selected"]), menuItemClasses_default = menuItemClasses;

// node_modules/@mui/material/esm/MenuItem/MenuItem.js
var import_jsx_runtime64 = __toESM(require_jsx_runtime()), _excluded55 = ["autoFocus", "component", "dense", "divider", "disableGutters", "focusVisibleClassName", "role", "tabIndex"], overridesResolver = (props, styles4) => {
  let {
    ownerState
  } = props;
  return [styles4.root, ownerState.dense && styles4.dense, ownerState.divider && styles4.divider, !ownerState.disableGutters && styles4.gutters];
}, useUtilityClasses32 = (ownerState) => {
  let {
    disabled,
    dense,
    divider,
    disableGutters,
    selected,
    classes
  } = ownerState, composedClasses = composeClasses({
    root: ["root", dense && "dense", disabled && "disabled", !disableGutters && "gutters", divider && "divider", selected && "selected"]
  }, getMenuItemUtilityClass, classes);
  return _extends({}, classes, composedClasses);
}, MenuItemRoot = styled_default(ButtonBase_default, {
  shouldForwardProp: (prop) => rootShouldForwardProp(prop) || prop === "classes",
  name: "MuiMenuItem",
  slot: "Root",
  overridesResolver
})(({
  theme,
  ownerState
}) => _extends({}, theme.typography.body1, {
  display: "flex",
  justifyContent: "flex-start",
  alignItems: "center",
  position: "relative",
  textDecoration: "none",
  minHeight: 48,
  paddingTop: 6,
  paddingBottom: 6,
  boxSizing: "border-box",
  whiteSpace: "nowrap"
}, !ownerState.disableGutters && {
  paddingLeft: 16,
  paddingRight: 16
}, ownerState.divider && {
  borderBottom: `1px solid ${(theme.vars || theme).palette.divider}`,
  backgroundClip: "padding-box"
}, {
  "&:hover": {
    textDecoration: "none",
    backgroundColor: (theme.vars || theme).palette.action.hover,
    "@media (hover: none)": {
      backgroundColor: "transparent"
    }
  },
  [`&.${menuItemClasses_default.selected}`]: {
    backgroundColor: theme.vars ? `rgba(${theme.vars.palette.primary.mainChannel} / ${theme.vars.palette.action.selectedOpacity})` : alpha(theme.palette.primary.main, theme.palette.action.selectedOpacity),
    [`&.${menuItemClasses_default.focusVisible}`]: {
      backgroundColor: theme.vars ? `rgba(${theme.vars.palette.primary.mainChannel} / calc(${theme.vars.palette.action.selectedOpacity} + ${theme.vars.palette.action.focusOpacity}))` : alpha(theme.palette.primary.main, theme.palette.action.selectedOpacity + theme.palette.action.focusOpacity)
    }
  },
  [`&.${menuItemClasses_default.selected}:hover`]: {
    backgroundColor: theme.vars ? `rgba(${theme.vars.palette.primary.mainChannel} / calc(${theme.vars.palette.action.selectedOpacity} + ${theme.vars.palette.action.hoverOpacity}))` : alpha(theme.palette.primary.main, theme.palette.action.selectedOpacity + theme.palette.action.hoverOpacity),
    "@media (hover: none)": {
      backgroundColor: theme.vars ? `rgba(${theme.vars.palette.primary.mainChannel} / ${theme.vars.palette.action.selectedOpacity})` : alpha(theme.palette.primary.main, theme.palette.action.selectedOpacity)
    }
  },
  [`&.${menuItemClasses_default.focusVisible}`]: {
    backgroundColor: (theme.vars || theme).palette.action.focus
  },
  [`&.${menuItemClasses_default.disabled}`]: {
    opacity: (theme.vars || theme).palette.action.disabledOpacity
  },
  [`& + .${dividerClasses_default.root}`]: {
    marginTop: theme.spacing(1),
    marginBottom: theme.spacing(1)
  },
  [`& + .${dividerClasses_default.inset}`]: {
    marginLeft: 52
  },
  [`& .${listItemTextClasses_default.root}`]: {
    marginTop: 0,
    marginBottom: 0
  },
  [`& .${listItemTextClasses_default.inset}`]: {
    paddingLeft: 36
  },
  [`& .${listItemIconClasses_default.root}`]: {
    minWidth: 36
  }
}, !ownerState.dense && {
  [theme.breakpoints.up("sm")]: {
    minHeight: "auto"
  }
}, ownerState.dense && _extends({
  minHeight: 32,
  paddingTop: 4,
  paddingBottom: 4
}, theme.typography.body2, {
  [`& .${listItemIconClasses_default.root} svg`]: {
    fontSize: "1.25rem"
  }
}))), MenuItem = /* @__PURE__ */ React78.forwardRef(function(inProps, ref) {
  let props = useThemeProps2({
    props: inProps,
    name: "MuiMenuItem"
  }), {
    autoFocus = !1,
    component = "li",
    dense = !1,
    divider = !1,
    disableGutters = !1,
    focusVisibleClassName,
    role = "menuitem",
    tabIndex: tabIndexProp
  } = props, other = _objectWithoutPropertiesLoose2(props, _excluded55), context = React78.useContext(ListContext_default), childContext = {
    dense: dense || context.dense || !1,
    disableGutters
  }, menuItemRef = React78.useRef(null);
  useEnhancedEffect_default2(() => {
    autoFocus && (menuItemRef.current ? menuItemRef.current.focus() : console.error("MUI: Unable to set focus to a MenuItem whose component has not been rendered."));
  }, [autoFocus]);
  let ownerState = _extends({}, props, {
    dense: childContext.dense,
    divider,
    disableGutters
  }), classes = useUtilityClasses32(props), handleRef = useForkRef_default(menuItemRef, ref), tabIndex;
  return props.disabled || (tabIndex = tabIndexProp !== void 0 ? tabIndexProp : -1), /* @__PURE__ */ (0, import_jsx_runtime64.jsx)(ListContext_default.Provider, {
    value: childContext,
    children: /* @__PURE__ */ (0, import_jsx_runtime64.jsx)(MenuItemRoot, _extends({
      ref: handleRef,
      role,
      tabIndex,
      component,
      focusVisibleClassName: clsx_m_default(classes.focusVisible, focusVisibleClassName)
    }, other, {
      ownerState,
      classes
    }))
  });
});
MenuItem.propTypes = {
  autoFocus: import_prop_types52.default.bool,
  children: import_prop_types52.default.node,
  classes: import_prop_types52.default.object,
  component: import_prop_types52.default.elementType,
  dense: import_prop_types52.default.bool,
  disabled: import_prop_types52.default.bool,
  disableGutters: import_prop_types52.default.bool,
  divider: import_prop_types52.default.bool,
  focusVisibleClassName: import_prop_types52.default.string,
  role: import_prop_types52.default.string,
  selected: import_prop_types52.default.bool,
  sx: import_prop_types52.default.oneOfType([import_prop_types52.default.arrayOf(import_prop_types52.default.oneOfType([import_prop_types52.default.func, import_prop_types52.default.object, import_prop_types52.default.bool])), import_prop_types52.default.func, import_prop_types52.default.object]),
  tabIndex: import_prop_types52.default.number
};
var MenuItem_default = MenuItem;

// node_modules/@mui/material/esm/Toolbar/Toolbar.js
init_objectWithoutPropertiesLoose();
init_extends();
var React79 = __toESM(require_react()), import_prop_types53 = __toESM(require_prop_types());
init_clsx_m();
init_base();
init_useThemeProps3();
init_styled();

// node_modules/@mui/material/esm/Toolbar/toolbarClasses.js
init_base();
function getToolbarUtilityClass(slot) {
  return generateUtilityClass("MuiToolbar", slot);
}
var toolbarClasses = generateUtilityClasses("MuiToolbar", ["root", "gutters", "regular", "dense"]);

// node_modules/@mui/material/esm/Toolbar/Toolbar.js
var import_jsx_runtime65 = __toESM(require_jsx_runtime()), _excluded56 = ["className", "component", "disableGutters", "variant"], useUtilityClasses33 = (ownerState) => {
  let {
    classes,
    disableGutters,
    variant
  } = ownerState;
  return composeClasses({
    root: ["root", !disableGutters && "gutters", variant]
  }, getToolbarUtilityClass, classes);
}, ToolbarRoot = styled_default("div", {
  name: "MuiToolbar",
  slot: "Root",
  overridesResolver: (props, styles4) => {
    let {
      ownerState
    } = props;
    return [styles4.root, !ownerState.disableGutters && styles4.gutters, styles4[ownerState.variant]];
  }
})(({
  theme,
  ownerState
}) => _extends({
  position: "relative",
  display: "flex",
  alignItems: "center"
}, !ownerState.disableGutters && {
  paddingLeft: theme.spacing(2),
  paddingRight: theme.spacing(2),
  [theme.breakpoints.up("sm")]: {
    paddingLeft: theme.spacing(3),
    paddingRight: theme.spacing(3)
  }
}, ownerState.variant === "dense" && {
  minHeight: 48
}), ({
  theme,
  ownerState
}) => ownerState.variant === "regular" && theme.mixins.toolbar), Toolbar = /* @__PURE__ */ React79.forwardRef(function(inProps, ref) {
  let props = useThemeProps2({
    props: inProps,
    name: "MuiToolbar"
  }), {
    className,
    component = "div",
    disableGutters = !1,
    variant = "regular"
  } = props, other = _objectWithoutPropertiesLoose2(props, _excluded56), ownerState = _extends({}, props, {
    component,
    disableGutters,
    variant
  }), classes = useUtilityClasses33(ownerState);
  return /* @__PURE__ */ (0, import_jsx_runtime65.jsx)(ToolbarRoot, _extends({
    as: component,
    className: clsx_m_default(classes.root, className),
    ref,
    ownerState
  }, other));
});
Toolbar.propTypes = {
  children: import_prop_types53.default.node,
  classes: import_prop_types53.default.object,
  className: import_prop_types53.default.string,
  component: import_prop_types53.default.elementType,
  disableGutters: import_prop_types53.default.bool,
  sx: import_prop_types53.default.oneOfType([import_prop_types53.default.arrayOf(import_prop_types53.default.oneOfType([import_prop_types53.default.func, import_prop_types53.default.object, import_prop_types53.default.bool])), import_prop_types53.default.func, import_prop_types53.default.object]),
  variant: import_prop_types53.default.oneOfType([import_prop_types53.default.oneOf(["dense", "regular"]), import_prop_types53.default.string])
};
var Toolbar_default = Toolbar;

// node_modules/@mui/material/esm/TablePagination/TablePaginationActions.js
init_extends();
init_objectWithoutPropertiesLoose();
var React85 = __toESM(require_react()), import_prop_types55 = __toESM(require_prop_types());

// node_modules/@mui/material/esm/internal/svg-icons/KeyboardArrowLeft.js
var React80 = __toESM(require_react());
init_createSvgIcon();
var import_jsx_runtime66 = __toESM(require_jsx_runtime()), KeyboardArrowLeft_default = createSvgIcon(/* @__PURE__ */ (0, import_jsx_runtime66.jsx)("path", {
  d: "M15.41 16.09l-4.58-4.59 4.58-4.59L14 5.5l-6 6 6 6z"
}), "KeyboardArrowLeft");

// node_modules/@mui/material/esm/internal/svg-icons/KeyboardArrowRight.js
var React81 = __toESM(require_react());
init_createSvgIcon();
var import_jsx_runtime67 = __toESM(require_jsx_runtime()), KeyboardArrowRight_default = createSvgIcon(/* @__PURE__ */ (0, import_jsx_runtime67.jsx)("path", {
  d: "M8.59 16.34l4.58-4.59-4.58-4.59L10 5.75l6 6-6 6z"
}), "KeyboardArrowRight");

// node_modules/@mui/material/esm/IconButton/IconButton.js
init_objectWithoutPropertiesLoose();
init_extends();
var React82 = __toESM(require_react()), import_prop_types54 = __toESM(require_prop_types());
init_clsx_m();
init_esm2();
init_base();
init_esm3();
init_styled();
init_useThemeProps3();
init_capitalize2();

// node_modules/@mui/material/esm/IconButton/iconButtonClasses.js
init_base();
function getIconButtonUtilityClass(slot) {
  return generateUtilityClass("MuiIconButton", slot);
}
var iconButtonClasses = generateUtilityClasses("MuiIconButton", ["root", "disabled", "colorInherit", "colorPrimary", "colorSecondary", "edgeStart", "edgeEnd", "sizeSmall", "sizeMedium", "sizeLarge"]), iconButtonClasses_default = iconButtonClasses;

// node_modules/@mui/material/esm/IconButton/IconButton.js
var import_jsx_runtime68 = __toESM(require_jsx_runtime()), _excluded57 = ["edge", "children", "className", "color", "disabled", "disableFocusRipple", "size"], useUtilityClasses34 = (ownerState) => {
  let {
    classes,
    disabled,
    color: color2,
    edge,
    size
  } = ownerState, slots = {
    root: ["root", disabled && "disabled", color2 !== "default" && `color${capitalize_default(color2)}`, edge && `edge${capitalize_default(edge)}`, `size${capitalize_default(size)}`]
  };
  return composeClasses(slots, getIconButtonUtilityClass, classes);
}, IconButtonRoot = styled_default(ButtonBase_default, {
  name: "MuiIconButton",
  slot: "Root",
  overridesResolver: (props, styles4) => {
    let {
      ownerState
    } = props;
    return [styles4.root, ownerState.color !== "default" && styles4[`color${capitalize_default(ownerState.color)}`], ownerState.edge && styles4[`edge${capitalize_default(ownerState.edge)}`], styles4[`size${capitalize_default(ownerState.size)}`]];
  }
})(({
  theme,
  ownerState
}) => _extends({
  textAlign: "center",
  flex: "0 0 auto",
  fontSize: theme.typography.pxToRem(24),
  padding: 8,
  borderRadius: "50%",
  overflow: "visible",
  color: (theme.vars || theme).palette.action.active,
  transition: theme.transitions.create("background-color", {
    duration: theme.transitions.duration.shortest
  })
}, !ownerState.disableRipple && {
  "&:hover": {
    backgroundColor: theme.vars ? `rgba(${theme.vars.palette.action.activeChannel} / ${theme.vars.palette.action.hoverOpacity})` : alpha(theme.palette.action.active, theme.palette.action.hoverOpacity),
    "@media (hover: none)": {
      backgroundColor: "transparent"
    }
  }
}, ownerState.edge === "start" && {
  marginLeft: ownerState.size === "small" ? -3 : -12
}, ownerState.edge === "end" && {
  marginRight: ownerState.size === "small" ? -3 : -12
}), ({
  theme,
  ownerState
}) => _extends({}, ownerState.color === "inherit" && {
  color: "inherit"
}, ownerState.color !== "inherit" && ownerState.color !== "default" && _extends({
  color: (theme.vars || theme).palette[ownerState.color].main
}, !ownerState.disableRipple && {
  "&:hover": {
    backgroundColor: theme.vars ? `rgba(${theme.vars.palette[ownerState.color].mainChannel} / ${theme.vars.palette.action.hoverOpacity})` : alpha(theme.palette[ownerState.color].main, theme.palette.action.hoverOpacity),
    "@media (hover: none)": {
      backgroundColor: "transparent"
    }
  }
}), ownerState.size === "small" && {
  padding: 5,
  fontSize: theme.typography.pxToRem(18)
}, ownerState.size === "large" && {
  padding: 12,
  fontSize: theme.typography.pxToRem(28)
}, {
  [`&.${iconButtonClasses_default.disabled}`]: {
    backgroundColor: "transparent",
    color: (theme.vars || theme).palette.action.disabled
  }
})), IconButton = /* @__PURE__ */ React82.forwardRef(function(inProps, ref) {
  let props = useThemeProps2({
    props: inProps,
    name: "MuiIconButton"
  }), {
    edge = !1,
    children,
    className,
    color: color2 = "default",
    disabled = !1,
    disableFocusRipple = !1,
    size = "medium"
  } = props, other = _objectWithoutPropertiesLoose2(props, _excluded57), ownerState = _extends({}, props, {
    edge,
    color: color2,
    disabled,
    disableFocusRipple,
    size
  }), classes = useUtilityClasses34(ownerState);
  return /* @__PURE__ */ (0, import_jsx_runtime68.jsx)(IconButtonRoot, _extends({
    className: clsx_m_default(classes.root, className),
    centerRipple: !0,
    focusRipple: !disableFocusRipple,
    disabled,
    ref,
    ownerState
  }, other, {
    children
  }));
});
IconButton.propTypes = {
  children: chainPropTypes(import_prop_types54.default.node, (props) => React82.Children.toArray(props.children).some((child) => /* @__PURE__ */ React82.isValidElement(child) && child.props.onClick) ? new Error(["MUI: You are providing an onClick event listener to a child of a button element.", "Prefer applying it to the IconButton directly.", "This guarantees that the whole <button> will be responsive to click events."].join(`
`)) : null),
  classes: import_prop_types54.default.object,
  className: import_prop_types54.default.string,
  color: import_prop_types54.default.oneOfType([import_prop_types54.default.oneOf(["inherit", "default", "primary", "secondary", "error", "info", "success", "warning"]), import_prop_types54.default.string]),
  disabled: import_prop_types54.default.bool,
  disableFocusRipple: import_prop_types54.default.bool,
  disableRipple: import_prop_types54.default.bool,
  edge: import_prop_types54.default.oneOf(["end", "start", !1]),
  size: import_prop_types54.default.oneOfType([import_prop_types54.default.oneOf(["small", "medium", "large"]), import_prop_types54.default.string]),
  sx: import_prop_types54.default.oneOfType([import_prop_types54.default.arrayOf(import_prop_types54.default.oneOfType([import_prop_types54.default.func, import_prop_types54.default.object, import_prop_types54.default.bool])), import_prop_types54.default.func, import_prop_types54.default.object])
};
var IconButton_default = IconButton;

// node_modules/@mui/material/esm/internal/svg-icons/LastPage.js
var React83 = __toESM(require_react());
init_createSvgIcon();
var import_jsx_runtime69 = __toESM(require_jsx_runtime()), LastPage_default = createSvgIcon(/* @__PURE__ */ (0, import_jsx_runtime69.jsx)("path", {
  d: "M5.59 7.41L10.18 12l-4.59 4.59L7 18l6-6-6-6zM16 6h2v12h-2z"
}), "LastPage");

// node_modules/@mui/material/esm/internal/svg-icons/FirstPage.js
var React84 = __toESM(require_react());
init_createSvgIcon();
var import_jsx_runtime70 = __toESM(require_jsx_runtime()), FirstPage_default = createSvgIcon(/* @__PURE__ */ (0, import_jsx_runtime70.jsx)("path", {
  d: "M18.41 16.59L13.82 12l4.59-4.59L17 6l-6 6 6 6zM6 6h2v12H6z"
}), "FirstPage");

// node_modules/@mui/material/esm/TablePagination/TablePaginationActions.js
var import_jsx_runtime71 = __toESM(require_jsx_runtime()), import_jsx_runtime72 = __toESM(require_jsx_runtime()), _LastPageIcon, _FirstPageIcon, _KeyboardArrowRight, _KeyboardArrowLeft, _KeyboardArrowLeft2, _KeyboardArrowRight2, _FirstPageIcon2, _LastPageIcon2, _excluded58 = ["backIconButtonProps", "count", "getItemAriaLabel", "nextIconButtonProps", "onPageChange", "page", "rowsPerPage", "showFirstButton", "showLastButton"], TablePaginationActions = /* @__PURE__ */ React85.forwardRef(function(props, ref) {
  let {
    backIconButtonProps,
    count,
    getItemAriaLabel,
    nextIconButtonProps,
    onPageChange,
    page,
    rowsPerPage,
    showFirstButton,
    showLastButton
  } = props, other = _objectWithoutPropertiesLoose2(props, _excluded58), theme = useTheme4(), handleFirstPageButtonClick = (event) => {
    onPageChange(event, 0);
  }, handleBackButtonClick = (event) => {
    onPageChange(event, page - 1);
  }, handleNextButtonClick = (event) => {
    onPageChange(event, page + 1);
  }, handleLastPageButtonClick = (event) => {
    onPageChange(event, Math.max(0, Math.ceil(count / rowsPerPage) - 1));
  };
  return /* @__PURE__ */ (0, import_jsx_runtime72.jsxs)("div", _extends({
    ref
  }, other, {
    children: [showFirstButton && /* @__PURE__ */ (0, import_jsx_runtime71.jsx)(IconButton_default, {
      onClick: handleFirstPageButtonClick,
      disabled: page === 0,
      "aria-label": getItemAriaLabel("first", page),
      title: getItemAriaLabel("first", page),
      children: theme.direction === "rtl" ? _LastPageIcon || (_LastPageIcon = /* @__PURE__ */ (0, import_jsx_runtime71.jsx)(LastPage_default, {})) : _FirstPageIcon || (_FirstPageIcon = /* @__PURE__ */ (0, import_jsx_runtime71.jsx)(FirstPage_default, {}))
    }), /* @__PURE__ */ (0, import_jsx_runtime71.jsx)(IconButton_default, _extends({
      onClick: handleBackButtonClick,
      disabled: page === 0,
      color: "inherit",
      "aria-label": getItemAriaLabel("previous", page),
      title: getItemAriaLabel("previous", page)
    }, backIconButtonProps, {
      children: theme.direction === "rtl" ? _KeyboardArrowRight || (_KeyboardArrowRight = /* @__PURE__ */ (0, import_jsx_runtime71.jsx)(KeyboardArrowRight_default, {})) : _KeyboardArrowLeft || (_KeyboardArrowLeft = /* @__PURE__ */ (0, import_jsx_runtime71.jsx)(KeyboardArrowLeft_default, {}))
    })), /* @__PURE__ */ (0, import_jsx_runtime71.jsx)(IconButton_default, _extends({
      onClick: handleNextButtonClick,
      disabled: count !== -1 ? page >= Math.ceil(count / rowsPerPage) - 1 : !1,
      color: "inherit",
      "aria-label": getItemAriaLabel("next", page),
      title: getItemAriaLabel("next", page)
    }, nextIconButtonProps, {
      children: theme.direction === "rtl" ? _KeyboardArrowLeft2 || (_KeyboardArrowLeft2 = /* @__PURE__ */ (0, import_jsx_runtime71.jsx)(KeyboardArrowLeft_default, {})) : _KeyboardArrowRight2 || (_KeyboardArrowRight2 = /* @__PURE__ */ (0, import_jsx_runtime71.jsx)(KeyboardArrowRight_default, {}))
    })), showLastButton && /* @__PURE__ */ (0, import_jsx_runtime71.jsx)(IconButton_default, {
      onClick: handleLastPageButtonClick,
      disabled: page >= Math.ceil(count / rowsPerPage) - 1,
      "aria-label": getItemAriaLabel("last", page),
      title: getItemAriaLabel("last", page),
      children: theme.direction === "rtl" ? _FirstPageIcon2 || (_FirstPageIcon2 = /* @__PURE__ */ (0, import_jsx_runtime71.jsx)(FirstPage_default, {})) : _LastPageIcon2 || (_LastPageIcon2 = /* @__PURE__ */ (0, import_jsx_runtime71.jsx)(LastPage_default, {}))
    })]
  }));
});
TablePaginationActions.propTypes = {
  backIconButtonProps: import_prop_types55.default.object,
  count: import_prop_types55.default.number.isRequired,
  getItemAriaLabel: import_prop_types55.default.func.isRequired,
  nextIconButtonProps: import_prop_types55.default.object,
  onPageChange: import_prop_types55.default.func.isRequired,
  page: import_prop_types55.default.number.isRequired,
  rowsPerPage: import_prop_types55.default.number.isRequired,
  showFirstButton: import_prop_types55.default.bool.isRequired,
  showLastButton: import_prop_types55.default.bool.isRequired
};
var TablePaginationActions_default = TablePaginationActions;

// node_modules/@mui/material/esm/TablePagination/TablePagination.js
init_useId2();

// node_modules/@mui/material/esm/TablePagination/tablePaginationClasses.js
init_base();
function getTablePaginationUtilityClass(slot) {
  return generateUtilityClass("MuiTablePagination", slot);
}
var tablePaginationClasses2 = generateUtilityClasses("MuiTablePagination", ["root", "toolbar", "spacer", "selectLabel", "selectRoot", "select", "selectIcon", "input", "menuItem", "displayedRows", "actions"]), tablePaginationClasses_default = tablePaginationClasses2;

// node_modules/@mui/material/esm/TablePagination/TablePagination.js
var import_jsx_runtime73 = __toESM(require_jsx_runtime()), import_react14 = __toESM(require_react()), import_jsx_runtime74 = __toESM(require_jsx_runtime()), _InputBase, _excluded59 = ["ActionsComponent", "backIconButtonProps", "className", "colSpan", "component", "count", "getItemAriaLabel", "labelDisplayedRows", "labelRowsPerPage", "nextIconButtonProps", "onPageChange", "onRowsPerPageChange", "page", "rowsPerPage", "rowsPerPageOptions", "SelectProps", "showFirstButton", "showLastButton"], TablePaginationRoot = styled_default(TableCell_default, {
  name: "MuiTablePagination",
  slot: "Root",
  overridesResolver: (props, styles4) => styles4.root
})(({
  theme
}) => ({
  overflow: "auto",
  color: (theme.vars || theme).palette.text.primary,
  fontSize: theme.typography.pxToRem(14),
  "&:last-child": {
    padding: 0
  }
})), TablePaginationToolbar = styled_default(Toolbar_default, {
  name: "MuiTablePagination",
  slot: "Toolbar",
  overridesResolver: (props, styles4) => _extends({
    [`& .${tablePaginationClasses_default.actions}`]: styles4.actions
  }, styles4.toolbar)
})(({
  theme
}) => ({
  minHeight: 52,
  paddingRight: 2,
  [`${theme.breakpoints.up("xs")} and (orientation: landscape)`]: {
    minHeight: 52
  },
  [theme.breakpoints.up("sm")]: {
    minHeight: 52,
    paddingRight: 2
  },
  [`& .${tablePaginationClasses_default.actions}`]: {
    flexShrink: 0,
    marginLeft: 20
  }
})), TablePaginationSpacer = styled_default("div", {
  name: "MuiTablePagination",
  slot: "Spacer",
  overridesResolver: (props, styles4) => styles4.spacer
})({
  flex: "1 1 100%"
}), TablePaginationSelectLabel = styled_default("p", {
  name: "MuiTablePagination",
  slot: "SelectLabel",
  overridesResolver: (props, styles4) => styles4.selectLabel
})(({
  theme
}) => _extends({}, theme.typography.body2, {
  flexShrink: 0
})), TablePaginationSelect = styled_default(Select_default, {
  name: "MuiTablePagination",
  slot: "Select",
  overridesResolver: (props, styles4) => _extends({
    [`& .${tablePaginationClasses_default.selectIcon}`]: styles4.selectIcon,
    [`& .${tablePaginationClasses_default.select}`]: styles4.select
  }, styles4.input, styles4.selectRoot)
})({
  color: "inherit",
  fontSize: "inherit",
  flexShrink: 0,
  marginRight: 32,
  marginLeft: 8,
  [`& .${tablePaginationClasses_default.select}`]: {
    paddingLeft: 8,
    paddingRight: 24,
    textAlign: "right",
    textAlignLast: "right"
  }
}), TablePaginationMenuItem = styled_default(MenuItem_default, {
  name: "MuiTablePagination",
  slot: "MenuItem",
  overridesResolver: (props, styles4) => styles4.menuItem
})({}), TablePaginationDisplayedRows = styled_default("p", {
  name: "MuiTablePagination",
  slot: "DisplayedRows",
  overridesResolver: (props, styles4) => styles4.displayedRows
})(({
  theme
}) => _extends({}, theme.typography.body2, {
  flexShrink: 0
}));
function defaultLabelDisplayedRows({
  from: from2,
  to,
  count
}) {
  return `${from2}\u2013${to} of ${count !== -1 ? count : `more than ${to}`}`;
}
function defaultGetAriaLabel(type) {
  return `Go to ${type} page`;
}
var useUtilityClasses35 = (ownerState) => {
  let {
    classes
  } = ownerState;
  return composeClasses({
    root: ["root"],
    toolbar: ["toolbar"],
    spacer: ["spacer"],
    selectLabel: ["selectLabel"],
    select: ["select"],
    input: ["input"],
    selectIcon: ["selectIcon"],
    menuItem: ["menuItem"],
    displayedRows: ["displayedRows"],
    actions: ["actions"]
  }, getTablePaginationUtilityClass, classes);
}, TablePagination = /* @__PURE__ */ React86.forwardRef(function(inProps, ref) {
  let props = useThemeProps2({
    props: inProps,
    name: "MuiTablePagination"
  }), {
    ActionsComponent = TablePaginationActions_default,
    backIconButtonProps,
    className,
    colSpan: colSpanProp,
    component = TableCell_default,
    count,
    getItemAriaLabel = defaultGetAriaLabel,
    labelDisplayedRows = defaultLabelDisplayedRows,
    labelRowsPerPage = "Rows per page:",
    nextIconButtonProps,
    onPageChange,
    onRowsPerPageChange,
    page,
    rowsPerPage,
    rowsPerPageOptions = [10, 25, 50, 100],
    SelectProps = {},
    showFirstButton = !1,
    showLastButton = !1
  } = props, other = _objectWithoutPropertiesLoose2(props, _excluded59), ownerState = props, classes = useUtilityClasses35(ownerState), MenuItemComponent = SelectProps.native ? "option" : TablePaginationMenuItem, colSpan;
  (component === TableCell_default || component === "td") && (colSpan = colSpanProp || 1e3);
  let selectId = useId_default(SelectProps.id), labelId = useId_default(SelectProps.labelId), getLabelDisplayedRowsTo = () => count === -1 ? (page + 1) * rowsPerPage : rowsPerPage === -1 ? count : Math.min(count, (page + 1) * rowsPerPage);
  return /* @__PURE__ */ (0, import_jsx_runtime73.jsx)(TablePaginationRoot, _extends({
    colSpan,
    ref,
    as: component,
    ownerState,
    className: clsx_m_default(classes.root, className)
  }, other, {
    children: /* @__PURE__ */ (0, import_jsx_runtime74.jsxs)(TablePaginationToolbar, {
      className: classes.toolbar,
      children: [/* @__PURE__ */ (0, import_jsx_runtime73.jsx)(TablePaginationSpacer, {
        className: classes.spacer
      }), rowsPerPageOptions.length > 1 && /* @__PURE__ */ (0, import_jsx_runtime73.jsx)(TablePaginationSelectLabel, {
        className: classes.selectLabel,
        id: labelId,
        children: labelRowsPerPage
      }), rowsPerPageOptions.length > 1 && /* @__PURE__ */ (0, import_jsx_runtime73.jsx)(TablePaginationSelect, _extends({
        variant: "standard"
      }, !SelectProps.variant && {
        input: _InputBase || (_InputBase = /* @__PURE__ */ (0, import_jsx_runtime73.jsx)(InputBase_default, {}))
      }, {
        value: rowsPerPage,
        onChange: onRowsPerPageChange,
        id: selectId,
        labelId
      }, SelectProps, {
        classes: _extends({}, SelectProps.classes, {
          root: clsx_m_default(classes.input, classes.selectRoot, (SelectProps.classes || {}).root),
          select: clsx_m_default(classes.select, (SelectProps.classes || {}).select),
          icon: clsx_m_default(classes.selectIcon, (SelectProps.classes || {}).icon)
        }),
        children: rowsPerPageOptions.map((rowsPerPageOption) => /* @__PURE__ */ (0, import_react14.createElement)(MenuItemComponent, _extends({}, !isHostComponent_default(MenuItemComponent) && {
          ownerState
        }, {
          className: classes.menuItem,
          key: rowsPerPageOption.label ? rowsPerPageOption.label : rowsPerPageOption,
          value: rowsPerPageOption.value ? rowsPerPageOption.value : rowsPerPageOption
        }), rowsPerPageOption.label ? rowsPerPageOption.label : rowsPerPageOption))
      })), /* @__PURE__ */ (0, import_jsx_runtime73.jsx)(TablePaginationDisplayedRows, {
        className: classes.displayedRows,
        children: labelDisplayedRows({
          from: count === 0 ? 0 : page * rowsPerPage + 1,
          to: getLabelDisplayedRowsTo(),
          count: count === -1 ? -1 : count,
          page
        })
      }), /* @__PURE__ */ (0, import_jsx_runtime73.jsx)(ActionsComponent, {
        className: classes.actions,
        backIconButtonProps,
        count,
        nextIconButtonProps,
        onPageChange,
        page,
        rowsPerPage,
        showFirstButton,
        showLastButton,
        getItemAriaLabel
      })]
    })
  }));
});
TablePagination.propTypes = {
  ActionsComponent: import_prop_types56.default.elementType,
  backIconButtonProps: import_prop_types56.default.object,
  classes: import_prop_types56.default.object,
  className: import_prop_types56.default.string,
  colSpan: import_prop_types56.default.number,
  component: import_prop_types56.default.elementType,
  count: integerPropType_default.isRequired,
  getItemAriaLabel: import_prop_types56.default.func,
  labelDisplayedRows: import_prop_types56.default.func,
  labelRowsPerPage: import_prop_types56.default.node,
  nextIconButtonProps: import_prop_types56.default.object,
  onPageChange: import_prop_types56.default.func.isRequired,
  onRowsPerPageChange: import_prop_types56.default.func,
  page: chainPropTypes(integerPropType_default.isRequired, (props) => {
    let {
      count,
      page,
      rowsPerPage
    } = props;
    if (count === -1)
      return null;
    let newLastPage = Math.max(0, Math.ceil(count / rowsPerPage) - 1);
    return page < 0 || page > newLastPage ? new Error(`MUI: The page prop of a TablePagination is out of range (0 to ${newLastPage}, but page is ${page}).`) : null;
  }),
  rowsPerPage: integerPropType_default.isRequired,
  rowsPerPageOptions: import_prop_types56.default.arrayOf(import_prop_types56.default.oneOfType([import_prop_types56.default.number, import_prop_types56.default.shape({
    label: import_prop_types56.default.string.isRequired,
    value: import_prop_types56.default.number.isRequired
  })]).isRequired),
  SelectProps: import_prop_types56.default.object,
  showFirstButton: import_prop_types56.default.bool,
  showLastButton: import_prop_types56.default.bool,
  sx: import_prop_types56.default.oneOfType([import_prop_types56.default.arrayOf(import_prop_types56.default.oneOfType([import_prop_types56.default.func, import_prop_types56.default.object, import_prop_types56.default.bool])), import_prop_types56.default.func, import_prop_types56.default.object])
};
var TablePagination_default = TablePagination;

// node_modules/@mui/material/esm/TableRow/TableRow.js
init_extends();
init_objectWithoutPropertiesLoose();
var React87 = __toESM(require_react()), import_prop_types57 = __toESM(require_prop_types());
init_clsx_m();
init_base();
init_esm3();
init_useThemeProps3();
init_styled();

// node_modules/@mui/material/esm/TableRow/tableRowClasses.js
init_base();
function getTableRowUtilityClass(slot) {
  return generateUtilityClass("MuiTableRow", slot);
}
var tableRowClasses = generateUtilityClasses("MuiTableRow", ["root", "selected", "hover", "head", "footer"]), tableRowClasses_default = tableRowClasses;

// node_modules/@mui/material/esm/TableRow/TableRow.js
var import_jsx_runtime75 = __toESM(require_jsx_runtime()), _excluded60 = ["className", "component", "hover", "selected"], useUtilityClasses36 = (ownerState) => {
  let {
    classes,
    selected,
    hover,
    head,
    footer
  } = ownerState;
  return composeClasses({
    root: ["root", selected && "selected", hover && "hover", head && "head", footer && "footer"]
  }, getTableRowUtilityClass, classes);
}, TableRowRoot = styled_default("tr", {
  name: "MuiTableRow",
  slot: "Root",
  overridesResolver: (props, styles4) => {
    let {
      ownerState
    } = props;
    return [styles4.root, ownerState.head && styles4.head, ownerState.footer && styles4.footer];
  }
})(({
  theme
}) => ({
  color: "inherit",
  display: "table-row",
  verticalAlign: "middle",
  outline: 0,
  [`&.${tableRowClasses_default.hover}:hover`]: {
    backgroundColor: (theme.vars || theme).palette.action.hover
  },
  [`&.${tableRowClasses_default.selected}`]: {
    backgroundColor: theme.vars ? `rgba(${theme.vars.palette.primary.mainChannel} / ${theme.vars.palette.action.selectedOpacity})` : alpha(theme.palette.primary.main, theme.palette.action.selectedOpacity),
    "&:hover": {
      backgroundColor: theme.vars ? `rgba(${theme.vars.palette.primary.mainChannel} / calc(${theme.vars.palette.action.selectedOpacity} + ${theme.vars.palette.action.hoverOpacity}))` : alpha(theme.palette.primary.main, theme.palette.action.selectedOpacity + theme.palette.action.hoverOpacity)
    }
  }
})), defaultComponent4 = "tr", TableRow = /* @__PURE__ */ React87.forwardRef(function(inProps, ref) {
  let props = useThemeProps2({
    props: inProps,
    name: "MuiTableRow"
  }), {
    className,
    component = defaultComponent4,
    hover = !1,
    selected = !1
  } = props, other = _objectWithoutPropertiesLoose2(props, _excluded60), tablelvl24 = React87.useContext(Tablelvl2Context_default), ownerState = _extends({}, props, {
    component,
    hover,
    selected,
    head: tablelvl24 && tablelvl24.variant === "head",
    footer: tablelvl24 && tablelvl24.variant === "footer"
  }), classes = useUtilityClasses36(ownerState);
  return /* @__PURE__ */ (0, import_jsx_runtime75.jsx)(TableRowRoot, _extends({
    as: component,
    ref,
    className: clsx_m_default(classes.root, className),
    role: component === defaultComponent4 ? null : "row",
    ownerState
  }, other));
});
TableRow.propTypes = {
  children: import_prop_types57.default.node,
  classes: import_prop_types57.default.object,
  className: import_prop_types57.default.string,
  component: import_prop_types57.default.elementType,
  hover: import_prop_types57.default.bool,
  selected: import_prop_types57.default.bool,
  sx: import_prop_types57.default.oneOfType([import_prop_types57.default.arrayOf(import_prop_types57.default.oneOfType([import_prop_types57.default.func, import_prop_types57.default.object, import_prop_types57.default.bool])), import_prop_types57.default.func, import_prop_types57.default.object])
};
var TableRow_default = TableRow;

// app/components/table.tsx
var import_FirstPage2 = __toESM(require_FirstPage()), import_KeyboardArrowLeft2 = __toESM(require_KeyboardArrowLeft()), import_KeyboardArrowRight2 = __toESM(require_KeyboardArrowRight()), import_LastPage2 = __toESM(require_LastPage());

// node_modules/@mui/material/esm/TableHead/TableHead.js
init_extends();
init_objectWithoutPropertiesLoose();
var React88 = __toESM(require_react()), import_prop_types58 = __toESM(require_prop_types());
init_clsx_m();
init_base();
init_useThemeProps3();
init_styled();

// node_modules/@mui/material/esm/TableHead/tableHeadClasses.js
init_base();
function getTableHeadUtilityClass(slot) {
  return generateUtilityClass("MuiTableHead", slot);
}
var tableHeadClasses = generateUtilityClasses("MuiTableHead", ["root"]);

// node_modules/@mui/material/esm/TableHead/TableHead.js
var import_jsx_runtime76 = __toESM(require_jsx_runtime()), _excluded61 = ["className", "component"], useUtilityClasses37 = (ownerState) => {
  let {
    classes
  } = ownerState;
  return composeClasses({
    root: ["root"]
  }, getTableHeadUtilityClass, classes);
}, TableHeadRoot = styled_default("thead", {
  name: "MuiTableHead",
  slot: "Root",
  overridesResolver: (props, styles4) => styles4.root
})({
  display: "table-header-group"
}), tablelvl23 = {
  variant: "head"
}, defaultComponent5 = "thead", TableHead = /* @__PURE__ */ React88.forwardRef(function(inProps, ref) {
  let props = useThemeProps2({
    props: inProps,
    name: "MuiTableHead"
  }), {
    className,
    component = defaultComponent5
  } = props, other = _objectWithoutPropertiesLoose2(props, _excluded61), ownerState = _extends({}, props, {
    component
  }), classes = useUtilityClasses37(ownerState);
  return /* @__PURE__ */ (0, import_jsx_runtime76.jsx)(Tablelvl2Context_default.Provider, {
    value: tablelvl23,
    children: /* @__PURE__ */ (0, import_jsx_runtime76.jsx)(TableHeadRoot, _extends({
      as: component,
      className: clsx_m_default(classes.root, className),
      ref,
      role: component === defaultComponent5 ? null : "rowgroup",
      ownerState
    }, other))
  });
});
TableHead.propTypes = {
  children: import_prop_types58.default.node,
  classes: import_prop_types58.default.object,
  className: import_prop_types58.default.string,
  component: import_prop_types58.default.elementType,
  sx: import_prop_types58.default.oneOfType([import_prop_types58.default.arrayOf(import_prop_types58.default.oneOfType([import_prop_types58.default.func, import_prop_types58.default.object, import_prop_types58.default.bool])), import_prop_types58.default.func, import_prop_types58.default.object])
};
var TableHead_default = TableHead;

// app/components/table.tsx
var import_jsx_dev_runtime = __toESM(require_jsx_dev_runtime()), StyledTableCell = styled_default(TableCell_default)(({ theme }) => ({
  [`&.${tableCellClasses_default.head}`]: {
    backgroundColor: theme.palette.common.black,
    color: theme.palette.common.white
  },
  [`&.${tableCellClasses_default.body}`]: {
    fontSize: 14
  }
}));
function TablePaginationActions3(props) {
  let theme = useTheme4(), { count, page, rowsPerPage, onPageChange } = props, handleFirstPageButtonClick = (event) => {
    onPageChange(event, 0);
  }, handleBackButtonClick = (event) => {
    onPageChange(event, page - 1);
  }, handleNextButtonClick = (event) => {
    onPageChange(event, page + 1);
  }, handleLastPageButtonClick = (event) => {
    onPageChange(event, Math.max(0, Math.ceil(count / rowsPerPage) - 1));
  };
  return /* @__PURE__ */ (0, import_jsx_dev_runtime.jsxDEV)(Box_default, {
    sx: { flexShrink: 0, ml: 5 },
    children: [
      /* @__PURE__ */ (0, import_jsx_dev_runtime.jsxDEV)(IconButton_default, {
        onClick: handleFirstPageButtonClick,
        disabled: page === 0,
        "aria-label": "first page",
        children: theme.direction === "rtl" ? /* @__PURE__ */ (0, import_jsx_dev_runtime.jsxDEV)(import_LastPage2.default, {}, void 0, !1, {
          fileName: "app/components/table.tsx",
          lineNumber: 143,
          columnNumber: 38
        }, this) : /* @__PURE__ */ (0, import_jsx_dev_runtime.jsxDEV)(import_FirstPage2.default, {}, void 0, !1, {
          fileName: "app/components/table.tsx",
          lineNumber: 143,
          columnNumber: 57
        }, this)
      }, void 0, !1, {
        fileName: "app/components/table.tsx",
        lineNumber: 138,
        columnNumber: 7
      }, this),
      /* @__PURE__ */ (0, import_jsx_dev_runtime.jsxDEV)(IconButton_default, {
        onClick: handleBackButtonClick,
        disabled: page === 0,
        "aria-label": "previous page",
        children: theme.direction === "rtl" ? /* @__PURE__ */ (0, import_jsx_dev_runtime.jsxDEV)(import_KeyboardArrowRight2.default, {}, void 0, !1, {
          fileName: "app/components/table.tsx",
          lineNumber: 151,
          columnNumber: 11
        }, this) : /* @__PURE__ */ (0, import_jsx_dev_runtime.jsxDEV)(import_KeyboardArrowLeft2.default, {}, void 0, !1, {
          fileName: "app/components/table.tsx",
          lineNumber: 153,
          columnNumber: 11
        }, this)
      }, void 0, !1, {
        fileName: "app/components/table.tsx",
        lineNumber: 145,
        columnNumber: 7
      }, this),
      /* @__PURE__ */ (0, import_jsx_dev_runtime.jsxDEV)(IconButton_default, {
        onClick: handleNextButtonClick,
        disabled: page >= Math.ceil(count / rowsPerPage) - 1,
        "aria-label": "next page",
        children: theme.direction === "rtl" ? /* @__PURE__ */ (0, import_jsx_dev_runtime.jsxDEV)(import_KeyboardArrowLeft2.default, {}, void 0, !1, {
          fileName: "app/components/table.tsx",
          lineNumber: 162,
          columnNumber: 11
        }, this) : /* @__PURE__ */ (0, import_jsx_dev_runtime.jsxDEV)(import_KeyboardArrowRight2.default, {}, void 0, !1, {
          fileName: "app/components/table.tsx",
          lineNumber: 164,
          columnNumber: 11
        }, this)
      }, void 0, !1, {
        fileName: "app/components/table.tsx",
        lineNumber: 156,
        columnNumber: 7
      }, this),
      /* @__PURE__ */ (0, import_jsx_dev_runtime.jsxDEV)(IconButton_default, {
        onClick: handleLastPageButtonClick,
        disabled: page >= Math.ceil(count / rowsPerPage) - 1,
        "aria-label": "last page",
        children: theme.direction === "rtl" ? /* @__PURE__ */ (0, import_jsx_dev_runtime.jsxDEV)(import_FirstPage2.default, {}, void 0, !1, {
          fileName: "app/components/table.tsx",
          lineNumber: 172,
          columnNumber: 38
        }, this) : /* @__PURE__ */ (0, import_jsx_dev_runtime.jsxDEV)(import_LastPage2.default, {}, void 0, !1, {
          fileName: "app/components/table.tsx",
          lineNumber: 172,
          columnNumber: 58
        }, this)
      }, void 0, !1, {
        fileName: "app/components/table.tsx",
        lineNumber: 167,
        columnNumber: 7
      }, this)
    ]
  }, void 0, !0, {
    fileName: "app/components/table.tsx",
    lineNumber: 137,
    columnNumber: 5
  }, this);
}
function MyTable(props) {
  let [page, setPage] = React89.useState(0), [rowsPerPage, setRowsPerPage] = React89.useState(5), emptyRows = page > 0 ? Math.max(0, (1 + page) * rowsPerPage - props.loaderData.couples.length) : 0, handleChangePage = (event, newPage) => {
    setPage(newPage);
  }, handleChangeRowsPerPage = (event) => {
    setRowsPerPage(parseInt(event.target.value, 10)), setPage(0);
  };
  return /* @__PURE__ */ (0, import_jsx_dev_runtime.jsxDEV)(TableContainer_default, {
    component: Paper_default,
    children: /* @__PURE__ */ (0, import_jsx_dev_runtime.jsxDEV)(Table_default, {
      sx: { minWidth: 500 },
      "aria-label": "custom pagination table",
      children: [
        /* @__PURE__ */ (0, import_jsx_dev_runtime.jsxDEV)(TableHead_default, {
          children: /* @__PURE__ */ (0, import_jsx_dev_runtime.jsxDEV)(TableRow_default, {
            children: [
              /* @__PURE__ */ (0, import_jsx_dev_runtime.jsxDEV)(StyledTableCell, {
                children: "Nazwisko"
              }, void 0, !1, {
                fileName: "app/components/table.tsx",
                lineNumber: 207,
                columnNumber: 13
              }, this),
              /* @__PURE__ */ (0, import_jsx_dev_runtime.jsxDEV)(StyledTableCell, {
                align: "right",
                children: "Imi\u0119\xA0"
              }, void 0, !1, {
                fileName: "app/components/table.tsx",
                lineNumber: 208,
                columnNumber: 13
              }, this),
              /* @__PURE__ */ (0, import_jsx_dev_runtime.jsxDEV)(StyledTableCell, {
                align: "right",
                children: "Kod pocztowy\xA0"
              }, void 0, !1, {
                fileName: "app/components/table.tsx",
                lineNumber: 209,
                columnNumber: 13
              }, this),
              /* @__PURE__ */ (0, import_jsx_dev_runtime.jsxDEV)(StyledTableCell, {
                align: "right",
                children: "Miasto\xA0"
              }, void 0, !1, {
                fileName: "app/components/table.tsx",
                lineNumber: 210,
                columnNumber: 13
              }, this),
              /* @__PURE__ */ (0, import_jsx_dev_runtime.jsxDEV)(StyledTableCell, {
                align: "right",
                children: "Grupa\xA0"
              }, void 0, !1, {
                fileName: "app/components/table.tsx",
                lineNumber: 211,
                columnNumber: 13
              }, this),
              /* @__PURE__ */ (0, import_jsx_dev_runtime.jsxDEV)(StyledTableCell, {
                align: "right",
                children: "ID\xA0"
              }, void 0, !1, {
                fileName: "app/components/table.tsx",
                lineNumber: 212,
                columnNumber: 13
              }, this),
              /* @__PURE__ */ (0, import_jsx_dev_runtime.jsxDEV)(StyledTableCell, {
                align: "right",
                children: "Zaproszeni przez\xA0"
              }, void 0, !1, {
                fileName: "app/components/table.tsx",
                lineNumber: 213,
                columnNumber: 13
              }, this),
              /* @__PURE__ */ (0, import_jsx_dev_runtime.jsxDEV)(StyledTableCell, {
                align: "right",
                children: "Data urodzin\xA0"
              }, void 0, !1, {
                fileName: "app/components/table.tsx",
                lineNumber: 216,
                columnNumber: 13
              }, this),
              /* @__PURE__ */ (0, import_jsx_dev_runtime.jsxDEV)(StyledTableCell, {
                align: "right",
                children: "Data \u015Blubu\xA0"
              }, void 0, !1, {
                fileName: "app/components/table.tsx",
                lineNumber: 217,
                columnNumber: 13
              }, this),
              /* @__PURE__ */ (0, import_jsx_dev_runtime.jsxDEV)(StyledTableCell, {
                align: "right",
                children: "email\xA0"
              }, void 0, !1, {
                fileName: "app/components/table.tsx",
                lineNumber: 218,
                columnNumber: 13
              }, this),
              /* @__PURE__ */ (0, import_jsx_dev_runtime.jsxDEV)(StyledTableCell, {
                align: "right",
                children: "Akcje\xA0"
              }, void 0, !1, {
                fileName: "app/components/table.tsx",
                lineNumber: 219,
                columnNumber: 13
              }, this)
            ]
          }, void 0, !0, {
            fileName: "app/components/table.tsx",
            lineNumber: 206,
            columnNumber: 11
          }, this)
        }, void 0, !1, {
          fileName: "app/components/table.tsx",
          lineNumber: 205,
          columnNumber: 9
        }, this),
        /* @__PURE__ */ (0, import_jsx_dev_runtime.jsxDEV)(TableBody_default, {
          children: [
            (rowsPerPage > 0 ? props.loaderData.couples.slice(
              page * rowsPerPage,
              page * rowsPerPage + rowsPerPage
            ) : props.loaderData.couples).loaderData.couples.map((couple) => /* @__PURE__ */ (0, import_jsx_dev_runtime.jsxDEV)(TableRow_default, {
              children: [
                /* @__PURE__ */ (0, import_jsx_dev_runtime.jsxDEV)(TableCell_default, {
                  component: "th",
                  scope: "row",
                  children: couple.husband.lastName
                }, void 0, !1, {
                  fileName: "app/components/table.tsx",
                  lineNumber: 232,
                  columnNumber: 15
                }, this),
                /* @__PURE__ */ (0, import_jsx_dev_runtime.jsxDEV)(TableCell_default, {
                  style: { width: 160 },
                  align: "right",
                  children: couple.husband.firstName
                }, void 0, !1, {
                  fileName: "app/components/table.tsx",
                  lineNumber: 235,
                  columnNumber: 15
                }, this),
                /* @__PURE__ */ (0, import_jsx_dev_runtime.jsxDEV)(TableCell_default, {
                  style: { width: 160 },
                  align: "right",
                  children: couple.postalCode
                }, void 0, !1, {
                  fileName: "app/components/table.tsx",
                  lineNumber: 238,
                  columnNumber: 15
                }, this),
                /* @__PURE__ */ (0, import_jsx_dev_runtime.jsxDEV)(TableCell_default, {
                  style: { width: 160 },
                  align: "right",
                  children: couple.city
                }, void 0, !1, {
                  fileName: "app/components/table.tsx",
                  lineNumber: 241,
                  columnNumber: 15
                }, this),
                /* @__PURE__ */ (0, import_jsx_dev_runtime.jsxDEV)(TableCell_default, {
                  style: { width: 160 },
                  align: "right",
                  children: couple.group
                }, void 0, !1, {
                  fileName: "app/components/table.tsx",
                  lineNumber: 244,
                  columnNumber: 15
                }, this),
                /* @__PURE__ */ (0, import_jsx_dev_runtime.jsxDEV)(TableCell_default, {
                  style: { width: 160 },
                  align: "right",
                  children: couple.id
                }, void 0, !1, {
                  fileName: "app/components/table.tsx",
                  lineNumber: 247,
                  columnNumber: 15
                }, this),
                /* @__PURE__ */ (0, import_jsx_dev_runtime.jsxDEV)(TableCell_default, {
                  style: { width: 160 },
                  align: "right",
                  children: couple.invitedById
                }, void 0, !1, {
                  fileName: "app/components/table.tsx",
                  lineNumber: 250,
                  columnNumber: 15
                }, this),
                /* @__PURE__ */ (0, import_jsx_dev_runtime.jsxDEV)(TableCell_default, {
                  style: { width: 160 },
                  align: "right",
                  children: couple.birthYear
                }, void 0, !1, {
                  fileName: "app/components/table.tsx",
                  lineNumber: 253,
                  columnNumber: 15
                }, this),
                /* @__PURE__ */ (0, import_jsx_dev_runtime.jsxDEV)(TableCell_default, {
                  style: { width: 160 },
                  align: "right",
                  children: couple.weddingYear
                }, void 0, !1, {
                  fileName: "app/components/table.tsx",
                  lineNumber: 256,
                  columnNumber: 15
                }, this),
                /* @__PURE__ */ (0, import_jsx_dev_runtime.jsxDEV)(TableCell_default, {
                  style: { width: 160 },
                  align: "right",
                  children: couple.email
                }, void 0, !1, {
                  fileName: "app/components/table.tsx",
                  lineNumber: 259,
                  columnNumber: 15
                }, this)
              ]
            }, couple.husbandId, !0, {
              fileName: "app/components/table.tsx",
              lineNumber: 231,
              columnNumber: 13
            }, this)),
            emptyRows > 0 && /* @__PURE__ */ (0, import_jsx_dev_runtime.jsxDEV)(TableRow_default, {
              style: { height: 53 * emptyRows },
              children: /* @__PURE__ */ (0, import_jsx_dev_runtime.jsxDEV)(TableCell_default, {
                colSpan: 6
              }, void 0, !1, {
                fileName: "app/components/table.tsx",
                lineNumber: 266,
                columnNumber: 15
              }, this)
            }, void 0, !1, {
              fileName: "app/components/table.tsx",
              lineNumber: 265,
              columnNumber: 13
            }, this)
          ]
        }, void 0, !0, {
          fileName: "app/components/table.tsx",
          lineNumber: 223,
          columnNumber: 9
        }, this),
        /* @__PURE__ */ (0, import_jsx_dev_runtime.jsxDEV)(TableFooter_default, {
          children: /* @__PURE__ */ (0, import_jsx_dev_runtime.jsxDEV)(TableRow_default, {
            children: /* @__PURE__ */ (0, import_jsx_dev_runtime.jsxDEV)(TablePagination_default, {
              labelDisplayedRows: ({ from: from2, to, count }) => `${from2}\u2013${to} z ${count !== -1 ? count : `wi\u0119cej ni\u017C ${to}`}`,
              labelRowsPerPage: "Wierszy na stron\u0119:",
              rowsPerPageOptions: [5, 10, 25, 50],
              colSpan: 50,
              count: props.loaderData.couples.length,
              rowsPerPage,
              page,
              SelectProps: {
                inputProps: {
                  "aria-label": "rows per page"
                },
                native: !0
              },
              onPageChange: handleChangePage,
              onRowsPerPageChange: handleChangeRowsPerPage,
              ActionsComponent: TablePaginationActions3
            }, void 0, !1, {
              fileName: "app/components/table.tsx",
              lineNumber: 273,
              columnNumber: 13
            }, this)
          }, void 0, !1, {
            fileName: "app/components/table.tsx",
            lineNumber: 272,
            columnNumber: 11
          }, this)
        }, void 0, !1, {
          fileName: "app/components/table.tsx",
          lineNumber: 271,
          columnNumber: 9
        }, this)
      ]
    }, void 0, !0, {
      fileName: "app/components/table.tsx",
      lineNumber: 204,
      columnNumber: 7
    }, this)
  }, void 0, !1, {
    fileName: "app/components/table.tsx",
    lineNumber: 203,
    columnNumber: 5
  }, this);
}

// app/routes/index.tsx
var import_jsx_dev_runtime = __toESM(require_jsx_dev_runtime()), loader = async () => ({
  couples: [
    {
      id: "2-1-2005.01-15",
      city: "Wroc\u0142aw",
      group: "A",
      postalCode: "50-123",
      weddingYear: 2e3,
      wifeId: "1234",
      husbandId: "5678",
      invitedById: null,
      wife: {
        id: "1234",
        email: "email@email-wife.com",
        lastName: "Kowalska",
        firstName: "Anna",
        birthYear: 1980,
        phoneNumber: "123456789"
      },
      husband: {
        id: "123",
        email: "husband@email.com",
        lastName: "Kowalski",
        firstName: "Jan",
        birthYear: 1975,
        phoneNumber: "987654321"
      }
    },
    {
      id: "2-1-2006.01-15",
      city: "Wroc\u0142aw",
      group: "B",
      postalCode: "50-123",
      weddingYear: 2001,
      wifeId: "12340",
      husbandId: "56780",
      invitedById: null,
      wife: {
        id: "12340",
        email: "email2@email-wife.com",
        lastName: "Nowak",
        firstName: "Grazyna",
        birthYear: 1981,
        phoneNumber: "123456780"
      },
      husband: {
        id: "1230",
        email: "husband2@email.com",
        lastName: "Nowak",
        firstName: "Janusz",
        birthYear: 1976,
        phoneNumber: "987654320"
      }
    }
  ]
});
function Index2() {
  let loaderData = useLoaderData();
  return /* @__PURE__ */ (0, import_jsx_dev_runtime.jsxDEV)(Box_default, {
    style: { margin: "5rem" },
    children: /* @__PURE__ */ (0, import_jsx_dev_runtime.jsxDEV)("div", {
      style: { fontFamily: "system-ui, sans-serif", lineHeight: "1.4" },
      children: [
        /* @__PURE__ */ (0, import_jsx_dev_runtime.jsxDEV)("h1", {
          children: "Alma"
        }, void 0, !1, {
          fileName: "app/routes/index.tsx",
          lineNumber: 86,
          columnNumber: 9
        }, this),
        /* @__PURE__ */ (0, import_jsx_dev_runtime.jsxDEV)(TextField_default, {
          style: { marginRight: "1rem", marginBottom: "2rem" },
          id: "outlined-basic",
          label: "Szukaj...",
          variant: "standard"
        }, void 0, !1, {
          fileName: "app/routes/index.tsx",
          lineNumber: 87,
          columnNumber: 9
        }, this),
        /* @__PURE__ */ (0, import_jsx_dev_runtime.jsxDEV)("p", {}, void 0, !1, {
          fileName: "app/routes/index.tsx",
          lineNumber: 93,
          columnNumber: 9
        }, this),
        /* @__PURE__ */ (0, import_jsx_dev_runtime.jsxDEV)(FormControl_default, {
          style: {
            display: "flex",
            alignItems: "flex-end"
          },
          component: "fieldset",
          children: [
            /* @__PURE__ */ (0, import_jsx_dev_runtime.jsxDEV)(FormLabel_default, {
              component: "legend"
            }, void 0, !1, {
              fileName: "app/routes/index.tsx",
              lineNumber: 101,
              columnNumber: 11
            }, this),
            /* @__PURE__ */ (0, import_jsx_dev_runtime.jsxDEV)(FormGroup_default, {
              "aria-label": "position",
              row: !0,
              children: [
                /* @__PURE__ */ (0, import_jsx_dev_runtime.jsxDEV)(FormControlLabel_default, {
                  value: "Bez maila",
                  control: /* @__PURE__ */ (0, import_jsx_dev_runtime.jsxDEV)(Checkbox_default, {}, void 0, !1, {
                    fileName: "app/routes/index.tsx",
                    lineNumber: 105,
                    columnNumber: 24
                  }, this),
                  label: "Bez maila",
                  labelPlacement: "end"
                }, void 0, !1, {
                  fileName: "app/routes/index.tsx",
                  lineNumber: 103,
                  columnNumber: 13
                }, this),
                /* @__PURE__ */ (0, import_jsx_dev_runtime.jsxDEV)(FormControlLabel_default, {
                  value: "A",
                  control: /* @__PURE__ */ (0, import_jsx_dev_runtime.jsxDEV)(Checkbox_default, {}, void 0, !1, {
                    fileName: "app/routes/index.tsx",
                    lineNumber: 111,
                    columnNumber: 24
                  }, this),
                  label: "A",
                  labelPlacement: "end"
                }, void 0, !1, {
                  fileName: "app/routes/index.tsx",
                  lineNumber: 109,
                  columnNumber: 13
                }, this),
                /* @__PURE__ */ (0, import_jsx_dev_runtime.jsxDEV)(FormControlLabel_default, {
                  value: "B",
                  control: /* @__PURE__ */ (0, import_jsx_dev_runtime.jsxDEV)(Checkbox_default, {}, void 0, !1, {
                    fileName: "app/routes/index.tsx",
                    lineNumber: 117,
                    columnNumber: 24
                  }, this),
                  label: "B",
                  labelPlacement: "end"
                }, void 0, !1, {
                  fileName: "app/routes/index.tsx",
                  lineNumber: 115,
                  columnNumber: 13
                }, this),
                /* @__PURE__ */ (0, import_jsx_dev_runtime.jsxDEV)(FormControlLabel_default, {
                  value: "C",
                  control: /* @__PURE__ */ (0, import_jsx_dev_runtime.jsxDEV)(Checkbox_default, {}, void 0, !1, {
                    fileName: "app/routes/index.tsx",
                    lineNumber: 123,
                    columnNumber: 24
                  }, this),
                  label: "C",
                  labelPlacement: "end"
                }, void 0, !1, {
                  fileName: "app/routes/index.tsx",
                  lineNumber: 121,
                  columnNumber: 13
                }, this),
                /* @__PURE__ */ (0, import_jsx_dev_runtime.jsxDEV)(FormControlLabel_default, {
                  value: "D",
                  control: /* @__PURE__ */ (0, import_jsx_dev_runtime.jsxDEV)(Checkbox_default, {}, void 0, !1, {
                    fileName: "app/routes/index.tsx",
                    lineNumber: 129,
                    columnNumber: 24
                  }, this),
                  label: "D",
                  labelPlacement: "end"
                }, void 0, !1, {
                  fileName: "app/routes/index.tsx",
                  lineNumber: 127,
                  columnNumber: 13
                }, this),
                /* @__PURE__ */ (0, import_jsx_dev_runtime.jsxDEV)(FormControlLabel_default, {
                  value: "S/X",
                  control: /* @__PURE__ */ (0, import_jsx_dev_runtime.jsxDEV)(Checkbox_default, {}, void 0, !1, {
                    fileName: "app/routes/index.tsx",
                    lineNumber: 135,
                    columnNumber: 24
                  }, this),
                  label: "S/X",
                  labelPlacement: "end"
                }, void 0, !1, {
                  fileName: "app/routes/index.tsx",
                  lineNumber: 133,
                  columnNumber: 13
                }, this),
                /* @__PURE__ */ (0, import_jsx_dev_runtime.jsxDEV)(Button_default, {
                  variant: "outlined",
                  startIcon: /* @__PURE__ */ (0, import_jsx_dev_runtime.jsxDEV)(import_Clear.default, {}, void 0, !1, {
                    fileName: "app/routes/index.tsx",
                    lineNumber: 139,
                    columnNumber: 51
                  }, this),
                  children: "Wyczy\u015B\u0107 filtry"
                }, void 0, !1, {
                  fileName: "app/routes/index.tsx",
                  lineNumber: 139,
                  columnNumber: 13
                }, this)
              ]
            }, void 0, !0, {
              fileName: "app/routes/index.tsx",
              lineNumber: 102,
              columnNumber: 11
            }, this)
          ]
        }, void 0, !0, {
          fileName: "app/routes/index.tsx",
          lineNumber: 94,
          columnNumber: 9
        }, this),
        /* @__PURE__ */ (0, import_jsx_dev_runtime.jsxDEV)(MyTable, {}, void 0, !1, {
          fileName: "app/routes/index.tsx",
          lineNumber: 145,
          columnNumber: 9
        }, this),
        loaderData.couples.map((couple) => /* @__PURE__ */ (0, import_jsx_dev_runtime.jsxDEV)("div", {
          children: [
            /* @__PURE__ */ (0, import_jsx_dev_runtime.jsxDEV)("h2", {
              children: [
                couple.wife.firstName,
                " ",
                couple.wife.lastName,
                " &",
                " ",
                couple.husband.firstName,
                " ",
                couple.husband.lastName
              ]
            }, void 0, !0, {
              fileName: "app/routes/index.tsx",
              lineNumber: 148,
              columnNumber: 13
            }, this),
            /* @__PURE__ */ (0, import_jsx_dev_runtime.jsxDEV)("p", {
              children: [
                couple.city,
                ", ",
                couple.postalCode
              ]
            }, void 0, !0, {
              fileName: "app/routes/index.tsx",
              lineNumber: 152,
              columnNumber: 13
            }, this),
            /* @__PURE__ */ (0, import_jsx_dev_runtime.jsxDEV)("p", {
              children: couple.wife.email
            }, void 0, !1, {
              fileName: "app/routes/index.tsx",
              lineNumber: 155,
              columnNumber: 13
            }, this),
            /* @__PURE__ */ (0, import_jsx_dev_runtime.jsxDEV)("p", {
              children: couple.husband.email
            }, void 0, !1, {
              fileName: "app/routes/index.tsx",
              lineNumber: 156,
              columnNumber: 13
            }, this)
          ]
        }, couple.id, !0, {
          fileName: "app/routes/index.tsx",
          lineNumber: 147,
          columnNumber: 11
        }, this)),
        /* @__PURE__ */ (0, import_jsx_dev_runtime.jsxDEV)(Button_default, {
          variant: "contained",
          component: Link2,
          to: "/about",
          children: "Go to the about page"
        }, void 0, !1, {
          fileName: "app/routes/index.tsx",
          lineNumber: 160,
          columnNumber: 9
        }, this)
      ]
    }, void 0, !0, {
      fileName: "app/routes/index.tsx",
      lineNumber: 85,
      columnNumber: 7
    }, this)
  }, void 0, !1, {
    fileName: "app/routes/index.tsx",
    lineNumber: 84,
    columnNumber: 5
  }, this);
}

// app/routes/test.tsx
var test_exports = {};
__export(test_exports, {
  default: () => Index3
});
var import_Clear2 = __toESM(require_Clear());
var import_react17 = __toESM(require_react()), import_jsx_dev_runtime = __toESM(require_jsx_dev_runtime());
function Index3() {
  let loaderData = useLoaderData(), [isChecked, setIsChecked] = (0, import_react17.useState)(!1);
  return /* @__PURE__ */ (0, import_jsx_dev_runtime.jsxDEV)(FormControl_default, {
    style: {
      display: "flex",
      alignItems: "flex-end"
    },
    component: "fieldset",
    children: [
      /* @__PURE__ */ (0, import_jsx_dev_runtime.jsxDEV)(FormLabel_default, {
        component: "legend"
      }, void 0, !1, {
        fileName: "app/routes/test.tsx",
        lineNumber: 32,
        columnNumber: 7
      }, this),
      /* @__PURE__ */ (0, import_jsx_dev_runtime.jsxDEV)(FormGroup_default, {
        "aria-label": "position",
        row: !0,
        children: [
          /* @__PURE__ */ (0, import_jsx_dev_runtime.jsxDEV)(FormControlLabel_default, {
            value: "Bez maila",
            control: /* @__PURE__ */ (0, import_jsx_dev_runtime.jsxDEV)(Checkbox_default, {
              checked: isChecked,
              onChange: (e) => {
                setIsChecked(e.target.checked);
              }
            }, void 0, !1, {
              fileName: "app/routes/test.tsx",
              lineNumber: 37,
              columnNumber: 13
            }, this),
            label: "Bez maila",
            labelPlacement: "end"
          }, void 0, !1, {
            fileName: "app/routes/test.tsx",
            lineNumber: 34,
            columnNumber: 9
          }, this),
          /* @__PURE__ */ (0, import_jsx_dev_runtime.jsxDEV)(FormControlLabel_default, {
            value: "A",
            control: /* @__PURE__ */ (0, import_jsx_dev_runtime.jsxDEV)(Checkbox_default, {
              checked: isChecked,
              onChange: (e) => {
                setIsChecked(e.target.checked);
              }
            }, void 0, !1, {
              fileName: "app/routes/test.tsx",
              lineNumber: 50,
              columnNumber: 13
            }, this),
            label: "A",
            labelPlacement: "end"
          }, void 0, !1, {
            fileName: "app/routes/test.tsx",
            lineNumber: 47,
            columnNumber: 9
          }, this),
          /* @__PURE__ */ (0, import_jsx_dev_runtime.jsxDEV)(FormControlLabel_default, {
            value: "B",
            control: /* @__PURE__ */ (0, import_jsx_dev_runtime.jsxDEV)(Checkbox_default, {
              checked: isChecked,
              onChange: (e) => {
                setIsChecked(e.target.checked);
              }
            }, void 0, !1, {
              fileName: "app/routes/test.tsx",
              lineNumber: 63,
              columnNumber: 13
            }, this),
            label: "B",
            labelPlacement: "end"
          }, void 0, !1, {
            fileName: "app/routes/test.tsx",
            lineNumber: 60,
            columnNumber: 9
          }, this),
          /* @__PURE__ */ (0, import_jsx_dev_runtime.jsxDEV)(FormControlLabel_default, {
            value: "C",
            control: /* @__PURE__ */ (0, import_jsx_dev_runtime.jsxDEV)(Checkbox_default, {
              checked: isChecked,
              onChange: (e) => {
                setIsChecked(e.target.checked);
              }
            }, void 0, !1, {
              fileName: "app/routes/test.tsx",
              lineNumber: 76,
              columnNumber: 13
            }, this),
            label: "C",
            labelPlacement: "end"
          }, void 0, !1, {
            fileName: "app/routes/test.tsx",
            lineNumber: 73,
            columnNumber: 9
          }, this),
          /* @__PURE__ */ (0, import_jsx_dev_runtime.jsxDEV)(FormControlLabel_default, {
            value: "D",
            control: /* @__PURE__ */ (0, import_jsx_dev_runtime.jsxDEV)(Checkbox_default, {
              checked: isChecked,
              onChange: (e) => {
                setIsChecked(e.target.checked);
              }
            }, void 0, !1, {
              fileName: "app/routes/test.tsx",
              lineNumber: 89,
              columnNumber: 13
            }, this),
            label: "D",
            labelPlacement: "end"
          }, void 0, !1, {
            fileName: "app/routes/test.tsx",
            lineNumber: 86,
            columnNumber: 9
          }, this),
          /* @__PURE__ */ (0, import_jsx_dev_runtime.jsxDEV)(FormControlLabel_default, {
            value: "S/X",
            control: /* @__PURE__ */ (0, import_jsx_dev_runtime.jsxDEV)(Checkbox_default, {
              checked: isChecked,
              onChange: (e) => {
                setIsChecked(e.target.checked);
              }
            }, void 0, !1, {
              fileName: "app/routes/test.tsx",
              lineNumber: 102,
              columnNumber: 13
            }, this),
            label: "S/X",
            labelPlacement: "end"
          }, void 0, !1, {
            fileName: "app/routes/test.tsx",
            lineNumber: 99,
            columnNumber: 9
          }, this),
          /* @__PURE__ */ (0, import_jsx_dev_runtime.jsxDEV)(Button_default, {
            sx: { visibility: isChecked ? "visible" : "hidden" },
            onClick: () => {
              setIsChecked(!1);
            },
            variant: "outlined",
            startIcon: /* @__PURE__ */ (0, import_jsx_dev_runtime.jsxDEV)(import_Clear2.default, {}, void 0, !1, {
              fileName: "app/routes/test.tsx",
              lineNumber: 116,
              columnNumber: 22
            }, this),
            children: "Wyczy\u015B\u0107 filtry"
          }, void 0, !1, {
            fileName: "app/routes/test.tsx",
            lineNumber: 112,
            columnNumber: 9
          }, this)
        ]
      }, void 0, !0, {
        fileName: "app/routes/test.tsx",
        lineNumber: 33,
        columnNumber: 7
      }, this)
    ]
  }, void 0, !0, {
    fileName: "app/routes/test.tsx",
    lineNumber: 25,
    columnNumber: 5
  }, this);
}

// server-assets-manifest:@remix-run/dev/assets-manifest
var assets_manifest_default = { version: "0482452a", entry: { module: "/build/entry.client-POEJA6EC.js", imports: ["/build/_shared/chunk-OW2WZFAM.js", "/build/_shared/chunk-YLI6H36I.js"] }, routes: { root: { id: "root", parentId: void 0, path: "", index: void 0, caseSensitive: void 0, module: "/build/root-WQIYTUBB.js", imports: void 0, hasAction: !1, hasLoader: !1, hasCatchBoundary: !1, hasErrorBoundary: !1 }, "routes/about": { id: "routes/about", parentId: "root", path: "about", index: void 0, caseSensitive: void 0, module: "/build/routes/about-KDRLAWFK.js", imports: ["/build/_shared/chunk-GG33M3TJ.js"], hasAction: !1, hasLoader: !1, hasCatchBoundary: !1, hasErrorBoundary: !1 }, "routes/index": { id: "routes/index", parentId: "root", path: void 0, index: !0, caseSensitive: void 0, module: "/build/routes/index-RH4SGRTQ.js", imports: ["/build/_shared/chunk-4VQTWC6X.js", "/build/_shared/chunk-GG33M3TJ.js"], hasAction: !1, hasLoader: !0, hasCatchBoundary: !1, hasErrorBoundary: !1 }, "routes/test": { id: "routes/test", parentId: "root", path: "test", index: void 0, caseSensitive: void 0, module: "/build/routes/test-A5366CYM.js", imports: ["/build/_shared/chunk-4VQTWC6X.js", "/build/_shared/chunk-GG33M3TJ.js"], hasAction: !1, hasLoader: !1, hasCatchBoundary: !1, hasErrorBoundary: !1 } }, url: "/build/manifest-0482452A.js" };

// server-entry-module:@remix-run/dev/server-build
var assetsBuildDirectory = "public/build", publicPath = "/build/", entry = { module: entry_server_exports }, routes = {
  root: {
    id: "root",
    parentId: void 0,
    path: "",
    index: void 0,
    caseSensitive: void 0,
    module: root_exports
  },
  "routes/about": {
    id: "routes/about",
    parentId: "root",
    path: "about",
    index: void 0,
    caseSensitive: void 0,
    module: about_exports
  },
  "routes/index": {
    id: "routes/index",
    parentId: "root",
    path: void 0,
    index: !0,
    caseSensitive: void 0,
    module: routes_exports
  },
  "routes/test": {
    id: "routes/test",
    parentId: "root",
    path: "test",
    index: void 0,
    caseSensitive: void 0,
    module: test_exports
  }
};

// server.js
var handleRequest2 = createPagesFunctionHandler({
  build: server_build_exports,
  mode: "development",
  getLoadContext: (context) => context.env
});
function onRequest(context) {
  return handleRequest2(context);
}
export {
  onRequest
};
/*
object-assign
(c) Sindre Sorhus
@license MIT
*/
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
 * @license  MIT
 */
/*!
 * cookie
 * Copyright(c) 2012-2014 Roman Shtylman
 * Copyright(c) 2015 Douglas Christopher Wilson
 * MIT Licensed
 */
/**
 * @license React
 * react-is.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
/**
 * @remix-run/cloudflare v1.7.0
 *
 * Copyright (c) Remix Software Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.md file in the root directory of this source tree.
 *
 * @license MIT
 */
/**
 * @remix-run/cloudflare-pages v1.7.0
 *
 * Copyright (c) Remix Software Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.md file in the root directory of this source tree.
 *
 * @license MIT
 */
/**
 * @remix-run/react v1.7.0
 *
 * Copyright (c) Remix Software Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.md file in the root directory of this source tree.
 *
 * @license MIT
 */
/**
 * @remix-run/server-runtime v1.7.0
 *
 * Copyright (c) Remix Software Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.md file in the root directory of this source tree.
 *
 * @license MIT
 */
/**
 * Checks if an event is supported in the current execution environment.
 *
 * NOTE: This will not work correctly for non-generic events such as `change`,
 * `reset`, `load`, `error`, and `select`.
 *
 * Borrows from Modernizr.
 *
 * @param {string} eventNameSuffix Event name, e.g. "click".
 * @return {boolean} True if the event is supported.
 * @internal
 * @license Modernizr 3.0.0pre (Custom Build) | MIT
 */
/**
 * React Router DOM v6.3.0
 *
 * Copyright (c) Remix Software Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.md file in the root directory of this source tree.
 *
 * @license MIT
 */
/**
 * React Router v6.3.0
 *
 * Copyright (c) Remix Software Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.md file in the root directory of this source tree.
 *
 * @license MIT
 */
/** @license MUI v5.0.0-alpha.96
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
/** @license MUI v5.10.3
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
/** @license MUI v5.10.4
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
/** @license React v0.20.2
 * scheduler-tracing.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
/** @license React v0.20.2
 * scheduler.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
/** @license React v16.13.1
 * react-is.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
/** @license React v17.0.2
 * react-dom-server.node.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
/** @license React v17.0.2
 * react-dom.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
/** @license React v17.0.2
 * react-jsx-dev-runtime.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
/** @license React v17.0.2
 * react-jsx-runtime.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
/** @license React v17.0.2
 * react.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
//# sourceMappingURL=/build/[[path]].js.map
